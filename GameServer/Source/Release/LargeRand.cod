; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\LargeRand.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CLargeRand@@QAE@XZ				; CLargeRand::CLargeRand
PUBLIC	??1CLargeRand@@UAE@XZ				; CLargeRand::~CLargeRand
PUBLIC	?seedMT@CLargeRand@@QAEXK@Z			; CLargeRand::seedMT
PUBLIC	?reloadMT@CLargeRand@@QAEKXZ			; CLargeRand::reloadMT
PUBLIC	??_GCLargeRand@@UAEPAXI@Z			; CLargeRand::`scalar deleting destructor'
PUBLIC	?GetLargeRand@@YAKXZ				; GetLargeRand
PUBLIC	?RandomInit@CRandomMersenne@@QAEXH@Z		; CRandomMersenne::RandomInit
PUBLIC	?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z	; CRandomMersenne::RandomInitByArray
PUBLIC	?IRandom@CRandomMersenne@@QAEHHH@Z		; CRandomMersenne::IRandom
PUBLIC	?IRandom@CRandomMersenne@@QAEHH@Z		; CRandomMersenne::IRandom
PUBLIC	?IRandomX@CRandomMersenne@@QAEHHH@Z		; CRandomMersenne::IRandomX
PUBLIC	?IRandomX@CRandomMersenne@@QAEHH@Z		; CRandomMersenne::IRandomX
PUBLIC	?Random@CRandomMersenne@@QAENXZ			; CRandomMersenne::Random
PUBLIC	?BRandom@CRandomMersenne@@QAEKXZ		; CRandomMersenne::BRandom
PUBLIC	?Init0@CRandomMersenne@@AAEXH@Z			; CRandomMersenne::Init0
PUBLIC	??_7CLargeRand@@6B@				; CLargeRand::`vftable'
PUBLIC	?g_MersenneRand@@3VCRandomMersenne@@A		; g_MersenneRand
PUBLIC	?g_LargLand@@3VCLargeRand@@A			; g_LargLand
PUBLIC	??_R4CLargeRand@@6B@				; CLargeRand::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCLargeRand@@@8				; CLargeRand `RTTI Type Descriptor'
PUBLIC	??_R3CLargeRand@@8				; CLargeRand::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLargeRand@@8				; CLargeRand::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLargeRand@@8			; CLargeRand::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3df0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__time64:PROC
EXTRN	??_ECLargeRand@@UAEPAXI@Z:PROC			; CLargeRand::`vector deleting destructor'
EXTRN	__aulldiv:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_MersenneRand@@3VCRandomMersenne@@A DB 09ccH DUP (?)	; g_MersenneRand
?g_LargLand@@3VCLargeRand@@A DB 09d0H DUP (?)		; g_LargLand
_BSS	ENDS
CRT$XCU	SEGMENT
?g_LargLand$initializer$@@3P6AXXZA DD FLAT:??__Eg_LargLand@@YAXXZ ; g_LargLand$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@3df0000000000000
CONST	SEGMENT
__real@3df0000000000000 DQ 03df0000000000000r	; 2.32831e-10
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CLargeRand@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CLargeRand@@8 DD FLAT:??_R0?AVCLargeRand@@@8 ; CLargeRand::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLargeRand@@8
rdata$r	ENDS
;	COMDAT ??_R2CLargeRand@@8
rdata$r	SEGMENT
??_R2CLargeRand@@8 DD FLAT:??_R1A@?0A@EA@CLargeRand@@8	; CLargeRand::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CLargeRand@@8
rdata$r	SEGMENT
??_R3CLargeRand@@8 DD 00H				; CLargeRand::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CLargeRand@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLargeRand@@@8
data$r	SEGMENT
??_R0?AVCLargeRand@@@8 DD FLAT:??_7type_info@@6B@	; CLargeRand `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLargeRand@@', 00H
data$r	ENDS
;	COMDAT ??_R4CLargeRand@@6B@
rdata$r	SEGMENT
??_R4CLargeRand@@6B@ DD 00H				; CLargeRand::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLargeRand@@@8
	DD	FLAT:??_R3CLargeRand@@8
rdata$r	ENDS
;	COMDAT ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB
CONST	SEGMENT
?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB DD 00H	; `CRandomMersenne::BRandom'::`5'::mag01
	DD	09908b0dfH
CONST	ENDS
;	COMDAT ??_7CLargeRand@@6B@
CONST	SEGMENT
??_7CLargeRand@@6B@ DD FLAT:??_R4CLargeRand@@6B@	; CLargeRand::`vftable'
	DD	FLAT:??_ECLargeRand@@UAEPAXI@Z
CONST	ENDS
CRT$XCU	SEGMENT
?g_MersenneRand$initializer$@@3P6AXXZA DD FLAT:??__Eg_MersenneRand@@YAXXZ ; g_MersenneRand$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\users\michel\desktop\source\gameserver\source\largerand.h
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ??__Eg_MersenneRand@@YAXXZ
text$di	SEGMENT
??__Eg_MersenneRand@@YAXXZ PROC				; `dynamic initializer for 'g_MersenneRand'', COMDAT
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	83 c4 04	 add	 esp, 4
; File c:\users\michel\desktop\source\gameserver\source\largerand.h

; 63   :       RandomInit(seed); LastInterval = 0;}

  0000a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MersenneRand@@3VCRandomMersenne@@A ; g_MersenneRand
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?RandomInit@CRandomMersenne@@QAEXH@Z ; CRandomMersenne::RandomInit
  00015	c7 05 c4 09 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_MersenneRand@@3VCRandomMersenne@@A+2500, 0
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp

; 75   : CRandomMersenne g_MersenneRand((int)time(NULL));

  0001f	c3		 ret	 0
??__Eg_MersenneRand@@YAXXZ ENDP				; `dynamic initializer for 'g_MersenneRand''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_LargLand@@YAXXZ
text$yd	SEGMENT
??__Fg_LargLand@@YAXXZ PROC				; `dynamic atexit destructor for 'g_LargLand'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LargLand@@3VCLargeRand@@A ; g_LargLand
  00005	e9 00 00 00 00	 jmp	 ??1CLargeRand@@UAE@XZ	; CLargeRand::~CLargeRand
??__Fg_LargLand@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_LargLand''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ??__Eg_LargLand@@YAXXZ
text$di	SEGMENT
??__Eg_LargLand@@YAXXZ PROC				; `dynamic initializer for 'g_LargLand'', COMDAT

; 4    : CLargeRand g_LargLand;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LargLand@@3VCLargeRand@@A ; g_LargLand
  00005	e8 00 00 00 00	 call	 ??0CLargeRand@@QAE@XZ	; CLargeRand::CLargeRand
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_LargLand@@YAXXZ ; `dynamic atexit destructor for 'g_LargLand''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_LargLand@@YAXXZ ENDP				; `dynamic initializer for 'g_LargLand''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?Init0@CRandomMersenne@@AAEXH@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?Init0@CRandomMersenne@@AAEXH@Z PROC			; CRandomMersenne::Init0, COMDAT
; _this$ = ecx

; 77   : void CRandomMersenne::Init0(int seed) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :    // Seed generator
; 79   :    const DWORD factor = 1812433253UL;
; 80   :    mt[0]= seed;

  00003	8b 45 08	 mov	 eax, DWORD PTR _seed$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 81   :    for (mti=1; mti < MERS_N; mti++) {

  00008	c7 81 c0 09 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+2496], 1
  00012	56		 push	 esi
$LL4@Init0:

; 82   :       mt[mti] = (factor * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);

  00013	8b b1 c0 09 00
	00		 mov	 esi, DWORD PTR [ecx+2496]
  00019	8b 54 b1 fc	 mov	 edx, DWORD PTR [ecx+esi*4-4]
  0001d	c1 ea 1e	 shr	 edx, 30			; 0000001eH
  00020	33 54 b1 fc	 xor	 edx, DWORD PTR [ecx+esi*4-4]
  00024	69 c2 65 89 07
	6c		 imul	 eax, edx, 1812433253
  0002a	03 c6		 add	 eax, esi
  0002c	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  0002f	ff 81 c0 09 00
	00		 inc	 DWORD PTR [ecx+2496]
  00035	81 b9 c0 09 00
	00 70 02 00 00	 cmp	 DWORD PTR [ecx+2496], 624 ; 00000270H
  0003f	7c d2		 jl	 SHORT $LL4@Init0
  00041	5e		 pop	 esi

; 83   :    }
; 84   : }

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?Init0@CRandomMersenne@@AAEXH@Z ENDP			; CRandomMersenne::Init0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?BRandom@CRandomMersenne@@QAEKXZ
_TEXT	SEGMENT
?BRandom@CRandomMersenne@@QAEKXZ PROC			; CRandomMersenne::BRandom, COMDAT
; _this$ = ecx

; 123  : DWORD CRandomMersenne::BRandom() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 124  :    // Generate 32 random bits
; 125  :    DWORD y;
; 126  : 
; 127  :    if (mti >= MERS_N) {

  00003	81 be c0 09 00
	00 70 02 00 00	 cmp	 DWORD PTR [esi+2496], 624 ; 00000270H
  0000d	0f 8c b8 00 00
	00		 jl	 $LN8@BRandom

; 128  :       // Generate MERS_N words at one time
; 129  :       const DWORD LOWER_MASK = (1LU << MERS_R) - 1;       // Lower MERS_R bits
; 130  :       const DWORD UPPER_MASK = 0xFFFFFFFF << MERS_R;      // Upper (32 - MERS_R) bits
; 131  :       static const DWORD mag01[2] = {0, MERS_A};
; 132  : 
; 133  :       int kk;
; 134  :       for (kk=0; kk < MERS_N-MERS_M; kk++) {    

  00013	33 d2		 xor	 edx, edx
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@BRandom:

; 135  :          y = (mt[kk] & UPPER_MASK) | (mt[kk+1] & LOWER_MASK);

  00020	8b 4c 96 04	 mov	 ecx, DWORD PTR [esi+edx*4+4]
  00024	33 0c 96	 xor	 ecx, DWORD PTR [esi+edx*4]
  00027	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0002d	33 0c 96	 xor	 ecx, DWORD PTR [esi+edx*4]

; 136  :          mt[kk] = mt[kk+MERS_M] ^ (y >> 1) ^ mag01[y & 1];}

  00030	8b c1		 mov	 eax, ecx
  00032	d1 e9		 shr	 ecx, 1
  00034	83 e0 01	 and	 eax, 1
  00037	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB[eax*4]
  0003e	33 8c 96 34 06
	00 00		 xor	 ecx, DWORD PTR [esi+edx*4+1588]
  00045	89 0c 96	 mov	 DWORD PTR [esi+edx*4], ecx
  00048	42		 inc	 edx
  00049	81 fa e3 00 00
	00		 cmp	 edx, 227		; 000000e3H
  0004f	7c cf		 jl	 SHORT $LL4@BRandom

; 137  : 
; 138  :       for (; kk < MERS_N-1; kk++) {    

  00051	81 fa 6f 02 00
	00		 cmp	 edx, 623		; 0000026fH
  00057	7d 38		 jge	 SHORT $LN6@BRandom
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@BRandom:

; 139  :          y = (mt[kk] & UPPER_MASK) | (mt[kk+1] & LOWER_MASK);

  00060	8b 4c 96 04	 mov	 ecx, DWORD PTR [esi+edx*4+4]
  00064	33 0c 96	 xor	 ecx, DWORD PTR [esi+edx*4]
  00067	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0006d	33 0c 96	 xor	 ecx, DWORD PTR [esi+edx*4]

; 140  :          mt[kk] = mt[kk+(MERS_M-MERS_N)] ^ (y >> 1) ^ mag01[y & 1];}      

  00070	8b c1		 mov	 eax, ecx
  00072	d1 e9		 shr	 ecx, 1
  00074	83 e0 01	 and	 eax, 1
  00077	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB[eax*4]
  0007e	33 8c 96 74 fc
	ff ff		 xor	 ecx, DWORD PTR [esi+edx*4-908]
  00085	89 0c 96	 mov	 DWORD PTR [esi+edx*4], ecx
  00088	42		 inc	 edx
  00089	81 fa 6f 02 00
	00		 cmp	 edx, 623		; 0000026fH
  0008f	7c cf		 jl	 SHORT $LL7@BRandom
$LN6@BRandom:

; 141  : 
; 142  :       y = (mt[MERS_N-1] & UPPER_MASK) | (mt[0] & LOWER_MASK);

  00091	8b 8e bc 09 00
	00		 mov	 ecx, DWORD PTR [esi+2492]
  00097	33 0e		 xor	 ecx, DWORD PTR [esi]
  00099	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0009f	33 8e bc 09 00
	00		 xor	 ecx, DWORD PTR [esi+2492]

; 143  :       mt[MERS_N-1] = mt[MERS_M-1] ^ (y >> 1) ^ mag01[y & 1];

  000a5	8b c1		 mov	 eax, ecx
  000a7	d1 e9		 shr	 ecx, 1
  000a9	83 e0 01	 and	 eax, 1
  000ac	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB[eax*4]
  000b3	33 86 30 06 00
	00		 xor	 eax, DWORD PTR [esi+1584]
  000b9	33 c1		 xor	 eax, ecx
  000bb	89 86 bc 09 00
	00		 mov	 DWORD PTR [esi+2492], eax

; 144  :       mti = 0;

  000c1	c7 86 c0 09 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2496], 0
$LN8@BRandom:

; 145  :    }
; 146  :    y = mt[mti++];

  000cb	8b 86 c0 09 00
	00		 mov	 eax, DWORD PTR [esi+2496]
  000d1	8b 0c 86	 mov	 ecx, DWORD PTR [esi+eax*4]
  000d4	40		 inc	 eax
  000d5	89 86 c0 09 00
	00		 mov	 DWORD PTR [esi+2496], eax

; 147  : 
; 148  :    // Tempering (May be omitted):
; 149  :    y ^=  y >> MERS_U;

  000db	8b c1		 mov	 eax, ecx
  000dd	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  000e0	33 c8		 xor	 ecx, eax

; 150  :    y ^= (y << MERS_S) & MERS_B;

  000e2	8b c1		 mov	 eax, ecx
  000e4	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  000e9	c1 e0 07	 shl	 eax, 7
  000ec	33 c8		 xor	 ecx, eax

; 151  :    y ^= (y << MERS_T) & MERS_C;

  000ee	8b c1		 mov	 eax, ecx
  000f0	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  000f5	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  000f8	33 c8		 xor	 ecx, eax

; 152  :    y ^=  y >> MERS_L;

  000fa	8b c1		 mov	 eax, ecx
  000fc	c1 e8 12	 shr	 eax, 18			; 00000012H
  000ff	33 c1		 xor	 eax, ecx
  00101	5e		 pop	 esi

; 153  : 
; 154  :    return y;
; 155  : }

  00102	c3		 ret	 0
?BRandom@CRandomMersenne@@QAEKXZ ENDP			; CRandomMersenne::BRandom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?Random@CRandomMersenne@@QAENXZ
_TEXT	SEGMENT
tv73 = -8						; size = 8
?Random@CRandomMersenne@@QAENXZ PROC			; CRandomMersenne::Random, COMDAT
; _this$ = ecx

; 158  : double CRandomMersenne::Random() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 159  :    // Output random float number in the interval 0 <= x < 1
; 160  :    // Multiply by 2^(-32)
; 161  :    return (double)BRandom() * (1./(65536.*65536.));

  00006	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  0000b	66 0f 6e c0	 movd	 xmm0, eax
  0000f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00013	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00016	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0001f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3df0000000000000
  00027	f2 0f 11 45 f8	 movsd	 QWORD PTR tv73[ebp], xmm0
  0002c	dd 45 f8	 fld	 QWORD PTR tv73[ebp]

; 162  : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Random@CRandomMersenne@@QAENXZ ENDP			; CRandomMersenne::Random
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?IRandomX@CRandomMersenne@@QAEHH@Z
_TEXT	SEGMENT
_max$ = 8						; size = 4
?IRandomX@CRandomMersenne@@QAEHH@Z PROC			; CRandomMersenne::IRandomX, COMDAT
; _this$ = ecx

; 216  : int CRandomMersenne::IRandomX(int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 217  :    // 64 bit integers available. Use multiply and shift method
; 218  :    unsigned __int32 interval;                    // Length of interval
; 219  :    unsigned __int64 longran;                     // Random bits * interval
; 220  :    unsigned __int32 iran;                        // Longran / 2^32
; 221  :    unsigned __int32 remainder;                   // Longran % 2^32
; 222  : 
; 223  :    interval = (DWORD)(max);
; 224  :    if (interval != LastInterval) {

  00007	8b 7d 08	 mov	 edi, DWORD PTR _max$[ebp]
  0000a	3b be c4 09 00
	00		 cmp	 edi, DWORD PTR [esi+2500]
  00010	74 1e		 je	 SHORT $LL4@IRandomX

; 225  :       // Interval length has changed. Must calculate rejection limit
; 226  :       // Reject when remainder >= 2^32 / interval * interval
; 227  :       // RLimit will be 0 if interval is a power of 2. No rejection then
; 228  :       RLimit = DWORD(((unsigned __int64)1 << 32) / interval) * interval - 1;

  00012	6a 00		 push	 0
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	6a 00		 push	 0
  00019	e8 00 00 00 00	 call	 __aulldiv
  0001e	0f af c7	 imul	 eax, edi

; 229  :       LastInterval = interval;

  00021	89 be c4 09 00
	00		 mov	 DWORD PTR [esi+2500], edi
  00027	48		 dec	 eax
  00028	89 86 c8 09 00
	00		 mov	 DWORD PTR [esi+2504], eax
  0002e	66 90		 npad	 2
$LL4@IRandomX:

; 230  :    }
; 231  :    do { // Rejection loop
; 232  :       longran  = (unsigned __int64)BRandom() * interval;

  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  00037	8b c8		 mov	 ecx, eax
  00039	8b c7		 mov	 eax, edi
  0003b	f7 e1		 mul	 ecx

; 233  :       iran = (DWORD)(longran >> 32);
; 234  :       remainder = (DWORD)longran;
; 235  :    } while (remainder > RLimit);

  0003d	3b 86 c8 09 00
	00		 cmp	 eax, DWORD PTR [esi+2504]
  00043	77 eb		 ja	 SHORT $LL4@IRandomX

; 236  :    // Convert back to signed and return result
; 237  :    return (__int32)iran;

  00045	5f		 pop	 edi
  00046	8b c2		 mov	 eax, edx
  00048	5e		 pop	 esi

; 238  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?IRandomX@CRandomMersenne@@QAEHH@Z ENDP			; CRandomMersenne::IRandomX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?IRandomX@CRandomMersenne@@QAEHHH@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?IRandomX@CRandomMersenne@@QAEHHH@Z PROC		; CRandomMersenne::IRandomX, COMDAT
; _this$ = ecx

; 184  : int CRandomMersenne::IRandomX(int min, int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 185  :    // Output random integer in the interval min <= x <= max
; 186  :    // Each output value has exactly the same probability.
; 187  :    // This is obtained by rejecting certain bit values so that the number
; 188  :    // of possible bit values is divisible by the interval length
; 189  :    if (max <= min) {

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _min$[ebp]
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _max$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	3b f3		 cmp	 esi, ebx
  00010	7f 0f		 jg	 SHORT $LN7@IRandomX

; 190  :       if (max == min) return min; else return 0x80000000;

  00012	5f		 pop	 edi
  00013	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00018	5e		 pop	 esi
  00019	0f 44 c3	 cmove	 eax, ebx
  0001c	5b		 pop	 ebx

; 214  : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
$LN7@IRandomX:

; 191  :    }
; 192  : 
; 193  :    // 64 bit integers available. Use multiply and shift method
; 194  :    unsigned __int32 interval;                    // Length of interval
; 195  :    unsigned __int64 longran;                     // Random bits * interval
; 196  :    unsigned __int32 iran;                        // Longran / 2^32
; 197  :    unsigned __int32 remainder;                   // Longran % 2^32
; 198  : 
; 199  :    interval = (DWORD)(max - min + 1);

  00021	2b f3		 sub	 esi, ebx
  00023	46		 inc	 esi

; 200  :    if (interval != LastInterval) {

  00024	3b b7 c4 09 00
	00		 cmp	 esi, DWORD PTR [edi+2500]
  0002a	74 1c		 je	 SHORT $LL4@IRandomX

; 201  :       // Interval length has changed. Must calculate rejection limit
; 202  :       // Reject when remainder >= 2^32 / interval * interval
; 203  :       // RLimit will be 0 if interval is a power of 2. No rejection then
; 204  :       RLimit = DWORD(((unsigned __int64)1 << 32) / interval) * interval - 1;

  0002c	6a 00		 push	 0
  0002e	56		 push	 esi
  0002f	6a 01		 push	 1
  00031	6a 00		 push	 0
  00033	e8 00 00 00 00	 call	 __aulldiv
  00038	0f af c6	 imul	 eax, esi

; 205  :       LastInterval = interval;

  0003b	89 b7 c4 09 00
	00		 mov	 DWORD PTR [edi+2500], esi
  00041	48		 dec	 eax
  00042	89 87 c8 09 00
	00		 mov	 DWORD PTR [edi+2504], eax
$LL4@IRandomX:

; 206  :    }
; 207  :    do { // Rejection loop
; 208  :       longran  = (unsigned __int64)BRandom() * interval;

  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  0004f	8b c8		 mov	 ecx, eax
  00051	8b c6		 mov	 eax, esi
  00053	f7 e1		 mul	 ecx

; 209  :       iran = (DWORD)(longran >> 32);
; 210  :       remainder = (DWORD)longran;
; 211  :    } while (remainder > RLimit);

  00055	3b 87 c8 09 00
	00		 cmp	 eax, DWORD PTR [edi+2504]
  0005b	77 eb		 ja	 SHORT $LL4@IRandomX

; 212  :    // Convert back to signed and return result
; 213  :    return (__int32)iran + min;

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00062	5b		 pop	 ebx

; 214  : }

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
?IRandomX@CRandomMersenne@@QAEHHH@Z ENDP		; CRandomMersenne::IRandomX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?IRandom@CRandomMersenne@@QAEHH@Z
_TEXT	SEGMENT
tv76 = -8						; size = 8
tv74 = -8						; size = 8
_max$ = 8						; size = 4
?IRandom@CRandomMersenne@@QAEHH@Z PROC			; CRandomMersenne::IRandom, COMDAT
; _this$ = ecx

; 177  : int CRandomMersenne::IRandom(int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 178  :    // Multiply interval with random and truncate
; 179  :    int r = int((double)(DWORD)(max) * Random()); 

  00006	e8 00 00 00 00	 call	 ?Random@CRandomMersenne@@QAENXZ ; CRandomMersenne::Random
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _max$[ebp]
  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	66 0f 6e c1	 movd	 xmm0, ecx
  00017	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001b	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00024	f2 0f 11 45 f8	 movsd	 QWORD PTR tv74[ebp], xmm0
  00029	dc 4d f8	 fmul	 QWORD PTR tv74[ebp]
  0002c	dd 5d f8	 fstp	 QWORD PTR tv76[ebp]
  0002f	f2 0f 2c 45 f8	 cvttsd2si eax, QWORD PTR tv76[ebp]

; 180  :    if (r >= max) r = max-1;

  00034	3b c1		 cmp	 eax, ecx
  00036	7c 03		 jl	 SHORT $LN2@IRandom
  00038	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$LN2@IRandom:

; 181  :    return r;
; 182  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?IRandom@CRandomMersenne@@QAEHH@Z ENDP			; CRandomMersenne::IRandom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?IRandom@CRandomMersenne@@QAEHHH@Z
_TEXT	SEGMENT
tv87 = -8						; size = 8
tv84 = -8						; size = 8
tv80 = -8						; size = 8
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?IRandom@CRandomMersenne@@QAEHHH@Z PROC			; CRandomMersenne::IRandom, COMDAT
; _this$ = ecx

; 165  : int CRandomMersenne::IRandom(int min, int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 166  :    // Output random integer in the interval min <= x <= max
; 167  :    // Relative error on frequencies < 2^-32
; 168  :    if (max <= min) {

  00007	8b 75 08	 mov	 esi, DWORD PTR _min$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _max$[ebp]
  0000e	3b fe		 cmp	 edi, esi
  00010	7f 10		 jg	 SHORT $LN4@IRandom

; 169  :       if (max == min) return min; else return 0x80000000;

  00012	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00017	5f		 pop	 edi
  00018	0f 44 c6	 cmove	 eax, esi
  0001b	5e		 pop	 esi

; 174  :    return r;
; 175  : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
$LN4@IRandom:

; 170  :    }
; 171  :    // Multiply interval with random and truncate
; 172  :    int r = int((double)(DWORD)(max - min + 1) * Random() + min); 

  00022	e8 00 00 00 00	 call	 ?Random@CRandomMersenne@@QAENXZ ; CRandomMersenne::Random
  00027	8b c7		 mov	 eax, edi
  00029	2b c6		 sub	 eax, esi
  0002b	40		 inc	 eax
  0002c	66 0f 6e c0	 movd	 xmm0, eax
  00030	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00034	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00037	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00040	f2 0f 11 45 f8	 movsd	 QWORD PTR tv87[ebp], xmm0
  00045	dc 4d f8	 fmul	 QWORD PTR tv87[ebp]
  00048	66 0f 6e c6	 movd	 xmm0, esi
  0004c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00050	f2 0f 11 45 f8	 movsd	 QWORD PTR tv84[ebp], xmm0
  00055	dc 45 f8	 fadd	 QWORD PTR tv84[ebp]
  00058	dd 5d f8	 fstp	 QWORD PTR tv80[ebp]
  0005b	f2 0f 2c 45 f8	 cvttsd2si eax, QWORD PTR tv80[ebp]

; 173  :    if (r > max) r = max;

  00060	3b c7		 cmp	 eax, edi
  00062	0f 4f c7	 cmovg	 eax, edi
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 174  :    return r;
; 175  : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
?IRandom@CRandomMersenne@@QAEHHH@Z ENDP			; CRandomMersenne::IRandom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z
_TEXT	SEGMENT
_seeds$ = 8						; size = 4
_NumSeeds$ = 12						; size = 4
?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z PROC	; CRandomMersenne::RandomInitByArray, COMDAT
; _this$ = ecx

; 95   : void CRandomMersenne::RandomInitByArray(int const seeds[], int NumSeeds) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 96   :    // Seed by more than 32 bits
; 97   :    int i, j, k;
; 98   : 
; 99   :    // Initialize
; 100  :    Init0(19650218);

  00004	68 aa d6 2b 01	 push	 19650218		; 012bd6aaH
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?Init0@CRandomMersenne@@AAEXH@Z ; CRandomMersenne::Init0

; 101  : 
; 102  :    if (NumSeeds <= 0) return;

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _NumSeeds$[ebp]
  00013	85 c9		 test	 ecx, ecx
  00015	0f 8e b7 00 00
	00		 jle	 $LN9@RandomInit

; 103  : 
; 104  :    // Randomize mt[] using whole seeds[] array
; 105  :    i = 1;  j = 0;
; 106  :    k = (MERS_N > NumSeeds ? MERS_N : NumSeeds);

  0001b	53		 push	 ebx
  0001c	ba 70 02 00 00	 mov	 edx, 624		; 00000270H
  00021	8b d9		 mov	 ebx, ecx
  00023	57		 push	 edi
  00024	33 ff		 xor	 edi, edi
  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	3b ca		 cmp	 ecx, edx
  0002d	0f 4c da	 cmovl	 ebx, edx

; 107  :    for (; k; k--) {

  00030	85 db		 test	 ebx, ebx
  00032	74 42		 je	 SHORT $LN3@RandomInit
$LL4@RandomInit:

; 108  :       mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL)) + (DWORD)seeds[j] + j;

  00034	8b 54 86 fc	 mov	 edx, DWORD PTR [esi+eax*4-4]
  00038	c1 ea 1e	 shr	 edx, 30			; 0000001eH
  0003b	33 54 86 fc	 xor	 edx, DWORD PTR [esi+eax*4-4]
  0003f	69 ca 0d 66 19
	00		 imul	 ecx, edx, 1664525
  00045	8b 55 08	 mov	 edx, DWORD PTR _seeds$[ebp]
  00048	33 0c 86	 xor	 ecx, DWORD PTR [esi+eax*4]
  0004b	03 0c ba	 add	 ecx, DWORD PTR [edx+edi*4]
  0004e	03 cf		 add	 ecx, edi

; 109  :       i++; j++;

  00050	47		 inc	 edi
  00051	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  00054	40		 inc	 eax

; 110  :       if (i >= MERS_N) {mt[0] = mt[MERS_N-1]; i=1;}

  00055	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  0005a	7c 0d		 jl	 SHORT $LN12@RandomInit
  0005c	8b 86 bc 09 00
	00		 mov	 eax, DWORD PTR [esi+2492]
  00062	89 06		 mov	 DWORD PTR [esi], eax
  00064	b8 01 00 00 00	 mov	 eax, 1
$LN12@RandomInit:

; 111  :       if (j >= NumSeeds) j=0;}

  00069	33 c9		 xor	 ecx, ecx
  0006b	3b 7d 0c	 cmp	 edi, DWORD PTR _NumSeeds$[ebp]
  0006e	0f 4d f9	 cmovge	 edi, ecx
  00071	83 eb 01	 sub	 ebx, 1
  00074	75 be		 jne	 SHORT $LL4@RandomInit
$LN3@RandomInit:

; 112  :    for (k = MERS_N-1; k; k--) {

  00076	bf 6f 02 00 00	 mov	 edi, 623		; 0000026fH
  0007b	0f 1f 44 00 00	 npad	 5
$LL7@RandomInit:

; 113  :       mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL)) - i;

  00080	8b 54 86 fc	 mov	 edx, DWORD PTR [esi+eax*4-4]
  00084	c1 ea 1e	 shr	 edx, 30			; 0000001eH
  00087	33 54 86 fc	 xor	 edx, DWORD PTR [esi+eax*4-4]
  0008b	69 ca 65 8b 58
	5d		 imul	 ecx, edx, 1566083941
  00091	33 0c 86	 xor	 ecx, DWORD PTR [esi+eax*4]
  00094	2b c8		 sub	 ecx, eax
  00096	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx

; 114  :       if (++i >= MERS_N) {mt[0] = mt[MERS_N-1]; i=1;}}

  00099	40		 inc	 eax
  0009a	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  0009f	7c 0d		 jl	 SHORT $LN5@RandomInit
  000a1	8b 86 bc 09 00
	00		 mov	 eax, DWORD PTR [esi+2492]
  000a7	89 06		 mov	 DWORD PTR [esi], eax
  000a9	b8 01 00 00 00	 mov	 eax, 1
$LN5@RandomInit:

; 112  :    for (k = MERS_N-1; k; k--) {

  000ae	83 ef 01	 sub	 edi, 1
  000b1	75 cd		 jne	 SHORT $LL7@RandomInit

; 115  :    mt[0] = 0x80000000UL;  // MSB is 1; assuring non-zero initial array
; 116  : 
; 117  :    // Randomize some more
; 118  :    mti = 0;

  000b3	89 be c0 09 00
	00		 mov	 DWORD PTR [esi+2496], edi
  000b9	bf 71 02 00 00	 mov	 edi, 625		; 00000271H
  000be	c7 06 00 00 00
	80		 mov	 DWORD PTR [esi], -2147483648 ; 80000000H
$LL10@RandomInit:

; 119  :    for ( i = 0; i <= MERS_N; i++) BRandom();

  000c4	8b ce		 mov	 ecx, esi
  000c6	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  000cb	83 ef 01	 sub	 edi, 1
  000ce	75 f4		 jne	 SHORT $LL10@RandomInit
  000d0	5f		 pop	 edi
  000d1	5b		 pop	 ebx
$LN9@RandomInit:
  000d2	5e		 pop	 esi

; 120  : }

  000d3	5d		 pop	 ebp
  000d4	c2 08 00	 ret	 8
?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z ENDP	; CRandomMersenne::RandomInitByArray
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?RandomInit@CRandomMersenne@@QAEXH@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?RandomInit@CRandomMersenne@@QAEXH@Z PROC		; CRandomMersenne::RandomInit, COMDAT
; _this$ = ecx

; 86   : void CRandomMersenne::RandomInit(int seed) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 87   :    // Initialize and seed
; 88   :    Init0(seed);

  00005	ff 75 08	 push	 DWORD PTR _seed$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	e8 00 00 00 00	 call	 ?Init0@CRandomMersenne@@AAEXH@Z ; CRandomMersenne::Init0
  0000f	be 25 00 00 00	 mov	 esi, 37			; 00000025H
$LL4@RandomInit:

; 89   : 
; 90   :    // Randomize some more
; 91   :    for (int i = 0; i < 37; i++) BRandom();

  00014	8b cf		 mov	 ecx, edi
  00016	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  0001b	83 ee 01	 sub	 esi, 1
  0001e	75 f4		 jne	 SHORT $LL4@RandomInit
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 92   : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?RandomInit@CRandomMersenne@@QAEXH@Z ENDP		; CRandomMersenne::RandomInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.h
;	COMDAT ??0CRandomMersenne@@QAE@H@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
??0CRandomMersenne@@QAE@H@Z PROC			; CRandomMersenne::CRandomMersenne, COMDAT
; _this$ = ecx

; 62   :    CRandomMersenne(int seed) {         // Constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 63   :       RandomInit(seed); LastInterval = 0;}

  00004	ff 75 08	 push	 DWORD PTR _seed$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?RandomInit@CRandomMersenne@@QAEXH@Z ; CRandomMersenne::RandomInit
  0000e	c7 86 c4 09 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2500], 0
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0CRandomMersenne@@QAE@H@Z ENDP			; CRandomMersenne::CRandomMersenne
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
; File c:\users\michel\desktop\source\gameserver\source\largerand.h
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?GetLargeRand@@YAKXZ
_TEXT	SEGMENT
?GetLargeRand@@YAKXZ PROC				; GetLargeRand, COMDAT
; File c:\users\michel\desktop\source\gameserver\source\largerand.h

; 22   : 		this->left--;

  00000	83 2d cc 09 00
	00 01		 sub	 DWORD PTR ?g_LargLand@@3VCLargeRand@@A+2508, 1

; 23   : 
; 24   : 		if ( this->left< 0 )

  00007	79 0a		 jns	 SHORT $LN4@GetLargeRa

; 25   : 		{
; 26   : 			return this->reloadMT();

  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LargLand@@3VCLargeRand@@A ; g_LargLand
  0000e	e9 00 00 00 00	 jmp	 ?reloadMT@CLargeRand@@QAEKXZ ; CLargeRand::reloadMT
$LN4@GetLargeRa:

; 27   : 		}
; 28   : 
; 29   : 		DWORD y = *next;

  00013	a1 c8 09 00 00	 mov	 eax, DWORD PTR ?g_LargLand@@3VCLargeRand@@A+2504
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]

; 30   : 		next++;

  0001a	83 c0 04	 add	 eax, 4
  0001d	a3 c8 09 00 00	 mov	 DWORD PTR ?g_LargLand@@3VCLargeRand@@A+2504, eax

; 31   : 		y ^= ( (DWORD)y >> (DWORD)11 );

  00022	8b c1		 mov	 eax, ecx
  00024	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00027	33 c8		 xor	 ecx, eax

; 32   : 		y ^= ( y << 7 ) & 2636928640;

  00029	8b c1		 mov	 eax, ecx
  0002b	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  00030	c1 e0 07	 shl	 eax, 7
  00033	33 c8		 xor	 ecx, eax

; 33   : 		y ^= ( y << 15 ) & 4022730752;

  00035	8b c1		 mov	 eax, ecx
  00037	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  0003c	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0003f	33 c8		 xor	 ecx, eax

; 34   : 
; 35   : 		return y ^ ( y >> 18 );

  00041	8b c1		 mov	 eax, ecx
  00043	c1 e8 12	 shr	 eax, 18			; 00000012H
  00046	33 c1		 xor	 eax, ecx
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp

; 9    : }

  00048	c3		 ret	 0
?GetLargeRand@@YAKXZ ENDP				; GetLargeRand
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCLargeRand@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCLargeRand@@UAEPAXI@Z PROC				; CLargeRand::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CLargeRand@@UAE@XZ	; CLargeRand::~CLargeRand
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 d0 09 00 00	 push	 2512			; 000009d0H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCLargeRand@@UAEPAXI@Z ENDP				; CLargeRand::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.h
;	COMDAT ?randomMT@CLargeRand@@QAEKXZ
_TEXT	SEGMENT
?randomMT@CLargeRand@@QAEKXZ PROC			; CLargeRand::randomMT, COMDAT
; _this$ = ecx

; 21   : 	{

  00000	8b d1		 mov	 edx, ecx

; 22   : 		this->left--;

  00002	83 82 cc 09 00
	00 ff		 add	 DWORD PTR [edx+2508], -1

; 23   : 
; 24   : 		if ( this->left< 0 )

  00009	0f 88 00 00 00
	00		 js	 ?reloadMT@CLargeRand@@QAEKXZ ; CLargeRand::reloadMT

; 25   : 		{
; 26   : 			return this->reloadMT();
; 27   : 		}
; 28   : 
; 29   : 		DWORD y = *next;

  0000f	8b 82 c8 09 00
	00		 mov	 eax, DWORD PTR [edx+2504]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]

; 30   : 		next++;

  00017	83 c0 04	 add	 eax, 4
  0001a	89 82 c8 09 00
	00		 mov	 DWORD PTR [edx+2504], eax

; 31   : 		y ^= ( (DWORD)y >> (DWORD)11 );

  00020	8b c1		 mov	 eax, ecx
  00022	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00025	33 c8		 xor	 ecx, eax

; 32   : 		y ^= ( y << 7 ) & 2636928640;

  00027	8b c1		 mov	 eax, ecx
  00029	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  0002e	c1 e0 07	 shl	 eax, 7
  00031	33 c8		 xor	 ecx, eax

; 33   : 		y ^= ( y << 15 ) & 4022730752;

  00033	8b c1		 mov	 eax, ecx
  00035	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  0003a	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0003d	33 c8		 xor	 ecx, eax

; 34   : 
; 35   : 		return y ^ ( y >> 18 );

  0003f	8b c1		 mov	 eax, ecx
  00041	c1 e8 12	 shr	 eax, 18			; 00000012H
  00044	33 c1		 xor	 eax, ecx

; 36   : 	};

  00046	c3		 ret	 0
?randomMT@CLargeRand@@QAEKXZ ENDP			; CLargeRand::randomMT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?reloadMT@CLargeRand@@QAEKXZ
_TEXT	SEGMENT
tv302 = -12						; size = 4
tv297 = -8						; size = 4
_j$2$ = -8						; size = 4
_j$1$ = -4						; size = 4
_pM$1$ = -4						; size = 4
?reloadMT@CLargeRand@@QAEKXZ PROC			; CLargeRand::reloadMT, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 40   : 	DWORD * p0 = this->state;
; 41   : 	DWORD * p2 = &this->state[2];
; 42   : 	DWORD * pM = &this->state[397];
; 43   : 
; 44   : 	if ( this->left < -1 )

  0000b	83 bb cc 09 00
	00 ff		 cmp	 DWORD PTR [ebx+2508], -1
  00012	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00015	89 45 f4	 mov	 DWORD PTR tv302[ebp], eax
  00018	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  0001b	8b f8		 mov	 edi, eax
  0001d	8d 8b 38 06 00
	00		 lea	 ecx, DWORD PTR [ebx+1592]
  00023	7d 12		 jge	 SHORT $LN8@reloadMT

; 45   : 		this->seedMT(0x1105);

  00025	68 05 11 00 00	 push	 4357			; 00001105H
  0002a	8b cb		 mov	 ecx, ebx
  0002c	e8 00 00 00 00	 call	 ?seedMT@CLargeRand@@QAEXK@Z ; CLargeRand::seedMT
  00031	8d 8b 38 06 00
	00		 lea	 ecx, DWORD PTR [ebx+1592]
$LN8@reloadMT:

; 46   : 
; 47   : 	this->left = MAX_LARGE_RAND_STATE-2;
; 48   : 	this->next = &this->state[1];

  00037	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0003a	c7 83 cc 09 00
	00 6f 02 00 00	 mov	 DWORD PTR [ebx+2508], 623 ; 0000026fH
  00044	89 83 c8 09 00
	00		 mov	 DWORD PTR [ebx+2504], eax

; 49   : 	DWORD s0 = this->state[0];	
; 50   : 	DWORD s1 = this->state[1];
; 51   : 
; 52   : 	int j;
; 53   : 	for ( j= 228; --j != 0 ; s0 = s1, s1 = *p2, p2++)

  0004a	2b ce		 sub	 ecx, esi
  0004c	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  0004f	8b 10		 mov	 edx, DWORD PTR [eax]
  00051	c7 45 fc e3 00
	00 00		 mov	 DWORD PTR _j$1$[ebp], 227 ; 000000e3H
  00058	89 4d f8	 mov	 DWORD PTR tv297[ebp], ecx
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@reloadMT:

; 54   : 	{
; 55   : 		*p0++ = (*pM++ ^ (((s0 & 0x80000000) | (s1 & 0x7FFFFFFF)) >> 1)) ^ ((((s1&1)!=0)?-1:0)&0x9908B0DF);

  00060	8b ca		 mov	 ecx, edx
  00062	8b c2		 mov	 eax, edx
  00064	33 cb		 xor	 ecx, ebx
  00066	24 01		 and	 al, 1
  00068	81 e1 fe ff ff
	7f		 and	 ecx, 2147483646		; 7ffffffeH
  0006e	0f b6 c0	 movzx	 eax, al
  00071	33 cb		 xor	 ecx, ebx
  00073	8b da		 mov	 ebx, edx
  00075	d1 e9		 shr	 ecx, 1
  00077	f7 d8		 neg	 eax
  00079	1b c0		 sbb	 eax, eax
  0007b	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00080	33 c8		 xor	 ecx, eax
  00082	8b 45 f8	 mov	 eax, DWORD PTR tv297[ebp]
  00085	33 0c 30	 xor	 ecx, DWORD PTR [eax+esi]
  00088	89 0f		 mov	 DWORD PTR [edi], ecx
  0008a	83 c7 04	 add	 edi, 4
  0008d	8b 16		 mov	 edx, DWORD PTR [esi]
  0008f	83 c6 04	 add	 esi, 4
  00092	83 6d fc 01	 sub	 DWORD PTR _j$1$[ebp], 1
  00096	75 c8		 jne	 SHORT $LL4@reloadMT

; 56   : 	}
; 57   : 
; 58   : 	pM = this->state;

  00098	8b 45 f4	 mov	 eax, DWORD PTR tv302[ebp]
  0009b	89 45 fc	 mov	 DWORD PTR _pM$1$[ebp], eax

; 59   : 
; 60   : 	for( j=397 ; --j != 0 ; s0=s1 , s1 = *p2 , p2++ )

  0009e	c7 45 f8 8c 01
	00 00		 mov	 DWORD PTR _j$2$[ebp], 396 ; 0000018cH
$LL7@reloadMT:

; 61   : 	{
; 62   : 		*p0++ = (*pM++ ^ (((s0 & 0x80000000) | (s1 & 0x7FFFFFFF)) >> 1)) ^ ((((s1&1)!=0)?-1:0)&0x9908B0DF);

  000a5	8b ca		 mov	 ecx, edx
  000a7	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  000aa	33 cb		 xor	 ecx, ebx
  000ac	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  000af	81 e1 fe ff ff
	7f		 and	 ecx, 2147483646		; 7ffffffeH
  000b5	8b c2		 mov	 eax, edx
  000b7	24 01		 and	 al, 1
  000b9	33 cb		 xor	 ecx, ebx
  000bb	0f b6 c0	 movzx	 eax, al
  000be	8b da		 mov	 ebx, edx
  000c0	d1 e9		 shr	 ecx, 1
  000c2	f7 d8		 neg	 eax
  000c4	1b c0		 sbb	 eax, eax
  000c6	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  000cb	33 c8		 xor	 ecx, eax
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _pM$1$[ebp]
  000d0	33 08		 xor	 ecx, DWORD PTR [eax]
  000d2	83 c0 04	 add	 eax, 4
  000d5	83 6d f8 01	 sub	 DWORD PTR _j$2$[ebp], 1
  000d9	89 4f fc	 mov	 DWORD PTR [edi-4], ecx
  000dc	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000df	89 45 fc	 mov	 DWORD PTR _pM$1$[ebp], eax
  000e2	75 c1		 jne	 SHORT $LL7@reloadMT

; 63   : 	}
; 64   : 
; 65   : 	s1 = this->state[0];

  000e4	8b 45 f4	 mov	 eax, DWORD PTR tv302[ebp]
  000e7	8b 10		 mov	 edx, DWORD PTR [eax]

; 66   : 	*p0 = (*pM ^ (((s0 & 0x80000000) | (s1 & 0x7FFFFFFF)) >> 1)) ^ ((((s1&1)!=0)?-1:0)&0x9908B0DF);

  000e9	8b ca		 mov	 ecx, edx
  000eb	33 cb		 xor	 ecx, ebx
  000ed	8b c2		 mov	 eax, edx
  000ef	24 01		 and	 al, 1
  000f1	81 e1 fe ff ff
	7f		 and	 ecx, 2147483646		; 7ffffffeH
  000f7	0f b6 c0	 movzx	 eax, al
  000fa	33 cb		 xor	 ecx, ebx
  000fc	d1 e9		 shr	 ecx, 1
  000fe	f7 d8		 neg	 eax
  00100	1b c0		 sbb	 eax, eax
  00102	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00107	33 c8		 xor	 ecx, eax
  00109	8b 45 fc	 mov	 eax, DWORD PTR _pM$1$[ebp]
  0010c	33 08		 xor	 ecx, DWORD PTR [eax]

; 67   : 	s1 ^= s1 >> 11;

  0010e	8b c2		 mov	 eax, edx
  00110	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00113	33 d0		 xor	 edx, eax
  00115	89 0f		 mov	 DWORD PTR [edi], ecx

; 68   : 	s1 ^= (s1 << 7) & 0x9D2C5680;

  00117	8b c2		 mov	 eax, edx
  00119	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  0011e	c1 e0 07	 shl	 eax, 7
  00121	33 d0		 xor	 edx, eax

; 69   : 	s1 ^= (s1 << 15) & 0xEFC60000;

  00123	8b c2		 mov	 eax, edx
  00125	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  0012a	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0012d	33 d0		 xor	 edx, eax
  0012f	5f		 pop	 edi

; 70   : 
; 71   : 	return s1 ^ ( s1 >> 18 );

  00130	8b c2		 mov	 eax, edx
  00132	c1 e8 12	 shr	 eax, 18			; 00000012H
  00135	5e		 pop	 esi
  00136	33 c2		 xor	 eax, edx
  00138	5b		 pop	 ebx

; 72   : }

  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
?reloadMT@CLargeRand@@QAEKXZ ENDP			; CLargeRand::reloadMT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?seedMT@CLargeRand@@QAEXK@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?seedMT@CLargeRand@@QAEXK@Z PROC			; CLargeRand::seedMT, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 	DWORD x = seed | 1;

  00003	8b 55 08	 mov	 edx, DWORD PTR _seed$[ebp]

; 28   : 	DWORD * s = this->state;

  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00009	83 ca 01	 or	 edx, 1

; 29   : 	this->left = 0;

  0000c	c7 81 cc 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2508], 0

; 30   : 	*s = x;

  00016	89 10		 mov	 DWORD PTR [eax], edx

; 31   : 	s++;
; 32   : 
; 33   : 	for ( int j = MAX_LARGE_RAND_STATE-1 ; --j != 0 ;  x *= 69069, *s = x, s++);

  00018	b9 6f 02 00 00	 mov	 ecx, 623		; 0000026fH
  0001d	83 c0 04	 add	 eax, 4
$LL4@seedMT:
  00020	69 d2 cd 0d 01
	00		 imul	 edx, edx, 69069
  00026	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00029	89 50 fc	 mov	 DWORD PTR [eax-4], edx
  0002c	83 e9 01	 sub	 ecx, 1
  0002f	75 ef		 jne	 SHORT $LL4@seedMT

; 34   : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?seedMT@CLargeRand@@QAEXK@Z ENDP			; CLargeRand::seedMT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ??1CLargeRand@@UAE@XZ
_TEXT	SEGMENT
??1CLargeRand@@UAE@XZ PROC				; CLargeRand::~CLargeRand, COMDAT
; _this$ = ecx

; 20   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CLargeRand@@6B@

; 21   : 	return;
; 22   : }

  00006	c3		 ret	 0
??1CLargeRand@@UAE@XZ ENDP				; CLargeRand::~CLargeRand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ??0CLargeRand@@QAE@XZ
_TEXT	SEGMENT
??0CLargeRand@@QAE@XZ PROC				; CLargeRand::CLargeRand, COMDAT
; _this$ = ecx

; 13   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CLargeRand@@6B@

; 14   : 	this->left = -1;
; 15   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 81 cc 09 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+2508], -1
  00012	c3		 ret	 0
??0CLargeRand@@QAE@XZ ENDP				; CLargeRand::CLargeRand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  :         }

  00003	5d		 pop	 ebp

; 535  :             return _time64(_Time);

  00004	e9 00 00 00 00	 jmp	 __time64
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\largerand.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 239  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
