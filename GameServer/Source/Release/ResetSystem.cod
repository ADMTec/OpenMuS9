; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\ResetSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char *>
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
PUBLIC	?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z ; std::allocator<ResetItem>::allocate
PUBLIC	??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >
PUBLIC	?push_back@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEXABUResetItem@@@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::push_back
PUBLIC	?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reserve
PUBLIC	?_Tidy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXXZ ; std::vector<ResetItem,std::allocator<ResetItem> >::_Tidy
PUBLIC	??1ResetGroup@@QAE@XZ				; ResetGroup::~ResetGroup
PUBLIC	??0ResetGroup@@QAE@ABU0@@Z			; ResetGroup::ResetGroup
PUBLIC	??0ResetGroup@@QAE@$$QAU0@@Z			; ResetGroup::ResetGroup
PUBLIC	?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
PUBLIC	?allocate@?$allocator@UResetGroup@@@std@@QAEPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::allocate
PUBLIC	?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
PUBLIC	??1ResetData@@QAE@XZ				; ResetData::~ResetData
PUBLIC	??0ResetSystem@@QAE@XZ				; ResetSystem::ResetSystem
PUBLIC	??1ResetSystem@@UAE@XZ				; ResetSystem::~ResetSystem
PUBLIC	?Init@ResetSystem@@QAEXXZ			; ResetSystem::Init
PUBLIC	?Load@ResetSystem@@QAEXXZ			; ResetSystem::Load
PUBLIC	?Read@ResetSystem@@QAEXPAD@Z			; ResetSystem::Read
PUBLIC	?ProcDialog@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@0@Z ; ResetSystem::ProcDialog
PUBLIC	?ProcReset@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@EE@Z ; ResetSystem::ProcReset
PUBLIC	?GC_OpenDialog@ResetSystem@@QAEXPAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::GC_OpenDialog
PUBLIC	?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
PUBLIC	?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z ; ResetSystem::CG_RequestStart
PUBLIC	?IsValidItemNode@ResetSystem@@AAE_NUResetItem@@@Z ; ResetSystem::IsValidItemNode
PUBLIC	?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_NE@Z ; ResetSystem::CheckRequirements
PUBLIC	?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::CheckRequirements
PUBLIC	?GetItemInventoryPos@ResetSystem@@AAEEPAUOBJECTSTRUCT@@UResetItem@@@Z ; ResetSystem::GetItemInventoryPos
PUBLIC	?GetResetMoney@ResetSystem@@AAEHPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_N@Z ; ResetSystem::GetResetMoney
PUBLIC	?GetResetGroup@ResetSystem@@AAEPAUResetGroup@@PAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::GetResetGroup
PUBLIC	??_GResetSystem@@UAEPAXI@Z			; ResetSystem::`scalar deleting destructor'
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
PUBLIC	??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::allocator<ResetGroup>,ResetGroup>
PUBLIC	??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetItem *,ResetItem *,std::allocator<ResetItem>,ResetItem>
PUBLIC	??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::allocator<ResetItem> >
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7ResetSystem@@6B@				; ResetSystem::`vftable'
PUBLIC	?g_ResetSystem@@3VResetSystem@@A		; g_ResetSystem
PUBLIC	??_C@_0M@FCNIBGCF@?4?2Log?2Reset?$AA@		; `string'
PUBLIC	??_C@_05CCGMLFNG@Reset?$AA@			; `string'
PUBLIC	??_C@_0BH@MNGMBMNH@Custom?2ResetSystem?4xml?$AA@ ; `string'
PUBLIC	??_C@_0CB@KHAPEMJG@?$FLResetSystem?$FN?5File?5?$CFs?5not?5found?$CB@ ; `string'
PUBLIC	??_C@_0M@HLIFFONB@resetsystem?$AA@		; `string'
PUBLIC	??_C@_06IKLLLDHL@normal?$AA@			; `string'
PUBLIC	??_C@_07MHHIKOPA@enabled?$AA@			; `string'
PUBLIC	??_C@_03BPGDPAOH@npc?$AA@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id?$AA@			; `string'
PUBLIC	??_C@_03HBNNNHNM@map?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	??_C@_01EANLCPLP@y?$AA@				; `string'
PUBLIC	??_C@_09EKKKGLLH@grouplist?$AA@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group?$AA@			; `string'
PUBLIC	??_C@_08EHBDOELG@minlevel?$AA@			; `string'
PUBLIC	??_C@_08JAPIFGPH@maxlevel?$AA@			; `string'
PUBLIC	??_C@_08MLAKOPDG@minreset?$AA@			; `string'
PUBLIC	??_C@_08BMOBFNHH@maxreset?$AA@			; `string'
PUBLIC	??_C@_05IKCNOJAA@money?$AA@			; `string'
PUBLIC	??_C@_06JEOJDFIL@wcoinc?$AA@			; `string'
PUBLIC	??_C@_06PFAGHEBJ@wcoinp?$AA@			; `string'
PUBLIC	??_C@_06PAIFPAIP@wcoing?$AA@			; `string'
PUBLIC	??_C@_05KIGPLGEM@gensp?$AA@			; `string'
PUBLIC	??_C@_07JKABFLJI@credits?$AA@			; `string'
PUBLIC	??_C@_05EKJCMADO@delay?$AA@			; `string'
PUBLIC	??_C@_08OJKDDGJG@cleaning?$AA@			; `string'
PUBLIC	??_C@_05BLKJBNOD@stats?$AA@			; `string'
PUBLIC	??_C@_06GPGIDCJA@points?$AA@			; `string'
PUBLIC	??_C@_06HNCNFAFI@skills?$AA@			; `string'
PUBLIC	??_C@_09FJJPPKDN@equipment?$AA@			; `string'
PUBLIC	??_C@_09OCPGKIKB@inventory?$AA@			; `string'
PUBLIC	??_C@_04BFIJLIPK@shop?$AA@			; `string'
PUBLIC	??_C@_0M@BHKEDLCN@masterlevel?$AA@		; `string'
PUBLIC	??_C@_0N@GHLLHCDN@masterpoints?$AA@		; `string'
PUBLIC	??_C@_0N@HFPOBAPF@masterskills?$AA@		; `string'
PUBLIC	??_C@_0M@NJHEGDCF@marlonquest?$AA@		; `string'
PUBLIC	??_C@_06ELLFFOK@checks?$AA@			; `string'
PUBLIC	??_C@_06NPNBMBEO@reward?$AA@			; `string'
PUBLIC	??_C@_09LIMLDHCM@pointmode?$AA@			; `string'
PUBLIC	??_C@_05ENKANFLO@class?$AA@			; `string'
PUBLIC	??_C@_0DK@DFHDDGPP@?$FLResetSystem?$FN?5Syntax?5error?5in?5re@ ; `string'
PUBLIC	??_C@_05BBEJFBFA@point?$AA@			; `string'
PUBLIC	??_C@_09GEBMJOEB@itemslist?$AA@			; `string'
PUBLIC	??_C@_04NHONDGDE@item?$AA@			; `string'
PUBLIC	??_C@_04GPMDFGEJ@type?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_06GJMPOCOI@minlvl?$AA@			; `string'
PUBLIC	??_C@_06GKDMACKH@maxlvl?$AA@			; `string'
PUBLIC	??_C@_06HKHMELIB@mindur?$AA@			; `string'
PUBLIC	??_C@_06HJIPKLMO@maxdur?$AA@			; `string'
PUBLIC	??_C@_06PNOMKJON@minopt?$AA@			; `string'
PUBLIC	??_C@_06POBPEJKC@maxopt?$AA@			; `string'
PUBLIC	??_C@_04PFGGAFBF@luck?$AA@			; `string'
PUBLIC	??_C@_05ODMCMJAJ@skill?$AA@			; `string'
PUBLIC	??_C@_09MBDMPFOO@excellent?$AA@			; `string'
PUBLIC	??_C@_07ECLFICCK@ancient?$AA@			; `string'
PUBLIC	??_C@_06HBELJPBO@socket?$AA@			; `string'
PUBLIC	??_C@_07HCLJNICE@element?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_05BIJMAKPO@grand?$AA@			; `string'
PUBLIC	??_C@_0EH@JIBFDEBN@Configuration?5loaded?5?$CItotal?5norm@ ; `string'
PUBLIC	??_C@_0DK@CBFNKBNC@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DL@CCJFLBFF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DM@BHNBMNGH@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DM@BFGHIPAP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DM@IFBEJPOF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DM@LMACCKIM@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DM@CMHBDKGG@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DK@FBBLNOEP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DP@KLHIOMDO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DN@BLMDLPJA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DM@CNNHDLNO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0DN@NGBPCBKA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ ; `string'
PUBLIC	??_C@_0EC@DDGJLPOE@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0BE@JGOLOEHN@Please?5wait?5?$CFd?5min?4?$AA@ ; `string'
PUBLIC	??_C@_0N@MCNFFMDL@Reset?5Master?$AA@		; `string'
PUBLIC	??_C@_0CA@JEOKHFNI@You?5have?5already?5finished?5delay?$AA@ ; `string'
PUBLIC	??_C@_0CB@DCFNDEH@My?5regards?5?$CFs?$CB?6You?5get?5?$CFd?5reset?$CB@ ; `string'
PUBLIC	??_C@_0EJ@CFLHBDGO@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0DL@GGGLIEL@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0DM@ODCDHJJI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0EA@HDHNPDP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0ED@LOMANMPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0DP@IPNLPBJN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0DP@KLDGOEGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0DK@JNFAEODI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0EB@CGCLGMFP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0EC@HLOPMGCK@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0EB@LCDOCNPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0DE@KKKJHHJG@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0EI@PDDMMGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ ; `string'
PUBLIC	??_C@_0ED@HIBGDJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIOpenDia@ ; `string'
PUBLIC	??_C@_0EB@IEMKIHCJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0CP@OFICEAAH@Hey?5?$CFs?$CB?6I?5think?5you?5forgot?6remov@ ; `string'
PUBLIC	??_C@_0EB@JBHKEPMB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0CK@PMGLBKIN@?$CFs?0?5maybe?5you?5forgot?6clean?5out?5i@ ; `string'
PUBLIC	??_C@_0DM@INNFFOLH@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0CF@NPOOAECJ@?$CFs?0?5please?5clean?5your?6personal?5s@ ; `string'
PUBLIC	??_C@_0GL@HKMJCFGF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0CM@NIJOIGCG@Great?5?$CFs?$CB?6You?5need?5?$CFd?5level?6for?5@ ; `string'
PUBLIC	??_C@_0FH@GNAIDNOJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0CK@BAFCACOI@Hey?5?$CFs?$CB?6You?5need?5?$CFd?5Money?6for?5th@ ; `string'
PUBLIC	??_C@_0FJ@CMHDJMHA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0EB@ODDJMFE@Hello?0?5?$CFs?$CB?6You?5need?5?$CFd?5Credits?5f@ ; `string'
PUBLIC	??_C@_0FI@BADCMJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0CM@IMDIKCEK@Hey?0?5?$CFs?$CB?6You?5need?5?$CFd?5WCoinC?6for?5@ ; `string'
PUBLIC	??_C@_0FH@GEIIDDDF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0DD@MNPCIAAH@Great?5?$CFs?$CB?6You?5need?5?$CFd?5Contributi@ ; `string'
PUBLIC	??_C@_0BAA@LFFJLJBC@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0EK@OGMNMFNN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ ; `string'
PUBLIC	??_C@_0FG@DGNILBKD@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIGetRese@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4ResetSystem@@6B@				; ResetSystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVResetSystem@@@8				; ResetSystem `RTTI Type Descriptor'
PUBLIC	??_R3ResetSystem@@8				; ResetSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ResetSystem@@8				; ResetSystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ResetSystem@@8			; ResetSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
EXTRN	?Clear@CMagicInf@@QAEXXZ:PROC			; CMagicInf::Clear
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
EXTRN	??_EResetSystem@@UAEPAXI@Z:PROC			; ResetSystem::`vector deleting destructor'
EXTRN	?as_int@xml_attribute@pugi@@QBEHH@Z:PROC	; pugi::xml_attribute::as_int
EXTRN	??0xml_node@pugi@@QAE@XZ:PROC			; pugi::xml_node::xml_node
EXTRN	??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ:PROC	; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
EXTRN	?next_sibling@xml_node@pugi@@QBE?AV12@XZ:PROC	; pugi::xml_node::next_sibling
EXTRN	?text@xml_node@pugi@@QBE?AVxml_text@2@XZ:PROC	; pugi::xml_node::text
EXTRN	?child@xml_node@pugi@@QBE?AV12@PBD@Z:PROC	; pugi::xml_node::child
EXTRN	?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z:PROC ; pugi::xml_node::attribute
EXTRN	?as_int@xml_text@pugi@@QBEHH@Z:PROC		; pugi::xml_text::as_int
EXTRN	??0xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::xml_document
EXTRN	??1xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::~xml_document
EXTRN	?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z:PROC ; pugi::xml_document::load_file
EXTRN	?SetNextExp@CMasterExperience@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMasterExperience::SetNextExp
EXTRN	?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
EXTRN	?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::ReSetQuestState
EXTRN	?GetGate@CGate@@QAEHHAAE000AAF@Z:PROC		; CGate::GetGate
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?m_ObjBill@@3PAVBILL_CLASS@@A:BYTE		; m_ObjBill
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?g_MasterExp@@3VCMasterExperience@@A:BYTE	; g_MasterExp
EXTRN	?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A:BYTE ; g_MasterSkillSystem
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_ResetSystem@@3VResetSystem@@A DB 030H DUP (?)	; g_ResetSystem
_BSS	ENDS
CRT$XCU	SEGMENT
?g_ResetSystem$initializer$@@3P6AXXZA DD FLAT:??__Eg_ResetSystem@@YAXXZ ; g_ResetSystem$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@ResetSystem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ResetSystem@@8 DD FLAT:??_R0?AVResetSystem@@@8 ; ResetSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ResetSystem@@8
rdata$r	ENDS
;	COMDAT ??_R2ResetSystem@@8
rdata$r	SEGMENT
??_R2ResetSystem@@8 DD FLAT:??_R1A@?0A@EA@ResetSystem@@8 ; ResetSystem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ResetSystem@@8
rdata$r	SEGMENT
??_R3ResetSystem@@8 DD 00H				; ResetSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ResetSystem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVResetSystem@@@8
data$r	SEGMENT
??_R0?AVResetSystem@@@8 DD FLAT:??_7type_info@@6B@	; ResetSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResetSystem@@', 00H
data$r	ENDS
;	COMDAT ??_R4ResetSystem@@6B@
rdata$r	SEGMENT
??_R4ResetSystem@@6B@ DD 00H				; ResetSystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVResetSystem@@@8
	DD	FLAT:??_R3ResetSystem@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@DGNILBKD@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIGetRese@
CONST	SEGMENT
??_C@_0FG@DGNILBKD@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIGetRese@ DB '['
	DB	'ResetSystem] [%s] [%s] (GetResetMoney) Calculated wrong value'
	DB	' (Reset: %d, Value: %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@OGMNMFNN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0EK@OGMNMFNN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Group for this use'
	DB	'r not found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAA@LFFJLJBC@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0BAA@LFFJLJBC@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Not have required '
	DB	'item (type: %d, index: %d, minlevel: %d, maxlevel: %d, mindur'
	DB	': %d, maxdur: %d, minoption: %d, maxoption: %d, luck: %d, ski'
	DB	'll: %d, excellent: %d, ancient: %d, socket: %d, element: %d, '
	DB	'count: %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MNPCIAAH@Great?5?$CFs?$CB?6You?5need?5?$CFd?5Contributi@
CONST	SEGMENT
??_C@_0DD@MNPCIAAH@Great?5?$CFs?$CB?6You?5need?5?$CFd?5Contributi@ DB 'Gr'
	DB	'eat %s!', 0aH, 'You need %d Contribution', 0aH, 'for this res'
	DB	'et.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@GEIIDDDF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0FH@GEIIDDDF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Not have enough Ge'
	DB	'nsP (need: %d, user: %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IMDIKCEK@Hey?0?5?$CFs?$CB?6You?5need?5?$CFd?5WCoinC?6for?5@
CONST	SEGMENT
??_C@_0CM@IMDIKCEK@Hey?0?5?$CFs?$CB?6You?5need?5?$CFd?5WCoinC?6for?5@ DB 'H'
	DB	'ey, %s!', 0aH, 'You need %d WCoinC', 0aH, 'for this reset.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@BADCMJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0FI@BADCMJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Not have enough WC'
	DB	'oinC (need: %d, user: %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@ODDJMFE@Hello?0?5?$CFs?$CB?6You?5need?5?$CFd?5Credits?5f@
CONST	SEGMENT
??_C@_0EB@ODDJMFE@Hello?0?5?$CFs?$CB?6You?5need?5?$CFd?5Credits?5f@ DB 'H'
	DB	'ello, %s!', 0aH, 'You need %d Credits for', 0aH, ' this reset'
	DB	'. Now you have: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@CMHDJMHA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0FJ@CMHDJMHA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Not have enough Cr'
	DB	'edits (need: %d, user: %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BAFCACOI@Hey?5?$CFs?$CB?6You?5need?5?$CFd?5Money?6for?5th@
CONST	SEGMENT
??_C@_0CK@BAFCACOI@Hey?5?$CFs?$CB?6You?5need?5?$CFd?5Money?6for?5th@ DB 'H'
	DB	'ey %s!', 0aH, 'You need %d Money', 0aH, 'for this reset.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@GNAIDNOJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0FH@GNAIDNOJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Not have enough Mo'
	DB	'ney (need: %d, user: %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NIJOIGCG@Great?5?$CFs?$CB?6You?5need?5?$CFd?5level?6for?5@
CONST	SEGMENT
??_C@_0CM@NIJOIGCG@Great?5?$CFs?$CB?6You?5need?5?$CFd?5level?6for?5@ DB 'G'
	DB	'reat %s!', 0aH, 'You need %d level', 0aH, 'for this reset.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@HKMJCFGF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0GL@HKMJCFGF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Level is not valid'
	DB	' for this reset (min: %d, max: %d, user: %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NPOOAECJ@?$CFs?0?5please?5clean?5your?6personal?5s@
CONST	SEGMENT
??_C@_0CF@NPOOAECJ@?$CFs?0?5please?5clean?5your?6personal?5s@ DB '%s, ple'
	DB	'ase clean your', 0aH, 'personal shop.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@INNFFOLH@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0DM@INNFFOLH@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Shop check fail', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PMGLBKIN@?$CFs?0?5maybe?5you?5forgot?6clean?5out?5i@
CONST	SEGMENT
??_C@_0CK@PMGLBKIN@?$CFs?0?5maybe?5you?5forgot?6clean?5out?5i@ DB '%s, ma'
	DB	'ybe you forgot', 0aH, 'clean out inventory?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@JBHKEPMB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0EB@JBHKEPMB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Inventory check fa'
	DB	'il', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OFICEAAH@Hey?5?$CFs?$CB?6I?5think?5you?5forgot?6remov@
CONST	SEGMENT
??_C@_0CP@OFICEAAH@Hey?5?$CFs?$CB?6I?5think?5you?5forgot?6remov@ DB 'Hey '
	DB	'%s!', 0aH, 'I think you forgot', 0aH, 'remove equipment...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IEMKIHCJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
CONST	SEGMENT
??_C@_0EB@IEMKIHCJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@ DB '['
	DB	'ResetSystem] [%s] [%s] (CheckRequirements) Equipment check fa'
	DB	'il', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@HIBGDJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIOpenDia@
CONST	SEGMENT
??_C@_0ED@HIBGDJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIOpenDia@ DB '['
	DB	'ResetSystem] [%s] [%s] (OpenDialog) Group for this user not f'
	DB	'ound', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@PDDMMGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0EI@PDDMMGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Reset has been finished (R'
	DB	'eset: %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KKKJHHJG@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0DE@KKKJHHJG@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Added %d points', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LCDOCNPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0EB@LCDOCNPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) MarlonQuest has been reset'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HLOPMGCK@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0EC@HLOPMGCK@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) MasterPoints has been rese'
	DB	'ted', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@CGCLGMFP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0EB@CGCLGMFP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) MasterLevel has been reset'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@JNFAEODI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0DK@JNFAEODI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Shop has been reseted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KLDGOEGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0DP@KLDGOEGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Inventory has been reseted'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@IPNLPBJN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0DP@IPNLPBJN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Equipment has been reseted'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LOMANMPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0ED@LOMANMPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Normal skills has been res'
	DB	'eted', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HDHNPDP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0EA@HDHNPDP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) All skills has been resete'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ODCDHJJI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0DM@ODCDHJJI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Points has been reseted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GGGLIEL@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0DL@GGGLIEL@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Stats has been reseted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@CFLHBDGO@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0EJ@CFLHBDGO@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Money has been withdrawn, '
	DB	'amount: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DCFNDEH@My?5regards?5?$CFs?$CB?6You?5get?5?$CFd?5reset?$CB@
CONST	SEGMENT
??_C@_0CB@DCFNDEH@My?5regards?5?$CFs?$CB?6You?5get?5?$CFd?5reset?$CB@ DB 'M'
	DB	'y regards %s!', 0aH, 'You get %d reset!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JEOKHFNI@You?5have?5already?5finished?5delay?$AA@
CONST	SEGMENT
??_C@_0CA@JEOKHFNI@You?5have?5already?5finished?5delay?$AA@ DB 'You have '
	DB	'already finished delay', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
CONST	SEGMENT
??_C@_0N@MCNFFMDL@Reset?5Master?$AA@ DB 'Reset Master', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JGOLOEHN@Please?5wait?5?$CFd?5min?4?$AA@
CONST	SEGMENT
??_C@_0BE@JGOLOEHN@Please?5wait?5?$CFd?5min?4?$AA@ DB 'Please wait %d min'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@DDGJLPOE@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
CONST	SEGMENT
??_C@_0EC@DDGJLPOE@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@ DB '['
	DB	'ResetSystem] [%s] [%s] (ProcReset) Group for this user not fo'
	DB	'und', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NGBPCBKA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DN@NGBPCBKA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: element (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CNNHDLNO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DM@CNNHDLNO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: socket (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BLMDLPJA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DN@BLMDLPJA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: ancient (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KLHIOMDO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DP@KLHIOMDO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: excellent (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FBBLNOEP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DK@FBBLNOEP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: luck (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CMHBDKGG@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DM@CMHBDKGG@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: maxopt (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LMACCKIM@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DM@LMACCKIM@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: minopt (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@IFBEJPOF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DM@IFBEJPOF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: maxdur (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BFGHIPAP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DM@BFGHIPAP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: mindur (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BHNBMNGH@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DM@BHNBMNGH@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: minlvl (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CCJFLBFF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DL@CCJFLBFF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: index (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CBFNKBNC@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
CONST	SEGMENT
??_C@_0DK@CBFNKBNC@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@ DB '[Reset'
	DB	'System] Syntax error in item node, param: type (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JIBFDEBN@Configuration?5loaded?5?$CItotal?5norm@
CONST	SEGMENT
??_C@_0EH@JIBFDEBN@Configuration?5loaded?5?$CItotal?5norm@ DB 'Configurat'
	DB	'ion loaded (total normal groups: %d, total grand groups: %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BIJMAKPO@grand?$AA@
CONST	SEGMENT
??_C@_05BIJMAKPO@grand?$AA@ DB 'grand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCLJNICE@element?$AA@
CONST	SEGMENT
??_C@_07HCLJNICE@element?$AA@ DB 'element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBELJPBO@socket?$AA@
CONST	SEGMENT
??_C@_06HBELJPBO@socket?$AA@ DB 'socket', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECLFICCK@ancient?$AA@
CONST	SEGMENT
??_C@_07ECLFICCK@ancient?$AA@ DB 'ancient', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBDMPFOO@excellent?$AA@
CONST	SEGMENT
??_C@_09MBDMPFOO@excellent?$AA@ DB 'excellent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODMCMJAJ@skill?$AA@
CONST	SEGMENT
??_C@_05ODMCMJAJ@skill?$AA@ DB 'skill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFGGAFBF@luck?$AA@
CONST	SEGMENT
??_C@_04PFGGAFBF@luck?$AA@ DB 'luck', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06POBPEJKC@maxopt?$AA@
CONST	SEGMENT
??_C@_06POBPEJKC@maxopt?$AA@ DB 'maxopt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PNOMKJON@minopt?$AA@
CONST	SEGMENT
??_C@_06PNOMKJON@minopt?$AA@ DB 'minopt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJIPKLMO@maxdur?$AA@
CONST	SEGMENT
??_C@_06HJIPKLMO@maxdur?$AA@ DB 'maxdur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKHMELIB@mindur?$AA@
CONST	SEGMENT
??_C@_06HKHMELIB@mindur?$AA@ DB 'mindur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKDMACKH@maxlvl?$AA@
CONST	SEGMENT
??_C@_06GKDMACKH@maxlvl?$AA@ DB 'maxlvl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJMPOCOI@minlvl?$AA@
CONST	SEGMENT
??_C@_06GJMPOCOI@minlvl?$AA@ DB 'minlvl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type?$AA@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type?$AA@ DB 'type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NHONDGDE@item?$AA@
CONST	SEGMENT
??_C@_04NHONDGDE@item?$AA@ DB 'item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GEBMJOEB@itemslist?$AA@
CONST	SEGMENT
??_C@_09GEBMJOEB@itemslist?$AA@ DB 'itemslist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BBEJFBFA@point?$AA@
CONST	SEGMENT
??_C@_05BBEJFBFA@point?$AA@ DB 'point', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DFHDDGPP@?$FLResetSystem?$FN?5Syntax?5error?5in?5re@
CONST	SEGMENT
??_C@_0DK@DFHDDGPP@?$FLResetSystem?$FN?5Syntax?5error?5in?5re@ DB '[Reset'
	DB	'System] Syntax error in reward node, param: id (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05ENKANFLO@class?$AA@
CONST	SEGMENT
??_C@_05ENKANFLO@class?$AA@ DB 'class', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LIMLDHCM@pointmode?$AA@
CONST	SEGMENT
??_C@_09LIMLDHCM@pointmode?$AA@ DB 'pointmode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NPNBMBEO@reward?$AA@
CONST	SEGMENT
??_C@_06NPNBMBEO@reward?$AA@ DB 'reward', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ELLFFOK@checks?$AA@
CONST	SEGMENT
??_C@_06ELLFFOK@checks?$AA@ DB 'checks', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJHEGDCF@marlonquest?$AA@
CONST	SEGMENT
??_C@_0M@NJHEGDCF@marlonquest?$AA@ DB 'marlonquest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HFPOBAPF@masterskills?$AA@
CONST	SEGMENT
??_C@_0N@HFPOBAPF@masterskills?$AA@ DB 'masterskills', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GHLLHCDN@masterpoints?$AA@
CONST	SEGMENT
??_C@_0N@GHLLHCDN@masterpoints?$AA@ DB 'masterpoints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BHKEDLCN@masterlevel?$AA@
CONST	SEGMENT
??_C@_0M@BHKEDLCN@masterlevel?$AA@ DB 'masterlevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFIJLIPK@shop?$AA@
CONST	SEGMENT
??_C@_04BFIJLIPK@shop?$AA@ DB 'shop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OCPGKIKB@inventory?$AA@
CONST	SEGMENT
??_C@_09OCPGKIKB@inventory?$AA@ DB 'inventory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FJJPPKDN@equipment?$AA@
CONST	SEGMENT
??_C@_09FJJPPKDN@equipment?$AA@ DB 'equipment', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HNCNFAFI@skills?$AA@
CONST	SEGMENT
??_C@_06HNCNFAFI@skills?$AA@ DB 'skills', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GPGIDCJA@points?$AA@
CONST	SEGMENT
??_C@_06GPGIDCJA@points?$AA@ DB 'points', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLKJBNOD@stats?$AA@
CONST	SEGMENT
??_C@_05BLKJBNOD@stats?$AA@ DB 'stats', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJKDDGJG@cleaning?$AA@
CONST	SEGMENT
??_C@_08OJKDDGJG@cleaning?$AA@ DB 'cleaning', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EKJCMADO@delay?$AA@
CONST	SEGMENT
??_C@_05EKJCMADO@delay?$AA@ DB 'delay', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKABFLJI@credits?$AA@
CONST	SEGMENT
??_C@_07JKABFLJI@credits?$AA@ DB 'credits', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KIGPLGEM@gensp?$AA@
CONST	SEGMENT
??_C@_05KIGPLGEM@gensp?$AA@ DB 'gensp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PAIFPAIP@wcoing?$AA@
CONST	SEGMENT
??_C@_06PAIFPAIP@wcoing?$AA@ DB 'wcoing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PFAGHEBJ@wcoinp?$AA@
CONST	SEGMENT
??_C@_06PFAGHEBJ@wcoinp?$AA@ DB 'wcoinp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JEOJDFIL@wcoinc?$AA@
CONST	SEGMENT
??_C@_06JEOJDFIL@wcoinc?$AA@ DB 'wcoinc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IKCNOJAA@money?$AA@
CONST	SEGMENT
??_C@_05IKCNOJAA@money?$AA@ DB 'money', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BMOBFNHH@maxreset?$AA@
CONST	SEGMENT
??_C@_08BMOBFNHH@maxreset?$AA@ DB 'maxreset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLAKOPDG@minreset?$AA@
CONST	SEGMENT
??_C@_08MLAKOPDG@minreset?$AA@ DB 'minreset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAPIFGPH@maxlevel?$AA@
CONST	SEGMENT
??_C@_08JAPIFGPH@maxlevel?$AA@ DB 'maxlevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHBDOELG@minlevel?$AA@
CONST	SEGMENT
??_C@_08EHBDOELG@minlevel?$AA@ DB 'minlevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group?$AA@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group?$AA@ DB 'group', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EKKKGLLH@grouplist?$AA@
CONST	SEGMENT
??_C@_09EKKKGLLH@grouplist?$AA@ DB 'grouplist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EANLCPLP@y?$AA@
CONST	SEGMENT
??_C@_01EANLCPLP@y?$AA@ DB 'y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map?$AA@
CONST	SEGMENT
??_C@_03HBNNNHNM@map?$AA@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id?$AA@
CONST	SEGMENT
??_C@_02EGCJHIOB@id?$AA@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BPGDPAOH@npc?$AA@
CONST	SEGMENT
??_C@_03BPGDPAOH@npc?$AA@ DB 'npc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHHIKOPA@enabled?$AA@
CONST	SEGMENT
??_C@_07MHHIKOPA@enabled?$AA@ DB 'enabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT
??_C@_06IKLLLDHL@normal?$AA@ DB 'normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HLIFFONB@resetsystem?$AA@
CONST	SEGMENT
??_C@_0M@HLIFFONB@resetsystem?$AA@ DB 'resetsystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KHAPEMJG@?$FLResetSystem?$FN?5File?5?$CFs?5not?5found?$CB@
CONST	SEGMENT
??_C@_0CB@KHAPEMJG@?$FLResetSystem?$FN?5File?5?$CFs?5not?5found?$CB@ DB '['
	DB	'ResetSystem] File %s not found!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MNGMBMNH@Custom?2ResetSystem?4xml?$AA@
CONST	SEGMENT
??_C@_0BH@MNGMBMNH@Custom?2ResetSystem?4xml?$AA@ DB 'Custom\ResetSystem.x'
	DB	'ml', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGMLFNG@Reset?$AA@
CONST	SEGMENT
??_C@_05CCGMLFNG@Reset?$AA@ DB 'Reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCNIBGCF@?4?2Log?2Reset?$AA@
CONST	SEGMENT
??_C@_0M@FCNIBGCF@?4?2Log?2Reset?$AA@ DB '.\Log\Reset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7ResetSystem@@6B@
CONST	SEGMENT
??_7ResetSystem@@6B@ DD FLAT:??_R4ResetSystem@@6B@	; ResetSystem::`vftable'
	DD	FLAT:??_EResetSystem@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z$0
__ehfuncinfo$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z$0
__ehfuncinfo$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z$1
__ehfuncinfo$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z$1
__ehfuncinfo$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z$2
__ehfuncinfo$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z$2
__ehfuncinfo$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Read@ResetSystem@@QAEXPAD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?Read@ResetSystem@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Read@ResetSystem@@QAEXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$42
	DD	01H
	DD	FLAT:__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$66
	DD	00H
	DD	FLAT:__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$2
	DD	04H
	DD	FLAT:__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$203
	DD	04H
	DD	FLAT:__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$227
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ResetSystem@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ResetSystem@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ResetSystem@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ResetSystem@@QAE@XZ$2
__ehfuncinfo$??0ResetSystem@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0ResetSystem@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z$52 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z$52
__ehfuncinfo$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z$59
__ehfuncinfo$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z$50 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z$50
__ehfuncinfo$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z$66 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z$66
__ehfuncinfo$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@YA$$QAV?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@YA$$QAV?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<ResetItem,std::allocator<ResetItem> > >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@YA$$QAV?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<ResetItem,std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<ResetItem> > &>, COMDAT

; 1249 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1251 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<ResetItem> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::allocator<ResetItem> >, COMDAT

; 373  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 378  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 1e		 je	 SHORT $LN3@Uninit_cop
$LL4@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00010	85 c0		 test	 eax, eax
  00012	74 10		 je	 SHORT $LN2@Uninit_cop
  00014	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00017	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0001a	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  0001f	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
$LN2@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 378  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00024	83 c1 18	 add	 ecx, 24			; 00000018H
  00027	83 c0 18	 add	 eax, 24			; 00000018H
  0002a	3b ca		 cmp	 ecx, edx
  0002c	75 e2		 jne	 SHORT $LL4@Uninit_cop
$LN3@Uninit_cop:

; 379  : 		_Al.construct(_Dest, *_First);
; 380  : 	_CATCH_ALL
; 381  : 	for (; _Next != _Dest; ++_Next)
; 382  : 		_Al.destroy(_Next);
; 383  : 	_RERAISE;
; 384  : 	_CATCH_END
; 385  : 	return (_Dest);
; 386  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::allocator<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@U1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetItem@@U1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@$$QAU2@@Z PROC ; std::allocator<ResetItem>::construct<ResetItem,ResetItem>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN3@construct:

; 656  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@UResetItem@@U1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@$$QAU2@@Z ENDP ; std::allocator<ResetItem>::construct<ResetItem,ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@U1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetGroup@@U1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@$$QAU2@@Z PROC ; std::allocator<ResetGroup>::construct<ResetGroup,ResetGroup>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN3@construct
  0000a	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@$$QAU0@@Z
$LN3@construct:

; 656  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$construct@UResetGroup@@U1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@$$QAU2@@Z ENDP ; std::allocator<ResetGroup>::construct<ResetGroup,ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PBUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z PROC ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::allocator<ResetItem> >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Uninit_copy@PBUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z ENDP ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@YAPBUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@YAPBUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ResetItem> > >, COMDAT

; 265  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 266  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 267  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@YAPBUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@U1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UResetItem@@U1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<ResetItem> >::construct<ResetItem,ResetItem>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$construct@UResetItem@@U1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<ResetItem> >::construct<ResetItem,ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UResetItem@@@std@@YA$$QAUResetItem@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UResetItem@@@std@@YA$$QAUResetItem@@AAU1@@Z PROC ; std::forward<ResetItem>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UResetItem@@@std@@YA$$QAUResetItem@@AAU1@@Z ENDP ; std::forward<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@U1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UResetGroup@@U1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN8@construct
  0000a	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@$$QAU0@@Z
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$construct@UResetGroup@@U1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UResetGroup@@@std@@YA$$QAUResetGroup@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UResetGroup@@@std@@YA$$QAUResetGroup@@AAU1@@Z PROC ; std::forward<ResetGroup>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UResetGroup@@@std@@YA$$QAUResetGroup@@AAU1@@Z ENDP ; std::forward<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@UResetItem@@@std@@@std@@YA$$QAV?$allocator@UResetItem@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@UResetItem@@@std@@@std@@YA$$QAV?$allocator@UResetItem@@@0@AAV10@@Z PROC ; std::forward<std::allocator<ResetItem> >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@UResetItem@@@std@@@std@@YA$$QAV?$allocator@UResetItem@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@PAUResetItem@@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@@std@@YAPAUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@PAUResetItem@@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@@std@@YAPAUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::allocator<ResetItem> >
  00017	83 c4 14	 add	 esp, 20			; 00000014H

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@PAUResetItem@@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@@std@@YAPAUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UResetItem@@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UResetItem@@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@@Z PROC ; std::allocator<ResetItem>::destroy<ResetItem>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UResetItem@@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@@Z ENDP ; std::allocator<ResetItem>::destroy<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@U1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetItem@@U1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::construct<ResetItem,ResetItem>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@UResetItem@@U1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::construct<ResetItem,ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@U1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetGroup@@U1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN13@construct
  0000a	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@$$QAU0@@Z
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$construct@UResetGroup@@U1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UResetGroup@@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UResetGroup@@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@@Z PROC ; std::allocator<ResetGroup>::destroy<ResetGroup>, COMDAT
; _this$ = ecx

; 661  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	81 c6 f0 00 00
	00		 add	 esi, 240		; 000000f0H
  0000d	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  0000e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00010	85 ff		 test	 edi, edi
  00012	74 33		 je	 SHORT $LN14@destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	2b cf		 sub	 ecx, edi
  0001e	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00020	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00022	c1 fa 02	 sar	 edx, 2
  00025	8b c2		 mov	 eax, edx
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00039	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00040	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN14@destroy:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 663  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??$destroy@UResetGroup@@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@@Z ENDP ; std::allocator<ResetGroup>::destroy<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0V?$allocator@UResetItem@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UResetItem@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@UResetItem@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UResetItem@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1><std::allocator<ResetItem> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@UResetItem@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UResetItem@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1><std::allocator<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$allocator@UResetItem@@@std@@@std@@YA$$QAV?$allocator@UResetItem@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@UResetItem@@@std@@@std@@YA$$QAV?$allocator@UResetItem@@@0@AAV10@@Z PROC ; std::move<std::allocator<ResetItem> &>, COMDAT

; 1249 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1251 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@UResetItem@@@std@@@std@@YA$$QAV?$allocator@UResetItem@@@0@AAV10@@Z ENDP ; std::move<std::allocator<ResetItem> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEPAUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEPAUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@1@0PAU2@@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > > >, COMDAT
; _this$ = ecx

; 1670 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::allocator<ResetItem> >
  00015	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1673 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEPAUResetItem@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@1@0PAU2@@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@QBEPBUResetItem@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@QBEPBUResetItem@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@QBEPBUResetItem@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@QAE@PAUResetItem@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@QAE@PAUResetItem@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@std@@QAE@PAUResetItem@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UResetItem@@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UResetItem@@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@@Z PROC ; std::allocator_traits<std::allocator<ResetItem> >::destroy<ResetItem>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@UResetItem@@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@@Z ENDP ; std::allocator_traits<std::allocator<ResetItem> >::destroy<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UResetItem@@@std@@YAPAUResetItem@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UResetItem@@@std@@YAPAUResetItem@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ResetItem>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UResetItem@@@std@@YAPAUResetItem@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ResetItem *,ResetItem *,std::allocator<ResetItem>,ResetItem>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 1e		 je	 SHORT $LN3@Uninit_mov
$LL4@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00010	85 c0		 test	 eax, eax
  00012	74 10		 je	 SHORT $LN2@Uninit_mov
  00014	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00017	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0001a	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  0001f	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
$LN2@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00024	83 c1 18	 add	 ecx, 24			; 00000018H
  00027	83 c0 18	 add	 eax, 24			; 00000018H
  0002a	3b ca		 cmp	 ecx, edx
  0002c	75 e2		 jne	 SHORT $LL4@Uninit_mov
$LN3@Uninit_mov:

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);
; 450  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ResetItem *,ResetItem *,std::allocator<ResetItem>,ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUResetItem@@@std@@YAPAUResetItem@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUResetItem@@@std@@YAPAUResetItem@@PAU1@@Z PROC ; std::_Val_type<ResetItem *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUResetItem@@@std@@YAPAUResetItem@@PAU1@@Z ENDP ; std::_Val_type<ResetItem *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::allocator<ResetGroup>,ResetGroup>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 27		 je	 SHORT $LN37@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL4@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	85 ff		 test	 edi, edi
  00015	74 08		 je	 SHORT $LN2@Uninit_mov
  00017	56		 push	 esi
  00018	8b cf		 mov	 ecx, edi
  0001a	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@$$QAU0@@Z
$LN2@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0001f	81 c6 0c 01 00
	00		 add	 esi, 268		; 0000010cH
  00025	81 c7 0c 01 00
	00		 add	 edi, 268		; 0000010cH
  0002b	3b f3		 cmp	 esi, ebx
  0002d	75 e4		 jne	 SHORT $LL4@Uninit_mov

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);

  0002f	8b c7		 mov	 eax, edi
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 450  : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN37@Uninit_mov:

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);

  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx

; 450  : 	}

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::allocator<ResetGroup>,ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUResetGroup@@@std@@YAPAUResetGroup@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUResetGroup@@@std@@YAPAUResetGroup@@PAU1@@Z PROC ; std::_Val_type<ResetGroup *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUResetGroup@@@std@@YAPAUResetGroup@@PAU1@@Z ENDP ; std::_Val_type<ResetGroup *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UResetGroup@@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UResetGroup@@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@@Z PROC ; std::allocator_traits<std::allocator<ResetGroup> >::destroy<ResetGroup>, COMDAT

; 779  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	81 c6 f0 00 00
	00		 add	 esi, 240		; 000000f0H
  0000d	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  0000e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00010	85 ff		 test	 edi, edi
  00012	74 33		 je	 SHORT $LN16@destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	2b cf		 sub	 ecx, edi
  0001e	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00020	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00022	c1 fa 02	 sar	 edx, 2
  00025	8b c2		 mov	 eax, edx
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00039	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00040	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN16@destroy:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 781  : 		}

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$destroy@UResetGroup@@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@@Z ENDP ; std::allocator_traits<std::allocator<ResetGroup> >::destroy<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UResetGroup@@@std@@YAPAUResetGroup@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UResetGroup@@@std@@YAPAUResetGroup@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ResetGroup>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UResetGroup@@@std@@YAPAUResetGroup@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UResetItem@@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UResetItem@@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::destroy<ResetItem>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UResetItem@@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::destroy<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UResetItem@@@std@@YAPAUResetItem@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UResetItem@@@std@@YAPAUResetItem@@AAU1@@Z PROC ; std::addressof<ResetItem>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UResetItem@@@std@@YAPAUResetItem@@AAU1@@Z ENDP ; std::addressof<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUResetItem@@PAU1@@std@@YAAAPAUResetItem@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUResetItem@@PAU1@@std@@YAAAPAUResetItem@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<ResetItem *,ResetItem *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUResetItem@@PAU1@@std@@YAAAPAUResetItem@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<ResetItem *,ResetItem *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z PROC ; std::_Uninit_move<ResetItem *,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetItem *,ResetItem *,std::allocator<ResetItem>,ResetItem>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z ENDP ; std::_Uninit_move<ResetItem *,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUResetItem@@@std@@YAPAUResetItem@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUResetItem@@@std@@YAPAUResetItem@@PAU1@@Z PROC ; std::_Unchecked<ResetItem *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUResetItem@@@std@@YAPAUResetItem@@PAU1@@Z ENDP ; std::_Unchecked<ResetItem *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUResetGroup@@PAU1@@std@@YAAAPAUResetGroup@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUResetGroup@@PAU1@@std@@YAAAPAUResetGroup@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<ResetGroup *,ResetGroup *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUResetGroup@@PAU1@@std@@YAAAPAUResetGroup@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<ResetGroup *,ResetGroup *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUResetGroup@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUResetGroup@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z PROC ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::_Wrap_alloc<std::allocator<ResetGroup> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::allocator<ResetGroup>,ResetGroup>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUResetGroup@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z ENDP ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::_Wrap_alloc<std::allocator<ResetGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUResetGroup@@@std@@YAPAUResetGroup@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUResetGroup@@@std@@YAPAUResetGroup@@PAU1@@Z PROC ; std::_Unchecked<ResetGroup *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUResetGroup@@@std@@YAPAUResetGroup@@PAU1@@Z ENDP ; std::_Unchecked<ResetGroup *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UResetGroup@@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UResetGroup@@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::destroy<ResetGroup>, COMDAT
; _this$ = ecx

; 924  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	81 c6 f0 00 00
	00		 add	 esi, 240		; 000000f0H
  0000d	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  0000e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00010	85 ff		 test	 edi, edi
  00012	74 33		 je	 SHORT $LN18@destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	2b cf		 sub	 ecx, edi
  0001e	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00020	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00022	c1 fa 02	 sar	 edx, 2
  00025	8b c2		 mov	 eax, edx
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00039	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00040	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN18@destroy:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 926  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??$destroy@UResetGroup@@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::destroy<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UResetGroup@@@std@@YAPAUResetGroup@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UResetGroup@@@std@@YAPAUResetGroup@@AAU1@@Z PROC ; std::addressof<ResetGroup>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UResetGroup@@@std@@YAPAUResetGroup@@AAU1@@Z ENDP ; std::addressof<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@ABU1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetItem@@ABU1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@ABU2@@Z PROC ; std::allocator<ResetItem>::construct<ResetItem,ResetItem const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN3@construct:

; 656  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@UResetItem@@ABU1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@ABU2@@Z ENDP ; std::allocator<ResetItem>::construct<ResetItem,ResetItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@AAU1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetItem@@AAU1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@AAU2@@Z PROC ; std::allocator<ResetItem>::construct<ResetItem,ResetItem &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN3@construct:

; 656  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@UResetItem@@AAU1@@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@AAU2@@Z ENDP ; std::allocator<ResetItem>::construct<ResetItem,ResetItem &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z PROC ; std::allocator<ResetGroup>::construct<ResetGroup,ResetGroup const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
$LN3@construct:

; 656  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UResetGroup@@ABU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@ABU2@@Z ENDP ; std::allocator<ResetGroup>::construct<ResetGroup,ResetGroup const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z PROC ; std::allocator<ResetGroup>::construct<ResetGroup,ResetGroup &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
$LN3@construct:

; 656  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UResetGroup@@AAU1@@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@AAU2@@Z ENDP ; std::allocator<ResetGroup>::construct<ResetGroup,ResetGroup &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAUResetGroup@@@std@@YA$$QAPAUResetGroup@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAUResetGroup@@@std@@YA$$QAPAUResetGroup@@AAPAU1@@Z PROC ; std::_Move<ResetGroup * &>, COMDAT

; 1257 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1258 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1259 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAUResetGroup@@@std@@YA$$QAPAUResetGroup@@AAPAU1@@Z ENDP ; std::_Move<ResetGroup * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAXPAUResetItem@@0AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAXPAUResetItem@@0AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetItem> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAXPAUResetItem@@0AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UResetItem@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUResetItem@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UResetItem@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUResetItem@@0@Z PROC ; std::_Ptr_cat<ResetItem,ResetItem>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UResetItem@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUResetItem@@0@Z ENDP ; std::_Ptr_cat<ResetItem,ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UResetItem@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUResetItem@@PAU2@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UResetItem@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUResetItem@@PAU2@@Z PROC ; std::_Ptr_cat<ResetItem,ResetItem>, COMDAT

; 649  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 650  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 651  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 652  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UResetItem@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUResetItem@@PAU2@@Z ENDP ; std::_Ptr_cat<ResetItem,ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z PROC ; std::_Uninitialized_move<ResetItem *,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetItem *,ResetItem *,std::allocator<ResetItem>,ResetItem>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUResetItem@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<ResetItem *,ResetItem *,std::_Wrap_alloc<std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUResetGroup@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUResetGroup@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z PROC ; std::_Uninitialized_move<ResetGroup *,ResetGroup *,std::_Wrap_alloc<std::allocator<ResetGroup> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::allocator<ResetGroup>,ResetGroup>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUResetGroup@@PAU1@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<ResetGroup *,ResetGroup *,std::_Wrap_alloc<std::allocator<ResetGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UResetItem@@@std@@@std@@YAABV?$allocator@UResetItem@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UResetItem@@@std@@@std@@YAABV?$allocator@UResetItem@@@0@ABV10@@Z PROC ; std::forward<std::allocator<ResetItem> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UResetItem@@@std@@@std@@YAABV?$allocator@UResetItem@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<ResetItem> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >, COMDAT

; 170  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 171  : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 7d		 je	 SHORT $LN149@Destroy_ra
  0000f	81 c6 f0 00 00
	00		 add	 esi, 240		; 000000f0H
$LL4@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00015	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00017	85 c9		 test	 ecx, ecx
  00019	74 61		 je	 SHORT $LN29@Destroy_ra

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0001b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0001e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00023	2b d1		 sub	 edx, ecx
  00025	f7 ea		 imul	 edx
  00027	c1 fa 02	 sar	 edx, 2
  0002a	8b c2		 mov	 eax, edx
  0002c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002f	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00031	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00036	77 58		 ja	 SHORT $LN151@Destroy_ra

; 101  : 	const size_t _User_size = _Count * _Sz;

  00038	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0003b	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0003e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00043	72 1a		 jb	 SHORT $LN97@Destroy_ra

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00045	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00048	75 46		 jne	 SHORT $LN151@Destroy_ra

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0004a	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004d	3b c1		 cmp	 eax, ecx
  0004f	73 3f		 jae	 SHORT $LN151@Destroy_ra

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00051	2b c8		 sub	 ecx, eax
  00053	83 f9 04	 cmp	 ecx, 4
  00056	72 38		 jb	 SHORT $LN151@Destroy_ra

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0005b	77 33		 ja	 SHORT $LN151@Destroy_ra

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0005d	8b c8		 mov	 ecx, eax
$LN97@Destroy_ra:

; 138  : 	::operator delete(_Ptr);

  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00065	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  0006b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1663 : 			this->_Mylast() = pointer();

  0006e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00075	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN29@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 171  : 	for (; _First != _Last; ++_First)

  0007c	81 c6 0c 01 00
	00		 add	 esi, 268		; 0000010cH
  00082	8d 86 10 ff ff
	ff		 lea	 eax, DWORD PTR [esi-240]
  00088	3b c7		 cmp	 eax, edi
  0008a	75 89		 jne	 SHORT $LL4@Destroy_ra
$LN149@Destroy_ra:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
$LN151@Destroy_ra:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00090	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN152@Destroy_ra:
$LN150@Destroy_ra:
  00095	cc		 int	 3
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UResetGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUResetGroup@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UResetGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUResetGroup@@0@Z PROC ; std::_Ptr_cat<ResetGroup,ResetGroup>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UResetGroup@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUResetGroup@@0@Z ENDP ; std::_Ptr_cat<ResetGroup,ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UResetGroup@@@std@@@std@@YAABV?$allocator@UResetGroup@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UResetGroup@@@std@@@std@@YAABV?$allocator@UResetGroup@@@0@ABV10@@Z PROC ; std::forward<std::allocator<ResetGroup> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UResetGroup@@@std@@@std@@YAABV?$allocator@UResetGroup@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<ResetGroup> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ResetGroup> > >, COMDAT

; 999  : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ResetGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@ABU1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UResetItem@@ABU1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<ResetItem> >::construct<ResetItem,ResetItem const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$construct@UResetItem@@ABU1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<ResetItem> >::construct<ResetItem,ResetItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUResetItem@@@std@@YAABUResetItem@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUResetItem@@@std@@YAABUResetItem@@ABU1@@Z PROC ; std::forward<ResetItem const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUResetItem@@@std@@YAABUResetItem@@ABU1@@Z ENDP ; std::forward<ResetItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@AAU1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UResetItem@@AAU1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<ResetItem> >::construct<ResetItem,ResetItem &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$construct@UResetItem@@AAU1@@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAXAAV?$allocator@UResetItem@@@1@PAUResetItem@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<ResetItem> >::construct<ResetItem,ResetItem &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUResetItem@@@std@@YAAAUResetItem@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUResetItem@@@std@@YAAAUResetItem@@AAU1@@Z PROC ; std::forward<ResetItem &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUResetItem@@@std@@YAAAUResetItem@@AAU1@@Z ENDP ; std::forward<ResetItem &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBUResetItem@@@std@@YAPBUResetItem@@ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBUResetItem@@@std@@YAPBUResetItem@@ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ResetItem const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBUResetItem@@@std@@YAPBUResetItem@@ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ResetItem const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UResetGroup@@ABU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUResetGroup@@@std@@YAABUResetGroup@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUResetGroup@@@std@@YAABUResetGroup@@ABU1@@Z PROC ; std::forward<ResetGroup const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUResetGroup@@@std@@YAABUResetGroup@@ABU1@@Z ENDP ; std::forward<ResetGroup const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UResetGroup@@AAU1@@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAXAAV?$allocator@UResetGroup@@@1@PAUResetGroup@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUResetGroup@@@std@@YAAAUResetGroup@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUResetGroup@@@std@@YAAAUResetGroup@@AAU1@@Z PROC ; std::forward<ResetGroup &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUResetGroup@@@std@@YAAAUResetGroup@@AAU1@@Z ENDP ; std::forward<ResetGroup &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBUResetGroup@@@std@@YAPBUResetGroup@@ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBUResetGroup@@@std@@YAPBUResetGroup@@ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ResetGroup const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBUResetGroup@@@std@@YAPBUResetGroup@@ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ResetGroup const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAXPAUResetItem@@0AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAXPAUResetItem@@0AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetItem> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@@std@@YAXPAUResetItem@@0AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUResetItem@@@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEPAUResetItem@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUResetItem@@@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEPAUResetItem@@PAU2@00@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Umove<ResetItem *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetItem *,ResetItem *,std::allocator<ResetItem>,ResetItem>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUResetItem@@@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEPAUResetItem@@PAU2@00@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Umove<ResetItem *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUResetGroup@@@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEPAUResetGroup@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUResetGroup@@@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEPAUResetGroup@@PAU2@00@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Umove<ResetGroup *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::allocator<ResetGroup>,ResetGroup>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUResetGroup@@@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEPAUResetGroup@@PAU2@00@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Umove<ResetGroup *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UResetItem@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UResetItem@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UResetItem@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UResetItem@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1><std::allocator<ResetItem> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UResetItem@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UResetItem@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1><std::allocator<ResetItem> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >, COMDAT

; 185  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 	}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UResetGroup@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UResetGroup@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UResetGroup@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UResetGroup@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1><std::allocator<ResetGroup> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UResetGroup@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UResetGroup@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1><std::allocator<ResetGroup> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ResetGroup> > >, COMDAT

; 1004 : 	typename _Alty::propagate_on_container_swap _Tag;
; 1005 : 	_Pocs(_Left, _Right, _Tag);
; 1006 : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ResetGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetItem@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::construct<ResetItem,ResetItem const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@UResetItem@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::construct<ResetItem,ResetItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetItem@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetItem@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::construct<ResetItem,ResetItem &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@UResetItem@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::construct<ResetItem,ResetItem &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUResetItem@@@std@@YAPBUResetItem@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUResetItem@@@std@@YAPBUResetItem@@ABU1@@Z PROC ; std::addressof<ResetItem const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUResetItem@@@std@@YAPBUResetItem@@ABU1@@Z ENDP ; std::addressof<ResetItem const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UResetGroup@@ABU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UResetGroup@@AAU1@@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::construct<ResetGroup,ResetGroup &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUResetGroup@@@std@@YAPBUResetGroup@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUResetGroup@@@std@@YAPBUResetGroup@@ABU1@@Z PROC ; std::addressof<ResetGroup const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUResetGroup@@@std@@YAPBUResetGroup@@ABU1@@Z ENDP ; std::addressof<ResetGroup const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAUResetGroup@@@std@@YAXAAPAUResetGroup@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAUResetGroup@@@std@@YAXAAPAUResetGroup@@0@Z PROC ; std::swap<ResetGroup *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAUResetGroup@@@std@@YAXAAPAUResetGroup@@0@Z ENDP ; std::swap<ResetGroup *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$_Swap_adl@PAUResetGroup@@@std@@YAXAAPAUResetGroup@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAUResetGroup@@@std@@YAXAAPAUResetGroup@@0@Z PROC ; std::_Swap_adl<ResetGroup *>, COMDAT

; 61   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 62   : 	swap(_Left, _Right);
; 63   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAUResetGroup@@@std@@YAXAAPAUResetGroup@@0@Z ENDP ; std::_Swap_adl<ResetGroup *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8UResetGroup@@U0@@std@@YA_NABV?$allocator@UResetGroup@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UResetGroup@@U0@@std@@YA_NABV?$allocator@UResetGroup@@@0@0@Z PROC ; std::operator==<ResetGroup,ResetGroup>, COMDAT

; 712  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 713  : 	}

  00002	c3		 ret	 0
??$?8UResetGroup@@U0@@std@@YA_NABV?$allocator@UResetGroup@@@0@0@Z ENDP ; std::operator==<ResetGroup,ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@UResetGroup@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@UResetGroup@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<ResetGroup>,std::allocator<ResetGroup> >, COMDAT

; 939  : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 940  : 		== static_cast<const _Other&>(_Right));
; 941  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@UResetGroup@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<ResetGroup>,std::allocator<ResetGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_ResetSystem@@YAXXZ
text$yd	SEGMENT
??__Fg_ResetSystem@@YAXXZ PROC				; `dynamic atexit destructor for 'g_ResetSystem'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VResetSystem@@A ; g_ResetSystem
  00005	e9 00 00 00 00	 jmp	 ??1ResetSystem@@UAE@XZ	; ResetSystem::~ResetSystem
??__Fg_ResetSystem@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_ResetSystem''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ??__Eg_ResetSystem@@YAXXZ
text$di	SEGMENT
??__Eg_ResetSystem@@YAXXZ PROC				; `dynamic initializer for 'g_ResetSystem'', COMDAT

; 11   : ResetSystem g_ResetSystem;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VResetSystem@@A ; g_ResetSystem
  00005	e8 00 00 00 00	 call	 ??0ResetSystem@@QAE@XZ	; ResetSystem::ResetSystem
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_ResetSystem@@YAXXZ ; `dynamic atexit destructor for 'g_ResetSystem''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_ResetSystem@@YAXXZ ENDP				; `dynamic initializer for 'g_ResetSystem''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GResetSystem@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GResetSystem@@UAEPAXI@Z PROC				; ResetSystem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ResetSystem@@UAE@XZ	; ResetSystem::~ResetSystem
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 30		 push	 48			; 00000030H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GResetSystem@@UAEPAXI@Z ENDP				; ResetSystem::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?GetResetGroup@ResetSystem@@AAEPAUResetGroup@@PAUOBJECTSTRUCT@@W4T@ResetType@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_lpUser$ = 8						; size = 4
_Type$ = 12						; size = 4
?GetResetGroup@ResetSystem@@AAEPAUResetGroup@@PAUOBJECTSTRUCT@@W4T@ResetType@@@Z PROC ; ResetSystem::GetResetGroup, COMDAT
; _this$ = ecx

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 944  : 	if (Type == ResetType::Normal)

  00004	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	85 c0		 test	 eax, eax
  00011	75 7b		 jne	 SHORT $LN8@GetResetGr
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00013	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00016	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0001b	2b 53 0c	 sub	 edx, DWORD PTR [ebx+12]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 946  : 		for (int i = 0; i < this->m_NormalInfo.m_GroupList.size(); i++)

  0001e	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00020	f7 ea		 imul	 edx
  00022	c1 fa 03	 sar	 edx, 3
  00025	8b c2		 mov	 eax, edx
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 946  : 		for (int i = 0; i < this->m_NormalInfo.m_GroupList.size(); i++)

  0002c	74 40		 je	 SHORT $LN133@GetResetGr

; 949  : 				|| lpUser->iResetCount + 1 > this->m_NormalInfo.m_GroupList[i].MaxReset)

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00034	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 949  : 				|| lpUser->iResetCount + 1 > this->m_NormalInfo.m_GroupList[i].MaxReset)

  00037	8b 99 20 27 00
	00		 mov	 ebx, DWORD PTR [ecx+10016]
  0003d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00040	2b 48 0c	 sub	 ecx, DWORD PTR [eax+12]
  00043	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00048	f7 e9		 imul	 ecx
  0004a	c1 fa 03	 sar	 edx, 3
  0004d	8b ca		 mov	 ecx, edx
  0004f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00052	03 ca		 add	 ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 314  : 		return (_Myval2);

  00054	83 c6 08	 add	 esi, 8
$LL4@GetResetGr:
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 949  : 				|| lpUser->iResetCount + 1 > this->m_NormalInfo.m_GroupList[i].MaxReset)

  00057	3b 5e fc	 cmp	 ebx, DWORD PTR [esi-4]
  0005a	7c 07		 jl	 SHORT $LN2@GetResetGr
  0005c	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0005f	3b 06		 cmp	 eax, DWORD PTR [esi]
  00061	7e 16		 jle	 SHORT $LN10@GetResetGr
$LN2@GetResetGr:

; 946  : 		for (int i = 0; i < this->m_NormalInfo.m_GroupList.size(); i++)

  00063	47		 inc	 edi
  00064	81 c6 0c 01 00
	00		 add	 esi, 268		; 0000010cH
  0006a	3b f9		 cmp	 edi, ecx
  0006c	72 e9		 jb	 SHORT $LL4@GetResetGr
$LN133@GetResetGr:
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 963  : 			{
; 964  : 				continue;
; 965  : 			}
; 966  : 
; 967  : 			return &this->m_GrandInfo.m_GroupList[i];
; 968  : 		}
; 969  : 	}
; 970  : 
; 971  : 	return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	5b		 pop	 ebx

; 972  : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
$LN10@GetResetGr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0007c	69 c7 0c 01 00
	00		 imul	 eax, edi, 268
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 972  : }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN8@GetResetGr:

; 950  : 			{
; 951  : 				continue;
; 952  : 			}
; 953  : 
; 954  : 			return &this->m_NormalInfo.m_GroupList[i];
; 955  : 		}
; 956  : 	}
; 957  : 	else if (Type == ResetType::Grand)

  0008e	83 f8 01	 cmp	 eax, 1
  00091	75 db		 jne	 SHORT $LN133@GetResetGr
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00093	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00096	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0009b	2b 4b 20	 sub	 ecx, DWORD PTR [ebx+32]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 959  : 		for (int i = 0; i < this->m_GrandInfo.m_GroupList.size(); i++)

  0009e	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  000a0	f7 e9		 imul	 ecx
  000a2	c1 fa 03	 sar	 edx, 3
  000a5	8b c2		 mov	 eax, edx
  000a7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000aa	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 959  : 		for (int i = 0; i < this->m_GrandInfo.m_GroupList.size(); i++)

  000ac	74 c0		 je	 SHORT $LN133@GetResetGr

; 962  : 				|| lpUser->iResetCount + 1 > this->m_GrandInfo.m_GroupList[i].MaxReset)

  000ae	8b 45 08	 mov	 eax, DWORD PTR _lpUser$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  000b1	8b 73 20	 mov	 esi, DWORD PTR [ebx+32]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 962  : 				|| lpUser->iResetCount + 1 > this->m_GrandInfo.m_GroupList[i].MaxReset)

  000b4	8b 98 20 27 00
	00		 mov	 ebx, DWORD PTR [eax+10016]
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000bd	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c0	2b 48 20	 sub	 ecx, DWORD PTR [eax+32]
  000c3	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  000c8	f7 e9		 imul	 ecx
  000ca	c1 fa 03	 sar	 edx, 3
  000cd	8b ca		 mov	 ecx, edx
  000cf	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d2	03 ca		 add	 ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 314  : 		return (_Myval2);

  000d4	83 c6 08	 add	 esi, 8
$LL7@GetResetGr:
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 962  : 				|| lpUser->iResetCount + 1 > this->m_GrandInfo.m_GroupList[i].MaxReset)

  000d7	3b 5e fc	 cmp	 ebx, DWORD PTR [esi-4]
  000da	7c 07		 jl	 SHORT $LN5@GetResetGr
  000dc	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000df	3b 06		 cmp	 eax, DWORD PTR [esi]
  000e1	7e 16		 jle	 SHORT $LN13@GetResetGr
$LN5@GetResetGr:

; 959  : 		for (int i = 0; i < this->m_GrandInfo.m_GroupList.size(); i++)

  000e3	47		 inc	 edi
  000e4	81 c6 0c 01 00
	00		 add	 esi, 268		; 0000010cH
  000ea	3b f9		 cmp	 edi, ecx
  000ec	72 e9		 jb	 SHORT $LL7@GetResetGr

; 963  : 			{
; 964  : 				continue;
; 965  : 			}
; 966  : 
; 967  : 			return &this->m_GrandInfo.m_GroupList[i];
; 968  : 		}
; 969  : 	}
; 970  : 
; 971  : 	return NULL;

  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	33 c0		 xor	 eax, eax
  000f2	5b		 pop	 ebx

; 972  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 08 00	 ret	 8
$LN13@GetResetGr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000fc	69 c7 0c 01 00
	00		 imul	 eax, edi, 268
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx
  00105	03 41 20	 add	 eax, DWORD PTR [ecx+32]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 972  : }

  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 08 00	 ret	 8
?GetResetGroup@ResetSystem@@AAEPAUResetGroup@@PAUOBJECTSTRUCT@@W4T@ResetType@@@Z ENDP ; ResetSystem::GetResetGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?GetResetMoney@ResetSystem@@AAEHPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_N@Z
_TEXT	SEGMENT
_lpUser$ = 8						; size = 4
_Group$ = 12						; size = 4
_Type$ = 16						; size = 4
_ForNextReset$ = 20					; size = 1
?GetResetMoney@ResetSystem@@AAEHPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_N@Z PROC ; ResetSystem::GetResetMoney, COMDAT
; _this$ = ecx

; 927  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 928  : 	int ReturnMoney = Group->Money * (lpUser->iResetCount + ForNextReset);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Group$[ebp]
  00006	0f b6 4d 14	 movzx	 ecx, BYTE PTR _ForNextReset$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR _lpUser$[ebp]

; 929  : 
; 930  : 	ReturnMoney -= ReturnMoney * m_ObjBill[lpUser->m_Index].GetResetDiscount() / 100;

  00013	8b 07		 mov	 eax, DWORD PTR [edi]
  00015	8b 9f 20 27 00
	00		 mov	 ebx, DWORD PTR [edi+10016]
  0001b	03 d9		 add	 ebx, ecx
  0001d	0f af f3	 imul	 esi, ebx
  00020	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00023	c1 e0 04	 shl	 eax, 4
  00026	8b 88 28 00 00
	00		 mov	 ecx, DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[eax+40]
  0002c	b8 e1 7a 14 ae	 mov	 eax, -1374389535	; ae147ae1H
  00031	0f af ce	 imul	 ecx, esi
  00034	f7 e9		 imul	 ecx
  00036	c1 fa 05	 sar	 edx, 5
  00039	8b c2		 mov	 eax, edx
  0003b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003e	03 c2		 add	 eax, edx
  00040	03 f0		 add	 esi, eax

; 931  : 
; 932  : 	if (ReturnMoney < 0)

  00042	79 23		 jns	 SHORT $LN2@GetResetMo

; 933  : 	{
; 934  : 		LogAddC(2, "[ResetSystem] [%s] [%s] (GetResetMoney) Calculated wrong value (Reset: %d, Value: %d)",

  00044	56		 push	 esi
  00045	53		 push	 ebx
  00046	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00049	50		 push	 eax
  0004a	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@DGNILBKD@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIGetRese@
  00053	6a 02		 push	 2
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0005b	83 c4 18	 add	 esp, 24			; 00000018H

; 935  : 			lpUser->AccountID, lpUser->Name, lpUser->iResetCount + ForNextReset, ReturnMoney);
; 936  : 		return 0;

  0005e	33 c0		 xor	 eax, eax
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 940  : }

  00063	5d		 pop	 ebp
  00064	c2 10 00	 ret	 16			; 00000010H
$LN2@GetResetMo:
  00067	5f		 pop	 edi

; 937  : 	}
; 938  : 
; 939  : 	return ReturnMoney;

  00068	8b c6		 mov	 eax, esi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx

; 940  : }

  0006c	5d		 pop	 ebp
  0006d	c2 10 00	 ret	 16			; 00000010H
?GetResetMoney@ResetSystem@@AAEHPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_N@Z ENDP ; ResetSystem::GetResetMoney
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?GetItemInventoryPos@ResetSystem@@AAEEPAUOBJECTSTRUCT@@UResetItem@@@Z
_TEXT	SEGMENT
_lpUser$ = 8						; size = 4
_Item$ = 12						; size = 24
?GetItemInventoryPos@ResetSystem@@AAEEPAUOBJECTSTRUCT@@UResetItem@@@Z PROC ; ResetSystem::GetItemInventoryPos, COMDAT
; _this$ = ecx

; 914  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpUser$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 915  : 	for (BYTE i = INVETORY_WEAR_SIZE; i < MAIN_INVENTORY_SIZE; i++)

  00009	be f0 09 00 00	 mov	 esi, 2544		; 000009f0H
  0000e	bf c0 00 00 00	 mov	 edi, 192		; 000000c0H
$LL4@GetItemInv:

; 916  : 	{
; 917  : 		if( !lpUser->pInventory[i].IsItem() 
; 918  : 			|| lpUser->pInventory[i].m_Type != ITEMGET(Item.Type, Item.Index))

  00013	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  00019	03 ce		 add	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00020	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00026	83 ef 01	 sub	 edi, 1
  00029	75 e8		 jne	 SHORT $LL4@GetItemInv

; 919  : 		{
; 920  : 			continue;
; 921  : 		}
; 922  : 	}
; 923  : 	return (BYTE)-1;

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	0c ff		 or	 al, 255			; 000000ffH
  0002f	5b		 pop	 ebx

; 924  : }

  00030	5d		 pop	 ebp
  00031	c2 1c 00	 ret	 28			; 0000001cH
?GetItemInventoryPos@ResetSystem@@AAEEPAUOBJECTSTRUCT@@UResetItem@@@Z ENDP ; ResetSystem::GetItemInventoryPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@@Z
_TEXT	SEGMENT
_lpUser$ = 8						; size = 4
_Type$ = 12						; size = 4
?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@@Z PROC ; ResetSystem::CheckRequirements, COMDAT
; _this$ = ecx

; 898  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 899  : 	ResetGroup* Group = this->GetResetGroup(lpUser, Type);

  00005	ff 75 0c	 push	 DWORD PTR _Type$[ebp]
  00008	8b 7d 08	 mov	 edi, DWORD PTR _lpUser$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 ?GetResetGroup@ResetSystem@@AAEPAUResetGroup@@PAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::GetResetGroup

; 900  : 	
; 901  : 	if (Group == NULL)

  00013	85 c0		 test	 eax, eax
  00015	75 31		 jne	 SHORT $LN2@CheckRequi

; 902  : 	{
; 903  : 		this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Group for this user not found",

  00017	56		 push	 esi
  00018	8d 77 5d	 lea	 esi, DWORD PTR [edi+93]
  0001b	83 c7 52	 add	 edi, 82			; 00000052H
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OGMNMFNN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  00025	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00028	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 904  : 			lpUser->AccountID, lpUser->Name);
; 905  : 		LogAddC(2, "[ResetSystem] [%s] [%s] (CheckRequirements) Group for this user not found",

  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OGMNMFNN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  00034	6a 02		 push	 2
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0003c	83 c4 20	 add	 esp, 32			; 00000020H

; 906  : 			lpUser->AccountID, lpUser->Name);
; 907  : 		return false;

  0003f	32 c0		 xor	 al, al
  00041	5e		 pop	 esi
  00042	5f		 pop	 edi
  00043	5b		 pop	 ebx

; 911  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN2@CheckRequi:
  00048	5f		 pop	 edi

; 908  : 	}
; 909  : 
; 910  : 	return true;

  00049	b0 01		 mov	 al, 1
  0004b	5b		 pop	 ebx

; 911  : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@@Z ENDP ; ResetSystem::CheckRequirements
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_NE@Z
_TEXT	SEGMENT
_lpUser$ = 8						; size = 4
tv876 = 12						; size = 4
tv872 = 12						; size = 4
tv865 = 12						; size = 4
_Group$ = 12						; size = 4
_Type$ = 16						; size = 4
_i$1$ = 20						; size = 4
_NotifyMessage$ = 20					; size = 1
tv891 = 24						; size = 4
tv863 = 24						; size = 4
_PayType$ = 24						; size = 1
?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_NE@Z PROC ; ResetSystem::CheckRequirements, COMDAT
; _this$ = ecx

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 738  : 	int ItemPos;
; 739  : 
; 740  : 	if (Group->Checks.Equipment)

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpUser$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _Group$[ebp]
  0000e	80 bf 06 01 00
	00 00		 cmp	 BYTE PTR [edi+262], 0
  00015	74 30		 je	 SHORT $LN3@CheckRequi

; 741  : 	{
; 742  : 		for( ItemPos = 0; ItemPos < INVETORY_WEAR_SIZE; ItemPos++ )

  00017	33 c0		 xor	 eax, eax
  00019	89 45 0c	 mov	 DWORD PTR tv876[ebp], eax
  0001c	0f 1f 40 00	 npad	 4
$LL4@CheckRequi:

; 743  : 		{
; 744  : 			if( lpUser->pInventory[ItemPos].IsItem() )

  00020	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00026	03 c8		 add	 ecx, eax
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	85 c0		 test	 eax, eax
  0002f	0f 85 1c 01 00
	00		 jne	 $LN264@CheckRequi

; 741  : 	{
; 742  : 		for( ItemPos = 0; ItemPos < INVETORY_WEAR_SIZE; ItemPos++ )

  00035	8b 45 0c	 mov	 eax, DWORD PTR tv876[ebp]
  00038	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0003d	89 45 0c	 mov	 DWORD PTR tv876[ebp], eax
  00040	3d f0 09 00 00	 cmp	 eax, 2544		; 000009f0H
  00045	7c d9		 jl	 SHORT $LL4@CheckRequi
$LN3@CheckRequi:

; 751  : 				}
; 752  : 				return false;
; 753  : 			}
; 754  : 		}
; 755  : 	}
; 756  : 
; 757  : 	if (Group->Checks.Inventory)

  00047	80 bf 07 01 00
	00 00		 cmp	 BYTE PTR [edi+263], 0
  0004e	74 37		 je	 SHORT $LN6@CheckRequi

; 758  : 	{
; 759  : 		for( ItemPos = INVETORY_WEAR_SIZE; ItemPos < MAIN_INVENTORY_SIZE; ItemPos++ )

  00050	b8 f0 09 00 00	 mov	 eax, 2544		; 000009f0H
  00055	89 45 0c	 mov	 DWORD PTR tv872[ebp], eax
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@CheckRequi:

; 760  : 		{
; 761  : 			if( lpUser->pInventory[ItemPos].IsItem() )

  00060	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00066	03 c8		 add	 ecx, eax
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	85 c0		 test	 eax, eax
  0006f	0f 85 1c 01 00
	00		 jne	 $LN265@CheckRequi

; 758  : 	{
; 759  : 		for( ItemPos = INVETORY_WEAR_SIZE; ItemPos < MAIN_INVENTORY_SIZE; ItemPos++ )

  00075	8b 45 0c	 mov	 eax, DWORD PTR tv872[ebp]
  00078	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0007d	89 45 0c	 mov	 DWORD PTR tv872[ebp], eax
  00080	3d f0 a8 00 00	 cmp	 eax, 43248		; 0000a8f0H
  00085	7c d9		 jl	 SHORT $LL7@CheckRequi
$LN6@CheckRequi:

; 768  : 				}
; 769  : 		return false;
; 770  : 			}
; 771  : 		}
; 772  : 	}
; 773  : 
; 774  : 	if (Group->Checks.Shop)

  00087	80 bf 08 01 00
	00 00		 cmp	 BYTE PTR [edi+264], 0
  0008e	74 37		 je	 SHORT $LN9@CheckRequi

; 775  : 	{
; 776  : 		for( ItemPos = MAIN_INVENTORY_SIZE; ItemPos < INVENTORY_SIZE; ItemPos++ )

  00090	b8 f0 a8 00 00	 mov	 eax, 43248		; 0000a8f0H
  00095	89 45 0c	 mov	 DWORD PTR tv865[ebp], eax
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@CheckRequi:

; 777  : 		{
; 778  : 			if( lpUser->pInventory[ItemPos].IsItem() )

  000a0	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  000a6	03 c8		 add	 ecx, eax
  000a8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ad	85 c0		 test	 eax, eax
  000af	0f 85 1c 01 00
	00		 jne	 $LN266@CheckRequi

; 775  : 	{
; 776  : 		for( ItemPos = MAIN_INVENTORY_SIZE; ItemPos < INVENTORY_SIZE; ItemPos++ )

  000b5	8b 45 0c	 mov	 eax, DWORD PTR tv865[ebp]
  000b8	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  000bd	89 45 0c	 mov	 DWORD PTR tv865[ebp], eax
  000c0	3d 44 c4 00 00	 cmp	 eax, 50244		; 0000c444H
  000c5	7c d9		 jl	 SHORT $LL10@CheckRequi
$LN9@CheckRequi:

; 785  : 				}
; 786  : 		return false;
; 787  : 			}
; 788  : 		}
; 789  : 	}
; 790  : 
; 791  : 	if (lpUser->Level < Group->MinLevel || lpUser->Level > Group->MaxLevel)

  000c7	0f b7 86 96 00
	00 00		 movzx	 eax, WORD PTR [esi+150]
  000ce	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  000d1	66 3b c1	 cmp	 ax, cx
  000d4	0f 8c 4e 03 00
	00		 jl	 $LN24@CheckRequi
  000da	66 3b 47 02	 cmp	 ax, WORD PTR [edi+2]
  000de	0f 8f 44 03 00
	00		 jg	 $LN24@CheckRequi

; 800  : 	}
; 801  : 	
; 802  : 	if (PayType == 0)

  000e4	8a 45 18	 mov	 al, BYTE PTR _PayType$[ebp]
  000e7	84 c0		 test	 al, al
  000e9	0f 85 22 01 00
	00		 jne	 $LN26@CheckRequi

; 803  : 	{
; 804  : 		if (lpUser->Money < this->GetResetMoney(lpUser, Group, Type, true))

  000ef	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  000f5	8b cb		 mov	 ecx, ebx
  000f7	6a 01		 push	 1
  000f9	ff 75 10	 push	 DWORD PTR _Type$[ebp]
  000fc	89 45 18	 mov	 DWORD PTR tv891[ebp], eax
  000ff	57		 push	 edi
  00100	56		 push	 esi
  00101	e8 00 00 00 00	 call	 ?GetResetMoney@ResetSystem@@AAEHPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_N@Z ; ResetSystem::GetResetMoney
  00106	8b 4d 18	 mov	 ecx, DWORD PTR tv891[ebp]
  00109	3b c8		 cmp	 ecx, eax
  0010b	0f 8d a9 01 00
	00		 jge	 $LN35@CheckRequi

; 805  : 		{
; 806  : 			this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Not have enough Money (need: %d, user: %d)",

  00111	51		 push	 ecx
  00112	ff 77 0c	 push	 DWORD PTR [edi+12]
  00115	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00118	50		 push	 eax
  00119	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0011c	50		 push	 eax
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@GNAIDNOJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  00122	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00125	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0012a	83 c4 18	 add	 esp, 24			; 00000018H

; 807  : 				lpUser->AccountID, lpUser->Name, Group->Money, lpUser->Money);
; 808  : 			if (NotifyMessage)

  0012d	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  00131	0f 84 36 03 00
	00		 je	 $LN25@CheckRequi

; 809  : 			{
; 810  : 				this->GC_MessageBox(lpUser, "Reset Master", "Hey %s!\nYou need %d Money\nfor this reset.", lpUser->Name, Group->Money * (lpUser->iResetCount + 1));

  00137	8b 86 20 27 00
	00		 mov	 eax, DWORD PTR [esi+10016]
  0013d	40		 inc	 eax
  0013e	0f af 47 0c	 imul	 eax, DWORD PTR [edi+12]
  00142	50		 push	 eax
  00143	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00146	50		 push	 eax
  00147	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BAFCACOI@Hey?5?$CFs?$CB?6You?5need?5?$CFd?5Money?6for?5th@

; 811  : 			}
; 812  : 			return false;

  0014c	e9 0d 03 00 00	 jmp	 $LN280@CheckRequi
$LN264@CheckRequi:

; 745  : 			{
; 746  : 				this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Equipment check fail",

  00151	8d 7e 5d	 lea	 edi, DWORD PTR [esi+93]
  00154	57		 push	 edi
  00155	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00158	50		 push	 eax
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@IEMKIHCJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  0015e	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00161	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00166	83 c4 10	 add	 esp, 16			; 00000010H

; 747  : 					lpUser->AccountID, lpUser->Name);
; 748  : 				if (NotifyMessage)

  00169	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  0016d	0f 84 fa 02 00
	00		 je	 $LN25@CheckRequi

; 749  : 				{
; 750  : 					this->GC_MessageBox(lpUser, "Reset Master", "Hey %s!\nI think you forgot\nremove equipment...", lpUser->Name);

  00173	57		 push	 edi
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OFICEAAH@Hey?5?$CFs?$CB?6I?5think?5you?5forgot?6remov@
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  0017e	56		 push	 esi
  0017f	53		 push	 ebx
  00180	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
  00185	83 c4 14	 add	 esp, 20			; 00000014H

; 798  : 		}
; 799  : 		return false;

  00188	32 c0		 xor	 al, al

; 895  : }

  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx
  0018d	5d		 pop	 ebp
  0018e	c2 14 00	 ret	 20			; 00000014H
$LN265@CheckRequi:

; 762  : 			{
; 763  : 				this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Inventory check fail",

  00191	8d 7e 5d	 lea	 edi, DWORD PTR [esi+93]
  00194	57		 push	 edi
  00195	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00198	50		 push	 eax
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@JBHKEPMB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  0019e	ff 73 2c	 push	 DWORD PTR [ebx+44]
  001a1	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001a6	83 c4 10	 add	 esp, 16			; 00000010H

; 764  : 					lpUser->AccountID, lpUser->Name);
; 765  : 				if (NotifyMessage)

  001a9	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  001ad	0f 84 ba 02 00
	00		 je	 $LN25@CheckRequi

; 766  : 				{
; 767  : 				this->GC_MessageBox(lpUser, "Reset Master", "%s, maybe you forgot\nclean out inventory?", lpUser->Name);

  001b3	57		 push	 edi
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PMGLBKIN@?$CFs?0?5maybe?5you?5forgot?6clean?5out?5i@
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  001be	56		 push	 esi
  001bf	53		 push	 ebx
  001c0	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
  001c5	83 c4 14	 add	 esp, 20			; 00000014H

; 798  : 		}
; 799  : 		return false;

  001c8	32 c0		 xor	 al, al

; 895  : }

  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5b		 pop	 ebx
  001cd	5d		 pop	 ebp
  001ce	c2 14 00	 ret	 20			; 00000014H
$LN266@CheckRequi:

; 779  : 			{
; 780  : 				this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Shop check fail",

  001d1	8d 7e 5d	 lea	 edi, DWORD PTR [esi+93]
  001d4	57		 push	 edi
  001d5	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  001d8	50		 push	 eax
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@INNFFOLH@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  001de	ff 73 2c	 push	 DWORD PTR [ebx+44]
  001e1	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001e6	83 c4 10	 add	 esp, 16			; 00000010H

; 781  : 					lpUser->AccountID, lpUser->Name);
; 782  : 				if (NotifyMessage)

  001e9	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  001ed	0f 84 7a 02 00
	00		 je	 $LN25@CheckRequi

; 783  : 				{
; 784  : 				this->GC_MessageBox(lpUser, "Reset Master", "%s, please clean your\npersonal shop.", lpUser->Name);

  001f3	57		 push	 edi
  001f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NPOOAECJ@?$CFs?0?5please?5clean?5your?6personal?5s@
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  001fe	56		 push	 esi
  001ff	53		 push	 ebx
  00200	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
  00205	83 c4 14	 add	 esp, 20			; 00000014H

; 798  : 		}
; 799  : 		return false;

  00208	32 c0		 xor	 al, al

; 895  : }

  0020a	5f		 pop	 edi
  0020b	5e		 pop	 esi
  0020c	5b		 pop	 ebx
  0020d	5d		 pop	 ebp
  0020e	c2 14 00	 ret	 20			; 00000014H
$LN26@CheckRequi:

; 813  : 		}	
; 814  : 	}
; 815  : 	else if (PayType == 1)

  00211	3c 01		 cmp	 al, 1
  00213	75 5f		 jne	 SHORT $LN30@CheckRequi

; 816  : 	{
; 817  : 		if (lpUser->m_Credits < Group->Credits)

  00215	8b 86 38 27 00
	00		 mov	 eax, DWORD PTR [esi+10040]
  0021b	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  0021e	3b c1		 cmp	 eax, ecx
  00220	0f 83 94 00 00
	00		 jae	 $LN35@CheckRequi

; 818  : 	{
; 819  : 		this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Not have enough Credits (need: %d, user: %d)",

  00226	50		 push	 eax
  00227	51		 push	 ecx
  00228	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0022b	52		 push	 edx
  0022c	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0022f	50		 push	 eax
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@CMHDJMHA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  00235	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00238	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0023d	83 c4 18	 add	 esp, 24			; 00000018H

; 820  : 			lpUser->AccountID, lpUser->Name, Group->Credits, lpUser->m_Credits);
; 821  : 		if (NotifyMessage)

  00240	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  00244	0f 84 23 02 00
	00		 je	 $LN25@CheckRequi

; 822  : 				{
; 823  : 		this->GC_MessageBox(lpUser, "Reset Master", "Hello, %s!\nYou need %d Credits for\n this reset. Now you have: %d", 

  0024a	ff b6 38 27 00
	00		 push	 DWORD PTR [esi+10040]
  00250	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00253	ff 77 20	 push	 DWORD PTR [edi+32]
  00256	50		 push	 eax
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@ODDJMFE@Hello?0?5?$CFs?$CB?6You?5need?5?$CFd?5Credits?5f@
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  00261	56		 push	 esi
  00262	53		 push	 ebx
  00263	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
  00268	83 c4 1c	 add	 esp, 28			; 0000001cH
  0026b	32 c0		 xor	 al, al

; 895  : }

  0026d	5f		 pop	 edi
  0026e	5e		 pop	 esi
  0026f	5b		 pop	 ebx
  00270	5d		 pop	 ebp
  00271	c2 14 00	 ret	 20			; 00000014H
$LN30@CheckRequi:

; 824  : 			lpUser->Name, Group->Credits, lpUser->m_Credits);
; 825  : 		}
; 826  : 		return false;
; 827  : 	}	
; 828  : 	}
; 829  : 	else if (PayType == 2)

  00274	3c 02		 cmp	 al, 2
  00276	75 42		 jne	 SHORT $LN35@CheckRequi

; 830  : 	{
; 831  : 		if (lpUser->m_wcCashPoint < Group->WCoinC)

  00278	8b 86 68 24 00
	00		 mov	 eax, DWORD PTR [esi+9320]
  0027e	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00281	3b c1		 cmp	 eax, ecx
  00283	7d 35		 jge	 SHORT $LN35@CheckRequi

; 832  : 	{
; 833  : 		this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Not have enough WCoinC (need: %d, user: %d)",

  00285	50		 push	 eax
  00286	51		 push	 ecx
  00287	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0028a	52		 push	 edx
  0028b	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0028e	50		 push	 eax
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@BADCMJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  00294	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00297	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0029c	83 c4 18	 add	 esp, 24			; 00000018H

; 834  : 			lpUser->AccountID, lpUser->Name, Group->WCoinC, lpUser->m_wcCashPoint);
; 835  : 		if (NotifyMessage)

  0029f	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  002a3	0f 84 c4 01 00
	00		 je	 $LN25@CheckRequi

; 836  : 				{
; 837  : 		this->GC_MessageBox(lpUser, "Reset Master", "Hey, %s!\nYou need %d WCoinC\nfor this reset.", lpUser->Name, Group->WCoinC);

  002a9	ff 77 10	 push	 DWORD PTR [edi+16]
  002ac	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  002af	50		 push	 eax
  002b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@IMDIKCEK@Hey?0?5?$CFs?$CB?6You?5need?5?$CFd?5WCoinC?6for?5@

; 838  : 		}
; 839  : 		return false;

  002b5	e9 a4 01 00 00	 jmp	 $LN280@CheckRequi
$LN35@CheckRequi:

; 840  : 	}	
; 841  : 	}
; 842  : 
; 843  : 	
; 844  : 	
; 845  : 	/*if (lpUser->m_wpCashPoint < Group->WCoinP)
; 846  : 	{
; 847  : 		this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Not have enough WCoinP (need: %d, user: %d)",
; 848  : 			lpUser->AccountID, lpUser->Name, Group->WCoinP, lpUser->m_wpCashPoint);
; 849  : 		if (NotifyMessage)
; 850  : 				{
; 851  : 		this->GC_MessageBox(lpUser, "Reset Master", "Great %s!\nYou need %d WCoinP\nfor this reset.", lpUser->Name, Group->WCoinP);
; 852  : 		}
; 853  : 		return false;
; 854  : 	}
; 855  : 
; 856  : 	if (lpUser->m_wgCashPoint < Group->WCoinG)
; 857  : 	{
; 858  : 		this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Not have enough WCoinG (need: %d, user: %d)",
; 859  : 			lpUser->AccountID, lpUser->Name, Group->WCoinG, lpUser->m_wgCashPoint);
; 860  : 		if (NotifyMessage)
; 861  : 				{
; 862  : 		this->GC_MessageBox(lpUser, "Reset Master", "Great %s!\nYou need %d Goblin Point\nfor this reset.", lpUser->Name, Group->WCoinG);
; 863  : 		}
; 864  : 		return false;
; 865  : 	}*/
; 866  : 
; 867  : 	if (lpUser->m_GensInfo.iContribution < Group->GensP)

  002ba	8b 86 b4 26 00
	00		 mov	 eax, DWORD PTR [esi+9908]
  002c0	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  002c3	3b c1		 cmp	 eax, ecx
  002c5	7d 35		 jge	 SHORT $LN37@CheckRequi

; 868  : 	{
; 869  : 		this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Not have enough GensP (need: %d, user: %d)",

  002c7	50		 push	 eax
  002c8	51		 push	 ecx
  002c9	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  002cc	52		 push	 edx
  002cd	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  002d0	50		 push	 eax
  002d1	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@GEIIDDDF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  002d6	ff 73 2c	 push	 DWORD PTR [ebx+44]
  002d9	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  002de	83 c4 18	 add	 esp, 24			; 00000018H

; 870  : 			lpUser->AccountID, lpUser->Name, Group->GensP, lpUser->m_GensInfo.iContribution);
; 871  : 		if (NotifyMessage)

  002e1	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  002e5	0f 84 82 01 00
	00		 je	 $LN25@CheckRequi

; 872  : 				{
; 873  : 		this->GC_MessageBox(lpUser, "Reset Master", "Great %s!\nYou need %d Contribution\nfor this reset.", lpUser->Name, Group->GensP);

  002eb	ff 77 1c	 push	 DWORD PTR [edi+28]
  002ee	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  002f1	50		 push	 eax
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@MNPCIAAH@Great?5?$CFs?$CB?6You?5need?5?$CFd?5Contributi@

; 874  : 		}
; 875  : 		return false;

  002f7	e9 62 01 00 00	 jmp	 $LN280@CheckRequi
$LN37@CheckRequi:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  002fc	8b 8f f4 00 00
	00		 mov	 ecx, DWORD PTR [edi+244]
  00302	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00307	2b 8f f0 00 00
	00		 sub	 ecx, DWORD PTR [edi+240]
  0030d	f7 e9		 imul	 ecx
  0030f	c1 fa 02	 sar	 edx, 2
  00312	8b c2		 mov	 eax, edx
  00314	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00317	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 880  : 	if (Group->ItemList.size() > 0)

  00319	0f 84 86 00 00
	00		 je	 $LN12@CheckRequi

; 882  : 		for (int i = 0; i < Group->ItemList.size(); i++)

  0031f	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00321	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 882  : 		for (int i = 0; i < Group->ItemList.size(); i++)

  00326	89 4d 14	 mov	 DWORD PTR _i$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00329	8b 8f f4 00 00
	00		 mov	 ecx, DWORD PTR [edi+244]
  0032f	2b 8f f0 00 00
	00		 sub	 ecx, DWORD PTR [edi+240]
  00335	f7 e9		 imul	 ecx
  00337	c1 fa 02	 sar	 edx, 2
  0033a	8b c2		 mov	 eax, edx
  0033c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0033f	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 882  : 		for (int i = 0; i < Group->ItemList.size(); i++)

  00341	74 62		 je	 SHORT $LN12@CheckRequi
  00343	33 c0		 xor	 eax, eax
  00345	89 45 18	 mov	 DWORD PTR tv863[ebp], eax
  00348	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL13@CheckRequi:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00350	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR [edi+240]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 884  : 			if (this->GetItemInventoryPos(lpUser, Group->ItemList[i]) == (BYTE)-1)

  00356	83 ec 18	 sub	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00359	03 c8		 add	 ecx, eax
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 884  : 			if (this->GetItemInventoryPos(lpUser, Group->ItemList[i]) == (BYTE)-1)

  0035b	8b c4		 mov	 eax, esp
  0035d	56		 push	 esi
  0035e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00361	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00364	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  00369	8b cb		 mov	 ecx, ebx
  0036b	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  00370	e8 00 00 00 00	 call	 ?GetItemInventoryPos@ResetSystem@@AAEEPAUOBJECTSTRUCT@@UResetItem@@@Z ; ResetSystem::GetItemInventoryPos
  00375	3c ff		 cmp	 al, 255			; 000000ffH
  00377	74 35		 je	 SHORT $LN267@CheckRequi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00379	8b 8f f4 00 00
	00		 mov	 ecx, DWORD PTR [edi+244]
  0037f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00384	2b 8f f0 00 00
	00		 sub	 ecx, DWORD PTR [edi+240]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 882  : 		for (int i = 0; i < Group->ItemList.size(); i++)

  0038a	ff 45 14	 inc	 DWORD PTR _i$1$[ebp]
  0038d	83 45 18 18	 add	 DWORD PTR tv863[ebp], 24 ; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00391	f7 e9		 imul	 ecx
  00393	c1 fa 02	 sar	 edx, 2
  00396	8b c2		 mov	 eax, edx
  00398	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0039b	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 882  : 		for (int i = 0; i < Group->ItemList.size(); i++)

  0039d	39 45 14	 cmp	 DWORD PTR _i$1$[ebp], eax
  003a0	8b 45 18	 mov	 eax, DWORD PTR tv863[ebp]
  003a3	72 ab		 jb	 SHORT $LL13@CheckRequi
$LN12@CheckRequi:

; 887  : 					lpUser->AccountID, lpUser->Name, Group->ItemList[i].Type, Group->ItemList[i].Index, Group->ItemList[i].MinLevel, Group->ItemList[i].MaxLevel, Group->ItemList[i].MinDurability, Group->ItemList[i].MaxDurability, Group->ItemList[i].MinOption, Group->ItemList[i].MaxOption,
; 888  : 					Group->ItemList[i].Luck, Group->ItemList[i].Skill, Group->ItemList[i].Excellent, Group->ItemList[i].Ancient, Group->ItemList[i].Socket, Group->ItemList[i].Element, Group->ItemList[i].Count);
; 889  : 				return false;
; 890  : 			}
; 891  : 		}
; 892  : 	}
; 893  : 
; 894  : 	return true;

  003a5	b0 01		 mov	 al, 1

; 895  : }

  003a7	5f		 pop	 edi
  003a8	5e		 pop	 esi
  003a9	5b		 pop	 ebx
  003aa	5d		 pop	 ebp
  003ab	c2 14 00	 ret	 20			; 00000014H
$LN267@CheckRequi:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  003ae	8b 45 14	 mov	 eax, DWORD PTR _i$1$[ebp]
  003b1	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 886  : 				this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Not have required item (type: %d, index: %d, minlevel: %d, maxlevel: %d, mindur: %d, maxdur: %d, minoption: %d, maxoption: %d, luck: %d, skill: %d, excellent: %d, ancient: %d, socket: %d, element: %d, count: %d)",

  003b4	8b 87 f0 00 00
	00		 mov	 eax, DWORD PTR [edi+240]
  003ba	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  003bd	0f bf 41 16	 movsx	 eax, WORD PTR [ecx+22]
  003c1	50		 push	 eax
  003c2	0f bf 41 14	 movsx	 eax, WORD PTR [ecx+20]
  003c6	50		 push	 eax
  003c7	0f bf 41 12	 movsx	 eax, WORD PTR [ecx+18]
  003cb	50		 push	 eax
  003cc	0f bf 41 10	 movsx	 eax, WORD PTR [ecx+16]
  003d0	50		 push	 eax
  003d1	0f bf 41 0e	 movsx	 eax, WORD PTR [ecx+14]
  003d5	50		 push	 eax
  003d6	0f bf 41 0c	 movsx	 eax, WORD PTR [ecx+12]
  003da	50		 push	 eax
  003db	0f bf 41 0a	 movsx	 eax, WORD PTR [ecx+10]
  003df	50		 push	 eax
  003e0	0f b6 41 09	 movzx	 eax, BYTE PTR [ecx+9]
  003e4	50		 push	 eax
  003e5	0f b6 41 08	 movzx	 eax, BYTE PTR [ecx+8]
  003e9	50		 push	 eax
  003ea	0f b6 41 07	 movzx	 eax, BYTE PTR [ecx+7]
  003ee	50		 push	 eax
  003ef	0f b6 41 06	 movzx	 eax, BYTE PTR [ecx+6]
  003f3	50		 push	 eax
  003f4	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  003f8	50		 push	 eax
  003f9	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  003fd	50		 push	 eax
  003fe	0f bf 41 02	 movsx	 eax, WORD PTR [ecx+2]
  00402	50		 push	 eax
  00403	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  00406	50		 push	 eax
  00407	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0040a	83 c6 52	 add	 esi, 82			; 00000052H
  0040d	50		 push	 eax
  0040e	56		 push	 esi
  0040f	68 00 00 00 00	 push	 OFFSET ??_C@_0BAA@LFFJLJBC@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  00414	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00417	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0041c	83 c4 4c	 add	 esp, 76			; 0000004cH
  0041f	32 c0		 xor	 al, al

; 895  : }

  00421	5f		 pop	 edi
  00422	5e		 pop	 esi
  00423	5b		 pop	 ebx
  00424	5d		 pop	 ebp
  00425	c2 14 00	 ret	 20			; 00000014H
$LN24@CheckRequi:

; 792  : 	{
; 793  : 		this->Log->Output("[ResetSystem] [%s] [%s] (CheckRequirements) Level is not valid for this reset (min: %d, max: %d, user: %d)",

  00428	98		 cwde
  00429	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0042c	50		 push	 eax
  0042d	0f bf 47 02	 movsx	 eax, WORD PTR [edi+2]
  00431	50		 push	 eax
  00432	0f bf c1	 movsx	 eax, cx
  00435	50		 push	 eax
  00436	52		 push	 edx
  00437	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0043a	50		 push	 eax
  0043b	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@HKMJCFGF@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CICheckRe@
  00440	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00443	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00448	83 c4 1c	 add	 esp, 28			; 0000001cH

; 794  : 			lpUser->AccountID, lpUser->Name, Group->MinLevel, Group->MaxLevel, lpUser->Level);
; 795  : 		if (NotifyMessage)

  0044b	80 7d 14 00	 cmp	 BYTE PTR _NotifyMessage$[ebp], 0
  0044f	74 1c		 je	 SHORT $LN25@CheckRequi

; 796  : 				{
; 797  : 		this->GC_MessageBox(lpUser, "Reset Master", "Great %s!\nYou need %d level\nfor this reset.", lpUser->Name, Group->MinLevel);

  00451	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00454	50		 push	 eax
  00455	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00458	50		 push	 eax
  00459	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NIJOIGCG@Great?5?$CFs?$CB?6You?5need?5?$CFd?5level?6for?5@
$LN280@CheckRequi:
  0045e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  00463	56		 push	 esi
  00464	53		 push	 ebx
  00465	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
  0046a	83 c4 18	 add	 esp, 24			; 00000018H
$LN25@CheckRequi:

; 895  : }

  0046d	5f		 pop	 edi
  0046e	5e		 pop	 esi
  0046f	32 c0		 xor	 al, al
  00471	5b		 pop	 ebx
  00472	5d		 pop	 ebp
  00473	c2 14 00	 ret	 20			; 00000014H
?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_NE@Z ENDP ; ResetSystem::CheckRequirements
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?IsValidItemNode@ResetSystem@@AAE_NUResetItem@@@Z
_TEXT	SEGMENT
_NewItem$ = 8						; size = 24
?IsValidItemNode@ResetSystem@@AAE_NUResetItem@@@Z PROC	; ResetSystem::IsValidItemNode, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     if (NewItem.Type < 0 || NewItem.Type > 15)

  00003	8b 45 08	 mov	 eax, DWORD PTR _NewItem$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 f8 0f	 cmp	 ax, 15			; 0000000fH
  0000d	0f 87 9c 02 00
	00		 ja	 $LN3@IsValidIte

; 267  :     }
; 268  :     
; 269  :     if (NewItem.Index < 0 || NewItem.Index > 512)

  00013	c1 e8 10	 shr	 eax, 16			; 00000010H
  00016	66 85 c0	 test	 ax, ax
  00019	0f 88 65 02 00
	00		 js	 $LN5@IsValidIte
  0001f	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00024	66 3b c1	 cmp	 ax, cx
  00027	0f 8f 57 02 00
	00		 jg	 $LN5@IsValidIte

; 273  :         return false;
; 274  :     }
; 275  :     
; 276  :     if (NewItem.MinLevel < 0 || NewItem.MaxLevel > 15)

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _NewItem$[ebp+4]
  00030	8b c1		 mov	 eax, ecx
  00032	c1 e8 08	 shr	 eax, 8
  00035	3c 0f		 cmp	 al, 15			; 0000000fH
  00037	0f 87 1d 02 00
	00		 ja	 $LN7@IsValidIte

; 280  :         return false;
; 281  :     }
; 282  :     
; 283  :     if (NewItem.MaxLevel < 0 || NewItem.MaxLevel > 15)
; 284  :     {
; 285  :         MsgBox("[ResetSystem] Syntax error in item node, param: maxlvl (%d)", NewItem.MaxLevel);
; 286  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: maxlvl (%d)", NewItem.MaxLevel);
; 287  :         return false;
; 288  :     }
; 289  :     
; 290  :     if (NewItem.MinDurability < 0 || NewItem.MinDurability > 255)

  0003d	8b c1		 mov	 eax, ecx
  0003f	c1 e8 10	 shr	 eax, 16			; 00000010H
  00042	3c ff		 cmp	 al, 255			; 000000ffH
  00044	0f 87 e5 01 00
	00		 ja	 $LN11@IsValidIte

; 294  :         return false;
; 295  :     }
; 296  :     
; 297  :     if (NewItem.MaxDurability < 0 || NewItem.MaxDurability > 255)

  0004a	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0004d	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00050	0f 87 ae 01 00
	00		 ja	 $LN13@IsValidIte

; 301  :         return false;
; 302  :     }
; 303  :     
; 304  :     if (NewItem.MinOption < 0 || NewItem.MinOption > 7)

  00056	8b 4d 10	 mov	 ecx, DWORD PTR _NewItem$[ebp+8]
  00059	80 f9 07	 cmp	 cl, 7
  0005c	0f 87 78 01 00
	00		 ja	 $LN15@IsValidIte

; 308  :         return false;
; 309  :     }
; 310  :     
; 311  :     if (NewItem.MaxOption < 0 || NewItem.MaxOption > 7)

  00062	8b c1		 mov	 eax, ecx
  00064	c1 e8 08	 shr	 eax, 8
  00067	3c 07		 cmp	 al, 7
  00069	0f 87 41 01 00
	00		 ja	 $LN17@IsValidIte

; 315  :         return false;
; 316  :     }
; 317  : 
; 318  : 	if (NewItem.Luck < -1 || NewItem.Luck > 1)

  0006f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00072	66 83 f9 ff	 cmp	 cx, -1
  00076	0f 8c 09 01 00
	00		 jl	 $LN21@IsValidIte
  0007c	66 83 f9 01	 cmp	 cx, 1
  00080	0f 8f ff 00 00
	00		 jg	 $LN21@IsValidIte

; 319  :     {
; 320  :         MsgBox("[ResetSystem] Syntax error in item node, param: luck (%d)", NewItem.Luck);
; 321  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: luck (%d)", NewItem.Luck);
; 322  :         return false;
; 323  :     }
; 324  : 
; 325  : 	if (NewItem.Skill < -1 || NewItem.Skill > 1)

  00086	8b 4d 14	 mov	 ecx, DWORD PTR _NewItem$[ebp+12]
  00089	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0008c	66 83 f8 02	 cmp	 ax, 2
  00090	0f 87 ef 00 00
	00		 ja	 $LN21@IsValidIte

; 329  :         return false;
; 330  :     }
; 331  : 
; 332  : 	if (NewItem.Excellent < -1 || NewItem.Excellent > 63)

  00096	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00099	66 83 f9 ff	 cmp	 cx, -1
  0009d	0f 8c b7 00 00
	00		 jl	 $LN23@IsValidIte
  000a3	66 83 f9 3f	 cmp	 cx, 63			; 0000003fH
  000a7	0f 8f ad 00 00
	00		 jg	 $LN23@IsValidIte

; 336  :         return false;
; 337  :     }
; 338  : 
; 339  : 	if (NewItem.Ancient < -1 || NewItem.Ancient > 2)

  000ad	8b 4d 18	 mov	 ecx, DWORD PTR _NewItem$[ebp+16]
  000b0	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000b3	66 83 f8 03	 cmp	 ax, 3
  000b7	77 77		 ja	 SHORT $LN25@IsValidIte

; 343  :         return false;
; 344  :     }
; 345  : 	
; 346  : 	if (NewItem.Socket < -1 || NewItem.Socket > 5)

  000b9	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000bc	66 83 f9 ff	 cmp	 cx, -1
  000c0	7c 43		 jl	 SHORT $LN27@IsValidIte
  000c2	66 83 f9 05	 cmp	 cx, 5
  000c6	7f 3d		 jg	 SHORT $LN27@IsValidIte

; 350  :         return false;
; 351  :     }
; 352  : 
; 353  : 	if (NewItem.Element < -1 || NewItem.Element > 5)

  000c8	8b 4d 1c	 mov	 ecx, DWORD PTR _NewItem$[ebp+20]
  000cb	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000ce	66 83 f8 06	 cmp	 ax, 6
  000d2	77 07		 ja	 SHORT $LN29@IsValidIte

; 357  :         return false;
; 358  :     }
; 359  : 
; 360  : 	return true;

  000d4	b0 01		 mov	 al, 1
  000d6	5e		 pop	 esi

; 361  : }

  000d7	5d		 pop	 ebp
  000d8	c2 18 00	 ret	 24			; 00000018H
$LN29@IsValidIte:

; 354  :     {
; 355  :         MsgBox("[ResetSystem] Syntax error in item node, param: element (%d)", NewItem.Element);

  000db	0f bf c1	 movsx	 eax, cx
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NGBPCBKA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  000e4	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 356  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: element (%d)", NewItem.Element);

  000e9	0f bf 45 1c	 movsx	 eax, WORD PTR _NewItem$[ebp+20]
  000ed	50		 push	 eax
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NGBPCBKA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  000f3	ff 76 2c	 push	 DWORD PTR [esi+44]
  000f6	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  000fb	83 c4 14	 add	 esp, 20			; 00000014H
  000fe	32 c0		 xor	 al, al
  00100	5e		 pop	 esi

; 361  : }

  00101	5d		 pop	 ebp
  00102	c2 18 00	 ret	 24			; 00000018H
$LN27@IsValidIte:

; 347  :     {
; 348  :         MsgBox("[ResetSystem] Syntax error in item node, param: socket (%d)", NewItem.Socket);

  00105	0f bf 45 1a	 movsx	 eax, WORD PTR _NewItem$[ebp+18]
  00109	50		 push	 eax
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@CNNHDLNO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0010f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 349  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: socket (%d)", NewItem.Socket);

  00114	0f bf 45 1a	 movsx	 eax, WORD PTR _NewItem$[ebp+18]
  00118	50		 push	 eax
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@CNNHDLNO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0011e	ff 76 2c	 push	 DWORD PTR [esi+44]
  00121	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00126	83 c4 14	 add	 esp, 20			; 00000014H
  00129	32 c0		 xor	 al, al
  0012b	5e		 pop	 esi

; 361  : }

  0012c	5d		 pop	 ebp
  0012d	c2 18 00	 ret	 24			; 00000018H
$LN25@IsValidIte:

; 340  :     {
; 341  :         MsgBox("[ResetSystem] Syntax error in item node, param: ancient (%d)", NewItem.Ancient);

  00130	0f bf c1	 movsx	 eax, cx
  00133	50		 push	 eax
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@BLMDLPJA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00139	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 342  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: ancient (%d)", NewItem.Ancient);

  0013e	0f bf 45 18	 movsx	 eax, WORD PTR _NewItem$[ebp+16]
  00142	50		 push	 eax
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@BLMDLPJA@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00148	ff 76 2c	 push	 DWORD PTR [esi+44]
  0014b	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00150	83 c4 14	 add	 esp, 20			; 00000014H
  00153	32 c0		 xor	 al, al
  00155	5e		 pop	 esi

; 361  : }

  00156	5d		 pop	 ebp
  00157	c2 18 00	 ret	 24			; 00000018H
$LN23@IsValidIte:

; 333  :     {
; 334  :         MsgBox("[ResetSystem] Syntax error in item node, param: excellent (%d)", NewItem.Excellent);

  0015a	0f bf 45 16	 movsx	 eax, WORD PTR _NewItem$[ebp+14]
  0015e	50		 push	 eax
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@KLHIOMDO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00164	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 335  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: excellent (%d)", NewItem.Excellent);

  00169	0f bf 45 16	 movsx	 eax, WORD PTR _NewItem$[ebp+14]
  0016d	50		 push	 eax
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@KLHIOMDO@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00173	ff 76 2c	 push	 DWORD PTR [esi+44]
  00176	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0017b	83 c4 14	 add	 esp, 20			; 00000014H
  0017e	32 c0		 xor	 al, al
  00180	5e		 pop	 esi

; 361  : }

  00181	5d		 pop	 ebp
  00182	c2 18 00	 ret	 24			; 00000018H
$LN21@IsValidIte:

; 326  :     {
; 327  :         MsgBox("[ResetSystem] Syntax error in item node, param: luck (%d)", NewItem.Luck);

  00185	0f bf 45 12	 movsx	 eax, WORD PTR _NewItem$[ebp+10]
  00189	50		 push	 eax
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@FBBLNOEP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0018f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 328  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: luck (%d)", NewItem.Luck);

  00194	0f bf 45 12	 movsx	 eax, WORD PTR _NewItem$[ebp+10]
  00198	50		 push	 eax
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@FBBLNOEP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0019e	ff 76 2c	 push	 DWORD PTR [esi+44]
  001a1	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001a6	83 c4 14	 add	 esp, 20			; 00000014H
  001a9	32 c0		 xor	 al, al
  001ab	5e		 pop	 esi

; 361  : }

  001ac	5d		 pop	 ebp
  001ad	c2 18 00	 ret	 24			; 00000018H
$LN17@IsValidIte:

; 312  :     {
; 313  :         MsgBox("[ResetSystem] Syntax error in item node, param: maxopt (%d)", NewItem.MaxOption);

  001b0	0f b6 c5	 movzx	 eax, ch
  001b3	50		 push	 eax
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@CMHBDKGG@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  001b9	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 314  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: maxopt (%d)", NewItem.MaxOption);

  001be	0f b6 45 11	 movzx	 eax, BYTE PTR _NewItem$[ebp+9]
  001c2	50		 push	 eax
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@CMHBDKGG@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  001c8	ff 76 2c	 push	 DWORD PTR [esi+44]
  001cb	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001d0	83 c4 14	 add	 esp, 20			; 00000014H
  001d3	32 c0		 xor	 al, al
  001d5	5e		 pop	 esi

; 361  : }

  001d6	5d		 pop	 ebp
  001d7	c2 18 00	 ret	 24			; 00000018H
$LN15@IsValidIte:

; 305  :     {
; 306  :         MsgBox("[ResetSystem] Syntax error in item node, param: minopt (%d)", NewItem.MinOption);

  001da	0f b6 c1	 movzx	 eax, cl
  001dd	50		 push	 eax
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LMACCKIM@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  001e3	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 307  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: minopt (%d)", NewItem.MinOption);

  001e8	0f b6 45 10	 movzx	 eax, BYTE PTR _NewItem$[ebp+8]
  001ec	50		 push	 eax
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LMACCKIM@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  001f2	ff 76 2c	 push	 DWORD PTR [esi+44]
  001f5	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001fa	83 c4 14	 add	 esp, 20			; 00000014H
  001fd	32 c0		 xor	 al, al
  001ff	5e		 pop	 esi

; 361  : }

  00200	5d		 pop	 ebp
  00201	c2 18 00	 ret	 24			; 00000018H
$LN13@IsValidIte:

; 298  :     {
; 299  :         MsgBox("[ResetSystem] Syntax error in item node, param: maxdur (%d)", NewItem.MaxDurability);

  00204	0f b6 45 0f	 movzx	 eax, BYTE PTR _NewItem$[ebp+7]
  00208	50		 push	 eax
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@IFBEJPOF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0020e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 300  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: maxdur (%d)", NewItem.MaxDurability);

  00213	0f b6 45 0f	 movzx	 eax, BYTE PTR _NewItem$[ebp+7]
  00217	50		 push	 eax
  00218	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@IFBEJPOF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0021d	ff 76 2c	 push	 DWORD PTR [esi+44]
  00220	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00225	83 c4 14	 add	 esp, 20			; 00000014H
  00228	32 c0		 xor	 al, al
  0022a	5e		 pop	 esi

; 361  : }

  0022b	5d		 pop	 ebp
  0022c	c2 18 00	 ret	 24			; 00000018H
$LN11@IsValidIte:

; 291  :     {
; 292  :         MsgBox("[ResetSystem] Syntax error in item node, param: mindur (%d)", NewItem.MinDurability);

  0022f	0f b6 45 0e	 movzx	 eax, BYTE PTR _NewItem$[ebp+6]
  00233	50		 push	 eax
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BFGHIPAP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00239	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 293  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: mindur (%d)", NewItem.MinDurability);

  0023e	0f b6 45 0e	 movzx	 eax, BYTE PTR _NewItem$[ebp+6]
  00242	50		 push	 eax
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BFGHIPAP@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00248	ff 76 2c	 push	 DWORD PTR [esi+44]
  0024b	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00250	83 c4 14	 add	 esp, 20			; 00000014H
  00253	32 c0		 xor	 al, al
  00255	5e		 pop	 esi

; 361  : }

  00256	5d		 pop	 ebp
  00257	c2 18 00	 ret	 24			; 00000018H
$LN7@IsValidIte:

; 277  :     {
; 278  :         MsgBox("[ResetSystem] Syntax error in item node, param: minlvl (%d)", NewItem.MinLevel);

  0025a	0f b6 c1	 movzx	 eax, cl
  0025d	50		 push	 eax
  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BHNBMNGH@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00263	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 279  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: minlvl (%d)", NewItem.MinLevel);

  00268	0f b6 45 0c	 movzx	 eax, BYTE PTR _NewItem$[ebp+4]
  0026c	50		 push	 eax
  0026d	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BHNBMNGH@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  00272	ff 76 2c	 push	 DWORD PTR [esi+44]
  00275	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0027a	83 c4 14	 add	 esp, 20			; 00000014H
  0027d	32 c0		 xor	 al, al
  0027f	5e		 pop	 esi

; 361  : }

  00280	5d		 pop	 ebp
  00281	c2 18 00	 ret	 24			; 00000018H
$LN5@IsValidIte:

; 270  :     {
; 271  :         MsgBox("[ResetSystem] Syntax error in item node, param: index (%d)", NewItem.Index);

  00284	0f bf 45 0a	 movsx	 eax, WORD PTR _NewItem$[ebp+2]
  00288	50		 push	 eax
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@CCJFLBFF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0028e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 272  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: index (%d)", NewItem.Index);

  00293	0f bf 45 0a	 movsx	 eax, WORD PTR _NewItem$[ebp+2]
  00297	50		 push	 eax
  00298	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@CCJFLBFF@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  0029d	ff 76 2c	 push	 DWORD PTR [esi+44]
  002a0	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  002a5	83 c4 14	 add	 esp, 20			; 00000014H
  002a8	32 c0		 xor	 al, al
  002aa	5e		 pop	 esi

; 361  : }

  002ab	5d		 pop	 ebp
  002ac	c2 18 00	 ret	 24			; 00000018H
$LN3@IsValidIte:

; 263  :     {
; 264  :         MsgBox("[ResetSystem] Syntax error in item node, param: type (%d)", NewItem.Type);

  002af	98		 cwde
  002b0	50		 push	 eax
  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@CBFNKBNC@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  002b6	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 265  :         this->Log->Output("[ResetSystem] Syntax error in item node, param: type (%d)", NewItem.Type);

  002bb	0f bf 45 08	 movsx	 eax, WORD PTR _NewItem$[ebp]
  002bf	50		 push	 eax
  002c0	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@CBFNKBNC@?$FLResetSystem?$FN?5Syntax?5error?5in?5it@
  002c5	ff 76 2c	 push	 DWORD PTR [esi+44]
  002c8	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  002cd	83 c4 14	 add	 esp, 20			; 00000014H

; 266  :         return false;

  002d0	32 c0		 xor	 al, al
  002d2	5e		 pop	 esi

; 361  : }

  002d3	5d		 pop	 ebp
  002d4	c2 18 00	 ret	 24			; 00000018H
?IsValidItemNode@ResetSystem@@AAE_NUResetItem@@@Z ENDP	; ResetSystem::IsValidItemNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z
_TEXT	SEGMENT
_UserIndex$ = 8						; size = 4
_lpRequest$ = 12					; size = 4
?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z PROC ; ResetSystem::CG_RequestStart, COMDAT
; _this$ = ecx

; 725  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 726  : 	if (!gObjIsConnected(UserIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _UserIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	74 26		 je	 SHORT $LN1@CG_Request

; 727  : 	{
; 728  : 		return;
; 729  : 	}
; 730  : 
; 731  : 	LPOBJ lpUser = &gObj[UserIndex];
; 732  : 
; 733  : 	this->ProcReset(lpUser, (ResetType::T)lpRequest->Type, lpRequest->PayType, lpRequest->ProcWait);

  00017	8b 55 0c	 mov	 edx, DWORD PTR _lpRequest$[ebp]
  0001a	8b cf		 mov	 ecx, edi
  0001c	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  00020	50		 push	 eax
  00021	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00025	50		 push	 eax
  00026	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0002a	50		 push	 eax
  0002b	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00031	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?ProcReset@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@EE@Z ; ResetSystem::ProcReset
$LN1@CG_Request:
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 734  : }

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z ENDP ; ResetSystem::CG_RequestStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ
_TEXT	SEGMENT
_lpRequest$ = -720					; size = 204
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_lpUser$ = 12						; size = 4
_Title$ = 16						; size = 4
_Text$ = 20						; size = 4
?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ PROC ; ResetSystem::GC_MessageBox, COMDAT

; 708  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 02 00
	00		 sub	 esp, 720		; 000002d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _lpUser$[ebp]
  00017	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR _Title$[ebp]
  00021	57		 push	 edi
  00022	68 00 02 00 00	 push	 512			; 00000200H
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _memset
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00032	8d 45 18	 lea	 eax, DWORD PTR _Text$[ebp+4]
  00035	50		 push	 eax
  00036	6a 00		 push	 0
  00038	ff 75 14	 push	 DWORD PTR _Text$[ebp]
  0003b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00041	6a ff		 push	 -1
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	ff 70 04	 push	 DWORD PTR [eax+4]
  0004e	83 c9 01	 or	 ecx, 1
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 716  : 	PacketResetMessageBox lpRequest = { 0 };

  00057	68 cb 00 00 00	 push	 203			; 000000cbH
  0005c	8d 85 31 fd ff
	ff		 lea	 eax, DWORD PTR _lpRequest$[ebp+1]
  00062	6a 00		 push	 0
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _memset

; 717  : 	lpRequest.Head.set((LPBYTE)&lpRequest, 0xFE, 0x05, sizeof(PacketResetMessageBox));
; 718  : 	memcpy(lpRequest.Title, Title, sizeof(lpRequest.Title)-1);

  0006a	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  0006d	66 8b 46 38	 mov	 ax, WORD PTR [esi+56]

; 719  : 	memcpy(lpRequest.Text, szBuffer, sizeof(lpRequest.Text)-1);

  00071	8d bd 70 fd ff
	ff		 lea	 edi, DWORD PTR _lpRequest$[ebp+64]
  00077	66 89 85 6c fd
	ff ff		 mov	 WORD PTR _lpRequest$[ebp+60], ax
  0007e	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  00083	8a 46 3a	 mov	 al, BYTE PTR [esi+58]
  00086	0f 11 85 34 fd
	ff ff		 movups	 XMMWORD PTR _lpRequest$[ebp+4], xmm0
  0008d	88 85 6e fd ff
	ff		 mov	 BYTE PTR _lpRequest$[ebp+62], al

; 721  : 	DataSend(lpUser->m_Index, (LPBYTE)&lpRequest, lpRequest.Head.size);

  00093	8d 85 30 fd ff
	ff		 lea	 eax, DWORD PTR _lpRequest$[ebp]
  00099	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [esi+16]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0009d	c7 85 30 fd ff
	ff c1 cc fe 05	 mov	 DWORD PTR _lpRequest$[ebp], 100584641 ; 05feccc1H
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 721  : 	DataSend(lpUser->m_Index, (LPBYTE)&lpRequest, lpRequest.Head.size);

  000a7	68 cc 00 00 00	 push	 204			; 000000ccH
  000ac	0f 11 85 44 fd
	ff ff		 movups	 XMMWORD PTR _lpRequest$[ebp+20], xmm0
  000b3	50		 push	 eax
  000b4	0f 10 46 20	 movups	 xmm0, XMMWORD PTR [esi+32]
  000b8	ff 33		 push	 DWORD PTR [ebx]
  000ba	0f 11 85 54 fd
	ff ff		 movups	 XMMWORD PTR _lpRequest$[ebp+36], xmm0
  000c1	f3 0f 7e 46 30	 movq	 xmm0, QWORD PTR [esi+48]
  000c6	8d b5 fc fd ff
	ff		 lea	 esi, DWORD PTR _szBuffer$[ebp]
  000cc	66 0f d6 85 64
	fd ff ff	 movq	 QWORD PTR _lpRequest$[ebp+52], xmm0
  000d4	f3 a5		 rep movsd
  000d6	66 a5		 movsw
  000d8	a4		 movsb
  000d9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 722  : }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	83 c4 34	 add	 esp, 52			; 00000034H
  000e4	33 cd		 xor	 ecx, ebp
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ENDP ; ResetSystem::GC_MessageBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?GC_OpenDialog@ResetSystem@@QAEXPAUOBJECTSTRUCT@@W4T@ResetType@@@Z
_TEXT	SEGMENT
_Type$GSCopy$1$ = -44					; size = 4
_lpRequest$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
_Type$ = 12						; size = 4
?GC_OpenDialog@ResetSystem@@QAEXPAUOBJECTSTRUCT@@W4T@ResetType@@@Z PROC ; ResetSystem::GC_OpenDialog, COMDAT
; _this$ = ecx

; 672  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _lpUser$[ebp]
  00019	8b d9		 mov	 ebx, ecx

; 673  : 	ResetGroup* Group = this->GetResetGroup(lpUser, Type);

  0001b	50		 push	 eax
  0001c	57		 push	 edi
  0001d	89 45 d4	 mov	 DWORD PTR _Type$GSCopy$1$[ebp], eax
  00020	e8 00 00 00 00	 call	 ?GetResetGroup@ResetSystem@@AAEPAUResetGroup@@PAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::GetResetGroup
  00025	8b f0		 mov	 esi, eax

; 674  : 
; 675  : 	if (Group == NULL)

  00027	85 f6		 test	 esi, esi
  00029	75 3a		 jne	 SHORT $LN2@GC_OpenDia

; 676  : 	{
; 677  : 		this->Log->Output("[ResetSystem] [%s] [%s] (OpenDialog) Group for this user not found",

  0002b	8d 77 5d	 lea	 esi, DWORD PTR [edi+93]
  0002e	83 c7 52	 add	 edi, 82			; 00000052H
  00031	56		 push	 esi
  00032	57		 push	 edi
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@HIBGDJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIOpenDia@
  00038	ff 73 2c	 push	 DWORD PTR [ebx+44]
  0003b	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 678  : 			lpUser->AccountID, lpUser->Name);
; 679  : 		LogAddC(2, "[ResetSystem] [%s] [%s] (OpenDialog) Group for this user not found",

  00040	56		 push	 esi
  00041	57		 push	 edi
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@HIBGDJB@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIOpenDia@
  00047	6a 02		 push	 2
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0004f	83 c4 20	 add	 esp, 32			; 00000020H
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 705  : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@GC_OpenDia:

; 680  : 			lpUser->AccountID, lpUser->Name);
; 681  : 		return;
; 682  : 	}
; 683  : 
; 684  : 	PacketResetDialog lpRequest;
; 685  : 
; 686  : 	lpRequest.Head.set((LPBYTE)&lpRequest, 0xFE, 0x04, sizeof(PacketResetDialog));
; 687  : 	lpRequest.Type = (BYTE)Type;

  00065	8b 45 d4	 mov	 eax, DWORD PTR _Type$GSCopy$1$[ebp]

; 689  : 	lpRequest.RewardPoint = Group->RewardList[lpUser->Class].Point * lpRequest.NextReset;

  00068	0f b7 8f 90 00
	00 00		 movzx	 ecx, WORD PTR [edi+144]
  0006f	88 45 dc	 mov	 BYTE PTR _lpRequest$[ebp+4], al
  00072	66 8b 87 20 27
	00 00		 mov	 ax, WORD PTR [edi+10016]
  00079	66 40		 inc	 ax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0007b	c7 45 d8 c1 24
	fe 04		 mov	 DWORD PTR _lpRequest$[ebp], 83764417 ; 04fe24c1H
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 688  : 	lpRequest.NextReset = lpUser->iResetCount + 1;

  00082	66 89 45 de	 mov	 WORD PTR _lpRequest$[ebp+6], ax

; 689  : 	lpRequest.RewardPoint = Group->RewardList[lpUser->Class].Point * lpRequest.NextReset;

  00086	0f b7 d0	 movzx	 edx, ax
  00089	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00090	2b c1		 sub	 eax, ecx
  00092	8b 44 86 30	 mov	 eax, DWORD PTR [esi+eax*4+48]
  00096	0f af c2	 imul	 eax, edx
  00099	89 45 e0	 mov	 DWORD PTR _lpRequest$[ebp+8], eax

; 690  : 	lpRequest.ReqLevel = Group->MinLevel;

  0009c	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0009f	66 89 45 e4	 mov	 WORD PTR _lpRequest$[ebp+12], ax

; 691  : 	lpRequest.ReqMoney = Group->Money * lpRequest.NextReset;

  000a3	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000a6	0f af c2	 imul	 eax, edx
  000a9	89 45 e8	 mov	 DWORD PTR _lpRequest$[ebp+16], eax

; 692  : 	lpRequest.Delay = Group->Delay;

  000ac	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000af	89 45 ec	 mov	 DWORD PTR _lpRequest$[ebp+20], eax

; 693  : 	lpRequest.Credits = Group->Credits;

  000b2	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000b5	89 45 f0	 mov	 DWORD PTR _lpRequest$[ebp+24], eax

; 694  : 
; 695  : 	if (lpUser->m_Credits < lpRequest.Credits || lpRequest.Credits < 1)

  000b8	39 87 38 27 00
	00		 cmp	 DWORD PTR [edi+10040], eax
  000be	72 09		 jb	 SHORT $LN5@GC_OpenDia

; 698  : 	}
; 699  : 	else
; 700  : 	{
; 701  : 		lpRequest.AllowCredits = true;

  000c0	c6 45 f4 01	 mov	 BYTE PTR _lpRequest$[ebp+28], 1
  000c4	83 f8 01	 cmp	 eax, 1
  000c7	73 04		 jae	 SHORT $LN4@GC_OpenDia
$LN5@GC_OpenDia:

; 696  : 	{
; 697  : 		lpRequest.AllowCredits = false;

  000c9	c6 45 f4 00	 mov	 BYTE PTR _lpRequest$[ebp+28], 0
$LN4@GC_OpenDia:

; 702  : 	}
; 703  : 	
; 704  : 	DataSend(lpUser->m_Index, (LPBYTE)&lpRequest, lpRequest.Head.size);

  000cd	6a 24		 push	 36			; 00000024H
  000cf	8d 45 d8	 lea	 eax, DWORD PTR _lpRequest$[ebp]
  000d2	50		 push	 eax
  000d3	ff 37		 push	 DWORD PTR [edi]
  000d5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 705  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 08 00	 ret	 8
?GC_OpenDialog@ResetSystem@@QAEXPAUOBJECTSTRUCT@@W4T@ResetType@@@Z ENDP ; ResetSystem::GC_OpenDialog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?ProcReset@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@EE@Z
_TEXT	SEGMENT
_ResetGroup$1$ = -16					; size = 4
_this$1$ = -12						; size = 4
_Level$ = -8						; size = 2
_Dir$ = -3						; size = 1
_Y$ = -2						; size = 1
_X$ = -1						; size = 1
_lpUser$ = 8						; size = 4
_MapNumber$ = 11					; size = 1
_Type$ = 12						; size = 4
_PayType$ = 16						; size = 1
_ProcWait$ = 20						; size = 1
?ProcReset@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@EE@Z PROC ; ResetSystem::ProcReset, COMDAT
; _this$ = ecx

; 393  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 394  : 	PacketAnswerStart lpAnswer;
; 395  : 	lpAnswer.Head.set((LPBYTE)&lpAnswer, 0xFE, 0x06, sizeof(lpAnswer));
; 396  : 	lpAnswer.Type = (BYTE)Type;
; 397  : 	lpAnswer.PayType = PayType;
; 398  : 	//lpAnswer.WaitProc = lpUser->m_ResetWait;
; 399  : 	lpAnswer.Result = true;
; 400  : 
; 401  : 	ResetGroup* ResetGroup = GetResetGroup(lpUser, Type);

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpUser$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR _Type$[ebp]
  0000f	8b f9		 mov	 edi, ecx
  00011	56		 push	 esi
  00012	89 7d f4	 mov	 DWORD PTR _this$1$[ebp], edi
  00015	e8 00 00 00 00	 call	 ?GetResetGroup@ResetSystem@@AAEPAUResetGroup@@PAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::GetResetGroup
  0001a	8b d8		 mov	 ebx, eax
  0001c	89 5d f0	 mov	 DWORD PTR _ResetGroup$1$[ebp], ebx

; 402  : 
; 403  : 	if (ResetGroup == NULL)

  0001f	85 db		 test	 ebx, ebx
  00021	75 35		 jne	 SHORT $LN17@ProcReset

; 404  : 	{
; 405  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Group for this user not found",

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$1$[ebp]
  00026	8d 7e 5d	 lea	 edi, DWORD PTR [esi+93]
  00029	57		 push	 edi
  0002a	83 c6 52	 add	 esi, 82			; 00000052H
  0002d	56		 push	 esi
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@DDGJLPOE@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  00033	ff 70 2c	 push	 DWORD PTR [eax+44]
  00036	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 406  : 			lpUser->AccountID, lpUser->Name);
; 407  : 		LogAddC(2, "[ResetSystem] [%s] [%s] (ProcReset) Group for this user not found",

  0003b	57		 push	 edi
  0003c	56		 push	 esi
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@DDGJLPOE@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  00042	6a 02		 push	 2
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0004a	83 c4 20	 add	 esp, 32			; 00000020H
$LN90@ProcReset:

; 408  : 			lpUser->AccountID, lpUser->Name);
; 409  : 		//lpAnswer.Result = false;
; 410  : 		//DataSend(lpUser->m_Index, (LPBYTE)&lpAnswer, lpAnswer.Head.size);
; 411  : 		return false;

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	32 c0		 xor	 al, al
  00051	5b		 pop	 ebx

; 669  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 10 00	 ret	 16			; 00000010H
$LN17@ProcReset:

; 412  : 	}
; 413  : 	
; 414  : 	if (!this->CheckRequirements(lpUser, ResetGroup, Type, true, PayType))

  00058	ff 75 10	 push	 DWORD PTR _PayType$[ebp]
  0005b	8b cf		 mov	 ecx, edi
  0005d	6a 01		 push	 1
  0005f	ff 75 0c	 push	 DWORD PTR _Type$[ebp]
  00062	53		 push	 ebx
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?CheckRequirements@ResetSystem@@AAE_NPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_NE@Z ; ResetSystem::CheckRequirements
  00069	84 c0		 test	 al, al
  0006b	74 e0		 je	 SHORT $LN90@ProcReset

; 415  : 	{
; 416  : 		//lpAnswer.Result = false;
; 417  : 		//DataSend(lpUser->m_Index, (LPBYTE)&lpAnswer, lpAnswer.Head.size);
; 418  : 		return false;
; 419  : 	}
; 420  : 
; 421  : 	if (PayType == 0 && lpUser->m_ResetWait == 0)

  0006d	8b 45 10	 mov	 eax, DWORD PTR _PayType$[ebp]
  00070	84 c0		 test	 al, al
  00072	0f 85 05 01 00
	00		 jne	 $LN22@ProcReset
  00078	38 86 24 27 00
	00		 cmp	 BYTE PTR [esi+10020], al
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetTickCount@0
  00083	75 14		 jne	 SHORT $LN85@ProcReset

; 422  : 	{
; 423  : 		lpUser->m_ResetWaitTick = GetTickCount();

  00085	ff d0		 call	 eax
  00087	89 86 28 27 00
	00		 mov	 DWORD PTR [esi+10024], eax
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetTickCount@0

; 424  : 		lpUser->m_ResetWait = 1;

  00092	c6 86 24 27 00
	00 01		 mov	 BYTE PTR [esi+10020], 1
$LN85@ProcReset:

; 425  : 	}
; 426  : 
; 427  : 	if (PayType == 0 && lpUser->m_ResetWait == 1)

  00099	80 be 24 27 00
	00 01		 cmp	 BYTE PTR [esi+10020], 1
  000a0	75 30		 jne	 SHORT $LN23@ProcReset

; 428  : 	{
; 429  : 		DWORD RemainMin = (GetTickCount() - lpUser->m_ResetWaitTick) / 1000 / 60;

  000a2	ff d0		 call	 eax
  000a4	8b c8		 mov	 ecx, eax
  000a6	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  000ab	2b 8e 28 27 00
	00		 sub	 ecx, DWORD PTR [esi+10024]
  000b1	f7 e1		 mul	 ecx
  000b3	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  000b8	c1 ea 06	 shr	 edx, 6
  000bb	f7 e2		 mul	 edx

; 430  : 
; 431  : 		if (RemainMin >= ResetGroup->Delay)

  000bd	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  000c0	c1 ea 05	 shr	 edx, 5
  000c3	3b d0		 cmp	 edx, eax
  000c5	0f 82 90 00 00
	00		 jb	 $LN21@ProcReset

; 432  : 		{
; 433  : 			lpUser->m_ResetWait = 2;

  000cb	c6 86 24 27 00
	00 02		 mov	 BYTE PTR [esi+10020], 2
$LN23@ProcReset:

; 447  : 	}
; 448  : 
; 449  : 	lpUser->m_ResetWaitTick = 0;
; 450  : 	lpUser->m_ResetWait = 0;
; 451  : 
; 452  : 	this->GC_MessageBox(lpUser, "Reset Master", "My regards %s!\nYou get %d reset!", lpUser->Name, lpUser->iResetCount+1);

  000d2	8b 86 20 27 00
	00		 mov	 eax, DWORD PTR [esi+10016]
  000d8	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  000db	40		 inc	 eax
  000dc	c7 86 28 27 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+10024], 0
  000e6	50		 push	 eax
  000e7	51		 push	 ecx
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DCFNDEH@My?5regards?5?$CFs?$CB?6You?5get?5?$CFd?5reset?$CB@
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  000f2	56		 push	 esi
  000f3	57		 push	 edi
  000f4	c6 86 24 27 00
	00 00		 mov	 BYTE PTR [esi+10020], 0
  000fb	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox

; 453  : 
; 454  : 	int InputReset = lpUser->iResetCount;	
; 455  : 
; 456  : 	if (Type == ResetType::Normal)
; 457  : 	{
; 458  : 		InputReset = lpUser->iResetCount;
; 459  : 	}
; 460  : 	else if (Type == ResetType::Grand)
; 461  : 	{
; 462  : 		//InputReset = lpUser->iGrandResetCount;
; 463  : 	}
; 464  : 
; 465  : 	if (InputReset < 1)
; 466  : 	{
; 467  : 		InputReset = 1;
; 468  : 	}
; 469  : 
; 470  : 	if (PayType == 0)

  00100	8b 45 10	 mov	 eax, DWORD PTR _PayType$[ebp]
  00103	83 c4 18	 add	 esp, 24			; 00000018H
  00106	84 c0		 test	 al, al
  00108	0f 85 a3 00 00
	00		 jne	 $LN28@ProcReset

; 471  : 	{
; 472  : 		lpUser->Money -= this->GetResetMoney(lpUser, ResetGroup, Type, true);

  0010e	6a 01		 push	 1
  00110	ff 75 0c	 push	 DWORD PTR _Type$[ebp]
  00113	8b cf		 mov	 ecx, edi
  00115	53		 push	 ebx
  00116	56		 push	 esi
  00117	e8 00 00 00 00	 call	 ?GetResetMoney@ResetSystem@@AAEHPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_N@Z ; ResetSystem::GetResetMoney
  0011c	29 86 cc 00 00
	00		 sub	 DWORD PTR [esi+204], eax

; 473  : 		GCMoneySend(lpUser->m_Index, lpUser->Money);

  00122	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00128	ff 36		 push	 DWORD PTR [esi]
  0012a	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0012f	83 c4 08	 add	 esp, 8

; 474  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Money has been withdrawn, amount: %d", 

  00132	8b cf		 mov	 ecx, edi
  00134	6a 01		 push	 1
  00136	ff 75 0c	 push	 DWORD PTR _Type$[ebp]
  00139	53		 push	 ebx
  0013a	56		 push	 esi
  0013b	e8 00 00 00 00	 call	 ?GetResetMoney@ResetSystem@@AAEHPAUOBJECTSTRUCT@@PAUResetGroup@@W4T@ResetType@@_N@Z ; ResetSystem::GetResetMoney
  00140	50		 push	 eax
  00141	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00144	50		 push	 eax
  00145	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00148	50		 push	 eax
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@CFLHBDGO@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  0014e	ff 77 2c	 push	 DWORD PTR [edi+44]
  00151	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00156	83 c4 14	 add	 esp, 20			; 00000014H
  00159	eb 63		 jmp	 SHORT $LN30@ProcReset
$LN21@ProcReset:

; 434  : 		}
; 435  : 		else
; 436  : 		{
; 437  : 			this->GC_MessageBox(lpUser, "Reset Master", "Please wait %d min.", ResetGroup->Delay - RemainMin);

  0015b	2b c2		 sub	 eax, edx
  0015d	50		 push	 eax
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JGOLOEHN@Please?5wait?5?$CFd?5min?4?$AA@
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  00168	56		 push	 esi
  00169	57		 push	 edi
  0016a	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
  0016f	83 c4 14	 add	 esp, 20			; 00000014H

; 438  : 			return false;

  00172	32 c0		 xor	 al, al
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx

; 669  : }

  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 10 00	 ret	 16			; 00000010H
$LN22@ProcReset:

; 439  : 		}
; 440  : 
; 441  : 	}
; 442  : 
; 443  : 	if (PayType == 1 && lpUser->m_ResetWait == 2)

  0017d	3c 01		 cmp	 al, 1
  0017f	0f 85 4d ff ff
	ff		 jne	 $LN23@ProcReset
  00185	80 be 24 27 00
	00 02		 cmp	 BYTE PTR [esi+10020], 2
  0018c	0f 85 40 ff ff
	ff		 jne	 $LN23@ProcReset

; 444  : 	{
; 445  : 		this->GC_MessageBox(lpUser, "Reset Master", "You have already finished delay");

  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JEOKHFNI@You?5have?5already?5finished?5delay?$AA@
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MCNFFMDL@Reset?5Master?$AA@
  0019c	56		 push	 esi
  0019d	57		 push	 edi
  0019e	e8 00 00 00 00	 call	 ?GC_MessageBox@ResetSystem@@QAAXPAUOBJECTSTRUCT@@PAD1ZZ ; ResetSystem::GC_MessageBox
  001a3	83 c4 10	 add	 esp, 16			; 00000010H

; 446  : 		return false;

  001a6	32 c0		 xor	 al, al
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx

; 669  : }

  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 10 00	 ret	 16			; 00000010H
$LN28@ProcReset:

; 475  : 			lpUser->AccountID, lpUser->Name, this->GetResetMoney(lpUser, ResetGroup, Type, true));
; 476  : 	}
; 477  : 	else if (PayType == 1)

  001b1	3c 01		 cmp	 al, 1
  001b3	75 09		 jne	 SHORT $LN30@ProcReset

; 478  : 	{
; 479  : 		lpUser->m_Credits -= ResetGroup->Credits;;

  001b5	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  001b8	29 86 38 27 00
	00		 sub	 DWORD PTR [esi+10040], eax
$LN30@ProcReset:

; 480  : 	}
; 481  : 	else if (PayType == 2)
; 482  : 	{
; 483  : 
; 484  : 	}
; 485  : 
; 486  : 
; 487  : 	lpUser->Level		= 1;

  001be	b8 01 00 00 00	 mov	 eax, 1

; 488  : 	lpUser->Experience	= 0;

  001c3	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
  001cd	66 89 86 96 00
	00 00		 mov	 WORD PTR [esi+150], ax

; 489  : 
; 490  : 	if (ResetGroup->Cleaning.Stats)

  001d4	80 bb fc 00 00
	00 00		 cmp	 BYTE PTR [ebx+252], 0
  001db	74 6b		 je	 SHORT $LN33@ProcReset

; 491  : 	{
; 492  : 		lpUser->Strength	= DCInfo.DefClass[lpUser->Class].Strength;

  001dd	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  001e4	69 c8 c8 0b 00
	00		 imul	 ecx, eax, 3016
  001ea	0f b7 81 08 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+8]
  001f1	66 89 86 d0 00
	00 00		 mov	 WORD PTR [esi+208], ax

; 493  : 		lpUser->Dexterity	= DCInfo.DefClass[lpUser->Class].Dexterity;

  001f8	0f b7 81 0a 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+10]
  001ff	66 89 86 d2 00
	00 00		 mov	 WORD PTR [esi+210], ax

; 494  : 		lpUser->Energy		= DCInfo.DefClass[lpUser->Class].Energy;

  00206	0f b7 81 0e 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+14]
  0020d	66 89 86 d6 00
	00 00		 mov	 WORD PTR [esi+214], ax

; 495  : 		lpUser->Vitality	= DCInfo.DefClass[lpUser->Class].Vitality;

  00214	0f b7 81 0c 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+12]
  0021b	66 89 86 d4 00
	00 00		 mov	 WORD PTR [esi+212], ax

; 496  : 		lpUser->Leadership	= DCInfo.DefClass[lpUser->Class].Leadership;

  00222	0f b7 81 c8 0b
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[ecx+3016]
  00229	66 89 86 f4 00
	00 00		 mov	 WORD PTR [esi+244], ax

; 497  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Stats has been reseted", 

  00230	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00233	50		 push	 eax
  00234	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00237	50		 push	 eax
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GGGLIEL@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  0023d	ff 77 2c	 push	 DWORD PTR [edi+44]
  00240	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00245	83 c4 10	 add	 esp, 16			; 00000010H
$LN33@ProcReset:

; 498  : 			lpUser->AccountID, lpUser->Name);
; 499  : 	}
; 500  : 
; 501  : 	if (ResetGroup->Cleaning.Points)

  00248	80 bb fd 00 00
	00 00		 cmp	 BYTE PTR [ebx+253], 0
  0024f	74 22		 je	 SHORT $LN34@ProcReset

; 502  : 	{
; 503  : 		lpUser->LevelUpPoint = 0;
; 504  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Points has been reseted", 

  00251	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00254	c7 86 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+152], 0
  0025e	50		 push	 eax
  0025f	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00262	50		 push	 eax
  00263	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ODCDHJJI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  00268	ff 77 2c	 push	 DWORD PTR [edi+44]
  0026b	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00270	83 c4 10	 add	 esp, 16			; 00000010H
$LN34@ProcReset:

; 505  : 			lpUser->AccountID, lpUser->Name);
; 506  : 	}
; 507  : 
; 508  : 	if (ResetGroup->Cleaning.Skills && ResetGroup->Cleaning.MasterSkills )

  00273	8a 83 fe 00 00
	00		 mov	 al, BYTE PTR [ebx+254]
  00279	84 c0		 test	 al, al
  0027b	0f 84 ac 00 00
	00		 je	 $LN38@ProcReset
  00281	80 bb 04 01 00
	00 00		 cmp	 BYTE PTR [ebx+260], 0
  00288	74 3f		 je	 SHORT $LN35@ProcReset

; 509  : 	{
; 510  : 		for (int n = 0; n < MAGIC_SIZE;n++)

  0028a	33 ff		 xor	 edi, edi
  0028c	0f 1f 40 00	 npad	 4
$LL4@ProcReset:

; 511  : 		{
; 512  : 			if (lpUser->Magic[n].IsMagic() == TRUE)

  00290	8b 8e a8 06 00
	00		 mov	 ecx, DWORD PTR [esi+1704]
  00296	03 cf		 add	 ecx, edi
  00298	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0029d	83 f8 01	 cmp	 eax, 1
  002a0	75 0d		 jne	 SHORT $LN2@ProcReset

; 513  : 			{
; 514  : 				lpUser->Magic[n].Clear();

  002a2	8b 8e a8 06 00
	00		 mov	 ecx, DWORD PTR [esi+1704]
  002a8	03 cf		 add	 ecx, edi
  002aa	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear
$LN2@ProcReset:

; 509  : 	{
; 510  : 		for (int n = 0; n < MAGIC_SIZE;n++)

  002af	83 c7 18	 add	 edi, 24			; 00000018H
  002b2	81 ff 10 0e 00
	00		 cmp	 edi, 3600		; 00000e10H
  002b8	7c d6		 jl	 SHORT $LL4@ProcReset

; 515  : 			}
; 516  : 		}
; 517  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) All skills has been reseted", 

  002ba	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  002bd	50		 push	 eax
  002be	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  002c1	50		 push	 eax
  002c2	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HDHNPDP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  002c7	eb 56		 jmp	 SHORT $LN87@ProcReset
$LN35@ProcReset:

; 518  : 			lpUser->AccountID, lpUser->Name);
; 519  : 	}
; 520  : 	else if (ResetGroup->Cleaning.Skills)

  002c9	84 c0		 test	 al, al
  002cb	74 60		 je	 SHORT $LN38@ProcReset

; 521  : 	{
; 522  : 		for (int n = 0; n < MAGIC_SIZE;n++)

  002cd	33 ff		 xor	 edi, edi
  002cf	90		 npad	 1
$LL7@ProcReset:

; 523  : 		{
; 524  : 			if (lpUser->Magic[n].IsMagic() == TRUE && g_MasterSkillSystem.CheckMasterLevelSkill(lpUser->Magic[n].m_Skill) == FALSE)

  002d0	8b 8e a8 06 00
	00		 mov	 ecx, DWORD PTR [esi+1704]
  002d6	03 cf		 add	 ecx, edi
  002d8	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  002dd	83 f8 01	 cmp	 eax, 1
  002e0	75 25		 jne	 SHORT $LN5@ProcReset
  002e2	8b 86 a8 06 00
	00		 mov	 eax, DWORD PTR [esi+1704]
  002e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  002ed	ff 74 07 08	 push	 DWORD PTR [edi+eax+8]
  002f1	e8 00 00 00 00	 call	 ?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
  002f6	85 c0		 test	 eax, eax
  002f8	75 0d		 jne	 SHORT $LN5@ProcReset

; 525  : 			{
; 526  : 				lpUser->Magic[n].Clear();

  002fa	8b 8e a8 06 00
	00		 mov	 ecx, DWORD PTR [esi+1704]
  00300	03 cf		 add	 ecx, edi
  00302	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear
$LN5@ProcReset:

; 521  : 	{
; 522  : 		for (int n = 0; n < MAGIC_SIZE;n++)

  00307	83 c7 18	 add	 edi, 24			; 00000018H
  0030a	81 ff 10 0e 00
	00		 cmp	 edi, 3600		; 00000e10H
  00310	7c be		 jl	 SHORT $LL7@ProcReset

; 527  : 			}
; 528  : 		}
; 529  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Normal skills has been reseted", 

  00312	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00315	50		 push	 eax
  00316	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00319	50		 push	 eax
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@LOMANMPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
$LN87@ProcReset:
  0031f	8b 7d f4	 mov	 edi, DWORD PTR _this$1$[ebp]
  00322	ff 77 2c	 push	 DWORD PTR [edi+44]
  00325	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0032a	83 c4 10	 add	 esp, 16			; 00000010H
$LN38@ProcReset:

; 530  : 			lpUser->AccountID, lpUser->Name);
; 531  : 	}
; 532  : 
; 533  : 	if (ResetGroup->Cleaning.Equipment)

  0032d	80 bb ff 00 00
	00 00		 cmp	 BYTE PTR [ebx+255], 0
  00334	74 65		 je	 SHORT $LN40@ProcReset

; 534  : 	{
; 535  : 		for (int ItemPos = 0; ItemPos < INVETORY_WEAR_SIZE; ItemPos++ )

  00336	33 db		 xor	 ebx, ebx
  00338	33 ff		 xor	 edi, edi
  0033a	66 0f 1f 44 00
	00		 npad	 6
$LL10@ProcReset:

; 536  : 		{
; 537  : 			if (lpUser->pInventory[ItemPos].IsItem() )

  00340	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00346	03 cf		 add	 ecx, edi
  00348	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0034d	85 c0		 test	 eax, eax
  0034f	74 1d		 je	 SHORT $LN8@ProcReset

; 538  : 			{
; 539  : 				gObjInventoryItemSet(lpUser->m_Index, ItemPos, -1);

  00351	68 ff 00 00 00	 push	 255			; 000000ffH
  00356	53		 push	 ebx
  00357	ff 36		 push	 DWORD PTR [esi]
  00359	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 540  : 				lpUser->pInventory[ItemPos].Clear();

  0035e	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00364	83 c4 0c	 add	 esp, 12			; 0000000cH
  00367	03 cf		 add	 ecx, edi
  00369	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
$LN8@ProcReset:

; 534  : 	{
; 535  : 		for (int ItemPos = 0; ItemPos < INVETORY_WEAR_SIZE; ItemPos++ )

  0036e	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00374	43		 inc	 ebx
  00375	81 ff f0 09 00
	00		 cmp	 edi, 2544		; 000009f0H
  0037b	7c c3		 jl	 SHORT $LL10@ProcReset

; 541  : 			}
; 542  : 		}
; 543  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Equipment has been reseted", 

  0037d	8b 7d f4	 mov	 edi, DWORD PTR _this$1$[ebp]
  00380	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00383	50		 push	 eax
  00384	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00387	50		 push	 eax
  00388	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@IPNLPBJN@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  0038d	ff 77 2c	 push	 DWORD PTR [edi+44]
  00390	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00395	8b 5d f0	 mov	 ebx, DWORD PTR _ResetGroup$1$[ebp]
  00398	83 c4 10	 add	 esp, 16			; 00000010H
$LN40@ProcReset:

; 544  : 			lpUser->AccountID, lpUser->Name);
; 545  : 	}
; 546  : 
; 547  : 	if (ResetGroup->Cleaning.Inventory)

  0039b	80 bb 00 01 00
	00 00		 cmp	 BYTE PTR [ebx+256], 0
  003a2	74 67		 je	 SHORT $LN42@ProcReset

; 548  : 	{
; 549  : 		for (int ItemPos = INVETORY_WEAR_SIZE; ItemPos < MAIN_INVENTORY_SIZE; ItemPos++ )

  003a4	bb 0c 00 00 00	 mov	 ebx, 12			; 0000000cH
  003a9	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
  003ae	66 90		 npad	 2
$LL13@ProcReset:

; 550  : 		{
; 551  : 			if (lpUser->pInventory[ItemPos].IsItem() )

  003b0	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  003b6	03 cf		 add	 ecx, edi
  003b8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003bd	85 c0		 test	 eax, eax
  003bf	74 1d		 je	 SHORT $LN11@ProcReset

; 552  : 			{
; 553  : 				gObjInventoryItemSet(lpUser->m_Index, ItemPos, -1);

  003c1	68 ff 00 00 00	 push	 255			; 000000ffH
  003c6	53		 push	 ebx
  003c7	ff 36		 push	 DWORD PTR [esi]
  003c9	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 554  : 				lpUser->pInventory[ItemPos].Clear();

  003ce	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  003d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d7	03 cf		 add	 ecx, edi
  003d9	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
$LN11@ProcReset:

; 548  : 	{
; 549  : 		for (int ItemPos = INVETORY_WEAR_SIZE; ItemPos < MAIN_INVENTORY_SIZE; ItemPos++ )

  003de	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  003e4	43		 inc	 ebx
  003e5	81 ff f0 a8 00
	00		 cmp	 edi, 43248		; 0000a8f0H
  003eb	7c c3		 jl	 SHORT $LL13@ProcReset

; 555  : 			}
; 556  : 		}
; 557  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Inventory has been reseted", 

  003ed	8b 7d f4	 mov	 edi, DWORD PTR _this$1$[ebp]
  003f0	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  003f3	50		 push	 eax
  003f4	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  003f7	50		 push	 eax
  003f8	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@KLDGOEGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  003fd	ff 77 2c	 push	 DWORD PTR [edi+44]
  00400	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00405	8b 5d f0	 mov	 ebx, DWORD PTR _ResetGroup$1$[ebp]
  00408	83 c4 10	 add	 esp, 16			; 00000010H
$LN42@ProcReset:

; 558  : 			lpUser->AccountID, lpUser->Name);
; 559  : 	}
; 560  : 
; 561  : 	if (ResetGroup->Cleaning.Shop)

  0040b	80 bb 01 01 00
	00 00		 cmp	 BYTE PTR [ebx+257], 0
  00412	74 67		 je	 SHORT $LN44@ProcReset

; 562  : 	{
; 563  : 		for (int ItemPos = MAIN_INVENTORY_SIZE; ItemPos < INVENTORY_SIZE; ItemPos++ )

  00414	bb cc 00 00 00	 mov	 ebx, 204		; 000000ccH
  00419	bf f0 a8 00 00	 mov	 edi, 43248		; 0000a8f0H
  0041e	66 90		 npad	 2
$LL16@ProcReset:

; 564  : 		{
; 565  : 			if (lpUser->pInventory[ItemPos].IsItem() )

  00420	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00426	03 cf		 add	 ecx, edi
  00428	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0042d	85 c0		 test	 eax, eax
  0042f	74 1d		 je	 SHORT $LN14@ProcReset

; 566  : 			{
; 567  : 				gObjInventoryItemSet(lpUser->m_Index, ItemPos, -1);

  00431	68 ff 00 00 00	 push	 255			; 000000ffH
  00436	53		 push	 ebx
  00437	ff 36		 push	 DWORD PTR [esi]
  00439	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 568  : 				lpUser->pInventory[ItemPos].Clear();

  0043e	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00444	83 c4 0c	 add	 esp, 12			; 0000000cH
  00447	03 cf		 add	 ecx, edi
  00449	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
$LN14@ProcReset:

; 562  : 	{
; 563  : 		for (int ItemPos = MAIN_INVENTORY_SIZE; ItemPos < INVENTORY_SIZE; ItemPos++ )

  0044e	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00454	43		 inc	 ebx
  00455	81 ff 44 c4 00
	00		 cmp	 edi, 50244		; 0000c444H
  0045b	7c c3		 jl	 SHORT $LL16@ProcReset

; 569  : 			}
; 570  : 		}
; 571  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Shop has been reseted", 

  0045d	8b 7d f4	 mov	 edi, DWORD PTR _this$1$[ebp]
  00460	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00463	50		 push	 eax
  00464	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00467	50		 push	 eax
  00468	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@JNFAEODI@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  0046d	ff 77 2c	 push	 DWORD PTR [edi+44]
  00470	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00475	8b 5d f0	 mov	 ebx, DWORD PTR _ResetGroup$1$[ebp]
  00478	83 c4 10	 add	 esp, 16			; 00000010H
$LN44@ProcReset:

; 572  : 			lpUser->AccountID, lpUser->Name);
; 573  : 	}
; 574  : 
; 575  : 	if (ResetGroup->Cleaning.MasterLevel)

  0047b	80 bb 02 01 00
	00 00		 cmp	 BYTE PTR [ebx+258], 0
  00482	74 38		 je	 SHORT $LN46@ProcReset

; 576  : 	{
; 577  : 		lpUser->MasterLevel = 0;

  00484	33 c0		 xor	 eax, eax

; 578  : 		lpUser->MasterExperience = 0;
; 579  : 		g_MasterExp.SetNextExp(lpUser);

  00486	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  0048b	56		 push	 esi
  0048c	66 89 86 a8 00
	00 00		 mov	 WORD PTR [esi+168], ax
  00493	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax
  00499	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax
  0049f	e8 00 00 00 00	 call	 ?SetNextExp@CMasterExperience@@QAEXPAUOBJECTSTRUCT@@@Z ; CMasterExperience::SetNextExp

; 580  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) MasterLevel has been reseted", 

  004a4	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  004a7	50		 push	 eax
  004a8	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  004ab	50		 push	 eax
  004ac	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CGCLGMFP@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  004b1	ff 77 2c	 push	 DWORD PTR [edi+44]
  004b4	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  004b9	83 c4 10	 add	 esp, 16			; 00000010H
$LN46@ProcReset:

; 581  : 			lpUser->AccountID, lpUser->Name);
; 582  : 	}
; 583  : 	
; 584  : 	if (ResetGroup->Cleaning.MasterPoints)

  004bc	80 bb 03 01 00
	00 00		 cmp	 BYTE PTR [ebx+259], 0
  004c3	74 22		 je	 SHORT $LN47@ProcReset

; 585  : 	{
; 586  : 		lpUser->MasterPoint = 0;
; 587  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) MasterPoints has been reseted", 

  004c5	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  004c8	c7 86 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+192], 0
  004d2	50		 push	 eax
  004d3	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  004d6	50		 push	 eax
  004d7	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@HLOPMGCK@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  004dc	ff 77 2c	 push	 DWORD PTR [edi+44]
  004df	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  004e4	83 c4 10	 add	 esp, 16			; 00000010H
$LN47@ProcReset:

; 588  : 			lpUser->AccountID, lpUser->Name);
; 589  : 	}
; 590  : 
; 591  : 	if (ResetGroup->Cleaning.MarlonQuest)

  004e7	80 bb 05 01 00
	00 00		 cmp	 BYTE PTR [ebx+261], 0
  004ee	74 32		 je	 SHORT $LN48@ProcReset

; 592  : 	{
; 593  : 		g_QuestInfo.ReSetQuestState(lpUser, 2);

  004f0	6a 02		 push	 2
  004f2	56		 push	 esi
  004f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  004f8	e8 00 00 00 00	 call	 ?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::ReSetQuestState

; 594  : 		g_QuestInfo.ReSetQuestState(lpUser, 3);

  004fd	6a 03		 push	 3
  004ff	56		 push	 esi
  00500	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00505	e8 00 00 00 00	 call	 ?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::ReSetQuestState

; 595  : 		this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) MarlonQuest has been reseted", 

  0050a	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0050d	50		 push	 eax
  0050e	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00511	50		 push	 eax
  00512	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@LCDOCNPA@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  00517	ff 77 2c	 push	 DWORD PTR [edi+44]
  0051a	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0051f	83 c4 10	 add	 esp, 16			; 00000010H
$LN48@ProcReset:

; 596  : 			lpUser->AccountID, lpUser->Name);
; 597  : 	}
; 598  : 	
; 599  : 	if (Type == ResetType::Normal)

  00522	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  00525	85 c0		 test	 eax, eax
  00527	75 3b		 jne	 SHORT $LN49@ProcReset

; 600  : 	{
; 601  : 		lpUser->iResetCount++;

  00529	ff 86 20 27 00
	00		 inc	 DWORD PTR [esi+10016]

; 602  : 
; 603  : 		if (ResetGroup->PointMode == 0)

  0052f	8a 43 28	 mov	 al, BYTE PTR [ebx+40]
  00532	8b 96 20 27 00
	00		 mov	 edx, DWORD PTR [esi+10016]
  00538	84 c0		 test	 al, al
  0053a	75 5c		 jne	 SHORT $LN55@ProcReset

; 604  : 		{
; 605  : 			lpUser->LevelUpPoint += ResetGroup->RewardList[lpUser->Class].Point * lpUser->iResetCount;

  0053c	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  00543	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0054a	2b c1		 sub	 eax, ecx
  0054c	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  0054f	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00552	0f af c2	 imul	 eax, edx
  00555	01 86 98 00 00
	00		 add	 DWORD PTR [esi+152], eax

; 606  : 			this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Added %d points", 

  0055b	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0055e	0f af c2	 imul	 eax, edx
  00561	50		 push	 eax
  00562	eb 57		 jmp	 SHORT $LN88@ProcReset
$LN49@ProcReset:

; 607  : 				lpUser->AccountID, lpUser->Name, ResetGroup->RewardList[lpUser->Class].Point * lpUser->iResetCount);
; 608  : 		}
; 609  : 		else if (ResetGroup->PointMode == 1)
; 610  : 		{
; 611  : 			lpUser->LevelUpPoint += ResetGroup->RewardList[lpUser->Class].Point;
; 612  : 			this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Added %d points", 
; 613  : 				lpUser->AccountID, lpUser->Name, ResetGroup->RewardList[lpUser->Class].Point);
; 614  : 		}
; 615  : 	}
; 616  : 	else if (Type == ResetType::Grand)

  00564	83 f8 01	 cmp	 eax, 1
  00567	75 6a		 jne	 SHORT $LN57@ProcReset

; 617  : 	{
; 618  : 		//lpUser->iGrandResetCount++;
; 619  : 		lpUser->iResetCount = 0;

  00569	c7 86 20 27 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+10016], 0

; 620  : 
; 621  : 		if (ResetGroup->PointMode == 0)

  00573	8a 43 28	 mov	 al, BYTE PTR [ebx+40]
  00576	84 c0		 test	 al, al
  00578	75 1e		 jne	 SHORT $LN55@ProcReset

; 622  : 		{
; 623  : 			lpUser->LevelUpPoint += ResetGroup->RewardList[lpUser->Class].Point * (lpUser->iResetCount + 1);

  0057a	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]

; 624  : 			this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Added %d points", 

  00581	6a 00		 push	 0
  00583	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0058a	2b c1		 sub	 eax, ecx
  0058c	8b 44 83 30	 mov	 eax, DWORD PTR [ebx+eax*4+48]
  00590	01 86 98 00 00
	00		 add	 DWORD PTR [esi+152], eax
  00596	eb 23		 jmp	 SHORT $LN88@ProcReset
$LN55@ProcReset:

; 625  : 				lpUser->AccountID, lpUser->Name, ResetGroup->RewardList[lpUser->Class].Point * lpUser->iResetCount);
; 626  : 		}
; 627  : 		else if (ResetGroup->PointMode == 1)

  00598	3c 01		 cmp	 al, 1
  0059a	75 37		 jne	 SHORT $LN57@ProcReset

; 628  : 		{
; 629  : 			lpUser->LevelUpPoint += ResetGroup->RewardList[lpUser->Class].Point;

  0059c	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  005a3	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  005aa	2b c1		 sub	 eax, ecx
  005ac	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  005af	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  005b2	01 86 98 00 00
	00		 add	 DWORD PTR [esi+152], eax

; 630  : 			this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Added %d points", 

  005b8	ff 71 30	 push	 DWORD PTR [ecx+48]
$LN88@ProcReset:
  005bb	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  005be	50		 push	 eax
  005bf	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  005c2	50		 push	 eax
  005c3	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KKKJHHJG@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  005c8	ff 77 2c	 push	 DWORD PTR [edi+44]
  005cb	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  005d0	83 c4 14	 add	 esp, 20			; 00000014H
$LN57@ProcReset:

; 631  : 				lpUser->AccountID, lpUser->Name, ResetGroup->RewardList[lpUser->Class].Point);
; 632  : 		}
; 633  : 	}
; 634  : 
; 635  : 	lpUser->m_GensInfo.iContribution += ResetGroup->RewardList[lpUser->Class].GensP;

  005d3	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  005da	8b ca		 mov	 ecx, edx
  005dc	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  005e3	2b c1		 sub	 eax, ecx
  005e5	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  005e8	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  005eb	01 86 b4 26 00
	00		 add	 DWORD PTR [esi+9908], eax

; 636  : 	lpUser->m_Credits += ResetGroup->RewardList[lpUser->Class].Credits;

  005f1	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  005f4	01 86 38 27 00
	00		 add	 DWORD PTR [esi+10040], eax

; 637  : 
; 638  : 	int Gate = -1;
; 639  : 	BYTE X, Y;
; 640  : 	short Level;
; 641  : 	BYTE MapNumber, Dir;
; 642  : 
; 643  : 	if( lpUser->Class == CLASS_ELF )

  005fa	83 fa 02	 cmp	 edx, 2
  005fd	75 05		 jne	 SHORT $LN58@ProcReset

; 644  : 	{
; 645  : 		Gate = 27;

  005ff	8d 42 19	 lea	 eax, DWORD PTR [edx+25]
  00602	eb 10		 jmp	 SHORT $LN60@ProcReset
$LN58@ProcReset:

; 646  : 	}
; 647  : 	else if( lpUser->Class == CLASS_SUMMONER )

  00604	83 fa 05	 cmp	 edx, 5
  00607	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0060c	b9 0b 01 00 00	 mov	 ecx, 267		; 0000010bH
  00611	0f 44 c1	 cmove	 eax, ecx
$LN60@ProcReset:

; 648  : 	{
; 649  : 		Gate = 267;
; 650  : 	}
; 651  : 	else
; 652  : 	{
; 653  : 		Gate = 17;
; 654  : 	}
; 655  : 
; 656  : 	gGateC.GetGate(Gate, (BYTE&)X, (BYTE&)Y, (BYTE&)MapNumber, (BYTE&)Dir, (short&)Level);

  00614	8d 4d f8	 lea	 ecx, DWORD PTR _Level$[ebp]
  00617	51		 push	 ecx
  00618	8d 4d fd	 lea	 ecx, DWORD PTR _Dir$[ebp]
  0061b	51		 push	 ecx
  0061c	8d 4d 0b	 lea	 ecx, DWORD PTR _MapNumber$[ebp]
  0061f	51		 push	 ecx
  00620	8d 4d fe	 lea	 ecx, DWORD PTR _Y$[ebp]
  00623	51		 push	 ecx
  00624	8d 4d ff	 lea	 ecx, DWORD PTR _X$[ebp]
  00627	51		 push	 ecx
  00628	50		 push	 eax
  00629	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  0062e	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAE000AAF@Z ; CGate::GetGate

; 657  : 
; 658  : 	lpUser->MapNumber	= MapNumber;

  00633	8a 45 0b	 mov	 al, BYTE PTR _MapNumber$[ebp]
  00636	88 86 23 01 00
	00		 mov	 BYTE PTR [esi+291], al

; 659  : 	lpUser->X			= X;

  0063c	8a 45 ff	 mov	 al, BYTE PTR _X$[ebp]
  0063f	88 86 20 01 00
	00		 mov	 BYTE PTR [esi+288], al

; 660  : 	lpUser->Y			= Y;

  00645	8a 45 fe	 mov	 al, BYTE PTR _Y$[ebp]
  00648	88 86 21 01 00
	00		 mov	 BYTE PTR [esi+289], al

; 661  : 	lpUser->Dir			= Dir;

  0064e	8a 45 fd	 mov	 al, BYTE PTR _Dir$[ebp]

; 662  : 
; 663  : 	gObjCloseSet(lpUser->m_Index, 1);

  00651	6a 01		 push	 1
  00653	ff 36		 push	 DWORD PTR [esi]
  00655	88 86 22 01 00
	00		 mov	 BYTE PTR [esi+290], al
  0065b	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 664  : 	
; 665  : 	this->Log->Output("[ResetSystem] [%s] [%s] (ProcReset) Reset has been finished (Reset: %d)", 

  00660	ff b6 20 27 00
	00		 push	 DWORD PTR [esi+10016]
  00666	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00669	83 c6 52	 add	 esi, 82			; 00000052H
  0066c	50		 push	 eax
  0066d	56		 push	 esi
  0066e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PDDMMGJ@?$FLResetSystem?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CIProcRes@
  00673	ff 77 2c	 push	 DWORD PTR [edi+44]
  00676	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0067b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 666  : 		lpUser->AccountID, lpUser->Name, lpUser->iResetCount);
; 667  : 
; 668  : 	return true;

  0067e	b0 01		 mov	 al, 1
  00680	5f		 pop	 edi
  00681	5e		 pop	 esi
  00682	5b		 pop	 ebx

; 669  : }

  00683	8b e5		 mov	 esp, ebp
  00685	5d		 pop	 ebp
  00686	c2 10 00	 ret	 16			; 00000010H
?ProcReset@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@W4T@ResetType@@EE@Z ENDP ; ResetSystem::ProcReset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?ProcDialog@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpUser$ = 8						; size = 4
_lpNpc$ = 12						; size = 4
?ProcDialog@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@0@Z PROC	; ResetSystem::ProcDialog, COMDAT
; _this$ = ecx

; 364  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 365  : 	if( this->m_NormalInfo.m_Enabled )

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _lpNpc$[ebp]
  0000a	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000e	74 44		 je	 SHORT $LN3@ProcDialog

; 366  : 	{
; 367  : 		if(		this->m_NormalInfo.m_NPC.Class == lpNpc->Class
; 368  : 			&&	this->m_NormalInfo.m_NPC.MapNumber == lpNpc->MapNumber
; 369  : 			&&	this->m_NormalInfo.m_NPC.X == lpNpc->X
; 370  : 			&&	this->m_NormalInfo.m_NPC.Y == lpNpc->Y )

  00010	0f b7 97 90 00
	00 00		 movzx	 edx, WORD PTR [edi+144]
  00017	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0001b	3b c2		 cmp	 eax, edx
  0001d	75 35		 jne	 SHORT $LN3@ProcDialog
  0001f	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  00026	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  0002a	75 28		 jne	 SHORT $LN3@ProcDialog
  0002c	8a 46 0a	 mov	 al, BYTE PTR [esi+10]
  0002f	3a 87 20 01 00
	00		 cmp	 al, BYTE PTR [edi+288]
  00035	75 1d		 jne	 SHORT $LN3@ProcDialog
  00037	8a 46 0b	 mov	 al, BYTE PTR [esi+11]
  0003a	3a 87 21 01 00
	00		 cmp	 al, BYTE PTR [edi+289]
  00040	75 12		 jne	 SHORT $LN3@ProcDialog

; 371  : 		{
; 372  : 			this->GC_OpenDialog(lpUser, ResetType::Normal);

  00042	6a 00		 push	 0
  00044	ff 75 08	 push	 DWORD PTR _lpUser$[ebp]
  00047	e8 00 00 00 00	 call	 ?GC_OpenDialog@ResetSystem@@QAEXPAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::GC_OpenDialog
  0004c	5f		 pop	 edi

; 373  : 			return true;

  0004d	b0 01		 mov	 al, 1
  0004f	5e		 pop	 esi

; 390  : }

  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
$LN3@ProcDialog:

; 374  : 		}
; 375  : 	}
; 376  : 
; 377  : 	if( this->m_GrandInfo.m_Enabled )

  00054	80 7e 18 00	 cmp	 BYTE PTR [esi+24], 0
  00058	74 46		 je	 SHORT $LN5@ProcDialog

; 378  : 	{
; 379  : 		if(		this->m_GrandInfo.m_NPC.Class == lpNpc->Class
; 380  : 			&&	this->m_GrandInfo.m_NPC.MapNumber == lpNpc->MapNumber
; 381  : 			&&	this->m_GrandInfo.m_NPC.X == lpNpc->X
; 382  : 			&&	this->m_GrandInfo.m_NPC.Y == lpNpc->Y )

  0005a	0f b7 8f 90 00
	00 00		 movzx	 ecx, WORD PTR [edi+144]
  00061	0f bf 46 1a	 movsx	 eax, WORD PTR [esi+26]
  00065	3b c1		 cmp	 eax, ecx
  00067	75 37		 jne	 SHORT $LN5@ProcDialog
  00069	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  00070	66 39 46 1c	 cmp	 WORD PTR [esi+28], ax
  00074	75 2a		 jne	 SHORT $LN5@ProcDialog
  00076	8a 46 1e	 mov	 al, BYTE PTR [esi+30]
  00079	3a 87 20 01 00
	00		 cmp	 al, BYTE PTR [edi+288]
  0007f	75 1f		 jne	 SHORT $LN5@ProcDialog
  00081	8a 46 1f	 mov	 al, BYTE PTR [esi+31]
  00084	3a 87 21 01 00
	00		 cmp	 al, BYTE PTR [edi+289]
  0008a	75 14		 jne	 SHORT $LN5@ProcDialog

; 383  : 		{
; 384  : 			this->GC_OpenDialog(lpUser, ResetType::Grand);

  0008c	6a 01		 push	 1
  0008e	ff 75 08	 push	 DWORD PTR _lpUser$[ebp]
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ?GC_OpenDialog@ResetSystem@@QAEXPAUOBJECTSTRUCT@@W4T@ResetType@@@Z ; ResetSystem::GC_OpenDialog
  00098	5f		 pop	 edi

; 385  : 			return true;

  00099	b0 01		 mov	 al, 1
  0009b	5e		 pop	 esi

; 390  : }

  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
$LN5@ProcDialog:
  000a0	5f		 pop	 edi

; 386  : 		}
; 387  : 	}
; 388  : 
; 389  : 	return false;

  000a1	32 c0		 xor	 al, al
  000a3	5e		 pop	 esi

; 390  : }

  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
?ProcDialog@ResetSystem@@QAE_NPAUOBJECTSTRUCT@@0@Z ENDP	; ResetSystem::ProcDialog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?Read@ResetSystem@@QAEXPAD@Z
_TEXT	SEGMENT
_Result$ = -888						; size = 12
$T2 = -876						; size = 4
$T3 = -872						; size = 4
$T4 = -872						; size = 4
$T5 = -868						; size = 4
$T6 = -868						; size = 4
$T7 = -864						; size = 4
$T8 = -864						; size = 4
$T9 = -860						; size = 4
$T10 = -860						; size = 4
$T11 = -856						; size = 4
$T12 = -856						; size = 4
$T13 = -852						; size = 4
$T14 = -852						; size = 4
$T15 = -848						; size = 4
$T16 = -848						; size = 4
$T17 = -844						; size = 4
$T18 = -844						; size = 4
$T19 = -840						; size = 4
$T20 = -840						; size = 4
$T21 = -836						; size = 4
$T22 = -836						; size = 4
$T23 = -832						; size = 4
$T24 = -832						; size = 4
$T25 = -828						; size = 4
$T26 = -828						; size = 4
$T27 = -824						; size = 4
$T28 = -824						; size = 4
$T29 = -820						; size = 4
$T30 = -820						; size = 4
$T31 = -816						; size = 4
$T32 = -816						; size = 4
$T33 = -812						; size = 4
$T34 = -812						; size = 4
$T35 = -808						; size = 4
$T36 = -808						; size = 4
$T37 = -804						; size = 4
$T38 = -804						; size = 4
$T39 = -800						; size = 4
$T40 = -800						; size = 4
$T41 = -796						; size = 4
$T42 = -796						; size = 4
$T43 = -792						; size = 4
$T44 = -792						; size = 4
$T45 = -788						; size = 4
$T46 = -788						; size = 4
_SubNode$ = -784					; size = 4
$T47 = -780						; size = 4
$T48 = -780						; size = 4
$T49 = -776						; size = 4
$T50 = -776						; size = 4
$T51 = -772						; size = 4
$T52 = -772						; size = 4
$T53 = -768						; size = 4
$T54 = -768						; size = 4
$T55 = -764						; size = 4
$T56 = -764						; size = 4
$T57 = -760						; size = 4
$T58 = -760						; size = 4
$T59 = -756						; size = 4
$T60 = -756						; size = 4
$T61 = -752						; size = 4
$T62 = -752						; size = 4
$T63 = -748						; size = 4
$T64 = -748						; size = 4
$T65 = -744						; size = 4
$T66 = -744						; size = 4
$T67 = -740						; size = 4
$T68 = -740						; size = 4
$T69 = -736						; size = 4
$T70 = -736						; size = 4
$T71 = -732						; size = 4
$T72 = -732						; size = 4
$T73 = -728						; size = 4
$T74 = -728						; size = 4
$T75 = -724						; size = 4
$T76 = -724						; size = 4
$T77 = -720						; size = 4
$T78 = -720						; size = 4
$T79 = -716						; size = 4
$T80 = -716						; size = 4
$T81 = -712						; size = 4
$T82 = -712						; size = 4
$T83 = -708						; size = 4
$T84 = -708						; size = 4
$T85 = -704						; size = 4
$T86 = -704						; size = 4
$T87 = -700						; size = 4
$T88 = -700						; size = 4
$T89 = -696						; size = 4
$T90 = -696						; size = 4
$T91 = -692						; size = 4
$T92 = -692						; size = 4
$T93 = -688						; size = 4
$T94 = -688						; size = 4
$T95 = -684						; size = 4
$T96 = -684						; size = 4
$T97 = -680						; size = 4
$T98 = -680						; size = 4
$T99 = -676						; size = 4
$T100 = -676						; size = 4
$T101 = -672						; size = 4
$T102 = -672						; size = 4
$T103 = -668						; size = 4
$T104 = -668						; size = 4
$T105 = -664						; size = 4
$T106 = -664						; size = 4
$T107 = -660						; size = 4
$T108 = -660						; size = 4
$T109 = -656						; size = 4
$T110 = -656						; size = 4
$T111 = -652						; size = 4
$T112 = -652						; size = 4
$T113 = -648						; size = 4
$T114 = -648						; size = 4
$T115 = -644						; size = 4
$T116 = -644						; size = 4
$T117 = -640						; size = 4
$T118 = -640						; size = 4
$T119 = -636						; size = 4
$T120 = -636						; size = 4
$T121 = -632						; size = 4
$T122 = -632						; size = 4
$T123 = -628						; size = 4
$T124 = -628						; size = 4
$T125 = -624						; size = 4
$T126 = -624						; size = 4
$T127 = -620						; size = 4
$T128 = -620						; size = 4
$T129 = -616						; size = 4
$T130 = -616						; size = 4
$T131 = -612						; size = 4
$T132 = -612						; size = 4
$T133 = -608						; size = 4
$T134 = -608						; size = 4
$T135 = -604						; size = 4
$T136 = -604						; size = 4
$T137 = -600						; size = 4
$T138 = -600						; size = 4
$T139 = -596						; size = 4
$T140 = -596						; size = 4
$T141 = -592						; size = 4
$T142 = -592						; size = 4
$T143 = -588						; size = 4
$T144 = -588						; size = 4
$T145 = -584						; size = 4
$T146 = -584						; size = 4
$T147 = -584						; size = 4
$T148 = -580						; size = 4
$T149 = -580						; size = 4
$T150 = -580						; size = 4
$T151 = -576						; size = 4
$T152 = -576						; size = 4
$T153 = -576						; size = 4
$T154 = -572						; size = 4
$T155 = -572						; size = 4
$T156 = -572						; size = 4
$T157 = -568						; size = 4
$T158 = -568						; size = 4
$T159 = -568						; size = 4
__Ptr$ = -564						; size = 4
__Ptr$ = -564						; size = 4
$T160 = -564						; size = 4
$T161 = -560						; size = 4
$T162 = -560						; size = 4
$T163 = -560						; size = 4
_ResetSystem$ = -556					; size = 4
__Ptr$ = -552						; size = 4
$T164 = -552						; size = 4
$T165 = -552						; size = 4
$T166 = -552						; size = 4
_GroupList$ = -548					; size = 4
_this$GSCopy$1$ = -544					; size = 4
$T167 = -540						; size = 4
$T168 = -540						; size = 4
$T169 = -540						; size = 4
$T170 = -540						; size = 4
$T171 = -540						; size = 4
$T172 = -540						; size = 4
$T173 = -540						; size = 4
$T174 = -540						; size = 4
$T175 = -536						; size = 4
$T176 = -536						; size = 4
$T177 = -536						; size = 4
$T178 = -536						; size = 4
$T179 = -536						; size = 4
$T180 = -536						; size = 4
$T181 = -536						; size = 4
$T182 = -536						; size = 4
$T183 = -536						; size = 4
$T184 = -536						; size = 4
_GroupSub$ = -532					; size = 4
__Idx$1$ = -528						; size = 4
__Idx$1$ = -528						; size = 4
$T185 = -528						; size = 4
__Ptr$ = -528						; size = 4
$T186 = -528						; size = 4
$T187 = -528						; size = 4
$T188 = -528						; size = 4
$T189 = -528						; size = 4
$T190 = -528						; size = 4
$T191 = -528						; size = 4
_Category$ = -524					; size = 4
_RewardNode$ = -520					; size = 4
_ItemNode$ = -516					; size = 4
_Node$ = -512						; size = 4
_Document$ = -508					; size = 200
_NewGroup$192 = -308					; size = 268
_NewGroup$193 = -308					; size = 268
_NewItem$194 = -40					; size = 24
_NewItem$195 = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_File$ = 8						; size = 4
?Read@ResetSystem@@QAEXPAD@Z PROC			; ResetSystem::Read, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Read@ResetSystem@@QAEXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 6c 03 00
	00		 sub	 esp, 876		; 0000036cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00036	8b 75 08	 mov	 esi, DWORD PTR _File$[ebp]

; 45   : 	xml_document Document;

  00039	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  0003f	e8 00 00 00 00	 call	 ??0xml_document@pugi@@QAE@XZ ; pugi::xml_document::xml_document

; 46   : 	xml_parse_result Result = Document.load_file(File);

  00044	6a 00		 push	 0
  00046	6a 74		 push	 116			; 00000074H
  00048	56		 push	 esi
  00049	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _Result$[ebp]
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	50		 push	 eax
  00057	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  0005d	e8 00 00 00 00	 call	 ?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z ; pugi::xml_document::load_file

; 47   : 
; 48   : 	if (Result.status != status_ok)

  00062	83 bd 88 fc ff
	ff 00		 cmp	 DWORD PTR _Result$[ebp], 0
  00069	74 13		 je	 SHORT $LN20@Read

; 49   : 	{
; 50   : 		MsgBox("[ResetSystem] File %s not found!", File);

  0006b	56		 push	 esi
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KHAPEMJG@?$FLResetSystem?$FN?5File?5?$CFs?5not?5found?$CB@
  00071	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00076	83 c4 08	 add	 esp, 8
  00079	e9 8f 1a 00 00	 jmp	 $LN31@Read
$LN20@Read:

; 51   : 		return;
; 52   : 	}
; 53   : 
; 54   : 	xml_node ResetSystem = Document.child("resetsystem");

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HLIFFONB@resetsystem?$AA@
  00083	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _ResetSystem$[ebp]
  00089	50		 push	 eax
  0008a	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00090	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 55   : 	xml_node Node, SubNode, Category, GroupList, GroupSub, RewardNode, ItemNode;

  00095	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0009b	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node
  000a0	8d 8d f0 fc ff
	ff		 lea	 ecx, DWORD PTR _SubNode$[ebp]
  000a6	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node
  000ab	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  000b1	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node
  000b6	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _GroupList$[ebp]
  000bc	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node
  000c1	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _GroupSub$[ebp]
  000c7	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node
  000cc	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  000d2	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node
  000d7	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  000dd	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node

; 56   : 
; 57   : 	int ClassCounter = 0;
; 58   : 
; 59   : 	Category = ResetSystem.child("normal");

  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_06IKLLLDHL@normal?$AA@
  000e7	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T191[ebp]
  000ed	50		 push	 eax
  000ee	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _ResetSystem$[ebp]
  000f4	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 60   : 
; 61   : 	this->m_NormalInfo.m_Enabled = Category.child("enabled").text().as_int(0);

  000f9	6a 00		 push	 0
  000fb	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _Category$[ebp], eax
  00109	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T190[ebp]
  0010f	50		 push	 eax
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_07MHHIKOPA@enabled?$AA@
  00115	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T184[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00121	8b c8		 mov	 ecx, eax
  00123	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00128	8b c8		 mov	 ecx, eax
  0012a	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  0012f	85 c0		 test	 eax, eax

; 62   : 
; 63   : 	this->m_NormalInfo.m_NPC.Class				= Category.child("npc").attribute("id").as_int(0);

  00131	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00137	6a 00		 push	 0
  00139	0f 95 c0	 setne	 al
  0013c	88 43 04	 mov	 BYTE PTR [ebx+4], al
  0013f	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T183[ebp]
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  0014a	50		 push	 eax
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  00150	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T189[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0015c	8b c8		 mov	 ecx, eax
  0015e	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00163	8b c8		 mov	 ecx, eax
  00165	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 64   : 	this->m_NormalInfo.m_NPC.MapNumber			= Category.child("npc").attribute("map").as_int(0);

  0016a	6a 00		 push	 0
  0016c	66 89 43 06	 mov	 WORD PTR [ebx+6], ax
  00170	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_03HBNNNHNM@map?$AA@
  0017b	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T182[ebp]
  00181	50		 push	 eax
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  00187	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T188[ebp]
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00193	8b c8		 mov	 ecx, eax
  00195	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0019a	8b c8		 mov	 ecx, eax
  0019c	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 65   : 	this->m_NormalInfo.m_NPC.X					= Category.child("npc").attribute("x").as_int(0);

  001a1	6a 00		 push	 0
  001a3	66 89 43 08	 mov	 WORD PTR [ebx+8], ax
  001a7	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_01FJMABOPO@x?$AA@
  001b2	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T181[ebp]
  001b8	50		 push	 eax
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  001be	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T187[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  001ca	8b c8		 mov	 ecx, eax
  001cc	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001d1	8b c8		 mov	 ecx, eax
  001d3	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 66   : 	this->m_NormalInfo.m_NPC.Y					= Category.child("npc").attribute("y").as_int(0);

  001d8	6a 00		 push	 0
  001da	88 43 0a	 mov	 BYTE PTR [ebx+10], al
  001dd	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  001e3	68 00 00 00 00	 push	 OFFSET ??_C@_01EANLCPLP@y?$AA@
  001e8	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T180[ebp]
  001ee	50		 push	 eax
  001ef	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  001f4	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T186[ebp]
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00200	8b c8		 mov	 ecx, eax
  00202	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00207	8b c8		 mov	 ecx, eax
  00209	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  0020e	88 43 0b	 mov	 BYTE PTR [ebx+11], al

; 67   : 
; 68   : 	GroupList = Category.child("grouplist");

  00211	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_09EKKKGLLH@grouplist?$AA@
  0021c	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T179[ebp]
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 70   : 	for (Node = GroupList.child("group"); Node; Node = Node.next_sibling())

  00228	68 00 00 00 00	 push	 OFFSET ??_C@_05MGJOOGAJ@group?$AA@
  0022d	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _GroupList$[ebp]
  00233	8b 00		 mov	 eax, DWORD PTR [eax]
  00235	89 85 dc fd ff
	ff		 mov	 DWORD PTR _GroupList$[ebp], eax
  0023b	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T178[ebp]
  00241	50		 push	 eax
  00242	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00247	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0024d	8b 00		 mov	 eax, DWORD PTR [eax]
  0024f	89 85 00 fe ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  00255	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  0025a	85 c0		 test	 eax, eax
  0025c	0f 84 2d 0b 00
	00		 je	 $LN1038@Read
  00262	8d 7b 0c	 lea	 edi, DWORD PTR [ebx+12]
$LL4@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00265	33 f6		 xor	 esi, esi
  00267	89 75 bc	 mov	 DWORD PTR _NewGroup$193[ebp+240], esi

; 481  : 		_Mylast = pointer();

  0026a	89 75 c0	 mov	 DWORD PTR _NewGroup$193[ebp+244], esi

; 482  : 		_Myend = pointer();

  0026d	89 75 c4	 mov	 DWORD PTR _NewGroup$193[ebp+248], esi
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 74   : 		NewGroup.MinLevel = Node.attribute("minlevel").as_int(0);

  00270	56		 push	 esi
  00271	68 00 00 00 00	 push	 OFFSET ??_C@_08EHBDOELG@minlevel?$AA@
  00276	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T177[ebp]
  0027c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00280	50		 push	 eax
  00281	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00287	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0028c	8b c8		 mov	 ecx, eax
  0028e	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 75   : 		NewGroup.MaxLevel = Node.attribute("maxlevel").as_int(0);

  00293	56		 push	 esi
  00294	66 89 85 cc fe
	ff ff		 mov	 WORD PTR _NewGroup$193[ebp], ax
  0029b	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002a1	68 00 00 00 00	 push	 OFFSET ??_C@_08JAPIFGPH@maxlevel?$AA@
  002a6	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR $T160[ebp]
  002ac	50		 push	 eax
  002ad	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  002b2	8b c8		 mov	 ecx, eax
  002b4	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 76   : 		NewGroup.MinReset = Node.attribute("minreset").as_int(0);

  002b9	56		 push	 esi
  002ba	66 89 85 ce fe
	ff ff		 mov	 WORD PTR _NewGroup$193[ebp+2], ax
  002c1	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002c7	68 00 00 00 00	 push	 OFFSET ??_C@_08MLAKOPDG@minreset?$AA@
  002cc	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR $T92[ebp]
  002d2	50		 push	 eax
  002d3	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  002d8	8b c8		 mov	 ecx, eax
  002da	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 77   : 		NewGroup.MaxReset = Node.attribute("maxreset").as_int(0);

  002df	56		 push	 esi
  002e0	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+4], eax
  002e6	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_08BMOBFNHH@maxreset?$AA@
  002f1	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  002f7	50		 push	 eax
  002f8	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  002fd	8b c8		 mov	 ecx, eax
  002ff	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 78   : 		NewGroup.Money = Node.attribute("money").as_int(0);

  00304	56		 push	 esi
  00305	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+8], eax
  0030b	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00311	68 00 00 00 00	 push	 OFFSET ??_C@_05IKCNOJAA@money?$AA@
  00316	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  0031c	50		 push	 eax
  0031d	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00322	8b c8		 mov	 ecx, eax
  00324	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 79   : 		NewGroup.WCoinC = Node.attribute("wcoinc").as_int(0);

  00329	56		 push	 esi
  0032a	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+12], eax
  00330	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00336	68 00 00 00 00	 push	 OFFSET ??_C@_06JEOJDFIL@wcoinc?$AA@
  0033b	8d 85 b4 fc ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00347	8b c8		 mov	 ecx, eax
  00349	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 80   : 		NewGroup.WCoinP = Node.attribute("wcoinp").as_int(0);

  0034e	56		 push	 esi
  0034f	89 85 dc fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+16], eax
  00355	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0035b	68 00 00 00 00	 push	 OFFSET ??_C@_06PFAGHEBJ@wcoinp?$AA@
  00360	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00366	50		 push	 eax
  00367	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0036c	8b c8		 mov	 ecx, eax
  0036e	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 81   : 		NewGroup.WCoinG = Node.attribute("wcoing").as_int(0);

  00373	56		 push	 esi
  00374	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+20], eax
  0037a	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00380	68 00 00 00 00	 push	 OFFSET ??_C@_06PAIFPAIP@wcoing?$AA@
  00385	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0038b	50		 push	 eax
  0038c	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00391	8b c8		 mov	 ecx, eax
  00393	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 82   : 		NewGroup.GensP = Node.attribute("gensp").as_int(0);

  00398	56		 push	 esi
  00399	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+24], eax
  0039f	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  003a5	68 00 00 00 00	 push	 OFFSET ??_C@_05KIGPLGEM@gensp?$AA@
  003aa	50		 push	 eax
  003ab	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  003b1	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  003b6	8b c8		 mov	 ecx, eax
  003b8	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 83   : 		NewGroup.Credits = Node.attribute("credits").as_int(0);

  003bd	56		 push	 esi
  003be	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+28], eax
  003c4	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  003ca	68 00 00 00 00	 push	 OFFSET ??_C@_07JKABFLJI@credits?$AA@
  003cf	8d 85 a4 fc ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  003d5	50		 push	 eax
  003d6	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  003db	8b c8		 mov	 ecx, eax
  003dd	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 84   : 		NewGroup.Delay = Node.attribute("delay").as_int(0);

  003e2	56		 push	 esi
  003e3	89 85 ec fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+32], eax
  003e9	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  003ef	68 00 00 00 00	 push	 OFFSET ??_C@_05EKJCMADO@delay?$AA@
  003f4	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00400	8b c8		 mov	 ecx, eax
  00402	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 85   : 
; 86   : 	//	for (SubNode = Node.child("group"); SubNode; SubNode = SubNode.next_sibling())
; 87   : //		{
; 88   : 			NewGroup.Cleaning.Stats			= Node.child("cleaning").child("stats").text().as_int(0);

  00407	56		 push	 esi
  00408	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _NewGroup$193[ebp+36], eax
  0040e	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00414	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0041a	50		 push	 eax
  0041b	68 00 00 00 00	 push	 OFFSET ??_C@_05BLKJBNOD@stats?$AA@
  00420	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR $T144[ebp]
  00426	50		 push	 eax
  00427	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  0042c	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR $T142[ebp]
  00432	50		 push	 eax
  00433	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00438	8b c8		 mov	 ecx, eax
  0043a	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0043f	8b c8		 mov	 ecx, eax
  00441	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00446	8b c8		 mov	 ecx, eax
  00448	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  0044d	85 c0		 test	 eax, eax

; 89   : 			NewGroup.Cleaning.Points		= Node.child("cleaning").child("points").text().as_int(0);

  0044f	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00455	56		 push	 esi
  00456	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR $T140[ebp]
  0045c	0f 95 45 c8	 setne	 BYTE PTR _NewGroup$193[ebp+252]
  00460	50		 push	 eax
  00461	68 00 00 00 00	 push	 OFFSET ??_C@_06GPGIDCJA@points?$AA@
  00466	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR $T138[ebp]
  0046c	50		 push	 eax
  0046d	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  00472	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR $T136[ebp]
  00478	50		 push	 eax
  00479	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0047e	8b c8		 mov	 ecx, eax
  00480	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00485	8b c8		 mov	 ecx, eax
  00487	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0048c	8b c8		 mov	 ecx, eax
  0048e	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  00493	85 c0		 test	 eax, eax

; 90   : 			NewGroup.Cleaning.Skills		= Node.child("cleaning").child("skills").text().as_int(0);

  00495	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0049b	56		 push	 esi
  0049c	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR $T134[ebp]
  004a2	0f 95 45 c9	 setne	 BYTE PTR _NewGroup$193[ebp+253]
  004a6	50		 push	 eax
  004a7	68 00 00 00 00	 push	 OFFSET ??_C@_06HNCNFAFI@skills?$AA@
  004ac	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR $T132[ebp]
  004b2	50		 push	 eax
  004b3	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  004b8	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR $T130[ebp]
  004be	50		 push	 eax
  004bf	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  004c4	8b c8		 mov	 ecx, eax
  004c6	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  004cb	8b c8		 mov	 ecx, eax
  004cd	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  004d2	8b c8		 mov	 ecx, eax
  004d4	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  004d9	85 c0		 test	 eax, eax
  004db	0f 95 45 ca	 setne	 BYTE PTR _NewGroup$193[ebp+254]

; 91   : 			NewGroup.Cleaning.Equipment		= Node.child("cleaning").child("equipment").text().as_int(0);

  004df	56		 push	 esi
  004e0	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR $T128[ebp]
  004e6	50		 push	 eax
  004e7	68 00 00 00 00	 push	 OFFSET ??_C@_09FJJPPKDN@equipment?$AA@
  004ec	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR $T126[ebp]
  004f2	50		 push	 eax
  004f3	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  004f8	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR $T124[ebp]
  004fe	50		 push	 eax
  004ff	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00505	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0050a	8b c8		 mov	 ecx, eax
  0050c	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00511	8b c8		 mov	 ecx, eax
  00513	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00518	8b c8		 mov	 ecx, eax
  0051a	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  0051f	85 c0		 test	 eax, eax

; 92   : 			NewGroup.Cleaning.Inventory		= Node.child("cleaning").child("inventory").text().as_int(0);

  00521	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00527	56		 push	 esi
  00528	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR $T122[ebp]
  0052e	0f 95 45 cb	 setne	 BYTE PTR _NewGroup$193[ebp+255]
  00532	50		 push	 eax
  00533	68 00 00 00 00	 push	 OFFSET ??_C@_09OCPGKIKB@inventory?$AA@
  00538	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR $T120[ebp]
  0053e	50		 push	 eax
  0053f	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  00544	8d 85 80 fd ff
	ff		 lea	 eax, DWORD PTR $T118[ebp]
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00550	8b c8		 mov	 ecx, eax
  00552	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00557	8b c8		 mov	 ecx, eax
  00559	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0055e	8b c8		 mov	 ecx, eax
  00560	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  00565	85 c0		 test	 eax, eax

; 93   : 			NewGroup.Cleaning.Shop			= Node.child("cleaning").child("shop").text().as_int(0);

  00567	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0056d	56		 push	 esi
  0056e	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR $T116[ebp]
  00574	0f 95 45 cc	 setne	 BYTE PTR _NewGroup$193[ebp+256]
  00578	50		 push	 eax
  00579	68 00 00 00 00	 push	 OFFSET ??_C@_04BFIJLIPK@shop?$AA@
  0057e	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR $T114[ebp]
  00584	50		 push	 eax
  00585	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  0058a	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR $T112[ebp]
  00590	50		 push	 eax
  00591	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00596	8b c8		 mov	 ecx, eax
  00598	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0059d	8b c8		 mov	 ecx, eax
  0059f	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  005a4	8b c8		 mov	 ecx, eax
  005a6	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  005ab	85 c0		 test	 eax, eax

; 94   : 			NewGroup.Cleaning.MasterLevel	= Node.child("cleaning").child("masterlevel").text().as_int(0);

  005ad	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  005b3	56		 push	 esi
  005b4	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR $T110[ebp]
  005ba	0f 95 45 cd	 setne	 BYTE PTR _NewGroup$193[ebp+257]
  005be	50		 push	 eax
  005bf	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BHKEDLCN@masterlevel?$AA@
  005c4	8d 85 6c fd ff
	ff		 lea	 eax, DWORD PTR $T108[ebp]
  005ca	50		 push	 eax
  005cb	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  005d0	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR $T106[ebp]
  005d6	50		 push	 eax
  005d7	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  005dc	8b c8		 mov	 ecx, eax
  005de	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  005e3	8b c8		 mov	 ecx, eax
  005e5	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  005ea	8b c8		 mov	 ecx, eax
  005ec	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  005f1	85 c0		 test	 eax, eax

; 95   : 			NewGroup.Cleaning.MasterPoints	= Node.child("cleaning").child("masterpoints").text().as_int(0);

  005f3	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR $T104[ebp]
  005f9	56		 push	 esi
  005fa	50		 push	 eax
  005fb	0f 95 45 ce	 setne	 BYTE PTR _NewGroup$193[ebp+258]
  005ff	8d 85 60 fd ff
	ff		 lea	 eax, DWORD PTR $T102[ebp]
  00605	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GHLLHCDN@masterpoints?$AA@
  0060a	50		 push	 eax
  0060b	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  00610	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR $T100[ebp]
  00616	50		 push	 eax
  00617	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0061d	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00622	8b c8		 mov	 ecx, eax
  00624	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00629	8b c8		 mov	 ecx, eax
  0062b	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00630	8b c8		 mov	 ecx, eax
  00632	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  00637	85 c0		 test	 eax, eax

; 96   : 			NewGroup.Cleaning.MasterSkills	= Node.child("cleaning").child("masterskills").text().as_int(0);

  00639	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0063f	56		 push	 esi
  00640	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR $T98[ebp]
  00646	0f 95 45 cf	 setne	 BYTE PTR _NewGroup$193[ebp+259]
  0064a	50		 push	 eax
  0064b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HFPOBAPF@masterskills?$AA@
  00650	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR $T96[ebp]
  00656	50		 push	 eax
  00657	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  0065c	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T94[ebp]
  00662	50		 push	 eax
  00663	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00668	8b c8		 mov	 ecx, eax
  0066a	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0066f	8b c8		 mov	 ecx, eax
  00671	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00676	8b c8		 mov	 ecx, eax
  00678	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  0067d	85 c0		 test	 eax, eax

; 97   : 			NewGroup.Cleaning.MarlonQuest	= Node.child("cleaning").child("marlonquest").text().as_int(0);

  0067f	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00685	56		 push	 esi
  00686	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  0068c	0f 95 45 d0	 setne	 BYTE PTR _NewGroup$193[ebp+260]
  00690	50		 push	 eax
  00691	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJHEGDCF@marlonquest?$AA@
  00696	8d 85 48 fd ff
	ff		 lea	 eax, DWORD PTR $T90[ebp]
  0069c	50		 push	 eax
  0069d	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  006a2	8d 85 44 fd ff
	ff		 lea	 eax, DWORD PTR $T88[ebp]
  006a8	50		 push	 eax
  006a9	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  006ae	8b c8		 mov	 ecx, eax
  006b0	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  006b5	8b c8		 mov	 ecx, eax
  006b7	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  006bc	8b c8		 mov	 ecx, eax
  006be	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  006c3	85 c0		 test	 eax, eax

; 98   : 
; 99   : 			NewGroup.Checks.Equipment		= Node.child("checks").child("equipment").text().as_int(0);

  006c5	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  006cb	56		 push	 esi
  006cc	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR $T86[ebp]
  006d2	0f 95 45 d1	 setne	 BYTE PTR _NewGroup$193[ebp+261]
  006d6	50		 push	 eax
  006d7	68 00 00 00 00	 push	 OFFSET ??_C@_09FJJPPKDN@equipment?$AA@
  006dc	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR $T84[ebp]
  006e2	50		 push	 eax
  006e3	68 00 00 00 00	 push	 OFFSET ??_C@_06ELLFFOK@checks?$AA@
  006e8	8d 85 38 fd ff
	ff		 lea	 eax, DWORD PTR $T82[ebp]
  006ee	50		 push	 eax
  006ef	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  006f4	8b c8		 mov	 ecx, eax
  006f6	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  006fb	8b c8		 mov	 ecx, eax
  006fd	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00702	8b c8		 mov	 ecx, eax
  00704	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  00709	85 c0		 test	 eax, eax

; 100  : 			NewGroup.Checks.Inventory		= Node.child("checks").child("inventory").text().as_int(0);

  0070b	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00711	56		 push	 esi
  00712	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR $T80[ebp]
  00718	0f 95 45 d2	 setne	 BYTE PTR _NewGroup$193[ebp+262]
  0071c	50		 push	 eax
  0071d	68 00 00 00 00	 push	 OFFSET ??_C@_09OCPGKIKB@inventory?$AA@
  00722	8d 85 30 fd ff
	ff		 lea	 eax, DWORD PTR $T78[ebp]
  00728	50		 push	 eax
  00729	68 00 00 00 00	 push	 OFFSET ??_C@_06ELLFFOK@checks?$AA@
  0072e	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR $T76[ebp]
  00734	50		 push	 eax
  00735	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0073a	8b c8		 mov	 ecx, eax
  0073c	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00741	8b c8		 mov	 ecx, eax
  00743	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00748	8b c8		 mov	 ecx, eax
  0074a	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  0074f	85 c0		 test	 eax, eax

; 101  : 			NewGroup.Checks.Shop			= Node.child("checks").child("shop").text().as_int(0);

  00751	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00757	56		 push	 esi
  00758	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR $T74[ebp]
  0075e	0f 95 45 d3	 setne	 BYTE PTR _NewGroup$193[ebp+263]
  00762	50		 push	 eax
  00763	68 00 00 00 00	 push	 OFFSET ??_C@_04BFIJLIPK@shop?$AA@
  00768	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR $T72[ebp]
  0076e	50		 push	 eax
  0076f	68 00 00 00 00	 push	 OFFSET ??_C@_06ELLFFOK@checks?$AA@
  00774	8d 85 20 fd ff
	ff		 lea	 eax, DWORD PTR $T70[ebp]
  0077a	50		 push	 eax
  0077b	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00780	8b c8		 mov	 ecx, eax
  00782	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00787	8b c8		 mov	 ecx, eax
  00789	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0078e	8b c8		 mov	 ecx, eax
  00790	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  00795	85 c0		 test	 eax, eax

; 102  : 
; 103  : 			GroupSub = Node.child("reward");

  00797	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0079d	68 00 00 00 00	 push	 OFFSET ??_C@_06NPNBMBEO@reward?$AA@
  007a2	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR $T68[ebp]
  007a8	0f 95 45 d4	 setne	 BYTE PTR _NewGroup$193[ebp+264]
  007ac	50		 push	 eax
  007ad	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 104  : 			NewGroup.PointMode = GroupSub.attribute("pointmode").as_int(0);

  007b2	56		 push	 esi
  007b3	68 00 00 00 00	 push	 OFFSET ??_C@_09LIMLDHCM@pointmode?$AA@
  007b8	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _GroupSub$[ebp]
  007be	8b 00		 mov	 eax, DWORD PTR [eax]
  007c0	89 85 ec fd ff
	ff		 mov	 DWORD PTR _GroupSub$[ebp], eax
  007c6	8d 85 18 fd ff
	ff		 lea	 eax, DWORD PTR $T66[ebp]
  007cc	50		 push	 eax
  007cd	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  007d2	8b c8		 mov	 ecx, eax
  007d4	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  007d9	88 85 f4 fe ff
	ff		 mov	 BYTE PTR _NewGroup$193[ebp+40], al

; 105  : 
; 106  : 			for (RewardNode = GroupSub.child("class"); RewardNode; RewardNode = RewardNode.next_sibling())

  007df	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _GroupSub$[ebp]
  007e5	68 00 00 00 00	 push	 OFFSET ??_C@_05ENKANFLO@class?$AA@
  007ea	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR $T64[ebp]
  007f0	50		 push	 eax
  007f1	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  007f6	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  007fc	8b 00		 mov	 eax, DWORD PTR [eax]
  007fe	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _RewardNode$[ebp], eax
  00804	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00809	85 c0		 test	 eax, eax
  0080b	0f 84 7f 01 00
	00		 je	 $LN6@Read
$LL7@Read:

; 107  : 			{
; 108  : 				int ClassCode = RewardNode.attribute("id").as_int(-1);

  00811	6a ff		 push	 -1
  00813	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  00818	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR $T62[ebp]
  0081e	50		 push	 eax
  0081f	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  00825	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0082a	8b c8		 mov	 ecx, eax
  0082c	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00831	8b d8		 mov	 ebx, eax

; 109  : 
; 110  : 				if (ClassCode < 0 || ClassCode > 6)

  00833	83 fb 06	 cmp	 ebx, 6
  00836	0f 87 02 01 00
	00		 ja	 $LN22@Read

; 114  : 					continue;
; 115  : 				}
; 116  : 
; 117  : 				NewGroup.RewardList[ClassCode].Class = ClassCode;

  0083c	8d 34 dd 00 00
	00 00		 lea	 esi, DWORD PTR [ebx*8]

; 118  : 				NewGroup.RewardList[ClassCode].Point = RewardNode.attribute("point").as_int(0);

  00843	6a 00		 push	 0
  00845	2b f3		 sub	 esi, ebx
  00847	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR $T60[ebp]
  0084d	68 00 00 00 00	 push	 OFFSET ??_C@_05BBEJFBFA@point?$AA@
  00852	50		 push	 eax
  00853	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  00859	88 9c b5 f8 fe
	ff ff		 mov	 BYTE PTR _NewGroup$193[ebp+esi*4+44], bl
  00860	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00865	8b c8		 mov	 ecx, eax
  00867	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 119  : 				NewGroup.RewardList[ClassCode].WCoinC = RewardNode.attribute("wcoinc").as_int(0);

  0086c	6a 00		 push	 0
  0086e	89 84 b5 fc fe
	ff ff		 mov	 DWORD PTR _NewGroup$193[ebp+esi*4+48], eax
  00875	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  0087b	68 00 00 00 00	 push	 OFFSET ??_C@_06JEOJDFIL@wcoinc?$AA@
  00880	8d 85 08 fd ff
	ff		 lea	 eax, DWORD PTR $T58[ebp]
  00886	50		 push	 eax
  00887	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0088c	8b c8		 mov	 ecx, eax
  0088e	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 120  : 				NewGroup.RewardList[ClassCode].WCoinP = RewardNode.attribute("wcoinp").as_int(0);

  00893	6a 00		 push	 0
  00895	89 84 b5 00 ff
	ff ff		 mov	 DWORD PTR _NewGroup$193[ebp+esi*4+52], eax
  0089c	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  008a2	68 00 00 00 00	 push	 OFFSET ??_C@_06PFAGHEBJ@wcoinp?$AA@
  008a7	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR $T56[ebp]
  008ad	50		 push	 eax
  008ae	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  008b3	8b c8		 mov	 ecx, eax
  008b5	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 121  : 				NewGroup.RewardList[ClassCode].WCoinG = RewardNode.attribute("wcoing").as_int(0);

  008ba	6a 00		 push	 0
  008bc	89 84 b5 04 ff
	ff ff		 mov	 DWORD PTR _NewGroup$193[ebp+esi*4+56], eax
  008c3	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  008c9	68 00 00 00 00	 push	 OFFSET ??_C@_06PAIFPAIP@wcoing?$AA@
  008ce	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR $T54[ebp]
  008d4	50		 push	 eax
  008d5	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  008da	8b c8		 mov	 ecx, eax
  008dc	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 122  : 				NewGroup.RewardList[ClassCode].GensP = RewardNode.attribute("gensp").as_int(0);

  008e1	6a 00		 push	 0
  008e3	89 84 b5 08 ff
	ff ff		 mov	 DWORD PTR _NewGroup$193[ebp+esi*4+60], eax
  008ea	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  008f0	68 00 00 00 00	 push	 OFFSET ??_C@_05KIGPLGEM@gensp?$AA@
  008f5	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR $T52[ebp]
  008fb	50		 push	 eax
  008fc	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00901	8b c8		 mov	 ecx, eax
  00903	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 123  : 				NewGroup.RewardList[ClassCode].Credits = RewardNode.attribute("wcoing").as_int(0);

  00908	6a 00		 push	 0
  0090a	89 84 b5 0c ff
	ff ff		 mov	 DWORD PTR _NewGroup$193[ebp+esi*4+64], eax
  00911	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  00917	68 00 00 00 00	 push	 OFFSET ??_C@_06PAIFPAIP@wcoing?$AA@
  0091c	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR $T50[ebp]
  00922	50		 push	 eax
  00923	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00928	8b c8		 mov	 ecx, eax
  0092a	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 124  : 			}

  0092f	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  00935	89 84 b5 10 ff
	ff ff		 mov	 DWORD PTR _NewGroup$193[ebp+esi*4+68], eax
  0093c	eb 22		 jmp	 SHORT $LN5@Read
$LN22@Read:

; 111  : 				{
; 112  : 					MsgBox("[ResetSystem] Syntax error in reward node, param: id (%d)", ClassCode);

  0093e	53		 push	 ebx
  0093f	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DFHDDGPP@?$FLResetSystem?$FN?5Syntax?5error?5in?5re@
  00944	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 113  : 					this->Log->Output("[ResetSystem] Syntax error in reward node, param: id (%d)", ClassCode);

  00949	53		 push	 ebx
  0094a	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  00950	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DFHDDGPP@?$FLResetSystem?$FN?5Syntax?5error?5in?5re@
  00955	ff 73 2c	 push	 DWORD PTR [ebx+44]
  00958	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0095d	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@Read:

; 105  : 
; 106  : 			for (RewardNode = GroupSub.child("class"); RewardNode; RewardNode = RewardNode.next_sibling())

  00960	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR $T48[ebp]
  00966	50		 push	 eax
  00967	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  0096d	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  00972	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  00978	8b 00		 mov	 eax, DWORD PTR [eax]
  0097a	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _RewardNode$[ebp], eax
  00980	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00985	85 c0		 test	 eax, eax
  00987	0f 85 84 fe ff
	ff		 jne	 $LL7@Read
  0098d	8b 75 bc	 mov	 esi, DWORD PTR _NewGroup$193[ebp+240]
$LN6@Read:

; 125  : 
; 126  : 			GroupSub = Node.child("itemslist");

  00990	68 00 00 00 00	 push	 OFFSET ??_C@_09GEBMJOEB@itemslist?$AA@
  00995	8d 85 98 fc ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0099b	50		 push	 eax
  0099c	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  009a2	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 127  : 			
; 128  : 			for (ItemNode = GroupSub.child("item"); ItemNode; ItemNode = ItemNode.next_sibling())

  009a7	68 00 00 00 00	 push	 OFFSET ??_C@_04NHONDGDE@item?$AA@
  009ac	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _GroupSub$[ebp]
  009b2	8b 00		 mov	 eax, DWORD PTR [eax]
  009b4	89 85 ec fd ff
	ff		 mov	 DWORD PTR _GroupSub$[ebp], eax
  009ba	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR $T46[ebp]
  009c0	50		 push	 eax
  009c1	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  009c6	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  009cc	8b 00		 mov	 eax, DWORD PTR [eax]
  009ce	89 85 fc fd ff
	ff		 mov	 DWORD PTR _ItemNode$[ebp], eax
  009d4	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  009d9	85 c0		 test	 eax, eax
  009db	0f 84 73 02 00
	00		 je	 $LN9@Read
$LL10@Read:

; 129  : 			{
; 130  : 				ResetItem NewItem;
; 131  : 				NewItem.Type = ItemNode.attribute("type").as_int(0);

  009e1	6a 00		 push	 0
  009e3	68 00 00 00 00	 push	 OFFSET ??_C@_04GPMDFGEJ@type?$AA@
  009e8	8d 85 e8 fc ff
	ff		 lea	 eax, DWORD PTR $T44[ebp]
  009ee	50		 push	 eax
  009ef	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  009f5	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  009fa	8b c8		 mov	 ecx, eax
  009fc	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 132  : 				NewItem.Index = ItemNode.attribute("index").as_int(0);

  00a01	6a 00		 push	 0
  00a03	66 89 45 d8	 mov	 WORD PTR _NewItem$195[ebp], ax
  00a07	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00a0d	68 00 00 00 00	 push	 OFFSET ??_C@_05FKHKFDID@index?$AA@
  00a12	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR $T42[ebp]
  00a18	50		 push	 eax
  00a19	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00a1e	8b c8		 mov	 ecx, eax
  00a20	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 133  : 				NewItem.MinLevel = ItemNode.attribute("minlvl").as_int(0);

  00a25	6a 00		 push	 0
  00a27	66 89 45 da	 mov	 WORD PTR _NewItem$195[ebp+2], ax
  00a2b	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00a31	68 00 00 00 00	 push	 OFFSET ??_C@_06GJMPOCOI@minlvl?$AA@
  00a36	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR $T40[ebp]
  00a3c	50		 push	 eax
  00a3d	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00a42	8b c8		 mov	 ecx, eax
  00a44	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 134  : 				NewItem.MaxLevel = ItemNode.attribute("maxlvl").as_int(0);

  00a49	6a 00		 push	 0
  00a4b	88 45 dc	 mov	 BYTE PTR _NewItem$195[ebp+4], al
  00a4e	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00a54	68 00 00 00 00	 push	 OFFSET ??_C@_06GKDMACKH@maxlvl?$AA@
  00a59	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR $T38[ebp]
  00a5f	50		 push	 eax
  00a60	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00a65	8b c8		 mov	 ecx, eax
  00a67	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 135  : 				NewItem.MinDurability = ItemNode.attribute("mindur").as_int(0);

  00a6c	6a 00		 push	 0
  00a6e	88 45 dd	 mov	 BYTE PTR _NewItem$195[ebp+5], al
  00a71	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00a77	68 00 00 00 00	 push	 OFFSET ??_C@_06HKHMELIB@mindur?$AA@
  00a7c	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR $T36[ebp]
  00a82	50		 push	 eax
  00a83	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00a88	8b c8		 mov	 ecx, eax
  00a8a	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 136  : 				NewItem.MaxDurability = ItemNode.attribute("maxdur").as_int(0);

  00a8f	6a 00		 push	 0
  00a91	88 45 de	 mov	 BYTE PTR _NewItem$195[ebp+6], al
  00a94	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00a9a	68 00 00 00 00	 push	 OFFSET ??_C@_06HJIPKLMO@maxdur?$AA@
  00a9f	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T34[ebp]
  00aa5	50		 push	 eax
  00aa6	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00aab	8b c8		 mov	 ecx, eax
  00aad	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 137  : 				NewItem.MinOption = ItemNode.attribute("minopt").as_int(0);

  00ab2	6a 00		 push	 0
  00ab4	88 45 df	 mov	 BYTE PTR _NewItem$195[ebp+7], al
  00ab7	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00abd	68 00 00 00 00	 push	 OFFSET ??_C@_06PNOMKJON@minopt?$AA@
  00ac2	8d 85 d0 fc ff
	ff		 lea	 eax, DWORD PTR $T32[ebp]
  00ac8	50		 push	 eax
  00ac9	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00ace	8b c8		 mov	 ecx, eax
  00ad0	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 138  : 				NewItem.MaxOption = ItemNode.attribute("maxopt").as_int(0);

  00ad5	6a 00		 push	 0
  00ad7	88 45 e0	 mov	 BYTE PTR _NewItem$195[ebp+8], al
  00ada	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00ae0	68 00 00 00 00	 push	 OFFSET ??_C@_06POBPEJKC@maxopt?$AA@
  00ae5	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR $T30[ebp]
  00aeb	50		 push	 eax
  00aec	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00af1	8b c8		 mov	 ecx, eax
  00af3	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 139  : 				NewItem.Luck = ItemNode.attribute("luck").as_int(0);

  00af8	6a 00		 push	 0
  00afa	88 45 e1	 mov	 BYTE PTR _NewItem$195[ebp+9], al
  00afd	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00b03	68 00 00 00 00	 push	 OFFSET ??_C@_04PFGGAFBF@luck?$AA@
  00b08	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  00b0e	50		 push	 eax
  00b0f	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00b14	8b c8		 mov	 ecx, eax
  00b16	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00b1b	66 89 45 e2	 mov	 WORD PTR _NewItem$195[ebp+10], ax

; 140  : 				NewItem.Skill = ItemNode.attribute("skill").as_int(0);

  00b1f	6a 00		 push	 0
  00b21	68 00 00 00 00	 push	 OFFSET ??_C@_05ODMCMJAJ@skill?$AA@
  00b26	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR $T26[ebp]
  00b2c	50		 push	 eax
  00b2d	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00b33	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00b38	8b c8		 mov	 ecx, eax
  00b3a	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 141  : 				NewItem.Excellent = ItemNode.attribute("excellent").as_int(-1);

  00b3f	6a ff		 push	 -1
  00b41	66 89 45 e4	 mov	 WORD PTR _NewItem$195[ebp+12], ax
  00b45	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00b4b	68 00 00 00 00	 push	 OFFSET ??_C@_09MBDMPFOO@excellent?$AA@
  00b50	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR $T163[ebp]
  00b56	50		 push	 eax
  00b57	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00b5c	8b c8		 mov	 ecx, eax
  00b5e	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 142  : 				NewItem.Ancient = ItemNode.attribute("ancient").as_int(-1);

  00b63	6a ff		 push	 -1
  00b65	66 89 45 e6	 mov	 WORD PTR _NewItem$195[ebp+14], ax
  00b69	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00b6f	68 00 00 00 00	 push	 OFFSET ??_C@_07ECLFICCK@ancient?$AA@
  00b74	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR $T159[ebp]
  00b7a	50		 push	 eax
  00b7b	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00b80	8b c8		 mov	 ecx, eax
  00b82	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 143  : 				NewItem.Socket = ItemNode.attribute("socket").as_int(-1);

  00b87	6a ff		 push	 -1
  00b89	66 89 45 e8	 mov	 WORD PTR _NewItem$195[ebp+16], ax
  00b8d	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00b93	68 00 00 00 00	 push	 OFFSET ??_C@_06HBELJPBO@socket?$AA@
  00b98	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR $T156[ebp]
  00b9e	50		 push	 eax
  00b9f	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00ba4	8b c8		 mov	 ecx, eax
  00ba6	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 144  : 				NewItem.Element = ItemNode.attribute("element").as_int(-1);

  00bab	6a ff		 push	 -1
  00bad	66 89 45 ea	 mov	 WORD PTR _NewItem$195[ebp+18], ax
  00bb1	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00bb7	68 00 00 00 00	 push	 OFFSET ??_C@_07HCLJNICE@element?$AA@
  00bbc	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T153[ebp]
  00bc2	50		 push	 eax
  00bc3	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00bc8	8b c8		 mov	 ecx, eax
  00bca	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 145  : 				NewItem.Count = ItemNode.attribute("count").as_int(0);

  00bcf	6a 00		 push	 0
  00bd1	66 89 45 ec	 mov	 WORD PTR _NewItem$195[ebp+20], ax
  00bd5	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00bdb	68 00 00 00 00	 push	 OFFSET ??_C@_05IOMEMJEC@count?$AA@
  00be0	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR $T150[ebp]
  00be6	50		 push	 eax
  00be7	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00bec	8b c8		 mov	 ecx, eax
  00bee	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 146  : 				
; 147  : 				if (IsValidItemNode(NewItem))

  00bf3	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _NewItem$195[ebp]
  00bf7	66 89 45 ee	 mov	 WORD PTR _NewItem$195[ebp+22], ax
  00bfb	83 ec 18	 sub	 esp, 24			; 00000018H
  00bfe	8b c4		 mov	 eax, esp
  00c00	8b cb		 mov	 ecx, ebx
  00c02	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00c05	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR _NewItem$195[ebp+16]
  00c0a	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  00c0f	e8 00 00 00 00	 call	 ?IsValidItemNode@ResetSystem@@AAE_NUResetItem@@@Z ; ResetSystem::IsValidItemNode
  00c14	84 c0		 test	 al, al
  00c16	74 0c		 je	 SHORT $LN8@Read

; 148  : 				{
; 149  : 					NewGroup.ItemList.push_back(NewItem);

  00c18	8d 45 d8	 lea	 eax, DWORD PTR _NewItem$195[ebp]
  00c1b	50		 push	 eax
  00c1c	8d 4d bc	 lea	 ecx, DWORD PTR _NewGroup$193[ebp+240]
  00c1f	e8 00 00 00 00	 call	 ?push_back@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEXABUResetItem@@@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::push_back
$LN8@Read:

; 127  : 			
; 128  : 			for (ItemNode = GroupSub.child("item"); ItemNode; ItemNode = ItemNode.next_sibling())

  00c24	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR $T147[ebp]
  00c2a	50		 push	 eax
  00c2b	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00c31	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  00c36	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  00c3c	8b 00		 mov	 eax, DWORD PTR [eax]
  00c3e	89 85 fc fd ff
	ff		 mov	 DWORD PTR _ItemNode$[ebp], eax
  00c44	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00c49	85 c0		 test	 eax, eax
  00c4b	0f 85 90 fd ff
	ff		 jne	 $LL10@Read
  00c51	8b 75 bc	 mov	 esi, DWORD PTR _NewGroup$193[ebp+240]
$LN9@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00c54	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _NewGroup$193[ebp]
  00c5a	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00c5d	73 5b		 jae	 SHORT $LN51@Read
  00c5f	8b 07		 mov	 eax, DWORD PTR [edi]
  00c61	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _NewGroup$193[ebp]
  00c67	3b c1		 cmp	 eax, ecx
  00c69	77 4f		 ja	 SHORT $LN51@Read

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00c6b	2b c8		 sub	 ecx, eax
  00c6d	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00c72	f7 e9		 imul	 ecx
  00c74	c1 fa 03	 sar	 edx, 3
  00c77	8b c2		 mov	 eax, edx
  00c79	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00c7c	03 c2		 add	 eax, edx
  00c7e	89 85 f0 fd ff
	ff		 mov	 DWORD PTR __Idx$1$[ebp], eax

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00c84	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00c87	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00c8a	75 09		 jne	 SHORT $LN53@Read

; 1279 : 				_Reserve(1);

  00c8c	6a 01		 push	 1
  00c8e	8b cf		 mov	 ecx, edi
  00c90	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
$LN53@Read:

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00c95	69 85 f0 fd ff
	ff 0c 01 00 00	 imul	 eax, DWORD PTR __Idx$1$[ebp], 268
  00c9f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00ca2	89 8d f0 fd ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00ca8	89 8d d8 fd ff
	ff		 mov	 DWORD PTR $T164[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00cae	03 07		 add	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00cb0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00cb4	85 c9		 test	 ecx, ecx
  00cb6	74 39		 je	 SHORT $LN255@Read
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 		else

  00cb8	eb 2e		 jmp	 SHORT $LN1042@Read
$LN51@Read:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  00cba	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00cbd	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00cc0	75 09		 jne	 SHORT $LN54@Read

; 1288 : 				_Reserve(1);

  00cc2	6a 01		 push	 1
  00cc4	8b cf		 mov	 ecx, edi
  00cc6	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
$LN54@Read:

; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),

  00ccb	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00cce	89 8d d8 fd ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00cd4	89 8d f0 fd ff
	ff		 mov	 DWORD PTR $T185[ebp], ecx
  00cda	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00cde	85 c9		 test	 ecx, ecx
  00ce0	74 0f		 je	 SHORT $LN255@Read
  00ce2	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _NewGroup$193[ebp]
$LN1042@Read:
  00ce8	50		 push	 eax
  00ce9	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
  00cee	8b 75 bc	 mov	 esi, DWORD PTR _NewGroup$193[ebp+240]
$LN255@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00cf1	81 47 04 0c 01
	00 00		 add	 DWORD PTR [edi+4], 268	; 0000010cH
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 155  : 	}

  00cf8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00cfc	85 f6		 test	 esi, esi
  00cfe	74 62		 je	 SHORT $LN2@Read

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00d00	8b 4d c4	 mov	 ecx, DWORD PTR _NewGroup$193[ebp+248]
  00d03	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00d08	2b ce		 sub	 ecx, esi
  00d0a	f7 e9		 imul	 ecx
  00d0c	c1 fa 02	 sar	 edx, 2
  00d0f	8b c2		 mov	 eax, edx
  00d11	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00d14	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00d16	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00d1b	0f 87 cc 08 00
	00		 ja	 $LN1011@Read

; 101  : 	const size_t _User_size = _Count * _Sz;

  00d21	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00d24	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00d27	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00d2c	72 2b		 jb	 SHORT $LN347@Read

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00d2e	f6 45 bc 1f	 test	 BYTE PTR _NewGroup$193[ebp+240], 31 ; 0000001fH
  00d32	0f 85 b5 08 00
	00		 jne	 $LN1011@Read

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00d38	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00d3b	3b c6		 cmp	 eax, esi
  00d3d	0f 83 aa 08 00
	00		 jae	 $LN1011@Read

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00d43	2b f0		 sub	 esi, eax
  00d45	83 fe 04	 cmp	 esi, 4
  00d48	0f 82 9f 08 00
	00		 jb	 $LN1011@Read

; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00d4e	83 fe 23	 cmp	 esi, 35			; 00000023H
  00d51	0f 87 96 08 00
	00		 ja	 $LN1011@Read

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00d57	8b f0		 mov	 esi, eax
$LN347@Read:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00d59	56		 push	 esi
  00d5a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d5f	83 c4 04	 add	 esp, 4
$LN2@Read:
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 70   : 	for (Node = GroupList.child("group"); Node; Node = Node.next_sibling())

  00d62	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T174[ebp]
  00d68	50		 push	 eax
  00d69	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00d6f	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  00d74	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00d7a	8b 00		 mov	 eax, DWORD PTR [eax]
  00d7c	89 85 00 fe ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  00d82	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00d87	85 c0		 test	 eax, eax
  00d89	0f 85 d6 f4 ff
	ff		 jne	 $LL4@Read
$LN1038@Read:

; 156  : 
; 157  : 	Category = ResetSystem.child("grand");

  00d8f	68 00 00 00 00	 push	 OFFSET ??_C@_05BIJMAKPO@grand?$AA@
  00d94	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T173[ebp]
  00d9a	50		 push	 eax
  00d9b	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _ResetSystem$[ebp]
  00da1	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 158  : 
; 159  : 	this->m_GrandInfo.m_Enabled	= Category.child("enabled").text().as_int(0);

  00da6	6a 00		 push	 0
  00da8	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00dae	8b 00		 mov	 eax, DWORD PTR [eax]
  00db0	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _Category$[ebp], eax
  00db6	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T172[ebp]
  00dbc	50		 push	 eax
  00dbd	68 00 00 00 00	 push	 OFFSET ??_C@_07MHHIKOPA@enabled?$AA@
  00dc2	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR $T166[ebp]
  00dc8	50		 push	 eax
  00dc9	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00dce	8b c8		 mov	 ecx, eax
  00dd0	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00dd5	8b c8		 mov	 ecx, eax
  00dd7	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  00ddc	85 c0		 test	 eax, eax

; 160  : 
; 161  : 	this->m_GrandInfo.m_NPC.Class				= Category.child("npc").attribute("id").as_int(0);

  00dde	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00de4	6a 00		 push	 0
  00de6	0f 95 c0	 setne	 al
  00de9	88 43 18	 mov	 BYTE PTR [ebx+24], al
  00dec	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T171[ebp]
  00df2	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  00df7	50		 push	 eax
  00df8	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  00dfd	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR $T146[ebp]
  00e03	50		 push	 eax
  00e04	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00e09	8b c8		 mov	 ecx, eax
  00e0b	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00e10	8b c8		 mov	 ecx, eax
  00e12	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 162  : 	this->m_GrandInfo.m_NPC.MapNumber			= Category.child("npc").attribute("map").as_int(0);

  00e17	6a 00		 push	 0
  00e19	66 89 43 1a	 mov	 WORD PTR [ebx+26], ax
  00e1d	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00e23	68 00 00 00 00	 push	 OFFSET ??_C@_03HBNNNHNM@map?$AA@
  00e28	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T170[ebp]
  00e2e	50		 push	 eax
  00e2f	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  00e34	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR $T149[ebp]
  00e3a	50		 push	 eax
  00e3b	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00e40	8b c8		 mov	 ecx, eax
  00e42	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00e47	8b c8		 mov	 ecx, eax
  00e49	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 163  : 	this->m_GrandInfo.m_NPC.X					= Category.child("npc").attribute("x").as_int(0);

  00e4e	6a 00		 push	 0
  00e50	66 89 43 1c	 mov	 WORD PTR [ebx+28], ax
  00e54	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00e5a	68 00 00 00 00	 push	 OFFSET ??_C@_01FJMABOPO@x?$AA@
  00e5f	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T169[ebp]
  00e65	50		 push	 eax
  00e66	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  00e6b	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T152[ebp]
  00e71	50		 push	 eax
  00e72	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00e77	8b c8		 mov	 ecx, eax
  00e79	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00e7e	8b c8		 mov	 ecx, eax
  00e80	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 164  : 	this->m_GrandInfo.m_NPC.Y					= Category.child("npc").attribute("y").as_int(0);

  00e85	6a 00		 push	 0
  00e87	88 43 1e	 mov	 BYTE PTR [ebx+30], al
  00e8a	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00e90	68 00 00 00 00	 push	 OFFSET ??_C@_01EANLCPLP@y?$AA@
  00e95	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T168[ebp]
  00e9b	50		 push	 eax
  00e9c	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  00ea1	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR $T155[ebp]
  00ea7	50		 push	 eax
  00ea8	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00ead	8b c8		 mov	 ecx, eax
  00eaf	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00eb4	8b c8		 mov	 ecx, eax
  00eb6	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00ebb	88 43 1f	 mov	 BYTE PTR [ebx+31], al

; 165  : 
; 166  : 	GroupList = Category.child("grouplist");

  00ebe	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR $T158[ebp]
  00ec4	68 00 00 00 00	 push	 OFFSET ??_C@_09EKKKGLLH@grouplist?$AA@
  00ec9	50		 push	 eax
  00eca	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _Category$[ebp]
  00ed0	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 168  : 	for (Node = GroupList.child("group"); Node; Node = Node.next_sibling())

  00ed5	68 00 00 00 00	 push	 OFFSET ??_C@_05MGJOOGAJ@group?$AA@
  00eda	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _GroupList$[ebp]
  00ee0	8b 00		 mov	 eax, DWORD PTR [eax]
  00ee2	89 85 dc fd ff
	ff		 mov	 DWORD PTR _GroupList$[ebp], eax
  00ee8	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR $T162[ebp]
  00eee	50		 push	 eax
  00eef	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00ef4	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00efa	8b 00		 mov	 eax, DWORD PTR [eax]
  00efc	89 85 00 fe ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  00f02	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00f07	85 c0		 test	 eax, eax
  00f09	0f 84 be 0b 00
	00		 je	 $LN1039@Read
  00f0f	90		 npad	 1
$LL13@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00f10	33 f6		 xor	 esi, esi

; 481  : 		_Mylast = pointer();

  00f12	33 ff		 xor	 edi, edi
  00f14	89 75 bc	 mov	 DWORD PTR _NewGroup$192[ebp+240], esi
  00f17	89 7d c0	 mov	 DWORD PTR _NewGroup$192[ebp+244], edi

; 482  : 		_Myend = pointer();

  00f1a	89 75 c4	 mov	 DWORD PTR _NewGroup$192[ebp+248], esi
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 172  : 		NewGroup.MinLevel = Node.attribute("minlevel").as_int(0);

  00f1d	57		 push	 edi
  00f1e	68 00 00 00 00	 push	 OFFSET ??_C@_08EHBDOELG@minlevel?$AA@
  00f23	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR $T167[ebp]
  00f29	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00f2d	50		 push	 eax
  00f2e	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00f34	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00f39	8b c8		 mov	 ecx, eax
  00f3b	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 173  : 		NewGroup.MaxLevel = Node.attribute("maxlevel").as_int(0);

  00f40	57		 push	 edi
  00f41	66 89 85 cc fe
	ff ff		 mov	 WORD PTR _NewGroup$192[ebp], ax
  00f48	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00f4e	68 00 00 00 00	 push	 OFFSET ??_C@_08JAPIFGPH@maxlevel?$AA@
  00f53	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR $T165[ebp]
  00f59	50		 push	 eax
  00f5a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00f5f	8b c8		 mov	 ecx, eax
  00f61	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 174  : 		NewGroup.MinReset = Node.attribute("minreset").as_int(0);

  00f66	57		 push	 edi
  00f67	66 89 85 ce fe
	ff ff		 mov	 WORD PTR _NewGroup$192[ebp+2], ax
  00f6e	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00f74	68 00 00 00 00	 push	 OFFSET ??_C@_08MLAKOPDG@minreset?$AA@
  00f79	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR $T145[ebp]
  00f7f	50		 push	 eax
  00f80	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00f85	8b c8		 mov	 ecx, eax
  00f87	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 175  : 		NewGroup.MaxReset = Node.attribute("maxreset").as_int(0);

  00f8c	57		 push	 edi
  00f8d	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+4], eax
  00f93	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00f99	68 00 00 00 00	 push	 OFFSET ??_C@_08BMOBFNHH@maxreset?$AA@
  00f9e	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR $T148[ebp]
  00fa4	50		 push	 eax
  00fa5	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00faa	8b c8		 mov	 ecx, eax
  00fac	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 176  : 		NewGroup.Money = Node.attribute("money").as_int(0);

  00fb1	57		 push	 edi
  00fb2	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+8], eax
  00fb8	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00fbe	68 00 00 00 00	 push	 OFFSET ??_C@_05IKCNOJAA@money?$AA@
  00fc3	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T151[ebp]
  00fc9	50		 push	 eax
  00fca	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00fcf	8b c8		 mov	 ecx, eax
  00fd1	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 177  : 		NewGroup.WCoinC = Node.attribute("wcoinc").as_int(0);

  00fd6	57		 push	 edi
  00fd7	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+12], eax
  00fdd	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00fe3	68 00 00 00 00	 push	 OFFSET ??_C@_06JEOJDFIL@wcoinc?$AA@
  00fe8	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR $T154[ebp]
  00fee	50		 push	 eax
  00fef	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00ff4	8b c8		 mov	 ecx, eax
  00ff6	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 178  : 		NewGroup.WCoinP = Node.attribute("wcoinp").as_int(0);

  00ffb	57		 push	 edi
  00ffc	89 85 dc fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+16], eax
  01002	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01008	68 00 00 00 00	 push	 OFFSET ??_C@_06PFAGHEBJ@wcoinp?$AA@
  0100d	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR $T157[ebp]
  01013	50		 push	 eax
  01014	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01019	8b c8		 mov	 ecx, eax
  0101b	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 179  : 		NewGroup.WCoinG = Node.attribute("wcoing").as_int(0);

  01020	57		 push	 edi
  01021	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+20], eax
  01027	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0102d	68 00 00 00 00	 push	 OFFSET ??_C@_06PAIFPAIP@wcoing?$AA@
  01032	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR $T161[ebp]
  01038	50		 push	 eax
  01039	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0103e	8b c8		 mov	 ecx, eax
  01040	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 180  : 		NewGroup.GensP = Node.attribute("gensp").as_int(0);

  01045	57		 push	 edi
  01046	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+24], eax
  0104c	68 00 00 00 00	 push	 OFFSET ??_C@_05KIGPLGEM@gensp?$AA@
  01051	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  01057	50		 push	 eax
  01058	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0105e	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01063	8b c8		 mov	 ecx, eax
  01065	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 181  : 		NewGroup.Credits = Node.attribute("credits").as_int(0);

  0106a	57		 push	 edi
  0106b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+28], eax
  01071	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01077	68 00 00 00 00	 push	 OFFSET ??_C@_07JKABFLJI@credits?$AA@
  0107c	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR $T27[ebp]
  01082	50		 push	 eax
  01083	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01088	8b c8		 mov	 ecx, eax
  0108a	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 182  : 		NewGroup.Delay = Node.attribute("delay").as_int(0);

  0108f	57		 push	 edi
  01090	89 85 ec fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+32], eax
  01096	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0109c	68 00 00 00 00	 push	 OFFSET ??_C@_05EKJCMADO@delay?$AA@
  010a1	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR $T29[ebp]
  010a7	50		 push	 eax
  010a8	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  010ad	8b c8		 mov	 ecx, eax
  010af	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 183  : 
; 184  : 	//	for (SubNode = Node.child("group"); SubNode; SubNode = SubNode.next_sibling())
; 185  : 	//	{
; 186  : 			NewGroup.Cleaning.Stats			= Node.child("cleaning").child("stats").text().as_int(0);

  010b4	57		 push	 edi
  010b5	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _NewGroup$192[ebp+36], eax
  010bb	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  010c1	8d 85 d0 fc ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  010c7	50		 push	 eax
  010c8	68 00 00 00 00	 push	 OFFSET ??_C@_05BLKJBNOD@stats?$AA@
  010cd	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T33[ebp]
  010d3	50		 push	 eax
  010d4	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  010d9	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR $T35[ebp]
  010df	50		 push	 eax
  010e0	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  010e5	8b c8		 mov	 ecx, eax
  010e7	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  010ec	8b c8		 mov	 ecx, eax
  010ee	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  010f3	8b c8		 mov	 ecx, eax
  010f5	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  010fa	85 c0		 test	 eax, eax

; 187  : 			NewGroup.Cleaning.Points		= Node.child("cleaning").child("points").text().as_int(0);

  010fc	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01102	57		 push	 edi
  01103	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR $T37[ebp]
  01109	0f 95 45 c8	 setne	 BYTE PTR _NewGroup$192[ebp+252]
  0110d	50		 push	 eax
  0110e	68 00 00 00 00	 push	 OFFSET ??_C@_06GPGIDCJA@points?$AA@
  01113	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR $T39[ebp]
  01119	50		 push	 eax
  0111a	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  0111f	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR $T41[ebp]
  01125	50		 push	 eax
  01126	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0112b	8b c8		 mov	 ecx, eax
  0112d	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01132	8b c8		 mov	 ecx, eax
  01134	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  01139	8b c8		 mov	 ecx, eax
  0113b	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  01140	85 c0		 test	 eax, eax

; 188  : 			NewGroup.Cleaning.Skills		= Node.child("cleaning").child("skills").text().as_int(0);

  01142	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01148	57		 push	 edi
  01149	8d 85 e8 fc ff
	ff		 lea	 eax, DWORD PTR $T43[ebp]
  0114f	0f 95 45 c9	 setne	 BYTE PTR _NewGroup$192[ebp+253]
  01153	50		 push	 eax
  01154	68 00 00 00 00	 push	 OFFSET ??_C@_06HNCNFAFI@skills?$AA@
  01159	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR $T45[ebp]
  0115f	50		 push	 eax
  01160	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  01165	8d 85 98 fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0116b	50		 push	 eax
  0116c	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01171	8b c8		 mov	 ecx, eax
  01173	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01178	8b c8		 mov	 ecx, eax
  0117a	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0117f	8b c8		 mov	 ecx, eax
  01181	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  01186	85 c0		 test	 eax, eax

; 189  : 			NewGroup.Cleaning.Equipment		= Node.child("cleaning").child("equipment").text().as_int(0);

  01188	57		 push	 edi
  01189	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR $T47[ebp]
  0118f	0f 95 45 ca	 setne	 BYTE PTR _NewGroup$192[ebp+254]
  01193	50		 push	 eax
  01194	68 00 00 00 00	 push	 OFFSET ??_C@_09FJJPPKDN@equipment?$AA@
  01199	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR $T49[ebp]
  0119f	50		 push	 eax
  011a0	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  011a5	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR $T51[ebp]
  011ab	50		 push	 eax
  011ac	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  011b2	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  011b7	8b c8		 mov	 ecx, eax
  011b9	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  011be	8b c8		 mov	 ecx, eax
  011c0	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  011c5	8b c8		 mov	 ecx, eax
  011c7	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  011cc	85 c0		 test	 eax, eax

; 190  : 			NewGroup.Cleaning.Inventory		= Node.child("cleaning").child("inventory").text().as_int(0);

  011ce	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  011d4	57		 push	 edi
  011d5	8d 85 00 fd ff
	ff		 lea	 eax, DWORD PTR $T53[ebp]
  011db	0f 95 45 cb	 setne	 BYTE PTR _NewGroup$192[ebp+255]
  011df	50		 push	 eax
  011e0	68 00 00 00 00	 push	 OFFSET ??_C@_09OCPGKIKB@inventory?$AA@
  011e5	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR $T55[ebp]
  011eb	50		 push	 eax
  011ec	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  011f1	8d 85 08 fd ff
	ff		 lea	 eax, DWORD PTR $T57[ebp]
  011f7	50		 push	 eax
  011f8	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  011fd	8b c8		 mov	 ecx, eax
  011ff	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01204	8b c8		 mov	 ecx, eax
  01206	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0120b	8b c8		 mov	 ecx, eax
  0120d	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  01212	85 c0		 test	 eax, eax

; 191  : 			NewGroup.Cleaning.Shop			= Node.child("cleaning").child("shop").text().as_int(0);

  01214	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0121a	57		 push	 edi
  0121b	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR $T59[ebp]
  01221	0f 95 45 cc	 setne	 BYTE PTR _NewGroup$192[ebp+256]
  01225	50		 push	 eax
  01226	68 00 00 00 00	 push	 OFFSET ??_C@_04BFIJLIPK@shop?$AA@
  0122b	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR $T61[ebp]
  01231	50		 push	 eax
  01232	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  01237	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR $T63[ebp]
  0123d	50		 push	 eax
  0123e	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01243	8b c8		 mov	 ecx, eax
  01245	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0124a	8b c8		 mov	 ecx, eax
  0124c	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  01251	8b c8		 mov	 ecx, eax
  01253	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  01258	85 c0		 test	 eax, eax

; 192  : 			NewGroup.Cleaning.MasterLevel	= Node.child("cleaning").child("masterlevel").text().as_int(0);

  0125a	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01260	57		 push	 edi
  01261	8d 85 18 fd ff
	ff		 lea	 eax, DWORD PTR $T65[ebp]
  01267	0f 95 45 cd	 setne	 BYTE PTR _NewGroup$192[ebp+257]
  0126b	50		 push	 eax
  0126c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BHKEDLCN@masterlevel?$AA@
  01271	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR $T67[ebp]
  01277	50		 push	 eax
  01278	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  0127d	8d 85 20 fd ff
	ff		 lea	 eax, DWORD PTR $T69[ebp]
  01283	50		 push	 eax
  01284	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01289	8b c8		 mov	 ecx, eax
  0128b	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01290	8b c8		 mov	 ecx, eax
  01292	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  01297	8b c8		 mov	 ecx, eax
  01299	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  0129e	85 c0		 test	 eax, eax

; 193  : 			NewGroup.Cleaning.MasterPoints	= Node.child("cleaning").child("masterpoints").text().as_int(0);

  012a0	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR $T71[ebp]
  012a6	57		 push	 edi
  012a7	50		 push	 eax
  012a8	0f 95 45 ce	 setne	 BYTE PTR _NewGroup$192[ebp+258]
  012ac	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GHLLHCDN@masterpoints?$AA@
  012b1	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR $T73[ebp]
  012b7	50		 push	 eax
  012b8	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  012bd	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR $T75[ebp]
  012c3	50		 push	 eax
  012c4	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  012ca	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  012cf	8b c8		 mov	 ecx, eax
  012d1	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  012d6	8b c8		 mov	 ecx, eax
  012d8	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  012dd	8b c8		 mov	 ecx, eax
  012df	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  012e4	85 c0		 test	 eax, eax

; 194  : 			NewGroup.Cleaning.MasterSkills	= Node.child("cleaning").child("masterskills").text().as_int(0);

  012e6	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  012ec	57		 push	 edi
  012ed	8d 85 30 fd ff
	ff		 lea	 eax, DWORD PTR $T77[ebp]
  012f3	0f 95 45 cf	 setne	 BYTE PTR _NewGroup$192[ebp+259]
  012f7	50		 push	 eax
  012f8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HFPOBAPF@masterskills?$AA@
  012fd	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR $T79[ebp]
  01303	50		 push	 eax
  01304	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  01309	8d 85 38 fd ff
	ff		 lea	 eax, DWORD PTR $T81[ebp]
  0130f	50		 push	 eax
  01310	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01315	8b c8		 mov	 ecx, eax
  01317	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0131c	8b c8		 mov	 ecx, eax
  0131e	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  01323	8b c8		 mov	 ecx, eax
  01325	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  0132a	85 c0		 test	 eax, eax

; 195  : 			NewGroup.Cleaning.MarlonQuest	= Node.child("cleaning").child("marlonquest").text().as_int(0);

  0132c	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01332	57		 push	 edi
  01333	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR $T83[ebp]
  01339	0f 95 45 d0	 setne	 BYTE PTR _NewGroup$192[ebp+260]
  0133d	50		 push	 eax
  0133e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJHEGDCF@marlonquest?$AA@
  01343	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR $T85[ebp]
  01349	50		 push	 eax
  0134a	68 00 00 00 00	 push	 OFFSET ??_C@_08OJKDDGJG@cleaning?$AA@
  0134f	8d 85 44 fd ff
	ff		 lea	 eax, DWORD PTR $T87[ebp]
  01355	50		 push	 eax
  01356	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0135b	8b c8		 mov	 ecx, eax
  0135d	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01362	8b c8		 mov	 ecx, eax
  01364	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  01369	8b c8		 mov	 ecx, eax
  0136b	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  01370	85 c0		 test	 eax, eax

; 196  : 
; 197  : 			NewGroup.Checks.Equipment		= Node.child("checks").child("equipment").text().as_int(0);

  01372	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01378	57		 push	 edi
  01379	8d 85 48 fd ff
	ff		 lea	 eax, DWORD PTR $T89[ebp]
  0137f	0f 95 45 d1	 setne	 BYTE PTR _NewGroup$192[ebp+261]
  01383	50		 push	 eax
  01384	68 00 00 00 00	 push	 OFFSET ??_C@_09FJJPPKDN@equipment?$AA@
  01389	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
  0138f	50		 push	 eax
  01390	68 00 00 00 00	 push	 OFFSET ??_C@_06ELLFFOK@checks?$AA@
  01395	8d 85 50 fd ff
	ff		 lea	 eax, DWORD PTR $T93[ebp]
  0139b	50		 push	 eax
  0139c	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  013a1	8b c8		 mov	 ecx, eax
  013a3	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  013a8	8b c8		 mov	 ecx, eax
  013aa	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  013af	8b c8		 mov	 ecx, eax
  013b1	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  013b6	85 c0		 test	 eax, eax

; 198  : 			NewGroup.Checks.Inventory		= Node.child("checks").child("inventory").text().as_int(0);

  013b8	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR $T95[ebp]
  013be	57		 push	 edi
  013bf	50		 push	 eax
  013c0	68 00 00 00 00	 push	 OFFSET ??_C@_09OCPGKIKB@inventory?$AA@
  013c5	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR $T97[ebp]
  013cb	0f 95 45 d2	 setne	 BYTE PTR _NewGroup$192[ebp+262]
  013cf	50		 push	 eax
  013d0	68 00 00 00 00	 push	 OFFSET ??_C@_06ELLFFOK@checks?$AA@
  013d5	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR $T99[ebp]
  013db	50		 push	 eax
  013dc	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  013e2	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  013e7	8b c8		 mov	 ecx, eax
  013e9	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  013ee	8b c8		 mov	 ecx, eax
  013f0	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  013f5	8b c8		 mov	 ecx, eax
  013f7	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  013fc	85 c0		 test	 eax, eax

; 199  : 			NewGroup.Checks.Shop			= Node.child("checks").child("shop").text().as_int(0);

  013fe	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01404	57		 push	 edi
  01405	8d 85 60 fd ff
	ff		 lea	 eax, DWORD PTR $T101[ebp]
  0140b	0f 95 45 d3	 setne	 BYTE PTR _NewGroup$192[ebp+263]
  0140f	50		 push	 eax
  01410	68 00 00 00 00	 push	 OFFSET ??_C@_04BFIJLIPK@shop?$AA@
  01415	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR $T103[ebp]
  0141b	50		 push	 eax
  0141c	68 00 00 00 00	 push	 OFFSET ??_C@_06ELLFFOK@checks?$AA@
  01421	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR $T105[ebp]
  01427	50		 push	 eax
  01428	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0142d	8b c8		 mov	 ecx, eax
  0142f	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  01434	8b c8		 mov	 ecx, eax
  01436	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0143b	8b c8		 mov	 ecx, eax
  0143d	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  01442	85 c0		 test	 eax, eax

; 200  : 
; 201  : 			GroupSub = Node.child("reward");

  01444	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0144a	68 00 00 00 00	 push	 OFFSET ??_C@_06NPNBMBEO@reward?$AA@
  0144f	8d 85 6c fd ff
	ff		 lea	 eax, DWORD PTR $T107[ebp]
  01455	0f 95 45 d4	 setne	 BYTE PTR _NewGroup$192[ebp+264]
  01459	50		 push	 eax
  0145a	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 202  : 
; 203  : 			NewGroup.PointMode = GroupSub.attribute("pointmode").as_int(0);

  0145f	57		 push	 edi
  01460	68 00 00 00 00	 push	 OFFSET ??_C@_09LIMLDHCM@pointmode?$AA@
  01465	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _GroupSub$[ebp]
  0146b	8b 00		 mov	 eax, DWORD PTR [eax]
  0146d	89 85 ec fd ff
	ff		 mov	 DWORD PTR _GroupSub$[ebp], eax
  01473	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR $T109[ebp]
  01479	50		 push	 eax
  0147a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0147f	8b c8		 mov	 ecx, eax
  01481	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  01486	88 85 f4 fe ff
	ff		 mov	 BYTE PTR _NewGroup$192[ebp+40], al

; 204  : 
; 205  : 			for (RewardNode = GroupSub.child("class"); RewardNode; RewardNode = RewardNode.next_sibling())

  0148c	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _GroupSub$[ebp]
  01492	68 00 00 00 00	 push	 OFFSET ??_C@_05ENKANFLO@class?$AA@
  01497	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR $T111[ebp]
  0149d	50		 push	 eax
  0149e	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  014a3	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  014a9	8b 00		 mov	 eax, DWORD PTR [eax]
  014ab	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _RewardNode$[ebp], eax
  014b1	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  014b6	85 c0		 test	 eax, eax
  014b8	0f 84 89 01 00
	00		 je	 $LN15@Read
  014be	66 90		 npad	 2
$LL16@Read:

; 206  : 			{
; 207  : 				int ClassCode = RewardNode.attribute("id").as_int(-1);

  014c0	6a ff		 push	 -1
  014c2	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  014c7	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR $T113[ebp]
  014cd	50		 push	 eax
  014ce	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  014d4	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  014d9	8b c8		 mov	 ecx, eax
  014db	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  014e0	8b d8		 mov	 ebx, eax

; 208  : 
; 209  : 				if (ClassCode < 0 || ClassCode > 6)

  014e2	83 fb 06	 cmp	 ebx, 6
  014e5	0f 87 07 01 00
	00		 ja	 $LN25@Read

; 213  : 					continue;
; 214  : 				}
; 215  : 				
; 216  : 				NewGroup.RewardList[ClassCode].Class = ClassCode;

  014eb	8d 34 dd 00 00
	00 00		 lea	 esi, DWORD PTR [ebx*8]

; 217  : 				NewGroup.RewardList[ClassCode].Point = RewardNode.attribute("point").as_int(0);

  014f2	6a 00		 push	 0
  014f4	2b f3		 sub	 esi, ebx
  014f6	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR $T115[ebp]
  014fc	68 00 00 00 00	 push	 OFFSET ??_C@_05BBEJFBFA@point?$AA@
  01501	50		 push	 eax
  01502	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  01508	88 9c b5 f8 fe
	ff ff		 mov	 BYTE PTR _NewGroup$192[ebp+esi*4+44], bl
  0150f	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01514	8b c8		 mov	 ecx, eax
  01516	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 218  : 				NewGroup.RewardList[ClassCode].WCoinC = RewardNode.attribute("wcoinc").as_int(0);

  0151b	6a 00		 push	 0
  0151d	89 84 b5 fc fe
	ff ff		 mov	 DWORD PTR _NewGroup$192[ebp+esi*4+48], eax
  01524	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  0152a	68 00 00 00 00	 push	 OFFSET ??_C@_06JEOJDFIL@wcoinc?$AA@
  0152f	8d 85 80 fd ff
	ff		 lea	 eax, DWORD PTR $T117[ebp]
  01535	50		 push	 eax
  01536	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0153b	8b c8		 mov	 ecx, eax
  0153d	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 219  : 				NewGroup.RewardList[ClassCode].WCoinP = RewardNode.attribute("wcoinp").as_int(0);

  01542	6a 00		 push	 0
  01544	89 84 b5 00 ff
	ff ff		 mov	 DWORD PTR _NewGroup$192[ebp+esi*4+52], eax
  0154b	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  01551	68 00 00 00 00	 push	 OFFSET ??_C@_06PFAGHEBJ@wcoinp?$AA@
  01556	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR $T119[ebp]
  0155c	50		 push	 eax
  0155d	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01562	8b c8		 mov	 ecx, eax
  01564	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 220  : 				NewGroup.RewardList[ClassCode].WCoinG = RewardNode.attribute("wcoing").as_int(0);

  01569	6a 00		 push	 0
  0156b	89 84 b5 04 ff
	ff ff		 mov	 DWORD PTR _NewGroup$192[ebp+esi*4+56], eax
  01572	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  01578	68 00 00 00 00	 push	 OFFSET ??_C@_06PAIFPAIP@wcoing?$AA@
  0157d	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR $T121[ebp]
  01583	50		 push	 eax
  01584	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01589	8b c8		 mov	 ecx, eax
  0158b	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 221  : 				NewGroup.RewardList[ClassCode].GensP = RewardNode.attribute("gensp").as_int(0);

  01590	6a 00		 push	 0
  01592	89 84 b5 08 ff
	ff ff		 mov	 DWORD PTR _NewGroup$192[ebp+esi*4+60], eax
  01599	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  0159f	68 00 00 00 00	 push	 OFFSET ??_C@_05KIGPLGEM@gensp?$AA@
  015a4	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR $T123[ebp]
  015aa	50		 push	 eax
  015ab	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  015b0	8b c8		 mov	 ecx, eax
  015b2	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 222  : 				NewGroup.RewardList[ClassCode].Credits = RewardNode.attribute("wcoing").as_int(0);

  015b7	6a 00		 push	 0
  015b9	89 84 b5 0c ff
	ff ff		 mov	 DWORD PTR _NewGroup$192[ebp+esi*4+64], eax
  015c0	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  015c6	68 00 00 00 00	 push	 OFFSET ??_C@_06PAIFPAIP@wcoing?$AA@
  015cb	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR $T125[ebp]
  015d1	50		 push	 eax
  015d2	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  015d7	8b c8		 mov	 ecx, eax
  015d9	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 223  : 			}

  015de	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  015e4	89 84 b5 10 ff
	ff ff		 mov	 DWORD PTR _NewGroup$192[ebp+esi*4+68], eax
  015eb	eb 27		 jmp	 SHORT $LN14@Read
$LN1011@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  015ed	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1044@Read:
$LN25@Read:
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 211  : 					MsgBox("[ResetSystem] Syntax error in reward node, param: id (%d)", ClassCode);

  015f2	53		 push	 ebx
  015f3	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DFHDDGPP@?$FLResetSystem?$FN?5Syntax?5error?5in?5re@
  015f8	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 212  : 					this->Log->Output("[ResetSystem] Syntax error in reward node, param: id (%d)", ClassCode);

  015fd	53		 push	 ebx
  015fe	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  01604	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DFHDDGPP@?$FLResetSystem?$FN?5Syntax?5error?5in?5re@
  01609	ff 73 2c	 push	 DWORD PTR [ebx+44]
  0160c	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  01611	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@Read:

; 204  : 
; 205  : 			for (RewardNode = GroupSub.child("class"); RewardNode; RewardNode = RewardNode.next_sibling())

  01614	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR $T127[ebp]
  0161a	50		 push	 eax
  0161b	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  01621	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  01626	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _RewardNode$[ebp]
  0162c	8b 00		 mov	 eax, DWORD PTR [eax]
  0162e	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _RewardNode$[ebp], eax
  01634	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  01639	85 c0		 test	 eax, eax
  0163b	0f 85 7f fe ff
	ff		 jne	 $LL16@Read
  01641	8b 7d c0	 mov	 edi, DWORD PTR _NewGroup$192[ebp+244]
  01644	8b 75 bc	 mov	 esi, DWORD PTR _NewGroup$192[ebp+240]
$LN15@Read:

; 224  : 
; 225  : 			GroupSub = SubNode.child("itemslist");

  01647	68 00 00 00 00	 push	 OFFSET ??_C@_09GEBMJOEB@itemslist?$AA@
  0164c	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR $T129[ebp]
  01652	50		 push	 eax
  01653	8d 8d f0 fc ff
	ff		 lea	 ecx, DWORD PTR _SubNode$[ebp]
  01659	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 227  : 			for (ItemNode = GroupSub.child("item"); ItemNode; ItemNode = ItemNode.next_sibling())

  0165e	68 00 00 00 00	 push	 OFFSET ??_C@_04NHONDGDE@item?$AA@
  01663	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _GroupSub$[ebp]
  01669	8b 00		 mov	 eax, DWORD PTR [eax]
  0166b	89 85 ec fd ff
	ff		 mov	 DWORD PTR _GroupSub$[ebp], eax
  01671	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR $T131[ebp]
  01677	50		 push	 eax
  01678	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0167d	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  01683	8b 00		 mov	 eax, DWORD PTR [eax]
  01685	89 85 fc fd ff
	ff		 mov	 DWORD PTR _ItemNode$[ebp], eax
  0168b	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  01690	85 c0		 test	 eax, eax
  01692	0f 84 f6 02 00
	00		 je	 $LN18@Read
  01698	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL19@Read:

; 228  : 			{
; 229  : 				ResetItem NewItem;
; 230  : 				NewItem.Type = ItemNode.attribute("type").as_int(0);

  016a0	6a 00		 push	 0
  016a2	68 00 00 00 00	 push	 OFFSET ??_C@_04GPMDFGEJ@type?$AA@
  016a7	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR $T133[ebp]
  016ad	50		 push	 eax
  016ae	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  016b4	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  016b9	8b c8		 mov	 ecx, eax
  016bb	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 231  : 				NewItem.Index = ItemNode.attribute("index").as_int(0);

  016c0	6a 00		 push	 0
  016c2	66 89 45 d8	 mov	 WORD PTR _NewItem$194[ebp], ax
  016c6	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  016cc	68 00 00 00 00	 push	 OFFSET ??_C@_05FKHKFDID@index?$AA@
  016d1	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR $T135[ebp]
  016d7	50		 push	 eax
  016d8	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  016dd	8b c8		 mov	 ecx, eax
  016df	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 232  : 				NewItem.MinLevel = ItemNode.attribute("minlvl").as_int(0);

  016e4	6a 00		 push	 0
  016e6	66 89 45 da	 mov	 WORD PTR _NewItem$194[ebp+2], ax
  016ea	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  016f0	68 00 00 00 00	 push	 OFFSET ??_C@_06GJMPOCOI@minlvl?$AA@
  016f5	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR $T137[ebp]
  016fb	50		 push	 eax
  016fc	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01701	8b c8		 mov	 ecx, eax
  01703	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 233  : 				NewItem.MaxLevel = ItemNode.attribute("maxlvl").as_int(0);

  01708	6a 00		 push	 0
  0170a	88 45 dc	 mov	 BYTE PTR _NewItem$194[ebp+4], al
  0170d	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  01713	68 00 00 00 00	 push	 OFFSET ??_C@_06GKDMACKH@maxlvl?$AA@
  01718	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR $T139[ebp]
  0171e	50		 push	 eax
  0171f	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01724	8b c8		 mov	 ecx, eax
  01726	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 234  : 				NewItem.MinDurability = ItemNode.attribute("mindur").as_int(0);

  0172b	6a 00		 push	 0
  0172d	88 45 dd	 mov	 BYTE PTR _NewItem$194[ebp+5], al
  01730	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  01736	68 00 00 00 00	 push	 OFFSET ??_C@_06HKHMELIB@mindur?$AA@
  0173b	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR $T141[ebp]
  01741	50		 push	 eax
  01742	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01747	8b c8		 mov	 ecx, eax
  01749	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 235  : 				NewItem.MaxDurability = ItemNode.attribute("maxdur").as_int(0);

  0174e	6a 00		 push	 0
  01750	88 45 de	 mov	 BYTE PTR _NewItem$194[ebp+6], al
  01753	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  01759	68 00 00 00 00	 push	 OFFSET ??_C@_06HJIPKLMO@maxdur?$AA@
  0175e	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR $T143[ebp]
  01764	50		 push	 eax
  01765	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0176a	8b c8		 mov	 ecx, eax
  0176c	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 236  : 				NewItem.MinOption = ItemNode.attribute("minopt").as_int(0);

  01771	6a 00		 push	 0
  01773	88 45 df	 mov	 BYTE PTR _NewItem$194[ebp+7], al
  01776	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  0177c	68 00 00 00 00	 push	 OFFSET ??_C@_06PNOMKJON@minopt?$AA@
  01781	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  01787	50		 push	 eax
  01788	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0178d	8b c8		 mov	 ecx, eax
  0178f	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 237  : 				NewItem.MaxOption = ItemNode.attribute("maxopt").as_int(0);

  01794	6a 00		 push	 0
  01796	88 45 e0	 mov	 BYTE PTR _NewItem$194[ebp+8], al
  01799	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  0179f	68 00 00 00 00	 push	 OFFSET ??_C@_06POBPEJKC@maxopt?$AA@
  017a4	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  017aa	50		 push	 eax
  017ab	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  017b0	8b c8		 mov	 ecx, eax
  017b2	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 238  : 				NewItem.Luck = ItemNode.attribute("luck").as_int(0);

  017b7	6a 00		 push	 0
  017b9	88 45 e1	 mov	 BYTE PTR _NewItem$194[ebp+9], al
  017bc	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  017c2	68 00 00 00 00	 push	 OFFSET ??_C@_04PFGGAFBF@luck?$AA@
  017c7	8d 85 a4 fc ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  017cd	50		 push	 eax
  017ce	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  017d3	8b c8		 mov	 ecx, eax
  017d5	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  017da	66 89 45 e2	 mov	 WORD PTR _NewItem$194[ebp+10], ax

; 239  : 				NewItem.Skill = ItemNode.attribute("skill").as_int(0);

  017de	6a 00		 push	 0
  017e0	68 00 00 00 00	 push	 OFFSET ??_C@_05ODMCMJAJ@skill?$AA@
  017e5	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  017eb	50		 push	 eax
  017ec	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  017f2	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  017f7	8b c8		 mov	 ecx, eax
  017f9	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 240  : 				NewItem.Excellent = ItemNode.attribute("excellent").as_int(-1);

  017fe	6a ff		 push	 -1
  01800	66 89 45 e4	 mov	 WORD PTR _NewItem$194[ebp+12], ax
  01804	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  0180a	68 00 00 00 00	 push	 OFFSET ??_C@_09MBDMPFOO@excellent?$AA@
  0180f	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  01815	50		 push	 eax
  01816	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0181b	8b c8		 mov	 ecx, eax
  0181d	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 241  : 				NewItem.Ancient = ItemNode.attribute("ancient").as_int(-1);

  01822	6a ff		 push	 -1
  01824	66 89 45 e6	 mov	 WORD PTR _NewItem$194[ebp+14], ax
  01828	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  0182e	68 00 00 00 00	 push	 OFFSET ??_C@_07ECLFICCK@ancient?$AA@
  01833	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  01839	50		 push	 eax
  0183a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0183f	8b c8		 mov	 ecx, eax
  01841	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 242  : 				NewItem.Socket = ItemNode.attribute("socket").as_int(-1);

  01846	6a ff		 push	 -1
  01848	66 89 45 e8	 mov	 WORD PTR _NewItem$194[ebp+16], ax
  0184c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  01852	68 00 00 00 00	 push	 OFFSET ??_C@_06HBELJPBO@socket?$AA@
  01857	8d 85 b4 fc ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  0185d	50		 push	 eax
  0185e	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01863	8b c8		 mov	 ecx, eax
  01865	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 243  : 				NewItem.Element = ItemNode.attribute("element").as_int(-1);

  0186a	6a ff		 push	 -1
  0186c	66 89 45 ea	 mov	 WORD PTR _NewItem$194[ebp+18], ax
  01870	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  01876	68 00 00 00 00	 push	 OFFSET ??_C@_07HCLJNICE@element?$AA@
  0187b	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  01881	50		 push	 eax
  01882	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  01887	8b c8		 mov	 ecx, eax
  01889	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 244  : 				NewItem.Count = ItemNode.attribute("count").as_int(0);

  0188e	6a 00		 push	 0
  01890	66 89 45 ec	 mov	 WORD PTR _NewItem$194[ebp+20], ax
  01894	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  0189a	68 00 00 00 00	 push	 OFFSET ??_C@_05IOMEMJEC@count?$AA@
  0189f	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  018a5	50		 push	 eax
  018a6	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  018ab	8b c8		 mov	 ecx, eax
  018ad	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 245  : 				
; 246  : 				if (IsValidItemNode(NewItem))

  018b2	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _NewItem$194[ebp]
  018b6	66 89 45 ee	 mov	 WORD PTR _NewItem$194[ebp+22], ax
  018ba	83 ec 18	 sub	 esp, 24			; 00000018H
  018bd	8b c4		 mov	 eax, esp
  018bf	8b cb		 mov	 ecx, ebx
  018c1	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  018c4	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR _NewItem$194[ebp+16]
  018c9	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  018ce	e8 00 00 00 00	 call	 ?IsValidItemNode@ResetSystem@@AAE_NUResetItem@@@Z ; ResetSystem::IsValidItemNode
  018d3	84 c0		 test	 al, al
  018d5	0f 84 86 00 00
	00		 je	 $LN17@Read
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  018db	8d 45 d8	 lea	 eax, DWORD PTR _NewItem$194[ebp]
  018de	3b c7		 cmp	 eax, edi
  018e0	73 4f		 jae	 SHORT $LN405@Read
  018e2	3b f0		 cmp	 esi, eax
  018e4	77 4b		 ja	 SHORT $LN405@Read

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  018e6	8b c8		 mov	 ecx, eax
  018e8	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  018ed	2b ce		 sub	 ecx, esi
  018ef	f7 e9		 imul	 ecx
  018f1	c1 fa 02	 sar	 edx, 2
  018f4	8b da		 mov	 ebx, edx
  018f6	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  018f9	03 da		 add	 ebx, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  018fb	3b 7d c4	 cmp	 edi, DWORD PTR _NewGroup$192[ebp+248]
  018fe	75 10		 jne	 SHORT $LN407@Read

; 1279 : 				_Reserve(1);

  01900	6a 01		 push	 1
  01902	8d 4d bc	 lea	 ecx, DWORD PTR _NewGroup$192[ebp+240]
  01905	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reserve
  0190a	8b 7d c0	 mov	 edi, DWORD PTR _NewGroup$192[ebp+244]
  0190d	8b 75 bc	 mov	 esi, DWORD PTR _NewGroup$192[ebp+240]
$LN407@Read:

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  01910	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  01913	85 ff		 test	 edi, edi
  01915	74 12		 je	 SHORT $LN527@Read
  01917	0f 10 04 c6	 movups	 xmm0, XMMWORD PTR [esi+eax*8]
  0191b	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0191e	f3 0f 7e 44 c6
	10		 movq	 xmm0, QWORD PTR [esi+eax*8+16]
  01924	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN527@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 		else

  01929	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  0192f	eb 2a		 jmp	 SHORT $LN608@Read
$LN405@Read:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  01931	3b 7d c4	 cmp	 edi, DWORD PTR _NewGroup$192[ebp+248]
  01934	75 10		 jne	 SHORT $LN408@Read

; 1288 : 				_Reserve(1);

  01936	6a 01		 push	 1
  01938	8d 4d bc	 lea	 ecx, DWORD PTR _NewGroup$192[ebp+240]
  0193b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reserve
  01940	8b 7d c0	 mov	 edi, DWORD PTR _NewGroup$192[ebp+244]
  01943	8b 75 bc	 mov	 esi, DWORD PTR _NewGroup$192[ebp+240]
$LN408@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  01946	85 ff		 test	 edi, edi
  01948	74 11		 je	 SHORT $LN608@Read
  0194a	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _NewItem$194[ebp]
  0194e	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  01951	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR _NewItem$194[ebp+16]
  01956	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
$LN608@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  0195b	83 c7 18	 add	 edi, 24			; 00000018H
  0195e	89 7d c0	 mov	 DWORD PTR _NewGroup$192[ebp+244], edi
$LN17@Read:
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 227  : 			for (ItemNode = GroupSub.child("item"); ItemNode; ItemNode = ItemNode.next_sibling())

  01961	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR $T91[ebp]
  01967	50		 push	 eax
  01968	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  0196e	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  01973	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _ItemNode$[ebp]
  01979	8b 00		 mov	 eax, DWORD PTR [eax]
  0197b	89 85 fc fd ff
	ff		 mov	 DWORD PTR _ItemNode$[ebp], eax
  01981	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  01986	85 c0		 test	 eax, eax
  01988	0f 85 12 fd ff
	ff		 jne	 $LL19@Read
$LN18@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  0198e	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _NewGroup$192[ebp]
  01994	3b 43 24	 cmp	 eax, DWORD PTR [ebx+36]
  01997	73 5e		 jae	 SHORT $LN625@Read
  01999	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0199c	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _NewGroup$192[ebp]
  019a2	3b c1		 cmp	 eax, ecx
  019a4	77 51		 ja	 SHORT $LN625@Read

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  019a6	2b c8		 sub	 ecx, eax
  019a8	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  019ad	f7 e9		 imul	 ecx
  019af	c1 fa 03	 sar	 edx, 3
  019b2	8b c2		 mov	 eax, edx
  019b4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  019b7	03 c2		 add	 eax, edx
  019b9	89 85 f0 fd ff
	ff		 mov	 DWORD PTR __Idx$1$[ebp], eax

; 1278 : 			if (this->_Mylast() == this->_Myend())

  019bf	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  019c2	3b 43 28	 cmp	 eax, DWORD PTR [ebx+40]
  019c5	75 0a		 jne	 SHORT $LN627@Read

; 1279 : 				_Reserve(1);

  019c7	6a 01		 push	 1
  019c9	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  019cc	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
$LN627@Read:

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  019d1	69 85 f0 fd ff
	ff 0c 01 00 00	 imul	 eax, DWORD PTR __Idx$1$[ebp], 268
  019db	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  019de	89 8d cc fd ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  019e4	89 8d e8 fd ff
	ff		 mov	 DWORD PTR $T176[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  019ea	03 43 20	 add	 eax, DWORD PTR [ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  019ed	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  019f1	85 c9		 test	 ecx, ecx
  019f3	74 3a		 je	 SHORT $LN829@Read
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 		else

  019f5	eb 2f		 jmp	 SHORT $LN1043@Read
$LN625@Read:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  019f7	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  019fa	3b 43 28	 cmp	 eax, DWORD PTR [ebx+40]
  019fd	75 0a		 jne	 SHORT $LN628@Read

; 1288 : 				_Reserve(1);

  019ff	6a 01		 push	 1
  01a01	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  01a04	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
$LN628@Read:

; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),

  01a09	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  01a0c	89 8d cc fd ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  01a12	89 8d e8 fd ff
	ff		 mov	 DWORD PTR $T175[ebp], ecx
  01a18	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  01a1c	85 c9		 test	 ecx, ecx
  01a1e	74 0f		 je	 SHORT $LN829@Read
  01a20	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _NewGroup$192[ebp]
$LN1043@Read:
  01a26	50		 push	 eax
  01a27	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
  01a2c	8b 75 bc	 mov	 esi, DWORD PTR _NewGroup$192[ebp+240]
$LN829@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  01a2f	81 43 24 0c 01
	00 00		 add	 DWORD PTR [ebx+36], 268	; 0000010cH
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 254  : 	}

  01a36	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  01a3a	85 f6		 test	 esi, esi
  01a3c	74 62		 je	 SHORT $LN11@Read

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  01a3e	8b 4d c4	 mov	 ecx, DWORD PTR _NewGroup$192[ebp+248]
  01a41	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  01a46	2b ce		 sub	 ecx, esi
  01a48	f7 e9		 imul	 ecx
  01a4a	c1 fa 02	 sar	 edx, 2
  01a4d	8b c2		 mov	 eax, edx
  01a4f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01a52	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  01a54	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  01a59	0f 87 8e fb ff
	ff		 ja	 $LN1011@Read

; 101  : 	const size_t _User_size = _Count * _Sz;

  01a5f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01a62	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  01a65	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  01a6a	72 2b		 jb	 SHORT $LN921@Read

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  01a6c	f6 45 bc 1f	 test	 BYTE PTR _NewGroup$192[ebp+240], 31 ; 0000001fH
  01a70	0f 85 77 fb ff
	ff		 jne	 $LN1011@Read

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01a76	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  01a79	3b c6		 cmp	 eax, esi
  01a7b	0f 83 6c fb ff
	ff		 jae	 $LN1011@Read

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  01a81	2b f0		 sub	 esi, eax
  01a83	83 fe 04	 cmp	 esi, 4
  01a86	0f 82 61 fb ff
	ff		 jb	 $LN1011@Read

; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  01a8c	83 fe 23	 cmp	 esi, 35			; 00000023H
  01a8f	0f 87 58 fb ff
	ff		 ja	 $LN1011@Read

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01a95	8b f0		 mov	 esi, eax
$LN921@Read:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  01a97	56		 push	 esi
  01a98	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01a9d	83 c4 04	 add	 esp, 4
$LN11@Read:
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 168  : 	for (Node = GroupList.child("group"); Node; Node = Node.next_sibling())

  01aa0	8d 85 94 fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  01aa6	50		 push	 eax
  01aa7	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01aad	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  01ab2	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  01ab8	8b 00		 mov	 eax, DWORD PTR [eax]
  01aba	89 85 00 fe ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  01ac0	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  01ac5	85 c0		 test	 eax, eax
  01ac7	0f 85 43 f4 ff
	ff		 jne	 $LL13@Read
$LN1039@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  01acd	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  01ad0	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  01ad5	2b 4b 20	 sub	 ecx, DWORD PTR [ebx+32]
  01ad8	f7 e9		 imul	 ecx
  01ada	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  01adf	c1 fa 03	 sar	 edx, 3
  01ae2	8b ca		 mov	 ecx, edx
  01ae4	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01ae7	03 ca		 add	 ecx, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 256  : 	this->Log->Output("Configuration loaded (total normal groups: %d, total grand groups: %d)", 

  01ae9	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  01aea	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  01aed	2b 4b 0c	 sub	 ecx, DWORD PTR [ebx+12]
  01af0	f7 e9		 imul	 ecx
  01af2	c1 fa 03	 sar	 edx, 3
  01af5	8b c2		 mov	 eax, edx
  01af7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01afa	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 256  : 	this->Log->Output("Configuration loaded (total normal groups: %d, total grand groups: %d)", 

  01afc	50		 push	 eax
  01afd	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@JIBFDEBN@Configuration?5loaded?5?$CItotal?5norm@
  01b02	ff 73 2c	 push	 DWORD PTR [ebx+44]
  01b05	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  01b0a	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@Read:

; 257  : 		m_NormalInfo.m_GroupList.size(), m_GrandInfo.m_GroupList.size());
; 258  : }

  01b0d	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  01b13	e8 00 00 00 00	 call	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
  01b18	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01b1b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01b22	59		 pop	 ecx
  01b23	5f		 pop	 edi
  01b24	5e		 pop	 esi
  01b25	5b		 pop	 ebx
  01b26	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b29	33 cd		 xor	 ecx, ebp
  01b2b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b30	8b e5		 mov	 esp, ebp
  01b32	5d		 pop	 ebp
  01b33	c2 04 00	 ret	 4
$LN1041@Read:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$0:
  00000	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$1:
  0000b	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _NewGroup$193[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1ResetGroup@@QAE@XZ
__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$42:
  00016	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	50		 push	 eax
  0001d	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR $T164[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
  0002c	c3		 ret	 0
__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$66:
  0002d	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR __Ptr$[ebp]
  00033	50		 push	 eax
  00034	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T185[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00040	83 c4 08	 add	 esp, 8
  00043	c3		 ret	 0
__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$2:
  00044	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _NewGroup$192[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1ResetGroup@@QAE@XZ
__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$203:
  0004f	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR __Ptr$[ebp]
  00055	50		 push	 eax
  00056	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR $T176[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00062	83 c4 08	 add	 esp, 8
  00065	c3		 ret	 0
__unwindfunclet$?Read@ResetSystem@@QAEXPAD@Z$227:
  00066	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006c	50		 push	 eax
  0006d	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR $T175[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  00079	83 c4 08	 add	 esp, 8
  0007c	c3		 ret	 0
__ehhandler$?Read@ResetSystem@@QAEXPAD@Z:
  0007d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00081	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00084	8b 8a 84 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-892]
  0008a	33 c8		 xor	 ecx, eax
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00094	33 c8		 xor	 ecx, eax
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Read@ResetSystem@@QAEXPAD@Z
  000a0	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Read@ResetSystem@@QAEXPAD@Z ENDP			; ResetSystem::Read
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?Load@ResetSystem@@QAEXXZ
_TEXT	SEGMENT
?Load@ResetSystem@@QAEXXZ PROC				; ResetSystem::Load, COMDAT
; _this$ = ecx

; 38   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 39   : 	this->Init();

  00003	e8 00 00 00 00	 call	 ?Init@ResetSystem@@QAEXXZ ; ResetSystem::Init

; 40   : 	this->Read(gDirPath.GetNewPath(FILE_CUSTOM_RESETSYSTEM));

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MNGMBMNH@Custom?2ResetSystem?4xml?$AA@
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00012	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00017	50		 push	 eax
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?Read@ResetSystem@@QAEXPAD@Z ; ResetSystem::Read
  0001f	5e		 pop	 esi

; 41   : }

  00020	c3		 ret	 0
?Load@ResetSystem@@QAEXXZ ENDP				; ResetSystem::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?Init@ResetSystem@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 12
$T2 = -16						; size = 12
_this$1$ = -4						; size = 4
__Cat$3 = -4						; size = 1
__Cat$4 = -4						; size = 1
__Cat$5 = -4						; size = 1
__Cat$6 = -4						; size = 1
?Init@ResetSystem@@QAEXXZ PROC				; ResetSystem::Init, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b c1		 mov	 eax, ecx
  0000a	57		 push	 edi
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax

; 25   : 	this->m_NormalInfo.m_GroupList.clear();

  0000e	8d 70 0c	 lea	 esi, DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00011	ff 75 fc	 push	 DWORD PTR __Cat$6[ebp]
  00014	56		 push	 esi
  00015	ff 76 04	 push	 DWORD PTR [esi+4]
  00018	ff 36		 push	 DWORD PTR [esi]
  0001a	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00021	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00024	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00027	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0002c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002f	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00031	f7 e9		 imul	 ecx
  00033	c1 fa 03	 sar	 edx, 3
  00036	8b c2		 mov	 eax, edx
  00038	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003b	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 26   : 	if( this->m_NormalInfo.m_GroupList.capacity() > 0 )

  0003d	74 55		 je	 SHORT $LN324@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1549 : 		if (this == &_Right)

  0003f	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  00042	3b c6		 cmp	 eax, esi
  00044	74 4e		 je	 SHORT $LN324@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00046	8b 3e		 mov	 edi, DWORD PTR [esi]

; 54   : 	_Right = _Move(_Tmp);

  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 53   : 	_Left = _Move(_Right);

  0004e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 54   : 	_Right = _Move(_Tmp);

  00051	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 53   : 	_Left = _Move(_Right);

  00058	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]

; 54   : 	_Right = _Move(_Tmp);

  0005b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00062	85 ff		 test	 edi, edi
  00064	74 2e		 je	 SHORT $LN324@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00066	ff 75 fc	 push	 DWORD PTR __Cat$5[ebp]
  00069	8d 4d f0	 lea	 ecx, DWORD PTR $T2[ebp]
  0006c	51		 push	 ecx
  0006d	50		 push	 eax
  0006e	57		 push	 edi
  0006f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00074	2b df		 sub	 ebx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00076	8d 4d f0	 lea	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00079	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0007e	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00081	f7 eb		 imul	 ebx
  00083	c1 fa 03	 sar	 edx, 3
  00086	8b c2		 mov	 eax, edx
  00088	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008b	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0008d	50		 push	 eax
  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
$LN324@Init:
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 30   : 	this->m_GrandInfo.m_GroupList.clear();

  00094	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00097	ff 75 fc	 push	 DWORD PTR __Cat$4[ebp]
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 30   : 	this->m_GrandInfo.m_GroupList.clear();

  0009a	83 c6 20	 add	 esi, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0009d	56		 push	 esi
  0009e	ff 76 04	 push	 DWORD PTR [esi+4]
  000a1	ff 36		 push	 DWORD PTR [esi]
  000a3	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  000a8	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  000aa	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  000ad	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  000b0	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  000b5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b8	2b 0e		 sub	 ecx, DWORD PTR [esi]
  000ba	f7 e9		 imul	 ecx
  000bc	c1 fa 03	 sar	 edx, 3
  000bf	8b c2		 mov	 eax, edx
  000c1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c4	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 31   : 	if( this->m_GrandInfo.m_GroupList.capacity() > 0 )

  000c6	74 54		 je	 SHORT $LN743@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1549 : 		if (this == &_Right)

  000c8	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  000cb	3b c6		 cmp	 eax, esi
  000cd	74 4d		 je	 SHORT $LN743@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  000cf	8b 3e		 mov	 edi, DWORD PTR [esi]

; 54   : 	_Right = _Move(_Tmp);

  000d1	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 53   : 	_Left = _Move(_Right);

  000d7	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 54   : 	_Right = _Move(_Tmp);

  000da	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 53   : 	_Left = _Move(_Right);

  000e1	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]

; 54   : 	_Right = _Move(_Tmp);

  000e4	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  000eb	85 ff		 test	 edi, edi
  000ed	74 2d		 je	 SHORT $LN743@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  000ef	ff 75 fc	 push	 DWORD PTR __Cat$3[ebp]
  000f2	8b d0		 mov	 edx, eax
  000f4	52		 push	 edx
  000f5	51		 push	 ecx
  000f6	57		 push	 edi
  000f7	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  000fc	2b df		 sub	 ebx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000fe	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00101	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00106	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00109	f7 eb		 imul	 ebx
  0010b	c1 fa 03	 sar	 edx, 3
  0010e	8b c2		 mov	 eax, edx
  00110	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00113	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00115	50		 push	 eax
  00116	57		 push	 edi
  00117	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
$LN743@Init:
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 35   : }

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
?Init@ResetSystem@@QAEXXZ ENDP				; ResetSystem::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ??1ResetSystem@@UAE@XZ
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__Cat$2 = -4						; size = 1
??1ResetSystem@@UAE@XZ PROC				; ResetSystem::~ResetSystem, COMDAT
; _this$ = ecx

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 20   : 	delete this->Log;

  00008	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  0000b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ResetSystem@@6B@
  00011	85 f6		 test	 esi, esi
  00013	74 15		 je	 SHORT $LN6@ResetSyste
  00015	8b ce		 mov	 ecx, esi
  00017	e8 00 00 00 00	 call	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
  0001c	68 28 02 01 00	 push	 66088			; 00010228H
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN6@ResetSyste:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  0002a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0002d	53		 push	 ebx
  0002e	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  00031	85 c0		 test	 eax, eax
  00033	74 45		 je	 SHORT $LN16@ResetSyste
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00035	ff 75 fc	 push	 DWORD PTR __Cat$2[ebp]
  00038	53		 push	 ebx
  00039	ff 73 04	 push	 DWORD PTR [ebx+4]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00042	8b 33		 mov	 esi, DWORD PTR [ebx]
  00044	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00049	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0004c	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0004f	2b ce		 sub	 ecx, esi
  00051	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00053	8b cb		 mov	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00055	c1 fa 03	 sar	 edx, 3
  00058	8b c2		 mov	 eax, edx
  0005a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0005f	50		 push	 eax
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00066	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 1663 : 			this->_Mylast() = pointer();

  0006c	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1664 : 			this->_Myend() = pointer();

  00073	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
$LN16@ResetSyste:

; 1656 : 		if (this->_Myfirst() != pointer())

  0007a	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0007d	83 c7 0c	 add	 edi, 12			; 0000000cH
  00080	5b		 pop	 ebx
  00081	85 c9		 test	 ecx, ecx
  00083	74 45		 je	 SHORT $LN126@ResetSyste
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00085	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00088	57		 push	 edi
  00089	ff 77 04	 push	 DWORD PTR [edi+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00092	8b 37		 mov	 esi, DWORD PTR [edi]
  00094	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00099	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0009c	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0009f	2b ce		 sub	 ecx, esi
  000a1	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000a3	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  000a5	c1 fa 03	 sar	 edx, 3
  000a8	8b c2		 mov	 eax, edx
  000aa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ad	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000af	50		 push	 eax
  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  000b6	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1663 : 			this->_Mylast() = pointer();

  000bc	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1664 : 			this->_Myend() = pointer();

  000c3	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN126@ResetSyste:
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 21   : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
??1ResetSystem@@UAE@XZ ENDP				; ResetSystem::~ResetSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ??0ResetSystem@@QAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ResetSystem@@QAE@XZ PROC				; ResetSystem::ResetSystem, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ResetSystem@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ResetSystem@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00031	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 481  : 		_Mylast = pointer();

  00038	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 482  : 		_Myend = pointer();

  0003f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 14   : {

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  0004d	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 481  : 		_Mylast = pointer();

  00054	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 482  : 		_Myend = pointer();

  0005b	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp

; 15   : 	this->Log = new CLogToFile(LOG_NAME_RESET, LOG_PATH_RESET, TRUE);

  00062	68 28 02 01 00	 push	 66088			; 00010228H
  00067	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00070	83 c4 04	 add	 esp, 4
  00073	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00076	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0007a	85 c0		 test	 eax, eax
  0007c	74 28		 je	 SHORT $LN3@ResetSyste
  0007e	6a 01		 push	 1
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FCNIBGCF@?4?2Log?2Reset?$AA@
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0008a	8b c8		 mov	 ecx, eax
  0008c	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00091	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 16   : }

  00094	8b c6		 mov	 eax, esi
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5e		 pop	 esi
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN3@ResetSyste:

; 15   : 	this->Log = new CLogToFile(LOG_NAME_RESET, LOG_PATH_RESET, TRUE);

  000a6	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 16   : }

  000ad	8b c6		 mov	 eax, esi
  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5e		 pop	 esi
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ResetSystem@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1ResetData@@QAE@XZ
__unwindfunclet$??0ResetSystem@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 18	 add	 ecx, 24			; 00000018H
  00011	e9 00 00 00 00	 jmp	 ??1ResetData@@QAE@XZ
__unwindfunclet$??0ResetSystem@@QAE@XZ$2:
  00016	68 28 02 01 00	 push	 66088			; 00010228H
  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
  00027	c3		 ret	 0
__ehhandler$??0ResetSystem@@QAE@XZ:
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ResetSystem@@QAE@XZ
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ResetSystem@@QAE@XZ ENDP				; ResetSystem::ResetSystem
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1ResetData@@QAE@XZ
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
??1ResetData@@QAE@XZ PROC				; ResetData::~ResetData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00004	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00007	57		 push	 edi
  00008	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
  0000b	85 c0		 test	 eax, eax
  0000d	74 44		 je	 SHORT $LN7@ResetData
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000f	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00012	57		 push	 edi
  00013	ff 77 04	 push	 DWORD PTR [edi+4]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0001c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001f	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00024	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00026	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00029	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0002b	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0002d	c1 fa 03	 sar	 edx, 3
  00030	8b c2		 mov	 eax, edx
  00032	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00035	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00037	50		 push	 eax
  00038	ff 37		 push	 DWORD PTR [edi]
  0003a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  0003f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1663 : 			this->_Mylast() = pointer();

  00045	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1664 : 			this->_Myend() = pointer();

  0004c	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN7@ResetData:
  00053	5f		 pop	 edi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??1ResetData@@QAE@XZ ENDP				; ResetData::~ResetData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0ResetData@@QAE@XZ
_TEXT	SEGMENT
??0ResetData@@QAE@XZ PROC				; ResetData::ResetData, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00007	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00009	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myend = pointer();

  00010	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00017	c3		 ret	 0
??0ResetData@@QAE@XZ ENDP				; ResetData::ResetData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEXPAUResetGroup@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEXPAUResetGroup@@0@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEXPAUResetGroup@@0@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEXXZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEXXZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
?_Tidy@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXXZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00007	8b 07		 mov	 eax, DWORD PTR [edi]
  00009	85 c0		 test	 eax, eax
  0000b	74 44		 je	 SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000d	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00010	57		 push	 edi
  00011	ff 77 04	 push	 DWORD PTR [edi+4]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0001a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001d	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00022	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00024	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00027	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00029	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0002b	c1 fa 03	 sar	 edx, 3
  0002e	8b c2		 mov	 eax, edx
  00030	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00033	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	50		 push	 eax
  00036	ff 37		 push	 DWORD PTR [edi]
  00038	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1663 : 			this->_Mylast() = pointer();

  00043	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1664 : 			this->_Myend() = pointer();

  0004a	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN2@Tidy:
  00051	5f		 pop	 edi

; 1665 : 			}
; 1666 : 		}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?_Tidy@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXXZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv202 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00006	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 1646 : 		if (_Unused_capacity() < _Count)

  0000d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00010	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00013	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	c1 fa 03	 sar	 edx, 3
  0001d	8b c2		 mov	 eax, edx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx

; 1646 : 		if (_Unused_capacity() < _Count)

  00024	3b c7		 cmp	 eax, edi
  00026	73 61		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00028	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002a	2b f0		 sub	 esi, eax
  0002c	89 45 08	 mov	 DWORD PTR tv202[ebp], eax
  0002f	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00034	f7 ee		 imul	 esi

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00036	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003b	c1 fa 03	 sar	 edx, 3
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00043	03 ca		 add	 ecx, edx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00045	2b c1		 sub	 eax, ecx
  00047	3b c7		 cmp	 eax, edi
  00049	72 45		 jb	 SHORT $LN134@Reserve

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	03 f9		 add	 edi, ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0004d	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00052	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00055	2b 4d 08	 sub	 ecx, DWORD PTR tv202[ebp]
  00058	f7 e9		 imul	 ecx
  0005a	c1 fa 03	 sar	 edx, 3
  0005d	8b f2		 mov	 esi, edx
  0005f	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00062	03 f2		 add	 esi, edx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00064	ba 8d 89 f4 00	 mov	 edx, 16025997		; 00f4898dH
  00069	8b c6		 mov	 eax, esi
  0006b	d1 e8		 shr	 eax, 1
  0006d	2b d0		 sub	 edx, eax
  0006f	3b d6		 cmp	 edx, esi
  00071	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00074	b8 00 00 00 00	 mov	 eax, 0
  00079	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  0007c	3b cf		 cmp	 ecx, edi
  0007e	0f 42 cf	 cmovb	 ecx, edi

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00081	51		 push	 ecx
  00082	8b cb		 mov	 ecx, ebx
  00084	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reallocate
$LN2@Reserve:
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1651 : 			}
; 1652 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  0009a	cc		 int	 3
?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Size$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Cat$3 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e8	 mov	 DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UResetGroup@@@std@@QAEPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	8b d8		 mov	 ebx, eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00044	6a 00		 push	 0
  00046	57		 push	 edi
  00047	53		 push	 ebx
  00048	ff 77 04	 push	 DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0004b	89 5d ec	 mov	 DWORD PTR __Ptr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004e	ff 37		 push	 DWORD PTR [edi]
  00050	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetGroup@@PAU1@V?$allocator@UResetGroup@@@std@@U1@@std@@YAPAUResetGroup@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetGroup *,ResetGroup *,std::allocator<ResetGroup>,ResetGroup>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00055	8b 37		 mov	 esi, DWORD PTR [edi]
  00057	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0005c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0005f	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00062	2b ce		 sub	 ecx, esi
  00064	f7 e9		 imul	 ecx
  00066	c1 fa 03	 sar	 edx, 3
  00069	8b c2		 mov	 eax, edx
  0006b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0006e	03 c2		 add	 eax, edx
  00070	89 45 ec	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00073	85 f6		 test	 esi, esi
  00075	74 31		 je	 SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00077	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
  0007a	57		 push	 edi
  0007b	ff 77 04	 push	 DWORD PTR [edi+4]
  0007e	56		 push	 esi
  0007f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00084	8b 37		 mov	 esi, DWORD PTR [edi]
  00086	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0008b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0008e	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00091	2b ce		 sub	 ecx, esi
  00093	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00095	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00097	c1 fa 03	 sar	 edx, 3
  0009a	8b c2		 mov	 eax, edx
  0009c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009f	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000a1	50		 push	 eax
  000a2	56		 push	 esi
  000a3	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1639 : 		this->_Myend() = _Ptr + _Count;

  000a8	69 45 08 0c 01
	00 00		 imul	 eax, DWORD PTR __Count$[ebp], 268
  000af	03 c3		 add	 eax, ebx
  000b1	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  000b4	69 45 ec 0c 01
	00 00		 imul	 eax, DWORD PTR __Size$1$[ebp], 268
  000bb	03 c3		 add	 eax, ebx
  000bd	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  000c0	89 1f		 mov	 DWORD PTR [edi], ebx

; 1642 : 		}

  000c2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cc	59		 pop	 ecx
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000d6	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000d9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000df	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1627 : 		_RERAISE;

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN191@Reallocate:
$LN190@Reallocate:
  000ed	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBE_NPBUResetGroup@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBE_NPBUResetGroup@@@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBE_NPBUResetGroup@@@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEII@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0000d	b9 8d 89 f4 00	 mov	 ecx, 16025997		; 00f4898dH

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00012	f7 ea		 imul	 edx
  00014	56		 push	 esi
  00015	c1 fa 03	 sar	 edx, 3
  00018	8b f2		 mov	 esi, edx
  0001a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001d	03 f2		 add	 esi, edx

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001f	8b c6		 mov	 eax, esi
  00021	d1 e8		 shr	 eax, 1
  00023	57		 push	 edi
  00024	2b c8		 sub	 ecx, eax
  00026	33 ff		 xor	 edi, edi
  00028	3b ce		 cmp	 ecx, esi
  0002a	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0002d	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00030	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00033	5f		 pop	 edi
  00034	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  00038	8b c2		 mov	 eax, edx
  0003a	5e		 pop	 esi

; 1612 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IBEII@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXPAUResetGroup@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$1 = 12						; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXPAUResetGroup@@0@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Destroy, COMDAT
; _this$ = ecx

; 1599 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00003	ff 75 0c	 push	 DWORD PTR __Cat$1[ebp]
  00006	51		 push	 ecx
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
  00012	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?_Destroy@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXPAUResetGroup@@0@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?swap@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXAAV12@@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::swap, COMDAT
; _this$ = ecx

; 1548 : 		{	// exchange contents with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1549 : 		if (this == &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 20		 je	 SHORT $LN7@swap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 16		 mov	 edx, DWORD PTR [esi]
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 54   : 	_Right = _Move(_Tmp);

  00014	89 17		 mov	 DWORD PTR [edi], edx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00019	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0001f	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00022	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 53   : 	_Left = _Move(_Right);

  00025	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 	_Right = _Move(_Tmp);

  0002b	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
$LN7@swap:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1576 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?swap@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
?clear@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXXZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00005	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1539 : 		{	// erase all

  00008	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0001a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001d	5e		 pop	 esi

; 1543 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?clear@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXXZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0002d	3b f9		 cmp	 edi, ecx
  0002f	73 46		 jae	 SHORT $LN2@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	3b c7		 cmp	 eax, edi
  00035	77 40		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00037	2b f8		 sub	 edi, eax
  00039	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0003e	f7 ef		 imul	 edi
  00040	c1 fa 03	 sar	 edx, 3
  00043	8b fa		 mov	 edi, edx
  00045	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00048	03 fa		 add	 edi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  0004a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
$LN4@push_back:

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	69 c7 0c 01 00
	00		 imul	 eax, edi, 268
  00061	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00064	89 4d f0	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00067	03 06		 add	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00070	85 c9		 test	 ecx, ecx
  00072	74 2b		 je	 SHORT $LN206@push_back
  00074	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 		else

  00075	eb 23		 jmp	 SHORT $LN225@push_back
$LN2@push_back:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  00077	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0007a	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  0007c	6a 01		 push	 1
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@IAEXI@Z ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Reserve
$LN5@push_back:

; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),

  00085	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00088	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0008b	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0008e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00095	85 c9		 test	 ecx, ecx
  00097	74 06		 je	 SHORT $LN206@push_back
  00099	57		 push	 edi
$LN225@push_back:
  0009a	e8 00 00 00 00	 call	 ??0ResetGroup@@QAE@ABU0@@Z
$LN206@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  0009f	81 46 04 0c 01
	00 00		 add	 DWORD PTR [esi+4], 268	; 0000010cH

; 1293 : 			}
; 1294 : 		}

  000a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b0	59		 pop	 ecx
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z$35:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__unwindfunclet$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z$59:
  00011	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00014	50		 push	 eax
  00015	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
__ehhandler$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEXABUResetGroup@@@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEAAUResetGroup@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEAAUResetGroup@@I@Z PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00003	69 45 08 0c 01
	00 00		 imul	 eax, DWORD PTR __Pos$[ebp], 268
  0000a	03 01		 add	 eax, DWORD PTR [ecx]

; 1241 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??A?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAEAAUResetGroup@@I@Z ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1180 : 		}

  00016	c3		 ret	 0
?size@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 03	 sar	 edx, 3
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx

; 1048 : 		}

  00017	c3		 ret	 0
?_Unused_capacity@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1043 : 		}

  00016	c3		 ret	 0
?capacity@?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
??1?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAE@XZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::~vector<ResetGroup,std::allocator<ResetGroup> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00007	8b 07		 mov	 eax, DWORD PTR [edi]
  00009	85 c0		 test	 eax, eax
  0000b	74 44		 je	 SHORT $LN4@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000d	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00010	57		 push	 edi
  00011	ff 77 04	 push	 DWORD PTR [edi+4]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@@std@@YAXPAUResetGroup@@0AAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ResetGroup> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0001a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001d	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00022	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00024	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00027	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00029	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0002b	c1 fa 03	 sar	 edx, 3
  0002e	8b c2		 mov	 eax, edx
  00030	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00033	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	50		 push	 eax
  00036	ff 37		 push	 DWORD PTR [edi]
  00038	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1663 : 			this->_Mylast() = pointer();

  00043	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1664 : 			this->_Myend() = pointer();

  0004a	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  00051	5f		 pop	 edi

; 975  : 		_Tidy();
; 976  : 		}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??1?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAE@XZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::~vector<ResetGroup,std::allocator<ResetGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAE@XZ PROC ; std::vector<ResetGroup,std::allocator<ResetGroup> >::vector<ResetGroup,std::allocator<ResetGroup> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@QAE@XZ ENDP ; std::vector<ResetGroup,std::allocator<ResetGroup> >::vector<ResetGroup,std::allocator<ResetGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetGroup> >,std::_Vector_val<std::_Simple_types<ResetGroup> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<ResetGroup> >::_Vector_val<std::_Simple_types<ResetGroup> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<ResetGroup> >::_Vector_val<std::_Simple_types<ResetGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABQAUResetGroup@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAPAUResetGroup@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetGroup@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Swap_all, COMDAT
; _this$ = ecx

; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Swap_alloc, COMDAT
; _this$ = ecx

; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Swap_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAE@ABV?$allocator@UResetGroup@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAE@ABV?$allocator@UResetGroup@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UResetGroup@@V?$allocator@UResetGroup@@@std@@@std@@@std@@QAE@ABV?$allocator@UResetGroup@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >::_Vector_alloc<std::_Vec_base_types<ResetGroup,std::allocator<ResetGroup> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEXPAUResetGroup@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEPAUResetGroup@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEPAUResetGroup@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UResetGroup@@@std@@QAEPAUResetGroup@@I@Z ; std::allocator<ResetGroup>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAEPAUResetGroup@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAE@ABV?$allocator@UResetGroup@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAE@ABV?$allocator@UResetGroup@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetGroup> >::_Wrap_alloc<std::allocator<ResetGroup> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UResetGroup@@@std@@@std@@QAE@ABV?$allocator@UResetGroup@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetGroup> >::_Wrap_alloc<std::allocator<ResetGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAIABV?$allocator@UResetGroup@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAIABV?$allocator@UResetGroup@@@2@@Z PROC ; std::allocator_traits<std::allocator<ResetGroup> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UResetGroup@@@std@@@std@@SAIABV?$allocator@UResetGroup@@@2@@Z ENDP ; std::allocator_traits<std::allocator<ResetGroup> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UResetGroup@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UResetGroup@@@std@@QBEIXZ PROC	; std::allocator<ResetGroup>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UResetGroup@@@std@@QBEIXZ ENDP	; std::allocator<ResetGroup>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UResetGroup@@@std@@QAEPAUResetGroup@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UResetGroup@@@std@@QAEPAUResetGroup@@I@Z PROC ; std::allocator<ResetGroup>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d 8d 89 f4 00	 cmp	 eax, 16025997		; 00f4898dH
  00013	77 3f		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	69 c0 0c 01 00
	00		 imul	 eax, eax, 268

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@UResetGroup@@@std@@QAEPAUResetGroup@@I@Z ENDP ; std::allocator<ResetGroup>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z PROC ; std::allocator<ResetGroup>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d 8d 89 f4 00	 cmp	 eax, 16025997		; 00f4898dH
  0000e	77 34		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	69 c0 0c 01 00
	00		 imul	 eax, eax, 268

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 639  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@UResetGroup@@@std@@QAEXPAUResetGroup@@I@Z ENDP ; std::allocator<ResetGroup>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UResetGroup@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UResetGroup@@@std@@QAE@ABV01@@Z PROC	; std::allocator<ResetGroup>::allocator<ResetGroup>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UResetGroup@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<ResetGroup>::allocator<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UResetGroup@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UResetGroup@@@std@@QAE@XZ PROC		; std::allocator<ResetGroup>::allocator<ResetGroup>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UResetGroup@@@std@@QAE@XZ ENDP		; std::allocator<ResetGroup>::allocator<ResetGroup>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??_GResetGroup@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GResetGroup@@QAEPAXI@Z PROC				; ResetGroup::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00006	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  0000c	57		 push	 edi
  0000d	8d be f0 00 00
	00		 lea	 edi, DWORD PTR [esi+240]
  00013	85 c9		 test	 ecx, ecx
  00015	74 33		 je	 SHORT $LN11@scalar

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00017	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0001a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001f	2b d1		 sub	 edx, ecx
  00021	f7 ea		 imul	 edx
  00023	c1 fa 02	 sar	 edx, 2
  00026	8b c2		 mov	 eax, edx
  00028	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002b	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	8b cf		 mov	 ecx, edi
  00031	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00036	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1663 : 			this->_Mylast() = pointer();

  0003c	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00043	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN11@scalar:
  0004a	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0004e	74 0e		 je	 SHORT $LN102@scalar
  00050	68 0c 01 00 00	 push	 268			; 0000010cH
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005b	83 c4 08	 add	 esp, 8
$LN102@scalar:
  0005e	5f		 pop	 edi
  0005f	8b c6		 mov	 eax, esi
  00061	5e		 pop	 esi
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??_GResetGroup@@QAEPAXI@Z ENDP				; ResetGroup::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0ResetGroup@@QAE@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0ResetGroup@@QAE@$$QAU0@@Z PROC			; ResetGroup::ResetGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  0000e	56		 push	 esi
  0000f	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00012	8d 72 2c	 lea	 esi, DWORD PTR [edx+44]
  00015	57		 push	 edi
  00016	66 89 03	 mov	 WORD PTR [ebx], ax
  00019	8d 7b 2c	 lea	 edi, DWORD PTR [ebx+44]
  0001c	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00020	66 89 43 02	 mov	 WORD PTR [ebx+2], ax
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00030	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00033	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00036	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00039	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0003c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0003f	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  00042	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00045	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00048	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0004b	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  0004e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00051	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00054	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00057	89 43 24	 mov	 DWORD PTR [ebx+36], eax
  0005a	0f b6 42 28	 movzx	 eax, BYTE PTR [edx+40]
  0005e	88 43 28	 mov	 BYTE PTR [ebx+40], al
  00061	f3 a5		 rep movsd

; 480  : 		_Myfirst = pointer();

  00063	c7 83 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+240], 0

; 481  : 		_Mylast = pointer();

  0006d	c7 83 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+244], 0

; 482  : 		_Myend = pointer();

  00077	c7 83 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+248], 0

; 483  : 		}
; 484  : 
; 485  : 	pointer _Myfirst;	// pointer to beginning of array
; 486  : 	pointer _Mylast;	// pointer to current end of sequence
; 487  : 	pointer _Myend;	// pointer to end of array
; 488  : 	};
; 489  : 
; 490  : 		// TEMPLATE CLASS _Vector_alloc
; 491  : template<class _Alloc_types>
; 492  : 	class _Vector_alloc
; 493  : 	{	// base class for vector to hold allocator
; 494  : public:
; 495  : 	typedef _Vector_alloc<_Alloc_types> _Myt;
; 496  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 497  : 	typedef typename _Alloc_types::_Alty _Alty;
; 498  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 499  : 
; 500  : 	typedef typename _Val_types::value_type value_type;
; 501  : 	typedef typename _Val_types::size_type size_type;
; 502  : 	typedef typename _Val_types::difference_type difference_type;
; 503  : 	typedef typename _Val_types::pointer pointer;
; 504  : 	typedef typename _Val_types::const_pointer const_pointer;
; 505  : 	typedef typename _Val_types::reference reference;
; 506  : 	typedef typename _Val_types::const_reference const_reference;
; 507  : 
; 508  : 	typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
; 509  : 	typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;
; 510  : 
; 511  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 512  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 513  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 514  : 		{	// construct allocator from _Al
; 515  : 		}
; 516  : 
; 517  : 	_Vector_alloc(_Alloc&& _Al)
; 518  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 519  : 		{	// construct allocator from _Al
; 520  : 		}
; 521  : 
; 522  : 	void _Copy_alloc(const _Alty& _Al)
; 523  : 		{	// replace old allocator
; 524  : 		_Pocca(_Getal(), _Al);
; 525  : 		}
; 526  : 
; 527  : 	void _Move_alloc(_Alty& _Al)
; 528  : 		{	// replace old allocator
; 529  : 		_Pocma(_Getal(), _Al);
; 530  : 		}
; 531  : 
; 532  : 	void _Swap_alloc(_Myt& _Right)
; 533  : 		{	// swap allocators
; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}
; 536  : 
; 537  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 538  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 539  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 540  : 		{	// construct allocator from _Al
; 541  : 		_Alloc_proxy();
; 542  : 		}
; 543  : 
; 544  : 	_Vector_alloc(_Alloc&& _Al)
; 545  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 546  : 		{	// construct allocator from _Al
; 547  : 		_Alloc_proxy();
; 548  : 		}
; 549  : 
; 550  : 	~_Vector_alloc() _NOEXCEPT
; 551  : 		{	// destroy proxy
; 552  : 		_Free_proxy();
; 553  : 		}
; 554  : 
; 555  : 	void _Copy_alloc(const _Alty& _Al)
; 556  : 		{	// replace old allocator
; 557  : 		_Free_proxy();
; 558  : 		_Pocca(_Getal(), _Al);
; 559  : 		_Alloc_proxy();
; 560  : 		}
; 561  : 
; 562  : 	void _Move_alloc(_Alty& _Al)
; 563  : 		{	// replace old allocator
; 564  : 		_Free_proxy();
; 565  : 		_Pocma(_Getal(), _Al);
; 566  : 		_Alloc_proxy();
; 567  : 		}
; 568  : 
; 569  : 	void _Swap_alloc(_Myt& _Right)
; 570  : 		{	// swap allocators
; 571  : 		_Pocs(_Getal(), _Right._Getal());
; 572  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 573  : 		}
; 574  : 
; 575  : 	void _Alloc_proxy()
; 576  : 		{	// construct proxy
; 577  : 		typename _Alty::template rebind<_Container_proxy>::other
; 578  : 			_Alproxy(_Getal());
; 579  : 		_Myproxy() = _Alproxy.allocate(1);
; 580  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 581  : 		_Myproxy()->_Mycont = &_Get_data();
; 582  : 		}
; 583  : 
; 584  : 	void _Free_proxy()
; 585  : 		{	// destroy proxy
; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());
; 588  : 		_Orphan_all();
; 589  : 		_Alproxy.destroy(_Myproxy());
; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 591  : 		_Myproxy() = 0;
; 592  : 		}
; 593  : 
; 594  : 	_Iterator_base12 **_Getpfirst() const
; 595  : 		{	// get address of iterator chain
; 596  : 		return (_Get_data()._Getpfirst());
; 597  : 		}
; 598  : 
; 599  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 600  : 		{	// return reference to _Myproxy
; 601  : 		return (_Get_data()._Myproxy);
; 602  : 		}
; 603  : 
; 604  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 605  : 		{	// return const reference to _Myproxy
; 606  : 		return (_Get_data()._Myproxy);
; 607  : 		}
; 608  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 609  : 
; 610  : 	void _Orphan_all()
; 611  : 		{	// orphan all iterators
; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_all(_Myt& _Right)
; 616  : 		{	// swap all iterators
; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}
; 619  : 
; 620  : 	_Alty& _Getal() _NOEXCEPT
; 621  : 		{	// return reference to allocator
; 622  : 		return (_Mypair._Get_first());
; 623  : 		}
; 624  : 
; 625  : 	const _Alty& _Getal() const _NOEXCEPT
; 626  : 		{	// return const reference to allocator
; 627  : 		return (_Mypair._Get_first());
; 628  : 		}
; 629  : 
; 630  : 	_Vector_val<_Val_types>& _Get_data() _NOEXCEPT
; 631  : 		{	// return reference to _Vector_val
; 632  : 		return (_Mypair._Get_second());
; 633  : 		}
; 634  : 
; 635  : 	const _Vector_val<_Val_types>& _Get_data() const _NOEXCEPT
; 636  : 		{	// return const reference to _Vector_val
; 637  : 		return (_Mypair._Get_second());
; 638  : 		}
; 639  : 
; 640  : 	pointer& _Myfirst() _NOEXCEPT
; 641  : 		{	// return reference to _Myfirst
; 642  : 		return (_Get_data()._Myfirst);
; 643  : 		}
; 644  : 
; 645  : 	const pointer& _Myfirst() const _NOEXCEPT
; 646  : 		{	// return const reference to _Myfirst
; 647  : 		return (_Get_data()._Myfirst);
; 648  : 		}
; 649  : 
; 650  : 	pointer& _Mylast() _NOEXCEPT
; 651  : 		{	// return reference to _Mylast
; 652  : 		return (_Get_data()._Mylast);
; 653  : 		}
; 654  : 
; 655  : 	const pointer& _Mylast() const _NOEXCEPT
; 656  : 		{	// return const reference to _Mylast
; 657  : 		return (_Get_data()._Mylast);
; 658  : 		}
; 659  : 
; 660  : 	pointer& _Myend() _NOEXCEPT
; 661  : 		{	// return reference to _Myend
; 662  : 		return (_Get_data()._Myend);
; 663  : 		}
; 664  : 
; 665  : 	const pointer& _Myend() const _NOEXCEPT
; 666  : 		{	// return const reference to _Myend
; 667  : 		return (_Get_data()._Myend);
; 668  : 		}
; 669  : 
; 670  : private:
; 671  : 	_Compressed_pair<_Alty, _Vector_val<_Val_types> > _Mypair;
; 672  : 	};
; 673  : 
; 674  : 		// TEMPLATE CLASS vector
; 675  : template<class _Ty,
; 676  : 	class _Alloc = allocator<_Ty> >
; 677  : 	class vector
; 678  : 		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >
; 679  : 	{	// varying size array of values
; 680  : public:
; 681  : 	typedef vector<_Ty, _Alloc> _Myt;
; 682  : 	typedef _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 683  : 	typedef _Alloc allocator_type;
; 684  : 
; 685  : 	typedef typename _Mybase::_Alty _Alty;
; 686  : 
; 687  : 	typedef typename _Mybase::value_type value_type;
; 688  : 	typedef typename _Mybase::size_type size_type;
; 689  : 	typedef typename _Mybase::difference_type difference_type;
; 690  : 	typedef typename _Mybase::pointer pointer;
; 691  : 	typedef typename _Mybase::const_pointer const_pointer;
; 692  : 	typedef typename _Mybase::reference reference;
; 693  : 	typedef typename _Mybase::const_reference const_reference;
; 694  : 
; 695  :  #define _VICONT(it)	it._Getcont()
; 696  :  #define _VIPTR(it)	(it)._Ptr
; 697  : 
; 698  : 	typedef typename _Mybase::iterator iterator;
; 699  : 	typedef typename _Mybase::const_iterator const_iterator;
; 700  : 
; 701  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 702  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 703  : 
; 704  : 	vector() _NOEXCEPT
; 705  : 		: _Mybase()
; 706  : 		{	// construct empty vector
; 707  : 		}
; 708  : 
; 709  : 	explicit vector(const _Alloc& _Al) _NOEXCEPT
; 710  : 		: _Mybase(_Al)
; 711  : 		{	// construct empty vector, allocator
; 712  : 		}
; 713  : 
; 714  : 	explicit vector(size_type _Count)
; 715  : 		: _Mybase()
; 716  : 		{	// construct from _Count * value_type()
; 717  : 		if (_Buy(_Count))
; 718  : 			{	// nonzero, fill it
; 719  : 			_TRY_BEGIN
; 720  : 			_Uninitialized_default_fill_n(this->_Myfirst(), _Count,
; 721  : 				this->_Getal());
; 722  : 			this->_Mylast() += _Count;
; 723  : 			_CATCH_ALL
; 724  : 			_Tidy();
; 725  : 			_RERAISE;
; 726  : 			_CATCH_END
; 727  : 			}
; 728  : 		}
; 729  : 
; 730  : 	vector(size_type _Count, const value_type& _Val)
; 731  : 		: _Mybase()
; 732  : 		{	// construct from _Count * _Val
; 733  : 		_Construct_n(_Count, _STD addressof(_Val));
; 734  : 		}
; 735  : 
; 736  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 737  : 		: _Mybase(_Al)
; 738  : 		{	// construct from _Count * _Val, allocator
; 739  : 		_Construct_n(_Count, _STD addressof(_Val));
; 740  : 		}
; 741  : 
; 742  : 	vector(const _Myt& _Right)
; 743  : 
; 744  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 745  : 
; 746  : 
; 747  : 		{	// construct by copying _Right
; 748  : 		if (_Buy(_Right.size()))
; 749  : 			_TRY_BEGIN
; 750  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 751  : 				this->_Myfirst());
; 752  : 			_CATCH_ALL
; 753  : 			_Tidy();
; 754  : 			_RERAISE;
; 755  : 			_CATCH_END
; 756  : 		}
; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();

  00081	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]
  00087	89 83 f0 00 00
	00		 mov	 DWORD PTR [ebx+240], eax

; 870  : 		this->_Mylast() = _Right._Mylast();

  0008d	8b 82 f4 00 00
	00		 mov	 eax, DWORD PTR [edx+244]
  00093	89 83 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], eax

; 871  : 		this->_Myend() = _Right._Myend();

  00099	8b 82 f8 00 00
	00		 mov	 eax, DWORD PTR [edx+248]
  0009f	89 83 f8 00 00
	00		 mov	 DWORD PTR [ebx+248], eax

; 872  : 
; 873  : 		_Right._Myfirst() = pointer();

  000a5	c7 82 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+240], 0

; 874  : 		_Right._Mylast() = pointer();

  000af	c7 82 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+244], 0

; 875  : 		_Right._Myend() = pointer();

  000b9	c7 82 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+248], 0
  000c3	f3 0f 7e 82 fc
	00 00 00	 movq	 xmm0, QWORD PTR [edx+252]
  000cb	66 0f d6 83 fc
	00 00 00	 movq	 QWORD PTR [ebx+252], xmm0
  000d3	0f b7 82 04 01
	00 00		 movzx	 eax, WORD PTR [edx+260]
  000da	66 89 83 04 01
	00 00		 mov	 WORD PTR [ebx+260], ax
  000e1	0f b7 82 06 01
	00 00		 movzx	 eax, WORD PTR [edx+262]
  000e8	66 89 83 06 01
	00 00		 mov	 WORD PTR [ebx+262], ax
  000ef	0f b6 82 08 01
	00 00		 movzx	 eax, BYTE PTR [edx+264]
  000f6	5f		 pop	 edi
  000f7	88 83 08 01 00
	00		 mov	 BYTE PTR [ebx+264], al
  000fd	8b c3		 mov	 eax, ebx
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
??0ResetGroup@@QAE@$$QAU0@@Z ENDP			; ResetGroup::ResetGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ResetGroup@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ResetGroup@@QAE@ABU0@@Z PROC				; ResetGroup::ResetGroup, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b d1		 mov	 edx, ecx
  00006	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  0000b	53		 push	 ebx
  0000c	8b 5d 08	 mov	 ebx, DWORD PTR ___that$[ebp]
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8d 7a 2c	 lea	 edi, DWORD PTR [edx+44]
  00014	89 55 fc	 mov	 DWORD PTR _this$[ebp], edx
  00017	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  0001a	8d 73 2c	 lea	 esi, DWORD PTR [ebx+44]
  0001d	66 89 02	 mov	 WORD PTR [edx], ax
  00020	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  00024	66 89 42 02	 mov	 WORD PTR [edx+2], ax
  00028	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002b	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0002e	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00031	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00034	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00037	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0003a	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0003d	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00040	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00043	89 42 14	 mov	 DWORD PTR [edx+20], eax
  00046	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00049	89 42 18	 mov	 DWORD PTR [edx+24], eax
  0004c	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0004f	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  00052	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00055	89 42 20	 mov	 DWORD PTR [edx+32], eax
  00058	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0005b	89 42 24	 mov	 DWORD PTR [edx+36], eax
  0005e	0f b6 43 28	 movzx	 eax, BYTE PTR [ebx+40]
  00062	88 42 28	 mov	 BYTE PTR [edx+40], al
  00065	8d 83 f0 00 00
	00		 lea	 eax, DWORD PTR [ebx+240]
  0006b	f3 a5		 rep movsd
  0006d	50		 push	 eax
  0006e	8d 8a f0 00 00
	00		 lea	 ecx, DWORD PTR [edx+240]
  00074	e8 00 00 00 00	 call	 ??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	f3 0f 7e 83 fc
	00 00 00	 movq	 xmm0, QWORD PTR [ebx+252]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	66 0f d6 81 fc
	00 00 00	 movq	 QWORD PTR [ecx+252], xmm0
  0008e	0f b7 83 04 01
	00 00		 movzx	 eax, WORD PTR [ebx+260]
  00095	66 89 81 04 01
	00 00		 mov	 WORD PTR [ecx+260], ax
  0009c	0f b7 83 06 01
	00 00		 movzx	 eax, WORD PTR [ebx+262]
  000a3	66 89 81 06 01
	00 00		 mov	 WORD PTR [ecx+262], ax
  000aa	0f b6 83 08 01
	00 00		 movzx	 eax, BYTE PTR [ebx+264]
  000b1	88 81 08 01 00
	00		 mov	 BYTE PTR [ecx+264], al
  000b7	8b c1		 mov	 eax, ecx
  000b9	5b		 pop	 ebx
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
??0ResetGroup@@QAE@ABU0@@Z ENDP				; ResetGroup::ResetGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1ResetGroup@@QAE@XZ
_TEXT	SEGMENT
??1ResetGroup@@QAE@XZ PROC				; ResetGroup::~ResetGroup, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8d b1 f0 00 00
	00		 lea	 esi, DWORD PTR [ecx+240]
  00007	57		 push	 edi

; 1656 : 		if (this->_Myfirst() != pointer())

  00008	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000a	85 ff		 test	 edi, edi
  0000c	74 33		 je	 SHORT $LN7@ResetGroup

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0000e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00011	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00016	2b cf		 sub	 ecx, edi
  00018	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001a	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0001c	c1 fa 02	 sar	 edx, 2
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00026	50		 push	 eax
  00027	57		 push	 edi
  00028	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00033	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN7@ResetGroup:
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	c3		 ret	 0
??1ResetGroup@@QAE@XZ ENDP				; ResetGroup::~ResetGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0ResetGroup@@QAE@XZ
_TEXT	SEGMENT
??0ResetGroup@@QAE@XZ PROC				; ResetGroup::ResetGroup, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 81 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+240], 0
  0000a	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  0000c	c7 81 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+244], 0

; 482  : 		_Myend = pointer();

  00016	c7 81 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+248], 0
  00020	c3		 ret	 0
??0ResetGroup@@QAE@XZ ENDP				; ResetGroup::ResetGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEXPAUResetItem@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEXPAUResetItem@@0@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEXPAUResetItem@@0@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEXXZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEXXZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXXZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 33		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	c1 fa 02	 sar	 edx, 2
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00035	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0003c	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0003d	c3		 ret	 0
?_Tidy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXXZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv202 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 1646 : 		if (_Unused_capacity() < _Count)

  0000d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00010	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00013	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	c1 fa 02	 sar	 edx, 2
  0001d	8b c2		 mov	 eax, edx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx

; 1646 : 		if (_Unused_capacity() < _Count)

  00024	3b c7		 cmp	 eax, edi
  00026	73 61		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00028	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002a	2b f0		 sub	 esi, eax
  0002c	89 45 08	 mov	 DWORD PTR tv202[ebp], eax
  0002f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00034	f7 ee		 imul	 esi

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00036	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003b	c1 fa 02	 sar	 edx, 2
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00043	03 ca		 add	 ecx, edx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00045	2b c1		 sub	 eax, ecx
  00047	3b c7		 cmp	 eax, edi
  00049	72 45		 jb	 SHORT $LN134@Reserve

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	03 f9		 add	 edi, ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0004d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00052	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00055	2b 4d 08	 sub	 ecx, DWORD PTR tv202[ebp]
  00058	f7 e9		 imul	 ecx
  0005a	c1 fa 02	 sar	 edx, 2
  0005d	8b f2		 mov	 esi, edx
  0005f	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00062	03 f2		 add	 esi, edx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00064	ba aa aa aa 0a	 mov	 edx, 178956970		; 0aaaaaaaH
  00069	8b c6		 mov	 eax, esi
  0006b	d1 e8		 shr	 eax, 1
  0006d	2b d0		 sub	 edx, eax
  0006f	3b d6		 cmp	 edx, esi
  00071	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00074	b8 00 00 00 00	 mov	 eax, 0
  00079	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  0007c	3b cf		 cmp	 ecx, edi
  0007e	0f 42 cf	 cmovb	 ecx, edi

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00081	51		 push	 ecx
  00082	8b cb		 mov	 ecx, ebx
  00084	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reallocate
$LN2@Reserve:
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1651 : 			}
; 1652 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  0009a	cc		 int	 3
?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z ; std::allocator<ResetItem>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	8b f8		 mov	 edi, eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00044	6a 00		 push	 0
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	ff 76 04	 push	 DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0004b	89 7d ec	 mov	 DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004e	ff 36		 push	 DWORD PTR [esi]
  00050	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@U1@@std@@YAPAUResetItem@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ResetItem *,ResetItem *,std::allocator<ResetItem>,ResetItem>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00055	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00058	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005d	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0005f	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00062	f7 e9		 imul	 ecx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00064	8b 06		 mov	 eax, DWORD PTR [esi]

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00066	c1 fa 02	 sar	 edx, 2
  00069	8b da		 mov	 ebx, edx
  0006b	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0006e	03 da		 add	 ebx, edx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00070	85 c0		 test	 eax, eax
  00072	74 20		 je	 SHORT $LN3@Reallocate

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00074	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00077	2b c8		 sub	 ecx, eax
  00079	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007e	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00080	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00082	c1 fa 02	 sar	 edx, 2
  00085	8b c2		 mov	 eax, edx
  00087	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0008c	50		 push	 eax
  0008d	ff 36		 push	 DWORD PTR [esi]
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1639 : 		this->_Myend() = _Ptr + _Count;

  00094	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00097	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0009a	8d 04 c7	 lea	 eax, DWORD PTR [edi+eax*8]
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  000a0	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  000a3	8d 04 c7	 lea	 eax, DWORD PTR [edi+eax*8]
  000a6	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  000a9	89 3e		 mov	 DWORD PTR [esi], edi

; 1642 : 		}

  000ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b5	59		 pop	 ecx
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000bf	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000c2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000c8	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1627 : 		_RERAISE;

  000cd	6a 00		 push	 0
  000cf	6a 00		 push	 0
  000d1	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN179@Reallocate:
$LN178@Reallocate:
  000d6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBE_NPBUResetItem@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBE_NPBUResetItem@@@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBE_NPBUResetItem@@@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEII@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0000d	b9 aa aa aa 0a	 mov	 ecx, 178956970		; 0aaaaaaaH

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00012	f7 ea		 imul	 edx
  00014	56		 push	 esi
  00015	c1 fa 02	 sar	 edx, 2
  00018	8b f2		 mov	 esi, edx
  0001a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001d	03 f2		 add	 esi, edx

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001f	8b c6		 mov	 eax, esi
  00021	d1 e8		 shr	 eax, 1
  00023	57		 push	 edi
  00024	2b c8		 sub	 ecx, eax
  00026	33 ff		 xor	 edi, edi
  00028	3b ce		 cmp	 ecx, esi
  0002a	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0002d	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00030	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00033	5f		 pop	 edi
  00034	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  00038	8b c2		 mov	 eax, edx
  0003a	5e		 pop	 esi

; 1612 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IBEII@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXPAUResetItem@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXPAUResetItem@@0@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXPAUResetItem@@0@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAE_NI@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Buy, COMDAT
; _this$ = ecx

; 1580 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1586 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 1596 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1587 : 		else if (max_size() < _Capacity)

  0002a	81 ff aa aa aa
	0a		 cmp	 edi, 178956970		; 0aaaaaaaH
  00030	77 1e		 ja	 SHORT $LN109@Buy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z ; std::allocator<ResetItem>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00038	89 06		 mov	 DWORD PTR [esi], eax

; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  0003a	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  0003d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	5f		 pop	 edi
  00043	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  00046	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1594 : 			}
; 1595 : 		return (true);

  00049	b0 01		 mov	 al, 1
  0004b	5e		 pop	 esi

; 1596 : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
$LN109@Buy:

; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00055	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Buy:
$LN108@Buy:
  0005a	cc		 int	 3
?_Buy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEXABUResetItem@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEXABUResetItem@@@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4f		 jae	 SHORT $LN2@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 49		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	c1 fa 02	 sar	 edx, 2
  00023	8b fa		 mov	 edi, edx
  00025	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00028	03 fa		 add	 edi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  0002a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002d	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  0002f	6a 01		 push	 1
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00038	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003b	85 d2		 test	 edx, edx
  0003d	74 46		 je	 SHORT $LN205@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00044	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00045	0f 10 04 c8	 movups	 xmm0, XMMWORD PTR [eax+ecx*8]
  00049	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0004c	f3 0f 7e 44 c8
	10		 movq	 xmm0, QWORD PTR [eax+ecx*8+16]
  00052	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00057	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  0005b	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN2@push_back:

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  00060	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00063	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  00065	6a 01		 push	 1
  00067	8b ce		 mov	 ecx, esi
  00069	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXI@Z ; std::vector<ResetItem,std::allocator<ResetItem> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0006e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00071	85 c0		 test	 eax, eax
  00073	74 10		 je	 SHORT $LN205@push_back
  00075	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00078	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0007b	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  00080	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
$LN205@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00085	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?push_back@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEXABUResetItem@@@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEAAUResetItem@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEAAUResetItem@@I@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]

; 1241 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEAAUResetItem@@I@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1180 : 		}

  00016	c3		 ret	 0
?size@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@2@XZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::end, COMDAT
; _this$ = ecx

; 1071 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@2@XZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@2@XZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::begin, COMDAT
; _this$ = ecx

; 1061 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@@2@XZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 02	 sar	 edx, 2
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx

; 1048 : 		}

  00017	c3		 ret	 0
?_Unused_capacity@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1043 : 		}

  00016	c3		 ret	 0
?capacity@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QBEIXZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@XZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::~vector<ResetItem,std::allocator<ResetItem> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 33		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	c1 fa 02	 sar	 edx, 2
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00035	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0003c	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0003d	c3		 ret	 0
??1?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@XZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::~vector<ResetItem,std::allocator<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::_Assign_rv, COMDAT
; _this$ = ecx

; 867  : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 870  : 		this->_Mylast() = _Right._Mylast();

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 871  : 		this->_Myend() = _Right._Myend();

  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 872  : 
; 873  : 		_Right._Myfirst() = pointer();

  00016	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 874  : 		_Right._Mylast() = pointer();

  0001c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 875  : 		_Right._Myend() = pointer();

  00023	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 876  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Assign_rv@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >, COMDAT
; _this$ = ecx

; 840  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]

; 480  : 		_Myfirst = pointer();

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();

  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();

  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 01		 mov	 DWORD PTR [ecx], eax

; 870  : 		this->_Mylast() = _Right._Mylast();

  0001e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00021	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 871  : 		this->_Myend() = _Right._Myend();

  00024	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00027	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}

  0002a	8b c1		 mov	 eax, ecx

; 872  : 
; 873  : 		_Right._Myfirst() = pointer();

  0002c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 874  : 		_Right._Mylast() = pointer();

  00032	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 875  : 		_Right._Myend() = pointer();

  00039	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Right$ = 8						; size = 4
??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >, COMDAT
; _this$ = ecx

; 747  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 483  : 		}
; 484  : 
; 485  : 	pointer _Myfirst;	// pointer to beginning of array
; 486  : 	pointer _Mylast;	// pointer to current end of sequence
; 487  : 	pointer _Myend;	// pointer to end of array
; 488  : 	};
; 489  : 
; 490  : 		// TEMPLATE CLASS _Vector_alloc
; 491  : template<class _Alloc_types>
; 492  : 	class _Vector_alloc
; 493  : 	{	// base class for vector to hold allocator
; 494  : public:
; 495  : 	typedef _Vector_alloc<_Alloc_types> _Myt;
; 496  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 497  : 	typedef typename _Alloc_types::_Alty _Alty;
; 498  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 499  : 
; 500  : 	typedef typename _Val_types::value_type value_type;
; 501  : 	typedef typename _Val_types::size_type size_type;
; 502  : 	typedef typename _Val_types::difference_type difference_type;
; 503  : 	typedef typename _Val_types::pointer pointer;
; 504  : 	typedef typename _Val_types::const_pointer const_pointer;
; 505  : 	typedef typename _Val_types::reference reference;
; 506  : 	typedef typename _Val_types::const_reference const_reference;
; 507  : 
; 508  : 	typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
; 509  : 	typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;
; 510  : 
; 511  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 512  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 513  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 514  : 		{	// construct allocator from _Al
; 515  : 		}
; 516  : 
; 517  : 	_Vector_alloc(_Alloc&& _Al)
; 518  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 519  : 		{	// construct allocator from _Al
; 520  : 		}
; 521  : 
; 522  : 	void _Copy_alloc(const _Alty& _Al)
; 523  : 		{	// replace old allocator
; 524  : 		_Pocca(_Getal(), _Al);
; 525  : 		}
; 526  : 
; 527  : 	void _Move_alloc(_Alty& _Al)
; 528  : 		{	// replace old allocator
; 529  : 		_Pocma(_Getal(), _Al);
; 530  : 		}
; 531  : 
; 532  : 	void _Swap_alloc(_Myt& _Right)
; 533  : 		{	// swap allocators
; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}
; 536  : 
; 537  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 538  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 539  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 540  : 		{	// construct allocator from _Al
; 541  : 		_Alloc_proxy();
; 542  : 		}
; 543  : 
; 544  : 	_Vector_alloc(_Alloc&& _Al)
; 545  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 546  : 		{	// construct allocator from _Al
; 547  : 		_Alloc_proxy();
; 548  : 		}
; 549  : 
; 550  : 	~_Vector_alloc() _NOEXCEPT
; 551  : 		{	// destroy proxy
; 552  : 		_Free_proxy();
; 553  : 		}
; 554  : 
; 555  : 	void _Copy_alloc(const _Alty& _Al)
; 556  : 		{	// replace old allocator
; 557  : 		_Free_proxy();
; 558  : 		_Pocca(_Getal(), _Al);
; 559  : 		_Alloc_proxy();
; 560  : 		}
; 561  : 
; 562  : 	void _Move_alloc(_Alty& _Al)
; 563  : 		{	// replace old allocator
; 564  : 		_Free_proxy();
; 565  : 		_Pocma(_Getal(), _Al);
; 566  : 		_Alloc_proxy();
; 567  : 		}
; 568  : 
; 569  : 	void _Swap_alloc(_Myt& _Right)
; 570  : 		{	// swap allocators
; 571  : 		_Pocs(_Getal(), _Right._Getal());
; 572  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 573  : 		}
; 574  : 
; 575  : 	void _Alloc_proxy()
; 576  : 		{	// construct proxy
; 577  : 		typename _Alty::template rebind<_Container_proxy>::other
; 578  : 			_Alproxy(_Getal());
; 579  : 		_Myproxy() = _Alproxy.allocate(1);
; 580  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 581  : 		_Myproxy()->_Mycont = &_Get_data();
; 582  : 		}
; 583  : 
; 584  : 	void _Free_proxy()
; 585  : 		{	// destroy proxy
; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());
; 588  : 		_Orphan_all();
; 589  : 		_Alproxy.destroy(_Myproxy());
; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 591  : 		_Myproxy() = 0;
; 592  : 		}
; 593  : 
; 594  : 	_Iterator_base12 **_Getpfirst() const
; 595  : 		{	// get address of iterator chain
; 596  : 		return (_Get_data()._Getpfirst());
; 597  : 		}
; 598  : 
; 599  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 600  : 		{	// return reference to _Myproxy
; 601  : 		return (_Get_data()._Myproxy);
; 602  : 		}
; 603  : 
; 604  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 605  : 		{	// return const reference to _Myproxy
; 606  : 		return (_Get_data()._Myproxy);
; 607  : 		}
; 608  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 609  : 
; 610  : 	void _Orphan_all()
; 611  : 		{	// orphan all iterators
; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_all(_Myt& _Right)
; 616  : 		{	// swap all iterators
; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}
; 619  : 
; 620  : 	_Alty& _Getal() _NOEXCEPT
; 621  : 		{	// return reference to allocator
; 622  : 		return (_Mypair._Get_first());
; 623  : 		}
; 624  : 
; 625  : 	const _Alty& _Getal() const _NOEXCEPT
; 626  : 		{	// return const reference to allocator
; 627  : 		return (_Mypair._Get_first());
; 628  : 		}
; 629  : 
; 630  : 	_Vector_val<_Val_types>& _Get_data() _NOEXCEPT
; 631  : 		{	// return reference to _Vector_val
; 632  : 		return (_Mypair._Get_second());
; 633  : 		}
; 634  : 
; 635  : 	const _Vector_val<_Val_types>& _Get_data() const _NOEXCEPT
; 636  : 		{	// return const reference to _Vector_val
; 637  : 		return (_Mypair._Get_second());
; 638  : 		}
; 639  : 
; 640  : 	pointer& _Myfirst() _NOEXCEPT
; 641  : 		{	// return reference to _Myfirst
; 642  : 		return (_Get_data()._Myfirst);
; 643  : 		}
; 644  : 
; 645  : 	const pointer& _Myfirst() const _NOEXCEPT
; 646  : 		{	// return const reference to _Myfirst
; 647  : 		return (_Get_data()._Myfirst);
; 648  : 		}
; 649  : 
; 650  : 	pointer& _Mylast() _NOEXCEPT
; 651  : 		{	// return reference to _Mylast
; 652  : 		return (_Get_data()._Mylast);
; 653  : 		}
; 654  : 
; 655  : 	const pointer& _Mylast() const _NOEXCEPT
; 656  : 		{	// return const reference to _Mylast
; 657  : 		return (_Get_data()._Mylast);

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00033	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH

; 480  : 		_Myfirst = pointer();

  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 481  : 		_Mylast = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 482  : 		_Myend = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0004c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0004f	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00051	f7 e9		 imul	 ecx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();

  00053	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00059	c1 fa 02	 sar	 edx, 2
  0005c	8b fa		 mov	 edi, edx

; 1582 : 		this->_Mylast() = pointer();

  0005e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00065	c1 ef 1f	 shr	 edi, 31			; 0000001fH

; 1583 : 		this->_Myend() = pointer();

  00068	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0006f	03 fa		 add	 edi, edx

; 1584 : 
; 1585 : 		if (_Capacity == 0)

  00071	74 47		 je	 SHORT $LN7@vector

; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)

  00073	81 ff aa aa aa
	0a		 cmp	 edi, 178956970		; 0aaaaaaaH
  00079	76 0a		 jbe	 SHORT $LN58@vector

; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00080	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN254@vector:
$LN58@vector:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00085	57		 push	 edi
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z ; std::allocator<ResetItem>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  0008d	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00090	89 06		 mov	 DWORD PTR [esi], eax

; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  00092	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00095	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00098	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  0009a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 749  : 			_TRY_BEGIN

  0009b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  000a2	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  000a5	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  000a8	ff 36		 push	 DWORD PTR [esi]
  000aa	ff 73 04	 push	 DWORD PTR [ebx+4]
  000ad	ff 33		 push	 DWORD PTR [ebx]
  000af	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUResetItem@@PAU1@V?$allocator@UResetItem@@@std@@@std@@YAPAUResetItem@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ResetItem const *,ResetItem *,std::allocator<ResetItem> >
  000b4	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 750  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

  000b7	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@vector:

; 755  : 			_CATCH_END
; 756  : 		}

  000ba	8b c6		 mov	 eax, esi
  000bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c6	59		 pop	 ecx
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
__catch$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z$0:

; 751  : 				this->_Myfirst());
; 752  : 			_CATCH_ALL
; 753  : 			_Tidy();

  000d0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@IAEXXZ ; std::vector<ResetItem,std::allocator<ResetItem> >::_Tidy

; 754  : 			_RERAISE;

  000d8	6a 00		 push	 0
  000da	6a 00		 push	 0
  000dc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN255@vector:
$LN253@vector:
  000e1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@XZ PROC ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@QAE@XZ ENDP ; std::vector<ResetItem,std::allocator<ResetItem> >::vector<ResetItem,std::allocator<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ResetItem> >,std::_Vector_val<std::_Simple_types<ResetItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<ResetItem> >::_Vector_val<std::_Simple_types<ResetItem> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<ResetItem> >::_Vector_val<std::_Simple_types<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABQAUResetItem@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAPAUResetItem@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UResetItem@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Swap_all, COMDAT
; _this$ = ecx

; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAE@$$QAV?$allocator@UResetItem@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAE@$$QAV?$allocator@UResetItem@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 520  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 520  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAE@$$QAV?$allocator@UResetItem@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAE@ABV?$allocator@UResetItem@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAE@ABV?$allocator@UResetItem@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UResetItem@@V?$allocator@UResetItem@@@std@@@std@@@std@@QAE@ABV?$allocator@UResetItem@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >::_Vector_alloc<std::_Vec_base_types<ResetItem,std::allocator<ResetItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ; std::allocator<ResetItem>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEXPAUResetItem@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEPAUResetItem@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEPAUResetItem@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z ; std::allocator<ResetItem>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAEPAUResetItem@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV?$allocator@UResetItem@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV?$allocator@UResetItem@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::_Wrap_alloc<std::allocator<ResetItem> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QAE@ABV?$allocator@UResetItem@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::_Wrap_alloc<std::allocator<ResetItem> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<ResetItem> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 828  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 829  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 830  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UResetItem@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ResetItem> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SA?AV?$allocator@UResetItem@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SA?AV?$allocator@UResetItem@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<ResetItem> >::select_on_container_copy_construction, COMDAT

; 790  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 791  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 792  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SA?AV?$allocator@UResetItem@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<ResetItem> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAIABV?$allocator@UResetItem@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAIABV?$allocator@UResetItem@@@2@@Z PROC ; std::allocator_traits<std::allocator<ResetItem> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UResetItem@@@std@@@std@@SAIABV?$allocator@UResetItem@@@2@@Z ENDP ; std::allocator_traits<std::allocator<ResetItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UResetItem@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UResetItem@@@std@@QBEIXZ PROC	; std::allocator<ResetItem>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UResetItem@@@std@@QBEIXZ ENDP	; std::allocator<ResetItem>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z PROC ; std::allocator<ResetItem>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00013	77 3f		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00018	c1 e0 03	 shl	 eax, 3

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@UResetItem@@@std@@QAEPAUResetItem@@I@Z ENDP ; std::allocator<ResetItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z PROC ; std::allocator<ResetItem>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0000e	77 34		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00013	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 639  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@UResetItem@@@std@@QAEXPAUResetItem@@I@Z ENDP ; std::allocator<ResetItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UResetItem@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UResetItem@@@std@@QAE@ABV01@@Z PROC	; std::allocator<ResetItem>::allocator<ResetItem>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UResetItem@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<ResetItem>::allocator<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UResetItem@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UResetItem@@@std@@QAE@XZ PROC		; std::allocator<ResetItem>::allocator<ResetItem>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UResetItem@@@std@@QAE@XZ ENDP		; std::allocator<ResetItem>::allocator<ResetItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCLogToFile@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCLogToFile@@QAEPAXI@Z PROC				; CLogToFile::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 28 02 01 00	 push	 66088			; 00010228H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCLogToFile@@QAEPAXI@Z ENDP				; CLogToFile::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 140  : 		lpBuf[0] = 0xC1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]

; 141  : 		lpBuf[1] = size;

  00006	8a 45 14	 mov	 al, BYTE PTR _size$[ebp]
  00009	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 142  : 		lpBuf[2] = head;

  0000c	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  0000f	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 143  : 		lpBuf[3] = sub;

  00012	8a 45 10	 mov	 al, BYTE PTR _sub$[ebp]
  00015	c6 01 c1	 mov	 BYTE PTR [ecx], 193	; 000000c1H
  00018	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 144  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\user.h
;	COMDAT ?GetResetDiscount@BILL_CLASS@@QAEHXZ
_TEXT	SEGMENT
?GetResetDiscount@BILL_CLASS@@QAEHXZ PROC		; BILL_CLASS::GetResetDiscount, COMDAT
; _this$ = ecx

; 2032 : 	int GetResetDiscount() { return ResetDiscount; };

  00000	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00003	c3		 ret	 0
?GetResetDiscount@BILL_CLASS@@QAEHXZ ENDP		; BILL_CLASS::GetResetDiscount
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 48   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 10	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000b	6a ff		 push	 -1
  0000d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00010	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	83 c9 01	 or	 ecx, 1
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1474 :     #pragma warning(push)
; 1475 :     #pragma warning(disable: 4996) // Deprecation
; 1476 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
; 1477 :     #pragma warning(pop)
; 1478 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 973  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\resetsystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 973  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
