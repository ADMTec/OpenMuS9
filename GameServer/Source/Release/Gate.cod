; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\Gate.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CGate@@QAE@XZ				; CGate::CGate
PUBLIC	??1CGate@@UAE@XZ				; CGate::~CGate
PUBLIC	?Init@CGate@@QAEXXZ				; CGate::Init
PUBLIC	?Load@CGate@@QAEXPAD@Z				; CGate::Load
PUBLIC	?IsGate@CGate@@QAEHH@Z				; CGate::IsGate
PUBLIC	?GetGate@CGate@@QAEHHAAE000AAF@Z		; CGate::GetGate
PUBLIC	?GetLevel@CGate@@QAEHH@Z			; CGate::GetLevel
PUBLIC	?IsInGate@CGate@@QAEHHH@Z			; CGate::IsInGate
PUBLIC	?CheckGateLevel@CGate@@QAEHHH@Z			; CGate::CheckGateLevel
PUBLIC	??_GCGate@@UAEPAXI@Z				; CGate::`scalar deleting destructor'
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??_7CGate@@6B@					; CGate::`vftable'
PUBLIC	?gGateC@@3VCGate@@A				; gGateC
PUBLIC	??_C@_0BN@KICDKMJA@?$FLMoveGate?$FN?5Loading?5fail?5?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_08IJGKCABI@movegate?$AA@			; `string'
PUBLIC	??_C@_04NKCHGMLH@gate?$AA@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id?$AA@			; `string'
PUBLIC	??_C@_0CE@JPENMKG@?$FLMoveGate?$FN?5GateNumber?5is?5wrong?5?$FL@ ; `string'
PUBLIC	??_C@_04DNPGJOMD@flag?$AA@			; `string'
PUBLIC	??_C@_03HBNNNHNM@map?$AA@			; `string'
PUBLIC	??_C@_02JMABBILH@x1?$AA@			; `string'
PUBLIC	??_C@_02JNMDHCIA@y1?$AA@			; `string'
PUBLIC	??_C@_02LHCMELHE@x2?$AA@			; `string'
PUBLIC	??_C@_02LGOOCBED@y2?$AA@			; `string'
PUBLIC	??_C@_06JJLAMBGK@target?$AA@			; `string'
PUBLIC	??_C@_03DAPAKLGM@dir?$AA@			; `string'
PUBLIC	??_C@_06GJMPOCOI@minlvl?$AA@			; `string'
PUBLIC	??_C@_06GKDMACKH@maxlvl?$AA@			; `string'
PUBLIC	??_C@_0BO@EPCOJCIM@?$FL?$CFs?$FN?5MoveGate?5has?5been?5loaded?$AA@ ; `string'
PUBLIC	??_C@_08NDPGJHEF@Gate?4cpp?$AA@			; `string'
PUBLIC	??_C@_0P@IOOEMHIK@CGate?3?3GetGate?$AA@		; `string'
PUBLIC	??_C@_0DG@JPCODGFL@?$FL?$CFs?$FN?5Wrong?5map?5number?0?5maybe?5asy@ ; `string'
PUBLIC	??_R4CGate@@6B@					; CGate::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGate@@@8				; CGate `RTTI Type Descriptor'
PUBLIC	??_R3CGate@@8					; CGate::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGate@@8					; CGate::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGate@@8				; CGate::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	_rand:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	??_ECGate@@UAEPAXI@Z:PROC			; CGate::`vector deleting destructor'
EXTRN	?LogAddDebug@@YAXPADZZ:PROC			; LogAddDebug
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?as_int@xml_attribute@pugi@@QBEHH@Z:PROC	; pugi::xml_attribute::as_int
EXTRN	??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ:PROC	; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
EXTRN	?next_sibling@xml_node@pugi@@QBE?AV12@XZ:PROC	; pugi::xml_node::next_sibling
EXTRN	?child@xml_node@pugi@@QBE?AV12@PBD@Z:PROC	; pugi::xml_node::child
EXTRN	?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z:PROC ; pugi::xml_node::attribute
EXTRN	??0xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::xml_document
EXTRN	??1xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::~xml_document
EXTRN	?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z:PROC ; pugi::xml_document::load_file
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?gGateC@@3VCGate@@A DB 01e04H DUP (?)			; gGateC
_BSS	ENDS
CRT$XCU	SEGMENT
?gGateC$initializer$@@3P6AXXZA DD FLAT:??__EgGateC@@YAXXZ ; gGateC$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CGate@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGate@@8 DD FLAT:??_R0?AVCGate@@@8	; CGate::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGate@@8
rdata$r	ENDS
;	COMDAT ??_R2CGate@@8
rdata$r	SEGMENT
??_R2CGate@@8 DD FLAT:??_R1A@?0A@EA@CGate@@8		; CGate::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGate@@8
rdata$r	SEGMENT
??_R3CGate@@8 DD 00H					; CGate::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGate@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGate@@@8
data$r	SEGMENT
??_R0?AVCGate@@@8 DD FLAT:??_7type_info@@6B@		; CGate `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGate@@', 00H
data$r	ENDS
;	COMDAT ??_R4CGate@@6B@
rdata$r	SEGMENT
??_R4CGate@@6B@ DD 00H					; CGate::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGate@@@8
	DD	FLAT:??_R3CGate@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DG@JPCODGFL@?$FL?$CFs?$FN?5Wrong?5map?5number?0?5maybe?5asy@
CONST	SEGMENT
??_C@_0DG@JPCODGFL@?$FL?$CFs?$FN?5Wrong?5map?5number?0?5maybe?5asy@ DB '['
	DB	'%s] Wrong map number, maybe async in packet reading!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOOEMHIK@CGate?3?3GetGate?$AA@
CONST	SEGMENT
??_C@_0P@IOOEMHIK@CGate?3?3GetGate?$AA@ DB 'CGate::GetGate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NDPGJHEF@Gate?4cpp?$AA@
CONST	SEGMENT
??_C@_08NDPGJHEF@Gate?4cpp?$AA@ DB 'Gate.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EPCOJCIM@?$FL?$CFs?$FN?5MoveGate?5has?5been?5loaded?$AA@
CONST	SEGMENT
??_C@_0BO@EPCOJCIM@?$FL?$CFs?$FN?5MoveGate?5has?5been?5loaded?$AA@ DB '[%'
	DB	's] MoveGate has been loaded', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKDMACKH@maxlvl?$AA@
CONST	SEGMENT
??_C@_06GKDMACKH@maxlvl?$AA@ DB 'maxlvl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJMPOCOI@minlvl?$AA@
CONST	SEGMENT
??_C@_06GJMPOCOI@minlvl?$AA@ DB 'minlvl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAPAKLGM@dir?$AA@
CONST	SEGMENT
??_C@_03DAPAKLGM@dir?$AA@ DB 'dir', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJLAMBGK@target?$AA@
CONST	SEGMENT
??_C@_06JJLAMBGK@target?$AA@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LGOOCBED@y2?$AA@
CONST	SEGMENT
??_C@_02LGOOCBED@y2?$AA@ DB 'y2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHCMELHE@x2?$AA@
CONST	SEGMENT
??_C@_02LHCMELHE@x2?$AA@ DB 'x2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNMDHCIA@y1?$AA@
CONST	SEGMENT
??_C@_02JNMDHCIA@y1?$AA@ DB 'y1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMABBILH@x1?$AA@
CONST	SEGMENT
??_C@_02JMABBILH@x1?$AA@ DB 'x1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map?$AA@
CONST	SEGMENT
??_C@_03HBNNNHNM@map?$AA@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DNPGJOMD@flag?$AA@
CONST	SEGMENT
??_C@_04DNPGJOMD@flag?$AA@ DB 'flag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JPENMKG@?$FLMoveGate?$FN?5GateNumber?5is?5wrong?5?$FL@
CONST	SEGMENT
??_C@_0CE@JPENMKG@?$FLMoveGate?$FN?5GateNumber?5is?5wrong?5?$FL@ DB '[Mov'
	DB	'eGate] GateNumber is wrong [%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id?$AA@
CONST	SEGMENT
??_C@_02EGCJHIOB@id?$AA@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKCHGMLH@gate?$AA@
CONST	SEGMENT
??_C@_04NKCHGMLH@gate?$AA@ DB 'gate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJGKCABI@movegate?$AA@
CONST	SEGMENT
??_C@_08IJGKCABI@movegate?$AA@ DB 'movegate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KICDKMJA@?$FLMoveGate?$FN?5Loading?5fail?5?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BN@KICDKMJA@?$FLMoveGate?$FN?5Loading?5fail?5?$FL?$CFs?$FN?$AA@ DB '['
	DB	'MoveGate] Loading fail [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CGate@@6B@
CONST	SEGMENT
??_7CGate@@6B@ DD FLAT:??_R4CGate@@6B@			; CGate::`vftable'
	DD	FLAT:??_ECGate@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Load@CGate@@QAEXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CGate@@QAEXPAD@Z$0
__ehfuncinfo$?Load@CGate@@QAEXPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Load@CGate@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FgGateC@@YAXXZ
text$yd	SEGMENT
??__FgGateC@@YAXXZ PROC					; `dynamic atexit destructor for 'gGateC'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  00005	e9 00 00 00 00	 jmp	 ??1CGate@@UAE@XZ	; CGate::~CGate
??__FgGateC@@YAXXZ ENDP					; `dynamic atexit destructor for 'gGateC''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ??__EgGateC@@YAXXZ
text$di	SEGMENT
??__EgGateC@@YAXXZ PROC					; `dynamic initializer for 'gGateC'', COMDAT

; 11   : CGate gGateC;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  00005	e8 00 00 00 00	 call	 ??0CGate@@QAE@XZ	; CGate::CGate
  0000a	68 00 00 00 00	 push	 OFFSET ??__FgGateC@@YAXXZ ; `dynamic atexit destructor for 'gGateC''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EgGateC@@YAXXZ ENDP					; `dynamic initializer for 'gGateC''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCGate@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGate@@UAEPAXI@Z PROC				; CGate::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CGate@@UAE@XZ	; CGate::~CGate
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 04 1e 00 00	 push	 7684			; 00001e04H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCGate@@UAEPAXI@Z ENDP				; CGate::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?CheckGateLevel@CGate@@QAEHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_GateNumber$ = 12					; size = 4
?CheckGateLevel@CGate@@QAEHHH@Z PROC			; CGate::CheckGateLevel, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 275  : 	LPOBJ lpObj = &gObj[aIndex];
; 276  : 
; 277  : 	if ( IsGate(GateNumber) == FALSE )

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _GateNumber$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00010	8b f1		 mov	 esi, ecx
  00012	53		 push	 ebx
  00013	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	e8 00 00 00 00	 call	 ?IsGate@CGate@@QAEHH@Z	; CGate::IsGate
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN2@CheckGateL
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx

; 293  : 	{
; 294  : 		return false;
; 295  : 	}
; 296  : 
; 297  : 	return true;
; 298  : }

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN2@CheckGateL:

; 278  : 	{
; 279  : 		return false;
; 280  : 	}
; 281  : 
; 282  : 	int level = m_Level[GateNumber];
; 283  : 
; 284  : 	if ( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA || lpObj->Class == CLASS_FIGHTER )

  00029	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  00030	0f b7 b4 5e 04
	16 00 00	 movzx	 esi, WORD PTR [esi+ebx*2+5636]
  00038	83 f8 04	 cmp	 eax, 4
  0003b	74 0a		 je	 SHORT $LN4@CheckGateL
  0003d	83 f8 03	 cmp	 eax, 3
  00040	74 05		 je	 SHORT $LN4@CheckGateL
  00042	83 f8 06	 cmp	 eax, 6
  00045	75 14		 jne	 SHORT $LN5@CheckGateL
$LN4@CheckGateL:

; 285  : 	{
; 286  : 		if ( level > 0 )

  00047	85 f6		 test	 esi, esi
  00049	7e 10		 jle	 SHORT $LN5@CheckGateL

; 287  : 		{
; 288  : 			level = (level/3)*2;

  0004b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00050	f7 ee		 imul	 esi
  00052	8b f2		 mov	 esi, edx
  00054	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00057	03 f2		 add	 esi, edx
  00059	03 f6		 add	 esi, esi
$LN5@CheckGateL:

; 289  : 		}
; 290  : 	}
; 291  : 
; 292  : 	if ( lpObj->Level < level )

  0005b	0f bf 8f 96 00
	00 00		 movsx	 ecx, WORD PTR [edi+150]
  00062	33 c0		 xor	 eax, eax
  00064	5f		 pop	 edi
  00065	3b ce		 cmp	 ecx, esi
  00067	5e		 pop	 esi
  00068	0f 9d c0	 setge	 al
  0006b	5b		 pop	 ebx

; 293  : 	{
; 294  : 		return false;
; 295  : 	}
; 296  : 
; 297  : 	return true;
; 298  : }

  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?CheckGateLevel@CGate@@QAEHHH@Z ENDP			; CGate::CheckGateLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?IsInGate@CGate@@QAEHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_GateNumber$ = 12					; size = 4
?IsInGate@CGate@@QAEHHH@Z PROC				; CGate::IsInGate, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 238  : 	LPOBJ lpObj = &gObj[aIndex];
; 239  : 
; 240  : 	if ( IsGate(GateNumber) == FALSE )

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _GateNumber$[ebp]
  00007	56		 push	 esi
  00008	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0000f	57		 push	 edi
  00010	53		 push	 ebx
  00011	8b f9		 mov	 edi, ecx
  00013	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	e8 00 00 00 00	 call	 ?IsGate@CGate@@QAEHH@Z	; CGate::IsGate
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 a2 00 00
	00		 je	 $LN9@IsInGate

; 241  : 	{
; 242  : 		return false;
; 243  : 	}
; 244  : 
; 245  : 	int level = m_Level[GateNumber];
; 246  : 
; 247  : 	if ( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA || lpObj->Class == CLASS_FIGHTER )

  00026	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  0002d	0f b7 8c 5f 04
	16 00 00	 movzx	 ecx, WORD PTR [edi+ebx*2+5636]
  00035	83 f8 04	 cmp	 eax, 4
  00038	74 0a		 je	 SHORT $LN4@IsInGate
  0003a	83 f8 03	 cmp	 eax, 3
  0003d	74 05		 je	 SHORT $LN4@IsInGate
  0003f	83 f8 06	 cmp	 eax, 6
  00042	75 14		 jne	 SHORT $LN5@IsInGate
$LN4@IsInGate:

; 248  : 	{
; 249  : 		if ( level > 0 )

  00044	85 c9		 test	 ecx, ecx
  00046	7e 10		 jle	 SHORT $LN5@IsInGate

; 250  : 		{
; 251  : 			level = level / 3 * 2;

  00048	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0004d	f7 e9		 imul	 ecx
  0004f	8b ca		 mov	 ecx, edx
  00051	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00054	03 ca		 add	 ecx, edx
  00056	03 c9		 add	 ecx, ecx
$LN5@IsInGate:

; 252  : 		}
; 253  : 	}
; 254  : 
; 255  : 	if ( lpObj->Level < level )

  00058	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  0005f	3b c1		 cmp	 eax, ecx
  00061	7c 65		 jl	 SHORT $LN9@IsInGate

; 256  : 	{
; 257  : 		return FALSE;
; 258  : 	}
; 259  : 
; 260  : 	if ( lpObj->MapNumber != m_MapNumber[GateNumber] )

  00063	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  00069	3a 84 3b 04 06
	00 00		 cmp	 al, BYTE PTR [ebx+edi+1540]
  00070	75 56		 jne	 SHORT $LN9@IsInGate

; 261  : 	{
; 262  : 		return FALSE;
; 263  : 	}
; 264  : 
; 265  : 	if ( lpObj->X < m_Sx[GateNumber]-5 || lpObj->X > m_Ex[GateNumber]+5 || lpObj->Y < m_Sy[GateNumber]-5 || lpObj->Y > m_Ey[GateNumber]+5 )

  00072	0f b6 84 3b 04
	08 00 00	 movzx	 eax, BYTE PTR [ebx+edi+2052]
  0007a	0f b6 8e 20 01
	00 00		 movzx	 ecx, BYTE PTR [esi+288]
  00081	83 e8 05	 sub	 eax, 5
  00084	3b c8		 cmp	 ecx, eax
  00086	7c 40		 jl	 SHORT $LN9@IsInGate
  00088	0f b6 84 3b 04
	0c 00 00	 movzx	 eax, BYTE PTR [ebx+edi+3076]
  00090	83 c0 05	 add	 eax, 5
  00093	3b c8		 cmp	 ecx, eax
  00095	7f 31		 jg	 SHORT $LN9@IsInGate
  00097	0f b6 84 3b 04
	0a 00 00	 movzx	 eax, BYTE PTR [ebx+edi+2564]
  0009f	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  000a6	83 e8 05	 sub	 eax, 5
  000a9	3b c8		 cmp	 ecx, eax
  000ab	7c 1b		 jl	 SHORT $LN9@IsInGate
  000ad	0f b6 84 3b 04
	0e 00 00	 movzx	 eax, BYTE PTR [ebx+edi+3588]
  000b5	83 c0 05	 add	 eax, 5
  000b8	3b c8		 cmp	 ecx, eax
  000ba	7f 0c		 jg	 SHORT $LN9@IsInGate

; 268  : 	}
; 269  : 
; 270  : 	return true;

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	5b		 pop	 ebx

; 271  : }

  000c4	5d		 pop	 ebp
  000c5	c2 08 00	 ret	 8
$LN9@IsInGate:
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi

; 266  : 	{
; 267  : 		return FALSE;

  000ca	33 c0		 xor	 eax, eax
  000cc	5b		 pop	 ebx

; 271  : }

  000cd	5d		 pop	 ebp
  000ce	c2 08 00	 ret	 8
?IsInGate@CGate@@QAEHHH@Z ENDP				; CGate::IsInGate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?GetLevel@CGate@@QAEHH@Z
_TEXT	SEGMENT
_GateNumber$ = 8					; size = 4
?GetLevel@CGate@@QAEHH@Z PROC				; CGate::GetLevel, COMDAT
; _this$ = ecx

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	if (GateNumber < 0 || GateNumber > MAX_GATES-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _GateNumber$[ebp]
  00006	3d ff 01 00 00	 cmp	 eax, 511		; 000001ffH
  0000b	77 0c		 ja	 SHORT $LN3@GetLevel

; 229  : 	}
; 230  : 
; 231  : 	return m_Level[GateNumber];

  0000d	0f b7 84 41 04
	16 00 00	 movzx	 eax, WORD PTR [ecx+eax*2+5636]

; 232  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN3@GetLevel:

; 226  : 	{
; 227  : 		LogAdd(lMsg.Get(MSGGET(1, 195)), GateNumber, __FILE__, __LINE__);

  00019	68 e3 00 00 00	 push	 227			; 000000e3H
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_08NDPGJHEF@Gate?4cpp?$AA@
  00023	50		 push	 eax
  00024	68 c3 01 00 00	 push	 451			; 000001c3H
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0002e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 228  : 		return -1;

  0003d	83 c8 ff	 or	 eax, -1

; 232  : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?GetLevel@CGate@@QAEHH@Z ENDP				; CGate::GetLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?GetGate@CGate@@QAEHHAAE000AAF@Z
_TEXT	SEGMENT
_tx$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
_gt$2$ = 8						; size = 4
_mgt$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_MapNumber$ = 20					; size = 4
_dir$ = 24						; size = 4
_Level$ = 28						; size = 4
?GetGate@CGate@@QAEHHAAE000AAF@Z PROC			; CGate::GetGate, COMDAT
; _this$ = ecx

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 159  : 	int gt;
; 160  : 	int tx;
; 161  : 	int ty;
; 162  : 	int loopcount;
; 163  : 	BYTE attr;
; 164  : 	
; 165  : 	if (IsGate(mgt) == 0)

  00008	8b 75 08	 mov	 esi, DWORD PTR _mgt$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	56		 push	 esi
  0000e	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  00011	e8 00 00 00 00	 call	 ?IsGate@CGate@@QAEHH@Z	; CGate::IsGate
  00016	85 c0		 test	 eax, eax
  00018	0f 84 21 01 00
	00		 je	 $LN20@GetGate

; 166  : 	{
; 167  : 		return -1;
; 168  : 	}
; 169  : 
; 170  : 	gt = m_TargetGate[mgt];

  0001e	0f b7 94 73 04
	10 00 00	 movzx	 edx, WORD PTR [ebx+esi*2+4100]

; 171  : 
; 172  : 	if (gt == 0)

  00026	85 d2		 test	 edx, edx
  00028	0f 44 d6	 cmove	 edx, esi

; 173  : 	{
; 174  : 		gt = mgt;
; 175  : 	}
; 176  : 
; 177  : 	if (MapNumber < 0 || MapNumber >= MAX_NUMBER_MAP) {

  0002b	8b 75 14	 mov	 esi, DWORD PTR _MapNumber$[ebp]
  0002e	89 55 08	 mov	 DWORD PTR _gt$2$[ebp], edx
  00031	80 3e 64	 cmp	 BYTE PTR [esi], 100	; 00000064H
  00034	0f 83 f3 00 00
	00		 jae	 $LN7@GetGate

; 180  : 	}
; 181  : 
; 182  : 	loopcount = 10;

  0003a	57		 push	 edi
  0003b	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00040	eb 06		 jmp	 SHORT $LN2@GetGate
$LL19@GetGate:
  00042	8b 55 08	 mov	 edx, DWORD PTR _gt$2$[ebp]
  00045	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN2@GetGate:

; 185  : 	{
; 186  : 		// For X coords
; 187  : 		if ( ( m_Ex[gt] - m_Sx[gt]) > 0 )

  00048	0f b6 8c 1a 04
	08 00 00	 movzx	 ecx, BYTE PTR [edx+ebx+2052]
  00050	4f		 dec	 edi
  00051	0f b6 84 1a 04
	0c 00 00	 movzx	 eax, BYTE PTR [edx+ebx+3076]
  00059	2b c1		 sub	 eax, ecx
  0005b	89 4d f8	 mov	 DWORD PTR _tx$1$[ebp], ecx
  0005e	85 c0		 test	 eax, eax
  00060	7e 29		 jle	 SHORT $LN8@GetGate

; 188  : 		{
; 189  : 			tx = m_Sx[gt] + ( rand() % ( m_Ex[gt] - m_Sx[gt] ) );	// Choose any X position between XBegin and XEnd

  00062	0f b6 b4 1a 04
	08 00 00	 movzx	 esi, BYTE PTR [edx+ebx+2052]
  0006a	e8 00 00 00 00	 call	 _rand
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _gt$2$[ebp]
  00072	99		 cdq
  00073	0f b6 8c 19 04
	0c 00 00	 movzx	 ecx, BYTE PTR [ecx+ebx+3076]
  0007b	2b ce		 sub	 ecx, esi
  0007d	f7 f9		 idiv	 ecx
  0007f	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]

; 190  : 		}
; 191  : 		else

  00082	8b 55 08	 mov	 edx, DWORD PTR _gt$2$[ebp]
  00085	8b 75 14	 mov	 esi, DWORD PTR _MapNumber$[ebp]
  00088	89 4d f8	 mov	 DWORD PTR _tx$1$[ebp], ecx
$LN8@GetGate:

; 192  : 		{
; 193  : 			tx = m_Sx[gt];	// If there is amistake while putting values in gate.txt
; 194  : 		}
; 195  : 		// For Y coords
; 196  : 		if ( ( m_Ey[gt] - m_Sy[gt]) > 0 )

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0008e	0f b6 9c 1a 04
	0a 00 00	 movzx	 ebx, BYTE PTR [edx+ebx+2564]
  00096	0f b6 84 0a 04
	0e 00 00	 movzx	 eax, BYTE PTR [edx+ecx+3588]
  0009e	2b c3		 sub	 eax, ebx
  000a0	85 c0		 test	 eax, eax
  000a2	7e 26		 jle	 SHORT $LN10@GetGate

; 197  : 		{
; 198  : 			ty = m_Sy[gt] + ( rand() % ( m_Ey[gt] - m_Sy[gt] ) );	// Choose any Y position between YBegin and YEnd

  000a4	0f b6 b4 0a 04
	0a 00 00	 movzx	 esi, BYTE PTR [edx+ecx+2564]
  000ac	e8 00 00 00 00	 call	 _rand
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _gt$2$[ebp]
  000b7	0f b6 8c 11 04
	0e 00 00	 movzx	 ecx, BYTE PTR [ecx+edx+3588]
  000bf	2b ce		 sub	 ecx, esi
  000c1	99		 cdq
  000c2	f7 f9		 idiv	 ecx
  000c4	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]

; 199  : 		}
; 200  : 		else

  000c7	8b 75 14	 mov	 esi, DWORD PTR _MapNumber$[ebp]
$LN10@GetGate:

; 201  : 		{
; 202  : 			ty = m_Sy[gt];	// If there is amistake while putting values in gate.txt
; 203  : 		}
; 204  : 
; 205  : 		attr = MapC[MapNumber].GetAttr(tx, ty);

  000ca	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000cd	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  000d3	53		 push	 ebx
  000d4	ff 75 f8	 push	 DWORD PTR _tx$1$[ebp]
  000d7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000dd	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000e2	a8 0e		 test	 al, 14			; 0000000eH

; 206  : 
; 207  : 		if ( (attr&4) != 4 && (attr&2) != 2 && (attr&8) != 8 )

  000e4	74 08		 je	 SHORT $LN15@GetGate

; 183  : 
; 184  : 	while ( loopcount-- != 0 )

  000e6	85 ff		 test	 edi, edi
  000e8	0f 85 54 ff ff
	ff		 jne	 $LL19@GetGate
$LN15@GetGate:

; 208  : 		{
; 209  : 			break;
; 210  : 		}
; 211  : 	}
; 212  : 
; 213  : 	x = tx;

  000ee	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _tx$1$[ebp]
  000f4	5f		 pop	 edi
  000f5	88 08		 mov	 BYTE PTR [eax], cl

; 214  : 	y = ty;

  000f7	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]

; 215  : 	MapNumber = m_MapNumber[gt];

  000fa	8b 45 08	 mov	 eax, DWORD PTR _gt$2$[ebp]
  000fd	88 19		 mov	 BYTE PTR [ecx], bl
  000ff	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00102	8a 8c 18 04 06
	00 00		 mov	 cl, BYTE PTR [eax+ebx+1540]
  00109	88 0e		 mov	 BYTE PTR [esi], cl

; 216  : 	dir = m_Dir[gt];

  0010b	8b 4d 18	 mov	 ecx, DWORD PTR _dir$[ebp]
  0010e	8a 94 18 04 14
	00 00		 mov	 dl, BYTE PTR [eax+ebx+5124]
  00115	5e		 pop	 esi
  00116	88 11		 mov	 BYTE PTR [ecx], dl

; 217  : 	Level = m_Level[gt];

  00118	8b 4d 1c	 mov	 ecx, DWORD PTR _Level$[ebp]
  0011b	66 8b 94 43 04
	16 00 00	 mov	 dx, WORD PTR [ebx+eax*2+5636]
  00123	5b		 pop	 ebx
  00124	66 89 11	 mov	 WORD PTR [ecx], dx

; 218  : 
; 219  : 	return gt;
; 220  : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 18 00	 ret	 24			; 00000018H
$LN7@GetGate:

; 178  : 		LogAddDebug("[%s] Wrong map number, maybe async in packet reading!", __FUNCTION__);

  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IOOEMHIK@CGate?3?3GetGate?$AA@
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JPCODGFL@?$FL?$CFs?$FN?5Wrong?5map?5number?0?5maybe?5asy@
  00137	e8 00 00 00 00	 call	 ?LogAddDebug@@YAXPADZZ	; LogAddDebug
  0013c	83 c4 08	 add	 esp, 8
$LN20@GetGate:

; 179  : 		return -1;

  0013f	5e		 pop	 esi
  00140	83 c8 ff	 or	 eax, -1
  00143	5b		 pop	 ebx

; 218  : 
; 219  : 	return gt;
; 220  : }

  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c2 18 00	 ret	 24			; 00000018H
?GetGate@CGate@@QAEHHAAE000AAF@Z ENDP			; CGate::GetGate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?IsGate@CGate@@QAEHH@Z
_TEXT	SEGMENT
_GateNumber$ = 8					; size = 4
?IsGate@CGate@@QAEHH@Z PROC				; CGate::IsGate, COMDAT
; _this$ = ecx

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 140  : 	if ( (GateNumber < 0) || (GateNumber > MAX_GATES-1) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _GateNumber$[ebp]
  00006	3d ff 01 00 00	 cmp	 eax, 511		; 000001ffH
  0000b	77 3e		 ja	 SHORT $LN3@IsGate

; 144  : 	}
; 145  : 
; 146  : 	if ( m_This[GateNumber] == (WORD)-1 )

  0000d	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00012	66 39 54 41 04	 cmp	 WORD PTR [ecx+eax*2+4], dx
  00017	75 29		 jne	 SHORT $LN4@IsGate

; 147  : 	{
; 148  : 		LogAdd( lMsg.Get(MSGGET(1, 196)), __FILE__, __LINE__);

  00019	68 94 00 00 00	 push	 148			; 00000094H
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_08NDPGJHEF@Gate?4cpp?$AA@
  00023	68 c4 01 00 00	 push	 452			; 000001c4H
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0002d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	33 c0		 xor	 eax, eax

; 153  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@IsGate:

; 149  : 		return 0;
; 150  : 	}
; 151  : 
; 152  : 	return 1;

  00042	b8 01 00 00 00	 mov	 eax, 1

; 153  : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN3@IsGate:

; 141  : 	{
; 142  : 		LogAdd(lMsg.Get(MSGGET(1, 195)), GateNumber, __FILE__, __LINE__);

  0004b	68 8e 00 00 00	 push	 142			; 0000008eH
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_08NDPGJHEF@Gate?4cpp?$AA@
  00055	50		 push	 eax
  00056	68 c3 01 00 00	 push	 451			; 000001c3H
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00060	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0006c	83 c4 10	 add	 esp, 16			; 00000010H

; 143  : 		return 0;

  0006f	33 c0		 xor	 eax, eax

; 153  : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?IsGate@CGate@@QAEHH@Z ENDP				; CGate::IsGate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?Load@CGate@@QAEXPAD@Z
_TEXT	SEGMENT
_Result$ = -284						; size = 12
$T2 = -272						; size = 4
$T3 = -268						; size = 4
$T4 = -264						; size = 4
$T5 = -260						; size = 4
$T6 = -256						; size = 4
$T7 = -252						; size = 4
$T8 = -248						; size = 4
$T9 = -244						; size = 4
$T10 = -240						; size = 4
$T11 = -236						; size = 4
$T12 = -232						; size = 4
$T13 = -228						; size = 4
_GateList$ = -224					; size = 4
_Gate$14 = -220						; size = 4
_Document$ = -216					; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
?Load@CGate@@QAEXPAD@Z PROC				; CGate::Load, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CGate@@QAEXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f9		 mov	 edi, ecx
  00030	8b 5d 08	 mov	 ebx, DWORD PTR _filename$[ebp]

; 40   : 	xml_document Document;

  00033	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00039	e8 00 00 00 00	 call	 ??0xml_document@pugi@@QAE@XZ ; pugi::xml_document::xml_document

; 41   : 	xml_parse_result Result = Document.load_file(filename);

  0003e	6a 00		 push	 0
  00040	6a 74		 push	 116			; 00000074H
  00042	53		 push	 ebx
  00043	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _Result$[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	50		 push	 eax
  00051	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00057	e8 00 00 00 00	 call	 ?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z ; pugi::xml_document::load_file

; 42   : 	// ----
; 43   : 	if( Result.status != status_ok )

  0005c	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _Result$[ebp], 0
  00063	74 10		 je	 SHORT $LN5@Load

; 44   : 	{
; 45   : 		MsgBox("[MoveGate] Loading fail [%s]", filename);

  00065	53		 push	 ebx
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KICDKMJA@?$FLMoveGate?$FN?5Loading?5fail?5?$FL?$CFs?$FN?$AA@
  0006b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00070	e9 40 02 00 00	 jmp	 $LN18@Load
$LN5@Load:

; 46   : 		return;
; 47   : 	}
; 48   : 	// ----
; 49   : 	xml_node GateList = Document.child("movegate");

  00075	68 00 00 00 00	 push	 OFFSET ??_C@_08IJGKCABI@movegate?$AA@
  0007a	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _GateList$[ebp]
  00080	50		 push	 eax
  00081	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00087	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 50   : 	// ----
; 51   : 	for( xml_node Gate = GateList.child("gate"); Gate; Gate = Gate.next_sibling() )

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_04NKCHGMLH@gate?$AA@
  00091	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _Gate$14[ebp]
  00097	50		 push	 eax
  00098	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _GateList$[ebp]
  0009e	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  000a3	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  000a9	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  000ae	85 c0		 test	 eax, eax
  000b0	0f 84 f3 01 00
	00		 je	 $LN3@Load
  000b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@Load:

; 52   : 	{
; 53   : 		int GateNumber = Gate.attribute("id").as_int(-1);

  000c0	6a ff		 push	 -1
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  000c7	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  000cd	50		 push	 eax
  000ce	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  000d4	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  000d9	8b c8		 mov	 ecx, eax
  000db	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  000e0	8b f0		 mov	 esi, eax

; 54   : 		// ----
; 55   : 		if( GateNumber < 0 || GateNumber >= MAX_GATES )

  000e2	81 fe ff 01 00
	00		 cmp	 esi, 511		; 000001ffH
  000e8	0f 87 f3 01 00
	00		 ja	 $LN13@Load

; 58   : 			return;
; 59   : 		}
; 60   : 		// ----
; 61   : 
; 62   : 			m_This[GateNumber]	= GateNumber;
; 63   : 			m_Flag[GateNumber]	= Gate.attribute("flag").as_int();

  000ee	6a 00		 push	 0
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_04DNPGJOMD@flag?$AA@
  000f5	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  000fb	66 89 74 77 04	 mov	 WORD PTR [edi+esi*2+4], si
  00100	50		 push	 eax
  00101	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00107	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0010c	8b c8		 mov	 ecx, eax
  0010e	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 64   : 			m_MapNumber[GateNumber] = Gate.attribute("map").as_int();

  00113	6a 00		 push	 0
  00115	88 84 37 04 04
	00 00		 mov	 BYTE PTR [edi+esi+1028], al
  0011c	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_03HBNNNHNM@map?$AA@
  00127	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00133	8b c8		 mov	 ecx, eax
  00135	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 65   : 			m_Sx[GateNumber] = Gate.attribute("x1").as_int();

  0013a	6a 00		 push	 0
  0013c	88 84 37 04 06
	00 00		 mov	 BYTE PTR [edi+esi+1540], al
  00143	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_02JMABBILH@x1?$AA@
  0014e	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0015a	8b c8		 mov	 ecx, eax
  0015c	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 66   : 			m_Sy[GateNumber] = Gate.attribute("y1").as_int();

  00161	6a 00		 push	 0
  00163	88 84 37 04 08
	00 00		 mov	 BYTE PTR [edi+esi+2052], al
  0016a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_02JNMDHCIA@y1?$AA@
  00175	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00181	8b c8		 mov	 ecx, eax
  00183	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 67   : 			m_Ex[GateNumber] = Gate.attribute("x2").as_int();

  00188	6a 00		 push	 0
  0018a	88 84 37 04 0a
	00 00		 mov	 BYTE PTR [edi+esi+2564], al
  00191	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_02LHCMELHE@x2?$AA@
  0019c	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001a8	8b c8		 mov	 ecx, eax
  001aa	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 68   : 			m_Ey[GateNumber] = Gate.attribute("y2").as_int();

  001af	6a 00		 push	 0
  001b1	88 84 37 04 0c
	00 00		 mov	 BYTE PTR [edi+esi+3076], al
  001b8	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_02LGOOCBED@y2?$AA@
  001c3	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001cf	8b c8		 mov	 ecx, eax
  001d1	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 69   : 			m_TargetGate[GateNumber] = Gate.attribute("target").as_int();

  001d6	6a 00		 push	 0
  001d8	88 84 37 04 0e
	00 00		 mov	 BYTE PTR [edi+esi+3588], al
  001df	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_06JJLAMBGK@target?$AA@
  001ea	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001f6	8b c8		 mov	 ecx, eax
  001f8	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 70   : 			m_Dir[GateNumber] = Gate.attribute("dir").as_int();

  001fd	6a 00		 push	 0
  001ff	66 89 84 77 04
	10 00 00	 mov	 WORD PTR [edi+esi*2+4100], ax
  00207	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_03DAPAKLGM@dir?$AA@
  00212	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0021e	8b c8		 mov	 ecx, eax
  00220	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 71   : 			m_Level[GateNumber] = Gate.attribute("minlvl").as_int();

  00225	6a 00		 push	 0
  00227	88 84 37 04 14
	00 00		 mov	 BYTE PTR [edi+esi+5124], al
  0022e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_06GJMPOCOI@minlvl?$AA@
  00239	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00245	8b c8		 mov	 ecx, eax
  00247	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 72   : 			m_MaxLevel[GateNumber] = Gate.attribute("maxlvl").as_int();

  0024c	6a 00		 push	 0
  0024e	66 89 84 77 04
	16 00 00	 mov	 WORD PTR [edi+esi*2+5636], ax
  00256	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_06GKDMACKH@maxlvl?$AA@
  00261	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00267	50		 push	 eax
  00268	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0026d	8b c8		 mov	 ecx, eax
  0026f	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00274	66 89 84 77 04
	1a 00 00	 mov	 WORD PTR [edi+esi*2+6660], ax
  0027c	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00282	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00288	50		 push	 eax
  00289	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  0028e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Gate$14[ebp]
  00294	8b 00		 mov	 eax, DWORD PTR [eax]
  00296	89 85 24 ff ff
	ff		 mov	 DWORD PTR _Gate$14[ebp], eax
  0029c	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  002a1	85 c0		 test	 eax, eax
  002a3	0f 85 17 fe ff
	ff		 jne	 $LL4@Load
$LN3@Load:

; 73   : 	}
; 74   : 	// ----
; 75   : 	/*int Token;
; 76   : 	int number;
; 77   : 	
; 78   : 	this->Init();
; 79   : 
; 80   : 	SMDFile=fopen(filename, "r");
; 81   : 	
; 82   : 	if (SMDFile==0)
; 83   : 	{
; 84   : 		LogAdd("[%s] gate information load error", filename);
; 85   : 		return;
; 86   : 	}
; 87   : 
; 88   : 	while ( true )
; 89   : 	{
; 90   : 		Token = GetToken();
; 91   : 
; 92   : 		if ( Token == 2 )
; 93   : 		{
; 94   : 			break;
; 95   : 		}
; 96   : 		else
; 97   : 		{
; 98   : 			if ( Token == 1 )
; 99   : 			{
; 100  : 
; 101  : 				number=(int)TokenNumber;
; 102  : 				m_This[number]=number;
; 103  : 
; 104  : 				Token=GetToken();
; 105  : 				m_Flag[number]=(BYTE)TokenNumber;
; 106  : 
; 107  : 				Token=GetToken();
; 108  : 				m_MapNumber[number]=(BYTE)TokenNumber;
; 109  : 
; 110  : 				Token=GetToken();
; 111  : 				m_Sx[number]=(BYTE)TokenNumber;
; 112  : 
; 113  : 				Token=GetToken();
; 114  : 				m_Sy[number]=(BYTE)TokenNumber;
; 115  : 
; 116  : 				Token=GetToken();
; 117  : 				m_Ex[number]=(BYTE)TokenNumber;
; 118  : 
; 119  : 				Token=GetToken();
; 120  : 				m_Ey[number]=(BYTE)TokenNumber;
; 121  : 
; 122  : 				Token=GetToken();
; 123  : 				m_TargetGate[number]=(WORD)TokenNumber;
; 124  : 
; 125  : 				Token=GetToken();
; 126  : 				m_Dir[number]=(BYTE)TokenNumber;
; 127  : 
; 128  : 				Token=GetToken();
; 129  : 				m_Level[number]=(WORD)TokenNumber;
; 130  : 			}
; 131  : 		}
; 132  : 	}
; 133  : 
; 134  : 	fclose(SMDFile);*/
; 135  : 	LogAdd("[%s] MoveGate has been loaded", filename);

  002a9	53		 push	 ebx
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@EPCOJCIM@?$FL?$CFs?$FN?5MoveGate?5has?5been?5loaded?$AA@
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
$LN18@Load:
  002b5	83 c4 08	 add	 esp, 8

; 136  : }

  002b8	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  002be	e8 00 00 00 00	 call	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
  002c3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002c6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002cd	59		 pop	 ecx
  002ce	5f		 pop	 edi
  002cf	5e		 pop	 esi
  002d0	5b		 pop	 ebx
  002d1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d4	33 cd		 xor	 ecx, ebp
  002d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002db	8b e5		 mov	 esp, ebp
  002dd	5d		 pop	 ebp
  002de	c2 04 00	 ret	 4
$LN13@Load:

; 56   : 		{
; 57   : 			MsgBox("[MoveGate] GateNumber is wrong [%d]", GateNumber);

  002e1	56		 push	 esi
  002e2	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@JPENMKG@?$FLMoveGate?$FN?5GateNumber?5is?5wrong?5?$FL@
  002e7	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002ec	eb c7		 jmp	 SHORT $LN18@Load
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CGate@@QAEXPAD@Z$0:
  00000	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
__ehhandler$?Load@CGate@@QAEXPAD@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a e0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-288]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CGate@@QAEXPAD@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CGate@@QAEXPAD@Z ENDP				; CGate::Load
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?Init@CGate@@QAEXXZ
_TEXT	SEGMENT
?Init@CGate@@QAEXXZ PROC				; CGate::Init, COMDAT
; _this$ = ecx

; 27   : {

  00000	56		 push	 esi

; 28   : 	int n;
; 29   : 
; 30   : 	for (n=0;n<MAX_GATES;n++)

  00001	8d 81 04 16 00
	00		 lea	 eax, DWORD PTR [ecx+5636]
  00007	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  0000c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
$LL4@Init:

; 31   : 	{
; 32   : 		m_This[n] = 0xFFFF;	// -1 NULL
; 33   : 		m_Level[n]=0;

  00011	33 d2		 xor	 edx, edx
  00013	66 89 b0 00 ea
	ff ff		 mov	 WORD PTR [eax-5632], si
  0001a	66 89 10	 mov	 WORD PTR [eax], dx
  0001d	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00020	83 e9 01	 sub	 ecx, 1
  00023	75 ec		 jne	 SHORT $LL4@Init
  00025	5e		 pop	 esi

; 34   : 	}
; 35   : }

  00026	c3		 ret	 0
?Init@CGate@@QAEXXZ ENDP				; CGate::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ??1CGate@@UAE@XZ
_TEXT	SEGMENT
??1CGate@@UAE@XZ PROC					; CGate::~CGate, COMDAT
; _this$ = ecx

; 21   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGate@@6B@

; 22   : 	return;
; 23   : }

  00006	c3		 ret	 0
??1CGate@@UAE@XZ ENDP					; CGate::~CGate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ??0CGate@@QAE@XZ
_TEXT	SEGMENT
??0CGate@@QAE@XZ PROC					; CGate::CGate, COMDAT
; _this$ = ecx

; 15   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGate@@6B@

; 16   : 	return;
; 17   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CGate@@QAE@XZ ENDP					; CGate::CGate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
