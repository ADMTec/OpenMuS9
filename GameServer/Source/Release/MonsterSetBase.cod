; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\MonsterSetBase.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode0
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?Init@CMonsterSetBase@@QAEXXZ			; CMonsterSetBase::Init
PUBLIC	?GetPentagramMainAttribute@CMonsterSetBase@@QAEXHPAH@Z ; CMonsterSetBase::GetPentagramMainAttribute
PUBLIC	?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z	; CMonsterSetBase::LoadSetBase
PUBLIC	?MonsterSetBaseReload@CMonsterSetBase@@QAEXH@Z	; CMonsterSetBase::MonsterSetBaseReload
PUBLIC	?RemoveMonsterSetBase@CMonsterSetBase@@QAEXH@Z	; CMonsterSetBase::RemoveMonsterSetBase
PUBLIC	?AddAllMonsters@CMonsterSetBase@@QAEXH@Z	; CMonsterSetBase::AddAllMonsters
PUBLIC	?GetPosition@CMonsterSetBase@@QAEHHFAAE0@Z	; CMonsterSetBase::GetPosition
PUBLIC	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAE0@Z ; CMonsterSetBase::GetBoxPosition
PUBLIC	?SetMonsterSetBase@CMonsterSetBase@@QAEHHHHHHHHHHHH@Z ; CMonsterSetBase::SetMonsterSetBase
PUBLIC	?GetShopID@CMonsterSetBase@@QAEHH@Z		; CMonsterSetBase::GetShopID
PUBLIC	?AddObj@CCrywolfObjInfo@@QAEHH@Z		; CCrywolfObjInfo::AddObj
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--
PUBLIC	??$_Buynode@U?$pair@HH@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@	; `string'
PUBLIC	??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0CJ@KBCGKPCD@file?5open?5error?5?$CFs?6Error?5descrip@ ; `string'
PUBLIC	??_C@_0P@JEDDHJC@monstersetbase?$AA@		; `string'
PUBLIC	??_C@_06IIMEFKJP@golden?$AA@			; `string'
PUBLIC	??_C@_07JHAJHILB@monster?$AA@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id?$AA@			; `string'
PUBLIC	??_C@_03HBNNNHNM@map?$AA@			; `string'
PUBLIC	??_C@_03CJOLJKCN@dis?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	??_C@_01EANLCPLP@y?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_01BDACAMKP@h?$AA@				; `string'
PUBLIC	??_C@_03DAPAKLGM@dir?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_0DN@PDLKLGMA@Failed?5to?5add?5GoldenMonster1?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_04DONFEANM@list?$AA@			; `string'
PUBLIC	??_C@_04GPMDFGEJ@type?$AA@			; `string'
PUBLIC	??_C@_03BPGDPAOH@npc?$AA@			; `string'
PUBLIC	??_C@_0BC@BHHJCJLK@Unknown?5attr?$CI?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_04BFIJLIPK@shop?$AA@			; `string'
PUBLIC	??_C@_04GOEDGNCF@area?$AA@			; `string'
PUBLIC	??_C@_03NNBHCDBP@day?$AA@			; `string'
PUBLIC	??_C@_07HCLJNICE@element?$AA@			; `string'
PUBLIC	??_C@_0DN@JODMEFJK@Failed?5to?5add?5GoldenMonster2?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0CC@GLIJPBCP@MonsterSetBase?5added?5?9?5?$CFd?5object@ ; `string'
PUBLIC	??_C@_0BL@GOBDOCKL@Monster?2MonsterSetBase?4xml?$AA@ ; `string'
PUBLIC	??_C@_0BE@PFCEFGJO@Monster?2Monster?4xml?$AA@	; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	_rand:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjViewportClose
EXTRN	?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolDestroy
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?LoadAttr@CMonsterAttr@@QAEXPAD@Z:PROC		; CMonsterAttr::LoadAttr
EXTRN	?GetLargeRand@@YAKXZ:PROC			; GetLargeRand
EXTRN	?Init@CIllusionTempleEvent@@QAEHXZ:PROC		; CIllusionTempleEvent::Init
EXTRN	?AddNpc@CIllusionTempleEvent@@QAEXEHH@Z:PROC	; CIllusionTempleEvent::AddNpc
EXTRN	?AddMonster@CIllusionTempleEvent@@QAEXEHH@Z:PROC ; CIllusionTempleEvent::AddMonster
EXTRN	?ResetObject@CIllusionTempleEvent@@QAEXXZ:PROC	; CIllusionTempleEvent::ResetObject
EXTRN	?Init@CMonsterItemMngEx@@QAEXXZ:PROC		; CMonsterItemMngEx::Init
EXTRN	?SetState@CRaklion@@QAEXH@Z:PROC		; CRaklion::SetState
EXTRN	?Init@CBloodCastle@@QAEX_N@Z:PROC		; CBloodCastle::Init
EXTRN	?LoadItemDropRate@CBloodCastle@@QAEXXZ:PROC	; CBloodCastle::LoadItemDropRate
EXTRN	?GetBridgeLevel@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetBridgeLevel
EXTRN	?Init@CDevilSquare@@QAEXXZ:PROC			; CDevilSquare::Init
EXTRN	?Init@CChaosCastle@@QAEX_N@Z:PROC		; CChaosCastle::Init
EXTRN	?SetCrownIndex@CCastleSiege@@QAEXH@Z:PROC	; CCastleSiege::SetCrownIndex
EXTRN	?as_int@xml_attribute@pugi@@QBEHH@Z:PROC	; pugi::xml_attribute::as_int
EXTRN	??0xml_node@pugi@@QAE@XZ:PROC			; pugi::xml_node::xml_node
EXTRN	??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ:PROC	; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
EXTRN	?next_sibling@xml_node@pugi@@QBE?AV12@XZ:PROC	; pugi::xml_node::next_sibling
EXTRN	?child@xml_node@pugi@@QBE?AV12@PBD@Z:PROC	; pugi::xml_node::child
EXTRN	?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z:PROC ; pugi::xml_node::attribute
EXTRN	?description@xml_parse_result@pugi@@QBEPBDXZ:PROC ; pugi::xml_parse_result::description
EXTRN	??0xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::xml_document
EXTRN	??1xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::~xml_document
EXTRN	?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z:PROC ; pugi::xml_document::load_file
EXTRN	?Init@ShopManager@@QAEXXZ:PROC			; ShopManager::Init
EXTRN	?Read@ShopManager@@QAEXH@Z:PROC			; ShopManager::Read
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__except_handler4:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjMonCount@@3HA:DWORD			; gObjMonCount
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	?g_bChaosCastle@@3HA:DWORD			; g_bChaosCastle
EXTRN	?g_bIllusionTemple@@3HA:DWORD			; g_bIllusionTemple
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	?g_MonsterItemMngEx@@3VCMonsterItemMngEx@@A:BYTE ; g_MonsterItemMngEx
EXTRN	?g_Raklion@@3VCRaklion@@A:BYTE			; g_Raklion
EXTRN	?gCurPaintPlayer@@3HA:DWORD			; gCurPaintPlayer
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_DevilSquare@@3VCDevilSquare@@A:BYTE		; g_DevilSquare
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_ShopManager@@3VShopManager@@A:BYTE		; g_ShopManager
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PFCEFGJO@Monster?2Monster?4xml?$AA@
CONST	SEGMENT
??_C@_0BE@PFCEFGJO@Monster?2Monster?4xml?$AA@ DB 'Monster\Monster.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOBDOCKL@Monster?2MonsterSetBase?4xml?$AA@
CONST	SEGMENT
??_C@_0BL@GOBDOCKL@Monster?2MonsterSetBase?4xml?$AA@ DB 'Monster\MonsterS'
	DB	'etBase.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GLIJPBCP@MonsterSetBase?5added?5?9?5?$CFd?5object@
CONST	SEGMENT
??_C@_0CC@GLIJPBCP@MonsterSetBase?5added?5?9?5?$CFd?5object@ DB 'MonsterS'
	DB	'etBase added - %d objects', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JODMEFJK@Failed?5to?5add?5GoldenMonster2?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0DN@JODMEFJK@Failed?5to?5add?5GoldenMonster2?$CI?$CFd?$CJ@ DB 'Fail'
	DB	'ed to add GoldenMonster2(%d) Map(%d) Dis(%d) X(%d) Y(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCLJNICE@element?$AA@
CONST	SEGMENT
??_C@_07HCLJNICE@element?$AA@ DB 'element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNBHCDBP@day?$AA@
CONST	SEGMENT
??_C@_03NNBHCDBP@day?$AA@ DB 'day', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOEDGNCF@area?$AA@
CONST	SEGMENT
??_C@_04GOEDGNCF@area?$AA@ DB 'area', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFIJLIPK@shop?$AA@
CONST	SEGMENT
??_C@_04BFIJLIPK@shop?$AA@ DB 'shop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BHHJCJLK@Unknown?5attr?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BC@BHHJCJLK@Unknown?5attr?$CI?$CFd?$CJ?6?$AA@ DB 'Unknown attr(%d)'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03BPGDPAOH@npc?$AA@
CONST	SEGMENT
??_C@_03BPGDPAOH@npc?$AA@ DB 'npc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type?$AA@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type?$AA@ DB 'type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DONFEANM@list?$AA@
CONST	SEGMENT
??_C@_04DONFEANM@list?$AA@ DB 'list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@PDLKLGMA@Failed?5to?5add?5GoldenMonster1?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0DN@PDLKLGMA@Failed?5to?5add?5GoldenMonster1?$CI?$CFd?$CJ@ DB 'Fail'
	DB	'ed to add GoldenMonster1(%d) Map(%d) Dis(%d) X(%d) Y(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAPAKLGM@dir?$AA@
CONST	SEGMENT
??_C@_03DAPAKLGM@dir?$AA@ DB 'dir', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h?$AA@
CONST	SEGMENT
??_C@_01BDACAMKP@h?$AA@ DB 'h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EANLCPLP@y?$AA@
CONST	SEGMENT
??_C@_01EANLCPLP@y?$AA@ DB 'y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJOLJKCN@dis?$AA@
CONST	SEGMENT
??_C@_03CJOLJKCN@dis?$AA@ DB 'dis', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map?$AA@
CONST	SEGMENT
??_C@_03HBNNNHNM@map?$AA@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id?$AA@
CONST	SEGMENT
??_C@_02EGCJHIOB@id?$AA@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JHAJHILB@monster?$AA@
CONST	SEGMENT
??_C@_07JHAJHILB@monster?$AA@ DB 'monster', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IIMEFKJP@golden?$AA@
CONST	SEGMENT
??_C@_06IIMEFKJP@golden?$AA@ DB 'golden', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JEDDHJC@monstersetbase?$AA@
CONST	SEGMENT
??_C@_0P@JEDDHJC@monstersetbase?$AA@ DB 'monstersetbase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KBCGKPCD@file?5open?5error?5?$CFs?6Error?5descrip@
CONST	SEGMENT
??_C@_0CJ@KBCGKPCD@file?5open?5error?5?$CFs?6Error?5descrip@ DB 'file ope'
	DB	'n error %s', 0aH, 'Error description: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@ DB 'ERROR : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@
CONST	SEGMENT
??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@ DB 'MonsterSetBase.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$58 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$58
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAE0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetBoxPosi
	DD	FLAT:$LN9@GetBoxPosi
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z$0
__ehfuncinfo$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::construct<std::pair<int const ,int>,std::pair<int,int> >, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 156  : 		: first(_STD forward<_Other1>(_Right.first)),

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax

; 157  : 			second(_STD forward<_Other2>(_Right.second))

  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 656  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::construct<std::pair<int const ,int>,std::pair<int,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PAU21@AAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PAU21@AAU?$pair@$$CBHH@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode_if_nil<std::pair<int const ,int> &>, COMDAT
; _this$ = ecx

; 1657 : 		{	// node exists, just return it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1658 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1659 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PAU21@AAU?$pair@$$CBHH@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode_if_nil<std::pair<int const ,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::pair<int const ,int>,std::pair<int,int> >, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN8@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 156  : 		: first(_STD forward<_Other1>(_Right.first)),

  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax

; 157  : 			second(_STD forward<_Other2>(_Right.second))

  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 774  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::pair<int const ,int>,std::pair<int,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 656  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHH@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBHH@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHH@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::destroy<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBHH@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHH@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::destroy<std::pair<int const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &,bool,void>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  : 		: first(_STD forward<_Other1>(_Val1)),

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 144  : 				second(_STD forward<_Other2>(_Val2))

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 146  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool,void>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  : 		: first(_STD forward<_Other1>(_Val1)),

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 144  : 				second(_STD forward<_Other2>(_Val2))

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 146  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1855 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1856 : 		if (max_size() - 1 <= this->_Mysize())

  00008	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000b	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  00010	0f 83 6e 01 00
	00		 jae	 $LN730@Insert_at

; 1860 : 			}
; 1861 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1862 : 			_STD forward<_Valty>(_Val));
; 1863 : 
; 1864 : 		++this->_Mysize();
; 1865 : 		_Newnode->_Parent = _Wherenode;

  00016	8b 5d 18	 mov	 ebx, DWORD PTR __Node$[ebp]
  00019	40		 inc	 eax
  0001a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00020	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1866 : 
; 1867 : 		if (_Wherenode == this->_Myhead())

  00023	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00025	3b c1		 cmp	 eax, ecx
  00027	75 0e		 jne	 SHORT $LN6@Insert_at

; 1868 : 			{	// first node in tree, just set head values
; 1869 : 			_Root() = _Newnode;

  00029	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);

  0002c	8b 07		 mov	 eax, DWORD PTR [edi]

; 1870 : 			_Lmost() = _Newnode;

  0002e	89 18		 mov	 DWORD PTR [eax], ebx

; 1871 : 			_Rmost() = _Newnode;

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
  00032	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00035	eb 1f		 jmp	 SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1872 : 			}
; 1873 : 		else if (_Addleft)

  00037	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003b	74 0c		 je	 SHORT $LN8@Insert_at

; 1874 : 			{	// add to left of _Wherenode
; 1875 : 			this->_Left(_Wherenode) = _Newnode;

  0003d	89 18		 mov	 DWORD PTR [eax], ebx

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);

  0003f	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1876 : 			if (_Wherenode == _Lmost())

  00041	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00043	75 11		 jne	 SHORT $LN11@Insert_at

; 1877 : 				_Lmost() = _Newnode;

  00045	89 19		 mov	 DWORD PTR [ecx], ebx

; 1878 : 			}
; 1879 : 		else

  00047	eb 0d		 jmp	 SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1880 : 			{	// add to right of _Wherenode
; 1881 : 			this->_Right(_Wherenode) = _Newnode;

  00049	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);

  0004c	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1882 : 			if (_Wherenode == _Rmost())

  0004e	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00051	75 03		 jne	 SHORT $LN11@Insert_at

; 1883 : 				_Rmost() = _Newnode;

  00053	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1884 : 			}
; 1885 : 
; 1886 : 		for (_Nodeptr _Pnode = _Newnode;
; 1887 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00056	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00059	8b f3		 mov	 esi, ebx
  0005b	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0005f	0f 85 0a 01 00
	00		 jne	 $LN3@Insert_at
$LL2@Insert_at:

; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00065	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);

  00068	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1888 : 			if (this->_Parent(_Pnode)
; 1889 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  0006b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0006d	3b c1		 cmp	 eax, ecx
  0006f	75 74		 jne	 SHORT $LN12@Insert_at

; 1890 : 				{	// fixup red-red in left subtree
; 1891 : 				_Wherenode =

  00071	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 1892 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 				if (this->_Color(_Wherenode) == this->_Red)

  00074	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00078	74 71		 je	 SHORT $LN729@Insert_at

; 1894 : 					{	// parent has two red children, blacken both
; 1895 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1896 : 					this->_Color(_Wherenode) = this->_Black;
; 1897 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1898 : 						= this->_Red;
; 1899 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1900 : 					}
; 1901 : 				else
; 1902 : 					{	// parent has red and black children
; 1903 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0007a	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0007d	75 0a		 jne	 SHORT $LN16@Insert_at

; 1904 : 						{	// rotate right child to left
; 1905 : 						_Pnode = this->_Parent(_Pnode);

  0007f	8b f0		 mov	 esi, eax

; 1906 : 						_Lrotate(_Pnode);

  00081	8b cf		 mov	 ecx, edi
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN16@Insert_at:

; 1907 : 						}
; 1908 : 					this->_Color(this->_Parent(_Pnode)) =

  00089	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1909 : 						this->_Black;	// propagate red up
; 1910 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

  00090	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00093	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00096	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1911 : 						this->_Red;
; 1912 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  0009a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2126 : 		}
; 2127 : 
; 2128 : 	_Nodeptr& _Rmost() const
; 2129 : 		{	// return rightmost node in nonmutable tree
; 2130 : 		return (this->_Right(this->_Myhead()));
; 2131 : 		}
; 2132 : 
; 2133 : 	_Nodeptr& _Root() const
; 2134 : 		{	// return root of nonmutable tree
; 2135 : 		return (this->_Parent(this->_Myhead()));
; 2136 : 		}
; 2137 : 
; 2138 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2139 : 		{	// promote left node to root of subtree
; 2140 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  000a0	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2141 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  000a2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 44   : 		{	// construct with node pointer _Pnode
; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);

  000a7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 2142 : 
; 2143 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  000aa	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ae	75 03		 jne	 SHORT $LN376@Insert_at

; 2144 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  000b0	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN376@Insert_at:

; 2145 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000b3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000b6	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  000b9	8b 07		 mov	 eax, DWORD PTR [edi]

; 2146 : 
; 2147 : 		if (_Wherenode == _Root())

  000bb	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000be	75 0b		 jne	 SHORT $LN377@Insert_at

; 2148 : 			_Root() = _Pnode;

  000c0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2153 : 
; 2154 : 		this->_Right(_Pnode) = _Wherenode;

  000c3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1913 : 					}
; 1914 : 				}
; 1915 : 			else

  000c6	e9 94 00 00 00	 jmp	 $LN728@Insert_at
$LN377@Insert_at:

; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);

  000cb	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2149 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000ce	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000d1	75 0b		 jne	 SHORT $LN379@Insert_at

; 2150 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000d3	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2153 : 
; 2154 : 		this->_Right(_Pnode) = _Wherenode;

  000d6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1913 : 					}
; 1914 : 				}
; 1915 : 			else

  000d9	e9 81 00 00 00	 jmp	 $LN728@Insert_at
$LN379@Insert_at:

; 2151 : 		else
; 2152 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000de	89 10		 mov	 DWORD PTR [eax], edx

; 2153 : 
; 2154 : 		this->_Right(_Pnode) = _Wherenode;

  000e0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1913 : 					}
; 1914 : 				}
; 1915 : 			else

  000e3	eb 7a		 jmp	 SHORT $LN728@Insert_at
$LN12@Insert_at:

; 1916 : 				{	// fixup red-red in right subtree
; 1917 : 				_Wherenode =
; 1918 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 				if (this->_Color(_Wherenode) == this->_Red)

  000e5	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  000e9	75 1a		 jne	 SHORT $LN17@Insert_at
$LN729@Insert_at:

; 1920 : 					{	// parent has two red children, blacken both
; 1921 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  000eb	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1922 : 					this->_Color(_Wherenode) = this->_Black;

  000ef	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1923 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

  000f3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1924 : 						this->_Red;
; 1925 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00100	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1926 : 					}
; 1927 : 				else

  00103	eb 5d		 jmp	 SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1928 : 					{	// parent has red and black children
; 1929 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00105	3b 30		 cmp	 esi, DWORD PTR [eax]
  00107	75 0a		 jne	 SHORT $LN19@Insert_at

; 1930 : 						{	// rotate left child to right
; 1931 : 						_Pnode = this->_Parent(_Pnode);

  00109	8b f0		 mov	 esi, eax

; 1932 : 						_Rrotate(_Pnode);

  0010b	8b cf		 mov	 ecx, edi
  0010d	56		 push	 esi
  0010e	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN19@Insert_at:

; 1933 : 						}
; 1934 : 					this->_Color(this->_Parent(_Pnode)) =

  00113	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00116	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1935 : 						this->_Black;	// propagate red up
; 1936 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

  0011a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1937 : 						this->_Red;
; 1938 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  00124	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00127	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1945 : 
; 1946 : 	template<class _Moveit>
; 1947 : 		void _Copy(const _Myt& _Right, _Moveit _Movefl)
; 1948 : 		{	// copy or move entire tree from _Right
; 1949 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);
; 1950 : 		this->_Mysize() = _Right.size();
; 1951 : 		if (!this->_Isnil(_Root()))
; 1952 : 			{	// nonempty tree, look for new smallest and largest
; 1953 : 			_Lmost() = this->_Min(_Root());
; 1954 : 			_Rmost() = this->_Max(_Root());
; 1955 : 			}
; 1956 : 		else
; 1957 : 			{	// empty tree, just tidy head pointers
; 1958 : 			_Lmost() = this->_Myhead();
; 1959 : 			_Rmost() = this->_Myhead();
; 1960 : 			}
; 1961 : 		}
; 1962 : 
; 1963 : 	template<class _Ty,
; 1964 : 		class _Is_set>
; 1965 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
; 1966 : 		{	// copy to new node
; 1967 : 		return (this->_Buynode(_Val));
; 1968 : 		}
; 1969 : 
; 1970 : 	template<class _Ty>
; 1971 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
; 1972 : 		{	// move to new node -- set
; 1973 : 		return (this->_Buynode(_STD move(_Val)));
; 1974 : 		}
; 1975 : 
; 1976 : 	template<class _Ty>
; 1977 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
; 1978 : 		{	// move to new node -- map
; 1979 : 		return (this->_Buynode(
; 1980 : 			_STD move(const_cast<key_type&>(_Val.first)),
; 1981 : 			_STD move(_Val.second)));
; 1982 : 		}
; 1983 : 
; 1984 : 	template<class _Moveit>
; 1985 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1986 : 			_Moveit _Movefl)
; 1987 : 		{	// copy entire subtree, recursively
; 1988 : 		_Nodeptr _Newroot = this->_Myhead();	// point at nil node
; 1989 : 
; 1990 : 		if (!this->_Isnil(_Rootnode))
; 1991 : 			{	// copy or move a node, then any subtrees
; 1992 : 			typename is_same<key_type, value_type>::type _Is_set;
; 1993 : 			_Nodeptr _Pnode = _Copy_or_move(
; 1994 : 				this->_Myval(_Rootnode), _Movefl, _Is_set);
; 1995 : 			_Pnode->_Parent = _Wherenode;
; 1996 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1997 : 			if (this->_Isnil(_Newroot))
; 1998 : 				_Newroot = _Pnode;	// memorize new root
; 1999 : 
; 2000 : 			_TRY_BEGIN
; 2001 : 			this->_Left(_Pnode) =
; 2002 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 2003 : 			this->_Right(_Pnode) =
; 2004 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 2005 : 			_CATCH_ALL
; 2006 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 2007 : 			_RERAISE;
; 2008 : 			_CATCH_END
; 2009 : 			}
; 2010 : 
; 2011 : 		return (_Newroot);	// return newly constructed tree
; 2012 : 		}
; 2013 : 
; 2014 : 	template<class _Other>
; 2015 : 		_Paircc _Eqrange(const _Other& _Keyval) const
; 2016 : 		{	// find leftmost node not less than _Keyval
; 2017 : 		_Nodeptr _Pnode = _Root();
; 2018 : 		_Nodeptr _Lonode = this->_Myhead();	// end() if search fails
; 2019 : 		_Nodeptr _Hinode = this->_Myhead();	// end() if search fails
; 2020 : 
; 2021 : 		while (!this->_Isnil(_Pnode))
; 2022 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2023 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2024 : 			else
; 2025 : 				{	// _Pnode not less than _Keyval, remember it
; 2026 : 				if (this->_Isnil(_Hinode)
; 2027 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2028 : 						this->_Key(_Pnode)))
; 2029 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2030 : 				_Lonode = _Pnode;
; 2031 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2032 : 				}
; 2033 : 
; 2034 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2035 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2036 : 		while (!this->_Isnil(_Pnode))
; 2037 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2038 : 				{	// _Pnode greater than _Keyval, remember it
; 2039 : 				_Hinode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 			else
; 2043 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2044 : 
; 2045 : 		const_iterator _First = const_iterator(_Lonode, &this->_Get_data());
; 2046 : 		const_iterator _Last = const_iterator(_Hinode, &this->_Get_data());
; 2047 : 		return (_Paircc(_First, _Last));
; 2048 : 		}
; 2049 : 
; 2050 : 	template<class _Other>
; 2051 : 		_Pairii _Eqrange(const _Other& _Keyval)
; 2052 : 		{	// find leftmost node not less than _Keyval
; 2053 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
; 2054 : 		iterator _First = iterator(_Ans.first._Ptr, &this->_Get_data());
; 2055 : 		iterator _Last = iterator(_Ans.second._Ptr, &this->_Get_data());
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	bool _Compare(const key_type& _Left, const key_type& _Right) const
; 2074 : 		{	// compare key_type to key_type, with debug checks
; 2075 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));
; 2076 : 		}
; 2077 : 
; 2078 : 	template<class _Ty1,
; 2079 : 		class _Ty2>
; 2080 : 		bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
; 2081 : 		{	// compare _Ty1 to _Ty2, without debug checks
; 2082 : 		return (this->_Getcomp()(_Left, _Right));
; 2083 : 		}
; 2084 : 
; 2085 : 	template<class _Other>
; 2086 : 		_Nodeptr _Lbound(const _Other& _Keyval) const
; 2087 : 		{	// find leftmost node not less than _Keyval
; 2088 : 		_Nodeptr _Pnode = _Root();
; 2089 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2090 : 
; 2091 : 		while (!this->_Isnil(_Pnode))
; 2092 : 			if (_Compare(this->_Key(_Pnode), _Keyval))
; 2093 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2094 : 			else
; 2095 : 				{	// _Pnode not less than _Keyval, remember it
; 2096 : 				_Wherenode = _Pnode;
; 2097 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2098 : 				}
; 2099 : 
; 2100 : 		return (_Wherenode);	// return best remembered candidate
; 2101 : 		}
; 2102 : 
; 2103 : 	_Nodeptr& _Lmost() const
; 2104 : 		{	// return leftmost node in nonmutable tree
; 2105 : 		return (this->_Left(this->_Myhead()));
; 2106 : 		}
; 2107 : 
; 2108 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2109 : 		{	// promote right node to root of subtree
; 2110 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0012a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 2111 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0012d	8b 02		 mov	 eax, DWORD PTR [edx]
  0012f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 44   : 		{	// construct with node pointer _Pnode
; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);

  00132	8b 02		 mov	 eax, DWORD PTR [edx]

; 2112 : 
; 2113 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00134	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00138	75 03		 jne	 SHORT $LN575@Insert_at

; 2114 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  0013a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN575@Insert_at:

; 2115 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0013d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00140	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00143	8b 07		 mov	 eax, DWORD PTR [edi]

; 2116 : 
; 2117 : 		if (_Wherenode == _Root())

  00145	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00148	75 05		 jne	 SHORT $LN576@Insert_at

; 2118 : 			_Root() = _Pnode;

  0014a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2119 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  0014d	eb 0e		 jmp	 SHORT $LN579@Insert_at
$LN576@Insert_at:

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);

  0014f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2119 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00152	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00154	75 04		 jne	 SHORT $LN578@Insert_at

; 2120 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00156	89 10		 mov	 DWORD PTR [eax], edx

; 2121 : 		else

  00158	eb 03		 jmp	 SHORT $LN579@Insert_at
$LN578@Insert_at:

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0015a	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN579@Insert_at:

; 2123 : 
; 2124 : 		this->_Left(_Pnode) = _Wherenode;

  0015d	89 0a		 mov	 DWORD PTR [edx], ecx
$LN728@Insert_at:

; 2125 : 		this->_Parent(_Wherenode) = _Pnode;

  0015f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1884 : 			}
; 1885 : 
; 1886 : 		for (_Nodeptr _Pnode = _Newnode;
; 1887 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00162	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00165	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00169	0f 84 f6 fe ff
	ff		 je	 $LL2@Insert_at
$LN3@Insert_at:

; 1939 : 					}
; 1940 : 				}
; 1941 : 
; 1942 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  0016f	8b 07		 mov	 eax, DWORD PTR [edi]
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00176	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

  0017a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0017d	89 18		 mov	 DWORD PTR [eax], ebx
  0017f	5b		 pop	 ebx

; 1943 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1944 : 		}

  00180	5d		 pop	 ebp
  00181	c2 14 00	 ret	 20			; 00000014H
$LN730@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00184	ff 75 18	 push	 DWORD PTR __Node$[ebp]
  00187	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0018c	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1859 : 			_Xlength_error("map/set<T> too long");

  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  00194	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN732@Insert_at:
$LN727@Insert_at:
  00199	cc		 int	 3
??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBHH@std@@@std@@YAAAU?$pair@$$CBHH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBHH@std@@@std@@YAAAU?$pair@$$CBHH@0@AAU10@@Z PROC ; std::forward<std::pair<int const ,int> &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@$$CBHH@std@@@std@@YAAAU?$pair@$$CBHH@0@AAU10@@Z ENDP ; std::forward<std::pair<int const ,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::pair<int const ,int>,std::pair<int,int> >, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN13@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 156  : 		: first(_STD forward<_Other1>(_Right.first)),

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax

; 157  : 			second(_STD forward<_Other2>(_Right.second))

  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 919  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBHH@std@@U?$pair@HH@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::pair<int const ,int>,std::pair<int,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,int>,void *> * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHH@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBHH@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$pair@$$CBHH@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::pair<int const ,int> >, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@U?$pair@$$CBHH@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$pair@$$CBHH@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::pair<int const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<std::pair<int const ,int> >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<std::pair<int const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
tv735 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1799 : 		{	// try to insert node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c1		 mov	 eax, ecx
  0002d	89 45 e8	 mov	 DWORD PTR _this$1$[ebp], eax

; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1802 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1803 : 		bool _Addleft = true;	// add to left of head if tree empty

  00032	b2 01		 mov	 dl, 1
  00034	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]
  00037	8b f9		 mov	 edi, ecx
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00040	89 4d e4	 mov	 DWORD PTR tv735[ebp], ecx

; 1800 : 		_TRY_BEGIN
; 1801 : 		_Nodeptr _Trynode = _Root();

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1802 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1803 : 		bool _Addleft = true;	// add to left of head if tree empty

  00046	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1804 : 
; 1805 : 		while (!this->_Isnil(_Trynode))

  00049	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004d	75 30		 jne	 SHORT $LN3@Insert_noh
  0004f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00051	8a 75 0c	 mov	 dh, BYTE PTR __Leftish$[ebp]
$LL2@Insert_noh:

; 1806 : 			{	// look for leaf to insert before (_Addleft) or after
; 1807 : 			_Wherenode = _Trynode;

  00054	8b f8		 mov	 edi, eax

; 1808 : 			if (_Leftish)

  00056	84 f6		 test	 dh, dh
  00058	74 08		 je	 SHORT $LN5@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  0005a	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1809 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

  0005d	0f 9d c2	 setge	 dl

; 1810 : 					this->_Key(_Trynode),
; 1811 : 					this->_Kfn(_Val));	// favor left end
; 1812 : 			else

  00060	eb 06		 jmp	 SHORT $LN336@Insert_noh
$LN5@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  00062	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00065	0f 9c c2	 setl	 dl
$LN336@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1813 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

  00068	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1814 : 					this->_Kfn(_Val),
; 1815 : 					this->_Key(_Trynode));	// favor right end
; 1816 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

  0006b	84 d2		 test	 dl, dl
  0006d	74 04		 je	 SHORT $LN16@Insert_noh
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  00073	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1804 : 
; 1805 : 		while (!this->_Isnil(_Trynode))

  00076	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007a	74 d8		 je	 SHORT $LL2@Insert_noh
  0007c	8b 4d e4	 mov	 ecx, DWORD PTR tv735[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

  0007f	8b f7		 mov	 esi, edi
  00081	89 75 0c	 mov	 DWORD PTR __Where$4[ebp], esi

; 1817 : 				: this->_Right(_Trynode);
; 1818 : 			}
; 1819 : 
; 1820 : 		if (this->_Multi)
; 1821 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1822 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1823 : 		else
; 1824 : 			{	// insert only if unique
; 1825 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1826 : 			if (!_Addleft)

  00084	84 d2		 test	 dl, dl
  00086	74 41		 je	 SHORT $LN12@Insert_noh

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);

  00088	3b 39		 cmp	 edi, DWORD PTR [ecx]

; 1827 : 				;	// need to test if insert after is okay
; 1828 : 			else if (_Where == begin())

  0008a	75 32		 jne	 SHORT $LN11@Insert_noh

; 1829 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  0008c	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0008f	53		 push	 ebx
  00090	57		 push	 edi
  00091	6a 01		 push	 1
$LN337@Insert_noh:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00096	8d 45 0c	 lea	 eax, DWORD PTR $T3[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 143  : 		: first(_STD forward<_Other1>(_Val1)),

  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx

; 144  : 				second(_STD forward<_Other2>(_Val2))

  000a6	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1849 : 		}

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode
; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000be	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$4[ebp]
  000c1	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--
  000c6	8b 75 0c	 mov	 esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  000c9	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1837 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000cc	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  000cf	3b 03		 cmp	 eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1834 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  000d1	7d 1b		 jge	 SHORT $LN13@Insert_noh

; 1837 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000d3	53		 push	 ebx
  000d4	57		 push	 edi
  000d5	ff 75 ec	 push	 DWORD PTR __Addleft$2[ebp]
  000d8	eb b9		 jmp	 SHORT $LN337@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  000da	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000dd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e2	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1847 : 		_RERAISE;

  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN338@Insert_noh:
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  000ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 143  : 		: first(_STD forward<_Other1>(_Val1)),

  000f3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  000f6	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 143  : 		: first(_STD forward<_Other1>(_Val1)),

  000f9	89 30		 mov	 DWORD PTR [eax], esi

; 144  : 				second(_STD forward<_Other2>(_Val2))

  000fb	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1849 : 		}

  000ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00102	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00109	59		 pop	 ecx
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 10 00	 ret	 16			; 00000010H
$LN335@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@HH@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@U?$pair@HH@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@$$QAU?$pair@HH@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >, COMDAT
; _this$ = ecx

; 887  : 		{	// allocate a node with defaults and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 888  : 		_Nodeptr _Pnode = _Buynode0();

  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode0
  00009	8b d0		 mov	 edx, eax

; 602  : 		return ((reference)_Pnode->_Myval);

  0000b	8d 72 10	 lea	 esi, DWORD PTR [edx+16]

; 889  : 
; 890  : 		this->_Color(_Pnode) = _Red;

  0000e	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00014	85 f6		 test	 esi, esi
  00016	74 0f		 je	 SHORT $LN50@Buynode
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 156  : 		: first(_STD forward<_Other1>(_Right.first)),

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	89 0e		 mov	 DWORD PTR [esi], ecx

; 157  : 			second(_STD forward<_Other2>(_Right.second))

  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 902  : 		return (_Pnode);

  00025	8b c2		 mov	 eax, edx
$LN50@Buynode:
  00027	5e		 pop	 esi

; 903  : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$_Buynode@U?$pair@HH@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@$$QAU?$pair@HH@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z PROC ; std::forward<std::pair<int,int> >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ENDP ; std::forward<std::pair<int,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>, COMDAT

; 61   : 		{	// extract key from element value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 63   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@H@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Lbound@H@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound<int>, COMDAT
; _this$ = ecx

; 2087 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2088 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2089 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2090 : 
; 2091 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN72@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL2@Lbound:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2092 : 			if (_Compare(this->_Key(_Pnode), _Keyval))

  00016	7d 05		 jge	 SHORT $LN4@Lbound

; 2093 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2094 : 			else

  0001b	eb 04		 jmp	 SHORT $LN5@Lbound
$LN4@Lbound:

; 2095 : 				{	// _Pnode not less than _Keyval, remember it
; 2096 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2097 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN5@Lbound:

; 2089 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2090 : 
; 2091 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL2@Lbound
$LN72@Lbound:

; 2098 : 				}
; 2099 : 
; 2100 : 		return (_Wherenode);	// return best remembered candidate

  00027	8b c2		 mov	 eax, edx

; 2101 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$_Lbound@H@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHH@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBHH@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHH@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBHH@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHH@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::pair<int const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,int> >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHH@std@@@std@@SAPAU?$pair@$$CBHH@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHH@std@@@std@@SAPAU?$pair@$$CBHH@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,int> *>::pointer_to, COMDAT

; 316  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 318  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHH@std@@@std@@SAPAU?$pair@$$CBHH@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,int> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--, COMDAT
; _this$ = ecx

; 422  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--

; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 425  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator->, COMDAT
; _this$ = ecx

; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);
; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);
; 598  : 		}
; 599  : 
; 600  : 	static reference _Myval(_Nodeptr _Pnode)
; 601  : 		{	// return reference to value in node
; 602  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*, COMDAT
; _this$ = ecx

; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);
; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);
; 598  : 		}
; 599  : 
; 600  : 	static reference _Myval(_Nodeptr _Pnode)
; 601  : 		{	// return reference to value in node
; 602  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 382  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 383  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 377  : 		{	// construct with null node
; 378  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator!=, COMDAT
; _this$ = ecx

; 338  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 334  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 339  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 334  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 339  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 340  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 335  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 312  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*, COMDAT
; _this$ = ecx

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);
; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);
; 598  : 		}
; 599  : 
; 600  : 	static reference _Myval(_Nodeptr _Pnode)
; 601  : 		{	// return reference to value in node
; 602  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 210  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN4@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);
; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);
; 598  : 		}
; 599  : 
; 600  : 	static reference _Myval(_Nodeptr _Pnode)
; 601  : 		{	// return reference to value in node
; 602  : 		return ((reference)_Pnode->_Myval);
; 603  : 		}
; 604  : 
; 605  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 606  : 		{	// return rightmost node in subtree at _Pnode
; 607  : 		while (!_Isnil(_Right(_Pnode)))

  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN23@operator
$LL22@operator:

; 608  : 			_Pnode = _Right(_Pnode);

  00023	8b c8		 mov	 ecx, eax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);
; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);
; 598  : 		}
; 599  : 
; 600  : 	static reference _Myval(_Nodeptr _Pnode)
; 601  : 		{	// return reference to value in node
; 602  : 		return ((reference)_Pnode->_Myval);
; 603  : 		}
; 604  : 
; 605  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 606  : 		{	// return rightmost node in subtree at _Pnode
; 607  : 		while (!_Isnil(_Right(_Pnode)))

  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	0f 1f 40 00	 npad	 4
$LL2@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int,int> >, COMDAT
; _this$ = ecx

; 1092 : 		{	// try to insert node with value _Val, favoring right side

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1093 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00004	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >

; 1094 : 		return (_Insert_nohint(false,

  0000e	50		 push	 eax

; 602  : 		return ((reference)_Pnode->_Myval);

  0000f	83 c0 10	 add	 eax, 16			; 00000010H

; 1094 : 		return (_Insert_nohint(false,

  00012	8b cf		 mov	 ecx, edi
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	5f		 pop	 edi

; 1095 : 			this->_Myval(_Newnode), _Newnode));
; 1096 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0HHX@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HHX@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z PROC ; std::pair<int const ,int>::pair<int const ,int><int,int,void>, COMDAT
; _this$ = ecx

; 158  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  : 		: first(_STD forward<_Other1>(_Right.first)),

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 157  : 			second(_STD forward<_Other2>(_Right.second))

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 159  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??$?0HHX@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z ENDP ; std::pair<int const ,int>::pair<int const ,int><int,int,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAHAAHX@?$pair@HH@std@@QAE@AAH0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAHX@?$pair@HH@std@@QAE@AAH0@Z PROC		; std::pair<int,int>::pair<int,int><int &,int &,void>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  : 		: first(_STD forward<_Other1>(_Val1)),

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 144  : 				second(_STD forward<_Other2>(_Val2))

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 146  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAHAAHX@?$pair@HH@std@@QAE@AAH0@Z ENDP		; std::pair<int,int>::pair<int,int><int &,int &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\crywolfobjinfo.h
;	COMDAT ?AddObj@CCrywolfObjInfo@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?AddObj@CCrywolfObjInfo@@QAEHH@Z PROC			; CCrywolfObjInfo::AddObj, COMDAT
; _this$ = ecx

; 36   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   : 		if ( this->m_iObjCount >= MAX_CRYWOLF_OBJ_INFO )

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	81 fa 2c 01 00
	00		 cmp	 edx, 300		; 0000012cH
  0000b	7c 06		 jl	 SHORT $LN2@AddObj

; 38   : 		{
; 39   : 			return FALSE;

  0000d	33 c0		 xor	 eax, eax

; 46   : 	}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN2@AddObj:

; 40   : 		}
; 41   : 
; 42   : 		this->m_iObjIndex[this->m_iObjCount] = iIndex;

  00013	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00016	89 44 91 04	 mov	 DWORD PTR [ecx+edx*4+4], eax

; 43   : 		this->m_iObjCount++;
; 44   : 		
; 45   : 		return TRUE;

  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	ff 01		 inc	 DWORD PTR [ecx]

; 46   : 	}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?AddObj@CCrywolfObjInfo@@QAEHH@Z ENDP			; CCrywolfObjInfo::AddObj
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\crywolfobjinfo.h
;	COMDAT ?Reset@CCrywolfObjInfo@@QAEXXZ
_TEXT	SEGMENT
?Reset@CCrywolfObjInfo@@QAEXXZ PROC			; CCrywolfObjInfo::Reset, COMDAT
; _this$ = ecx

; 26   : 	{

  00000	8b d1		 mov	 edx, ecx

; 27   : 		for ( int i=0;i<MAX_CRYWOLF_OBJ_INFO;i++)
; 28   : 		{
; 29   : 			this->m_iObjIndex[i] = -1;

  00002	83 c8 ff	 or	 eax, -1
  00005	57		 push	 edi
  00006	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH
  0000b	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  0000e	f3 ab		 rep stosd

; 30   : 		}
; 31   : 
; 32   : 		this->m_iObjCount = 0;

  00010	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00016	5f		 pop	 edi

; 33   : 	}

  00017	c3		 ret	 0
?Reset@CCrywolfObjInfo@@QAEXXZ ENDP			; CCrywolfObjInfo::Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?GetShopID@CMonsterSetBase@@QAEHH@Z
_TEXT	SEGMENT
__It$1 = -4						; size = 4
_posnum$ = 8						; size = 4
?GetShopID@CMonsterSetBase@@QAEHH@Z PROC		; CMonsterSetBase::GetShopID, COMDAT
; _this$ = ecx

; 723  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 724  : 	if( posnum != -1 )

  00004	83 7d 08 ff	 cmp	 DWORD PTR _posnum$[ebp], -1
  00008	74 27		 je	 SHORT $LN3@GetShopID

; 725  : 	{
; 726  : 		std::map<int,int>::iterator _It = this->m_mShopNum.find(posnum);

  0000a	56		 push	 esi
  0000b	8d 45 08	 lea	 eax, DWORD PTR _posnum$[ebp]
  0000e	50		 push	 eax
  0000f	8d b1 64 34 03
	00		 lea	 esi, DWORD PTR [ecx+210020]
  00015	8d 45 fc	 lea	 eax, DWORD PTR __It$1[ebp]
  00018	8b ce		 mov	 ecx, esi
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 334  : 		return (this->_Ptr == _Right._Ptr);

  00020	8b 45 fc	 mov	 eax, DWORD PTR __It$1[ebp]
  00023	3b 06		 cmp	 eax, DWORD PTR [esi]
  00025	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp

; 728  : 		if( _It != this->m_mShopNum.end() )

  00026	74 09		 je	 SHORT $LN3@GetShopID

; 729  : 			return _It->second;

  00028	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 732  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN3@GetShopID:

; 730  : 	}
; 731  : return -1;

  00031	83 c8 ff	 or	 eax, -1

; 732  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?GetShopID@CMonsterSetBase@@QAEHH@Z ENDP		; CMonsterSetBase::GetShopID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?SetMonsterSetBase@CMonsterSetBase@@QAEHHHHHHHHHHHH@Z
_TEXT	SEGMENT
_ArrangeType$ = 8					; size = 4
_LoadType$ = 12						; size = 4
_Type$ = 16						; size = 4
_MapNumber$ = 20					; size = 4
_Dis$ = 24						; size = 4
_X$ = 28						; size = 4
_Y$ = 32						; size = 4
_Dir$ = 36						; size = 4
_W$ = 40						; size = 4
_H$ = 44						; size = 4
_Element$ = 48						; size = 4
?SetMonsterSetBase@CMonsterSetBase@@QAEHHHHHHHHHHHH@Z PROC ; CMonsterSetBase::SetMonsterSetBase, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 43   : 	for(int i = 0; i < OBJ_MAXMONSTER; i++)

  00006	33 c0		 xor	 eax, eax
  00008	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@SetMonster:

; 44   : 	{
; 45   : 		if( this->m_Mp[i].m_ArrangeType != (BYTE)-1 )

  00010	80 3a ff	 cmp	 BYTE PTR [edx], 255	; 000000ffH
  00013	74 13		 je	 SHORT $LN5@SetMonster

; 43   : 	for(int i = 0; i < OBJ_MAXMONSTER; i++)

  00015	40		 inc	 eax
  00016	83 c2 14	 add	 edx, 20			; 00000014H
  00019	3d 04 29 00 00	 cmp	 eax, 10500		; 00002904H
  0001e	7c f0		 jl	 SHORT $LL4@SetMonster

; 59   : 		return i;
; 60   : 	}
; 61   : return -1;

  00020	83 c8 ff	 or	 eax, -1
  00023	5e		 pop	 esi

; 62   : }

  00024	5d		 pop	 ebp
  00025	c2 2c 00	 ret	 44			; 0000002cH
$LN5@SetMonster:

; 46   : 			continue;
; 47   : 
; 48   : 		this->m_Mp[i].m_ArrangeType = ArrangeType;

  00028	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0002b	8d 14 8e	 lea	 edx, DWORD PTR [esi+ecx*4]
  0002e	8a 4d 08	 mov	 cl, BYTE PTR _ArrangeType$[ebp]
  00031	88 4a 04	 mov	 BYTE PTR [edx+4], cl

; 49   : 		this->m_Mp[i].m_LoadType = LoadType;

  00034	8a 4d 0c	 mov	 cl, BYTE PTR _LoadType$[ebp]
  00037	88 4a 05	 mov	 BYTE PTR [edx+5], cl

; 50   : 		this->m_Mp[i].m_Type = Type;

  0003a	66 8b 4d 10	 mov	 cx, WORD PTR _Type$[ebp]
  0003e	66 89 4a 06	 mov	 WORD PTR [edx+6], cx

; 51   : 		this->m_Mp[i].m_MapNumber = MapNumber;

  00042	8a 4d 14	 mov	 cl, BYTE PTR _MapNumber$[ebp]
  00045	88 4a 08	 mov	 BYTE PTR [edx+8], cl

; 52   : 		this->m_Mp[i].m_Dis = Dis;

  00048	8a 4d 18	 mov	 cl, BYTE PTR _Dis$[ebp]
  0004b	88 4a 09	 mov	 BYTE PTR [edx+9], cl

; 53   : 		this->m_Mp[i].m_X = X;

  0004e	8a 4d 1c	 mov	 cl, BYTE PTR _X$[ebp]
  00051	88 4a 0a	 mov	 BYTE PTR [edx+10], cl

; 54   : 		this->m_Mp[i].m_Y = Y;

  00054	8a 4d 20	 mov	 cl, BYTE PTR _Y$[ebp]
  00057	88 4a 0b	 mov	 BYTE PTR [edx+11], cl

; 55   : 		this->m_Mp[i].m_Dir = Dir;

  0005a	8a 4d 24	 mov	 cl, BYTE PTR _Dir$[ebp]
  0005d	88 4a 0c	 mov	 BYTE PTR [edx+12], cl

; 56   : 		this->m_Mp[i].m_W = W;

  00060	8a 4d 28	 mov	 cl, BYTE PTR _W$[ebp]
  00063	88 4a 0d	 mov	 BYTE PTR [edx+13], cl

; 57   : 		this->m_Mp[i].m_H = H;

  00066	8a 4d 2c	 mov	 cl, BYTE PTR _H$[ebp]
  00069	88 4a 0e	 mov	 BYTE PTR [edx+14], cl

; 58   : 		this->m_Mp[i].m_PentagramMainAttribute = Element;

  0006c	8b 4d 30	 mov	 ecx, DWORD PTR _Element$[ebp]
  0006f	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  00072	5e		 pop	 esi

; 62   : }

  00073	5d		 pop	 ebp
  00074	c2 2c 00	 ret	 44			; 0000002cH
?SetMonsterSetBase@CMonsterSetBase@@QAEHHHHHHHHHHHH@Z ENDP ; CMonsterSetBase::SetMonsterSetBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAE0@Z
_TEXT	SEGMENT
_ty$ = -44						; size = 4
_count$ = -40						; size = 4
_tx$ = -36						; size = 4
_h$ = -32						; size = 4
_w$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_mapnumber$ = 8						; size = 4
_ax$ = 12						; size = 4
_ay$ = 16						; size = 4
_aw$ = 20						; size = 4
_ah$ = 24						; size = 4
_mx$ = 28						; size = 4
_my$ = 32						; size = 4
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAE0@Z PROC	; CMonsterSetBase::GetBoxPosition, COMDAT
; _this$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAE0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 89   : 	int count = 100 ; 

  00033	be 64 00 00 00	 mov	 esi, 100		; 00000064H
  00038	8b 7d 10	 mov	 edi, DWORD PTR _ay$[ebp]
  0003b	0f 1f 44 00 00	 npad	 5
$LL2@GetBoxPosi:

; 90   : 	int w;
; 91   : 	int h;
; 92   : 	int tx; 
; 93   : 	int ty;
; 94   : 	BYTE attr;
; 95   : 
; 96   : 	while ( count-- != 0)

  00040	8b c6		 mov	 eax, esi
  00042	4e		 dec	 esi
  00043	89 75 d8	 mov	 DWORD PTR _count$[ebp], esi
  00046	85 c0		 test	 eax, eax
  00048	0f 84 af 00 00
	00		 je	 $LN3@GetBoxPosi

; 97   : 	{
; 98   : 		w = aw - ax;

  0004e	8b 45 14	 mov	 eax, DWORD PTR _aw$[ebp]
  00051	8b 5d 0c	 mov	 ebx, DWORD PTR _ax$[ebp]
  00054	2b c3		 sub	 eax, ebx
  00056	89 45 e4	 mov	 DWORD PTR _w$[ebp], eax

; 99   : 		h = ah - ay;

  00059	8b 45 18	 mov	 eax, DWORD PTR _ah$[ebp]
  0005c	2b c7		 sub	 eax, edi
  0005e	89 45 e0	 mov	 DWORD PTR _h$[ebp], eax

; 100  : 
; 101  : 		__try

  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 102  : 		{
; 103  : 			tx = ax + (rand()%w);

  00068	e8 00 00 00 00	 call	 _rand
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR _w$[ebp]
  00070	99		 cdq
  00071	f7 f9		 idiv	 ecx
  00073	03 d3		 add	 edx, ebx
  00075	89 55 dc	 mov	 DWORD PTR _tx$[ebp], edx

; 104  : 			ty = ay + (rand()%h);

  00078	e8 00 00 00 00	 call	 _rand
  0007d	8b 4d e0	 mov	 ecx, DWORD PTR _h$[ebp]
  00080	99		 cdq
  00081	f7 f9		 idiv	 ecx
  00083	8d 1c 17	 lea	 ebx, DWORD PTR [edi+edx]
  00086	89 5d d4	 mov	 DWORD PTR _ty$[ebp], ebx

; 105  : 		}

  00089	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00090	eb 27		 jmp	 SHORT $LN11@GetBoxPosi
$LN8@GetBoxPosi:
$LN16@GetBoxPosi:

; 106  : 		__except (w=1,h=1,1)

  00092	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
  00099	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
  000a0	b8 01 00 00 00	 mov	 eax, 1
$LN15@GetBoxPosi:
$LN10@GetBoxPosi:
  000a5	c3		 ret	 0
$LN9@GetBoxPosi:
  000a6	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 105  : 		}

  000a9	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000b0	8b 7d 10	 mov	 edi, DWORD PTR _ay$[ebp]
  000b3	8b 75 d8	 mov	 esi, DWORD PTR _count$[ebp]
  000b6	8b 5d d4	 mov	 ebx, DWORD PTR _ty$[ebp]
$LN11@GetBoxPosi:

; 107  : 		{
; 108  : 
; 109  : 		}
; 110  : 
; 111  : 		attr = MapC[mapnumber].GetAttr(tx, ty);

  000b9	53		 push	 ebx
  000ba	ff 75 dc	 push	 DWORD PTR _tx$[ebp]
  000bd	69 4d 08 28 38
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 342056
  000c4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000ca	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000cf	a8 0d		 test	 al, 13			; 0000000dH

; 112  : 
; 113  : 		if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  000d1	0f 85 69 ff ff
	ff		 jne	 $LL2@GetBoxPosi

; 114  : 		{
; 115  : 			mx = tx;

  000d7	8b 45 1c	 mov	 eax, DWORD PTR _mx$[ebp]
  000da	8b 4d dc	 mov	 ecx, DWORD PTR _tx$[ebp]
  000dd	88 08		 mov	 BYTE PTR [eax], cl

; 116  : 			my = ty;

  000df	8b 45 20	 mov	 eax, DWORD PTR _my$[ebp]
  000e2	88 18		 mov	 BYTE PTR [eax], bl

; 117  : 			return TRUE;

  000e4	b8 01 00 00 00	 mov	 eax, 1

; 122  : }

  000e9	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f3	59		 pop	 ecx
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 1c 00	 ret	 28			; 0000001cH
$LN3@GetBoxPosi:

; 118  : 		}
; 119  : 	}
; 120  : 
; 121  : 	return false;

  000fd	33 c0		 xor	 eax, eax

; 122  : }

  000ff	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00102	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00109	59		 pop	 ecx
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 1c 00	 ret	 28			; 0000001cH
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAE0@Z ENDP	; CMonsterSetBase::GetBoxPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?GetPosition@CMonsterSetBase@@QAEHHFAAE0@Z
_TEXT	SEGMENT
_ty$1$ = -4						; size = 4
tv382 = 8						; size = 4
_TableNum$ = 8						; size = 4
_Ory$1$ = 12						; size = 4
tv375 = 12						; size = 4
_MapNumber$ = 12					; size = 2
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?GetPosition@CMonsterSetBase@@QAEHHFAAE0@Z PROC		; CMonsterSetBase::GetPosition, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 126  : 	int count = 100;
; 127  : 	BYTE attr;
; 128  : 	int tx;
; 129  : 	int ty;
; 130  : 	int w;
; 131  : 	int h;
; 132  : 
; 133  : 	if ( TableNum < 0 || TableNum > OBJ_MAXMONSTER-1 )

  00004	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00007	56		 push	 esi
  00008	be 64 00 00 00	 mov	 esi, 100		; 00000064H
  0000d	3d 03 29 00 00	 cmp	 eax, 10499		; 00002903H
  00012	0f 87 83 01 00
	00		 ja	 $LN7@GetPositio

; 137  : 	}
; 138  : 
; 139  : 	if ( this->m_Mp[TableNum].m_ArrangeType == 1 
; 140  : 		|| this->m_Mp[TableNum].m_ArrangeType == 3 
; 141  : 		|| this->m_Mp[TableNum].m_ArrangeType == 6 )

  00018	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0001b	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0001e	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  00021	89 55 08	 mov	 DWORD PTR tv382[ebp], edx
  00024	53		 push	 ebx
  00025	57		 push	 edi
  00026	3c 01		 cmp	 al, 1
  00028	0f 84 ce 00 00
	00		 je	 $LN35@GetPositio
  0002e	3c 03		 cmp	 al, 3
  00030	0f 84 c6 00 00
	00		 je	 $LN35@GetPositio
  00036	3c 06		 cmp	 al, 6
  00038	0f 84 be 00 00
	00		 je	 $LN35@GetPositio

; 168  : 				y = ty;
; 169  : 				return TRUE;
; 170  : 			}
; 171  : 		}
; 172  : 	}
; 173  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 0 )

  0003e	84 c0		 test	 al, al
  00040	0f 84 96 00 00
	00		 je	 $LN20@GetPositio

; 174  : 	{
; 175  : 		x = this->m_Mp[TableNum].m_X;
; 176  : 		y = this->m_Mp[TableNum].m_Y;
; 177  : 		return true;
; 178  : 	}
; 179  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 2 )

  00046	3c 02		 cmp	 al, 2
  00048	0f 85 82 00 00
	00		 jne	 $LN16@GetPositio
  0004e	0f bf 45 0c	 movsx	 eax, WORD PTR _MapNumber$[ebp]
  00052	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  00058	8d b8 00 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  0005e	66 90		 npad	 2
$LL4@GetPositio:

; 182  : 		{
; 183  : 			int Orx = this->m_Mp[TableNum].m_X -3;
; 184  : 			int Ory = this->m_Mp[TableNum].m_Y -3;

  00060	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  00064	4e		 dec	 esi
  00065	0f b6 5a 0a	 movzx	 ebx, BYTE PTR [edx+10]
  00069	83 e8 03	 sub	 eax, 3
  0006c	83 eb 03	 sub	 ebx, 3
  0006f	89 45 0c	 mov	 DWORD PTR _Ory$1$[ebp], eax

; 185  : 
; 186  : 			Orx += rand() % 7;

  00072	e8 00 00 00 00	 call	 _rand
  00077	99		 cdq
  00078	b9 07 00 00 00	 mov	 ecx, 7
  0007d	f7 f9		 idiv	 ecx
  0007f	03 da		 add	 ebx, edx

; 187  : 			Ory += rand() % 7;

  00081	e8 00 00 00 00	 call	 _rand
  00086	99		 cdq
  00087	b9 07 00 00 00	 mov	 ecx, 7
  0008c	f7 f9		 idiv	 ecx
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _Ory$1$[ebp]

; 188  : 
; 189  : 			attr = MapC[MapNumber].GetAttr(Orx, Ory);

  00091	8b cf		 mov	 ecx, edi
  00093	03 c2		 add	 eax, edx
  00095	50		 push	 eax
  00096	53		 push	 ebx
  00097	89 45 0c	 mov	 DWORD PTR _Ory$1$[ebp], eax
  0009a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0009f	a8 0d		 test	 al, 13			; 0000000dH

; 190  : 
; 191  : 			if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  000a1	74 12		 je	 SHORT $LN24@GetPositio

; 180  : 	{
; 181  : 		while ( count-- != 0 )

  000a3	8b 55 08	 mov	 edx, DWORD PTR tv382[ebp]
  000a6	85 f6		 test	 esi, esi
  000a8	75 b6		 jne	 SHORT $LL4@GetPositio

; 205  : 	}
; 206  : 
; 207  : 	return false;

  000aa	5f		 pop	 edi
  000ab	5b		 pop	 ebx
  000ac	33 c0		 xor	 eax, eax
  000ae	5e		 pop	 esi

; 208  : }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 10 00	 ret	 16			; 00000010H
$LN24@GetPositio:

; 192  : 			{
; 193  : 				x = Orx;

  000b5	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]

; 194  : 				y = Ory;

  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _Ory$1$[ebp]
  000bb	5f		 pop	 edi
  000bc	88 18		 mov	 BYTE PTR [eax], bl
  000be	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  000c1	5b		 pop	 ebx
  000c2	5e		 pop	 esi
  000c3	88 08		 mov	 BYTE PTR [eax], cl

; 204  : 		return TRUE;

  000c5	b8 01 00 00 00	 mov	 eax, 1

; 208  : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 10 00	 ret	 16			; 00000010H
$LN16@GetPositio:

; 195  : 				return TRUE;
; 196  : 			}
; 197  : 		}
; 198  : 	}
; 199  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 4 ||

  000d0	3c 04		 cmp	 al, 4
  000d2	74 08		 je	 SHORT $LN20@GetPositio
  000d4	3c 05		 cmp	 al, 5
  000d6	0f 85 99 00 00
	00		 jne	 $LN27@GetPositio
$LN20@GetPositio:

; 200  : 				this->m_Mp[TableNum].m_ArrangeType == 5 )
; 201  : 	{
; 202  : 		x = this->m_Mp[TableNum].m_X;

  000dc	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  000df	0f b6 4a 0a	 movzx	 ecx, BYTE PTR [edx+10]
  000e3	5f		 pop	 edi
  000e4	5b		 pop	 ebx
  000e5	88 08		 mov	 BYTE PTR [eax], cl

; 203  : 		y = this->m_Mp[TableNum].m_Y;

  000e7	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  000ea	0f b6 4a 0b	 movzx	 ecx, BYTE PTR [edx+11]
  000ee	5e		 pop	 esi
  000ef	88 08		 mov	 BYTE PTR [eax], cl

; 204  : 		return TRUE;

  000f1	b8 01 00 00 00	 mov	 eax, 1

; 208  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 10 00	 ret	 16			; 00000010H
$LN35@GetPositio:
  000fc	0f bf 45 0c	 movsx	 eax, WORD PTR _MapNumber$[ebp]

; 204  : 		return TRUE;

  00100	b9 01 00 00 00	 mov	 ecx, 1
  00105	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  0010b	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00111	89 45 0c	 mov	 DWORD PTR tv375[ebp], eax
$LL2@GetPositio:

; 142  : 	{
; 143  : 		while ( count-- != 0 )

  00114	0f b6 42 0a	 movzx	 eax, BYTE PTR [edx+10]
  00118	4e		 dec	 esi

; 144  : 		{
; 145  : 			w = this->m_Mp[TableNum].m_W - this->m_Mp[TableNum].m_X;

  00119	0f b6 7a 0d	 movzx	 edi, BYTE PTR [edx+13]

; 146  : 			h = this->m_Mp[TableNum].m_H - this->m_Mp[TableNum].m_Y;

  0011d	0f b6 5a 0e	 movzx	 ebx, BYTE PTR [edx+14]
  00121	2b f8		 sub	 edi, eax
  00123	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  00127	2b d8		 sub	 ebx, eax

; 147  : 
; 148  : 			if ( w < 1 )

  00129	83 ff 01	 cmp	 edi, 1
  0012c	0f 4c f9	 cmovl	 edi, ecx

; 149  : 			{
; 150  : 				w = 1;
; 151  : 			}
; 152  : 
; 153  : 			if ( h < 1 )

  0012f	83 fb 01	 cmp	 ebx, 1
  00132	0f 4c d9	 cmovl	 ebx, ecx

; 154  : 			{
; 155  : 				h = 1;
; 156  : 			}
; 157  : 
; 158  : 			int iRX = GetLargeRand()%w;

  00135	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  0013a	33 d2		 xor	 edx, edx
  0013c	f7 f7		 div	 edi
  0013e	8b fa		 mov	 edi, edx

; 159  : 			int iRY = GetLargeRand()%h;

  00140	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  00145	33 d2		 xor	 edx, edx

; 160  : 
; 161  : 			tx = this->m_Mp[TableNum].m_X +  iRX;
; 162  : 			ty = this->m_Mp[TableNum].m_Y +  iRY;
; 163  : 			attr = MapC[MapNumber].GetAttr(tx, ty);

  00147	8b 4d 0c	 mov	 ecx, DWORD PTR tv375[ebp]
  0014a	f7 f3		 div	 ebx
  0014c	8b 45 08	 mov	 eax, DWORD PTR tv382[ebp]
  0014f	0f b6 58 0a	 movzx	 ebx, BYTE PTR [eax+10]
  00153	0f b6 40 0b	 movzx	 eax, BYTE PTR [eax+11]
  00157	03 df		 add	 ebx, edi
  00159	03 c2		 add	 eax, edx
  0015b	50		 push	 eax
  0015c	53		 push	 ebx
  0015d	89 45 fc	 mov	 DWORD PTR _ty$1$[ebp], eax
  00160	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00165	a8 0d		 test	 al, 13			; 0000000dH

; 164  : 
; 165  : 			if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  00167	74 17		 je	 SHORT $LN25@GetPositio

; 142  : 	{
; 143  : 		while ( count-- != 0 )

  00169	8b 55 08	 mov	 edx, DWORD PTR tv382[ebp]
  0016c	b9 01 00 00 00	 mov	 ecx, 1
  00171	85 f6		 test	 esi, esi
  00173	75 9f		 jne	 SHORT $LL2@GetPositio
$LN27@GetPositio:
  00175	5f		 pop	 edi
  00176	5b		 pop	 ebx

; 205  : 	}
; 206  : 
; 207  : 	return false;

  00177	33 c0		 xor	 eax, eax
  00179	5e		 pop	 esi

; 208  : }

  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c2 10 00	 ret	 16			; 00000010H
$LN25@GetPositio:

; 166  : 			{
; 167  : 				x = tx;

  00180	8b 4d 10	 mov	 ecx, DWORD PTR _x$[ebp]

; 204  : 		return TRUE;

  00183	b8 01 00 00 00	 mov	 eax, 1
  00188	8b 55 fc	 mov	 edx, DWORD PTR _ty$1$[ebp]
  0018b	5f		 pop	 edi
  0018c	88 19		 mov	 BYTE PTR [ecx], bl
  0018e	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00191	5b		 pop	 ebx
  00192	5e		 pop	 esi
  00193	88 11		 mov	 BYTE PTR [ecx], dl

; 208  : }

  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c2 10 00	 ret	 16			; 00000010H
$LN7@GetPositio:

; 134  : 	{
; 135  : 		LogAdd("ERROR : %s %d", __FILE__, __LINE__ );

  0019b	68 87 00 00 00	 push	 135			; 00000087H
  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 136  : 		return false;

  001b3	33 c0		 xor	 eax, eax
  001b5	5e		 pop	 esi

; 208  : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 10 00	 ret	 16			; 00000010H
?GetPosition@CMonsterSetBase@@QAEHHFAAE0@Z ENDP		; CMonsterSetBase::GetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?AddAllMonsters@CMonsterSetBase@@QAEXH@Z
_TEXT	SEGMENT
tv803 = -28						; size = 4
tv801 = -24						; size = 4
tv799 = -20						; size = 4
tv797 = -16						; size = 4
tv795 = -12						; size = 4
tv793 = -8						; size = 4
_n$1$ = -4						; size = 4
_type$ = 8						; size = 4
?AddAllMonsters@CMonsterSetBase@@QAEXH@Z PROC		; CMonsterSetBase::AddAllMonsters, COMDAT
; _this$ = ecx

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 574  : 	gCurPaintPlayer = 0;
; 575  : 
; 576  : 	int result;
; 577  : 
; 578  : 	for ( int n=0;n< OBJ_MAXMONSTER;n++)

  00009	33 ff		 xor	 edi, edi
  0000b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCurPaintPlayer@@3HA, 0 ; gCurPaintPlayer
  00015	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
  00018	89 7d fc	 mov	 DWORD PTR _n$1$[ebp], edi
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  0001e	ba e8 00 00 00	 mov	 edx, 232		; 000000e8H
  00023	be 7d 01 00 00	 mov	 esi, 381		; 0000017dH
  00028	c7 45 f8 7e 01
	00 00		 mov	 DWORD PTR tv793[ebp], 382 ; 0000017eH
  0002f	c7 45 f4 7c 01
	00 00		 mov	 DWORD PTR tv795[ebp], 380 ; 0000017cH
  00036	c7 45 f0 7f 01
	00 00		 mov	 DWORD PTR tv797[ebp], 383 ; 0000017fH
  0003d	c7 45 ec 80 01
	00 00		 mov	 DWORD PTR tv799[ebp], 384 ; 00000180H
  00044	c7 45 e8 82 01
	00 00		 mov	 DWORD PTR tv801[ebp], 386 ; 00000182H
  0004b	c7 45 e4 93 01
	00 00		 mov	 DWORD PTR tv803[ebp], 403 ; 00000193H
$LL4@AddAllMons:

; 579  : 	{
; 580  : 		if ( this->m_Mp[n].m_ArrangeType == (BYTE)-1 )

  00052	80 7b fc ff	 cmp	 BYTE PTR [ebx-4], 255	; 000000ffH
  00056	0f 84 27 02 00
	00		 je	 $LN2@AddAllMons

; 581  : 			continue;
; 582  : 
; 583  : 		if ( type != LOAD_ALLOBJ && type != this->m_Mp[n].m_LoadType )

  0005c	83 f9 ff	 cmp	 ecx, -1
  0005f	74 0c		 je	 SHORT $LN6@AddAllMons
  00061	0f b6 43 fd	 movzx	 eax, BYTE PTR [ebx-3]
  00065	3b c8		 cmp	 ecx, eax
  00067	0f 85 16 02 00
	00		 jne	 $LN2@AddAllMons
$LN6@AddAllMons:

; 584  : 			continue;
; 585  : 
; 586  : 
; 587  : 		if ( DS_MAP_RANGE(this->m_Mp[n].m_MapNumber) != FALSE )

  0006d	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0006f	80 f9 09	 cmp	 cl, 9
  00072	0f 84 08 02 00
	00		 je	 $LN78@AddAllMons
  00078	33 c0		 xor	 eax, eax
  0007a	80 f9 20	 cmp	 cl, 32			; 00000020H
  0007d	0f 94 c0	 sete	 al
  00080	85 c0		 test	 eax, eax
  00082	0f 85 f8 01 00
	00		 jne	 $LN78@AddAllMons

; 588  : 		{
; 589  : 			continue;
; 590  : 		}
; 591  : 
; 592  : 		if ( BC_MAP_RANGE(this->m_Mp[n].m_MapNumber) != FALSE )

  00088	80 f9 34	 cmp	 cl, 52			; 00000034H
  0008b	74 13		 je	 SHORT $LN63@AddAllMons
  0008d	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00090	72 18		 jb	 SHORT $LN9@AddAllMons
  00092	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00097	3a c1		 cmp	 al, cl
  00099	1b c0		 sbb	 eax, eax
  0009b	83 c0 01	 add	 eax, 1
  0009e	74 0a		 je	 SHORT $LN9@AddAllMons
$LN63@AddAllMons:

; 593  : 		{
; 594  : 			if ( this->m_Mp[n].m_Type != 232 )

  000a0	66 39 53 fe	 cmp	 WORD PTR [ebx-2], dx
  000a4	0f 85 d6 01 00
	00		 jne	 $LN78@AddAllMons
$LN9@AddAllMons:

; 595  : 			{
; 596  : 				continue;
; 597  : 			}
; 598  : 		}
; 599  : 
; 600  : 		if (DG_MAP_RANGE(this->m_Mp[n].m_MapNumber) != FALSE )

  000aa	80 f9 41	 cmp	 cl, 65			; 00000041H
  000ad	72 0f		 jb	 SHORT $LN64@AddAllMons
  000af	b0 44		 mov	 al, 68			; 00000044H
  000b1	3a c1		 cmp	 al, cl
  000b3	1b c0		 sbb	 eax, eax
  000b5	83 c0 01	 add	 eax, 1
  000b8	0f 85 c2 01 00
	00		 jne	 $LN78@AddAllMons
$LN64@AddAllMons:

; 601  : 		{
; 602  : 			continue;
; 603  : 		}
; 604  : 
; 605  : 		if ( CC_MAP_RANGE(this->m_Mp[n].m_MapNumber) != FALSE )

  000be	80 f9 35	 cmp	 cl, 53			; 00000035H
  000c1	0f 84 b9 01 00
	00		 je	 $LN78@AddAllMons
  000c7	80 f9 12	 cmp	 cl, 18			; 00000012H
  000ca	72 0f		 jb	 SHORT $LN65@AddAllMons
  000cc	b0 17		 mov	 al, 23			; 00000017H
  000ce	3a c1		 cmp	 al, cl
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 c0 01	 add	 eax, 1
  000d5	0f 85 a5 01 00
	00		 jne	 $LN78@AddAllMons
$LN65@AddAllMons:

; 606  : 		{
; 607  : 			continue;
; 608  : 		}
; 609  : 
; 610  : 		if ( IF_MAP_RANGE(this->m_Mp[n].m_MapNumber) != FALSE )

  000db	80 f9 45	 cmp	 cl, 69			; 00000045H
  000de	72 0f		 jb	 SHORT $LN66@AddAllMons
  000e0	b0 48		 mov	 al, 72			; 00000048H
  000e2	3a c1		 cmp	 al, cl
  000e4	1b c0		 sbb	 eax, eax
  000e6	83 c0 01	 add	 eax, 1
  000e9	0f 85 91 01 00
	00		 jne	 $LN78@AddAllMons
$LN66@AddAllMons:

; 611  : 		{
; 612  : 			continue;
; 613  : 		}
; 614  : 
; 615  : 		if ( IT_MAP_RANGE(this->m_Mp[n].m_MapNumber) != FALSE )

  000ef	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000f2	72 60		 jb	 SHORT $LN14@AddAllMons
  000f4	b0 32		 mov	 al, 50			; 00000032H
  000f6	3a c1		 cmp	 al, cl
  000f8	1b c0		 sbb	 eax, eax
  000fa	83 c0 01	 add	 eax, 1
  000fd	74 55		 je	 SHORT $LN14@AddAllMons

; 616  : 		{
; 617  : 			if( this->m_Mp[n].m_Type != 381 && this->m_Mp[n].m_Type != 382 )

  000ff	0f b7 43 fe	 movzx	 eax, WORD PTR [ebx-2]
  00103	66 3b c6	 cmp	 ax, si
  00106	74 4c		 je	 SHORT $LN14@AddAllMons
  00108	66 3b 45 f8	 cmp	 ax, WORD PTR tv793[ebp]
  0010c	74 46		 je	 SHORT $LN14@AddAllMons

; 618  : 			{
; 619  : 				if( this->m_Mp[n].m_Type == 380 ||
; 620  : 					this->m_Mp[n].m_Type == 383 ||

  0010e	66 3b 45 f4	 cmp	 ax, WORD PTR tv795[ebp]
  00112	74 2e		 je	 SHORT $LN17@AddAllMons
  00114	66 3b 45 f0	 cmp	 ax, WORD PTR tv797[ebp]
  00118	74 28		 je	 SHORT $LN17@AddAllMons
  0011a	66 3b 45 ec	 cmp	 ax, WORD PTR tv799[ebp]
  0011e	74 22		 je	 SHORT $LN17@AddAllMons

; 624  : 				}
; 625  : 				else if( this->m_Mp[n].m_Type >= 386 ||

  00120	66 3b 45 e8	 cmp	 ax, WORD PTR tv801[ebp]
  00124	73 0a		 jae	 SHORT $LN19@AddAllMons
  00126	66 3b 45 e4	 cmp	 ax, WORD PTR tv803[ebp]
  0012a	0f 87 50 01 00
	00		 ja	 $LN78@AddAllMons
$LN19@AddAllMons:

; 626  : 						 this->m_Mp[n].m_Type <= 403 )
; 627  : 				{
; 628  : 					g_IllusionTemple.AddMonster(this->m_Mp[n].m_MapNumber,this->m_Mp[n].m_Type,n);

  00130	57		 push	 edi
  00131	50		 push	 eax
  00132	51		 push	 ecx
  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00138	e8 00 00 00 00	 call	 ?AddMonster@CIllusionTempleEvent@@QAEXEHH@Z ; CIllusionTempleEvent::AddMonster
  0013d	e9 39 01 00 00	 jmp	 $LN82@AddAllMons
$LN17@AddAllMons:

; 621  : 					this->m_Mp[n].m_Type == 384 )
; 622  : 				{
; 623  : 					g_IllusionTemple.AddNpc(this->m_Mp[n].m_MapNumber,this->m_Mp[n].m_Type,n);

  00142	57		 push	 edi
  00143	50		 push	 eax
  00144	51		 push	 ecx
  00145	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  0014a	e8 00 00 00 00	 call	 ?AddNpc@CIllusionTempleEvent@@QAEXEHH@Z ; CIllusionTempleEvent::AddNpc

; 629  : 				}
; 630  : 				continue;

  0014f	e9 27 01 00 00	 jmp	 $LN82@AddAllMons
$LN14@AddAllMons:

; 631  : 			}
; 632  : 		}
; 633  : 
; 634  : 		//if( this->m_Mp[n].m_MapNumber == MAP_INDEX_RAKLIONBOSS && (this->m_Mp[n].m_Type == 459 || this->m_Mp[n].m_Type == 457 || this->m_Mp[n].m_Type == 458 ))
; 635  : 			//continue;
; 636  : 
; 637  : 		result = gObjAddMonster(this->m_Mp[n].m_MapNumber);

  00154	0f b6 c1	 movzx	 eax, cl
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0015d	0f bf f0	 movsx	 esi, ax
  00160	83 c4 04	 add	 esp, 4

; 638  : 
; 639  : 		if ( result >= 0 )

  00163	85 f6		 test	 esi, esi
  00165	0f 88 0b 01 00
	00		 js	 $LN73@AddAllMons

; 640  : 		{
; 641  : 			gObjSetPosMonster(result, n);

  0016b	57		 push	 edi
  0016c	56		 push	 esi
  0016d	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 642  : 			gObjSetMonster(result, this->m_Mp[n].m_Type);

  00172	0f b7 43 fe	 movzx	 eax, WORD PTR [ebx-2]
  00176	50		 push	 eax
  00177	56		 push	 esi
  00178	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 643  : 			gCurPaintPlayer++;
; 644  : 
; 645  : 			if ( BC_MAP_RANGE(gObj[result].MapNumber) )

  0017d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00183	83 c4 10	 add	 esp, 16			; 00000010H
  00186	ff 05 00 00 00
	00		 inc	 DWORD PTR ?gCurPaintPlayer@@3HA ; gCurPaintPlayer
  0018c	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00192	8a 8c 3a 23 01
	00 00		 mov	 cl, BYTE PTR [edx+edi+291]
  00199	80 f9 34	 cmp	 cl, 52			; 00000034H
  0019c	74 10		 je	 SHORT $LN67@AddAllMons
  0019e	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  001a1	72 35		 jb	 SHORT $LN22@AddAllMons
  001a3	b0 11		 mov	 al, 17			; 00000011H
  001a5	3a c1		 cmp	 al, cl
  001a7	1b c0		 sbb	 eax, eax
  001a9	83 c0 01	 add	 eax, 1
  001ac	74 2a		 je	 SHORT $LN22@AddAllMons
$LN67@AddAllMons:

; 646  : 			{
; 647  : 				if ( gObj[result].Class == 232 )

  001ae	b8 e8 00 00 00	 mov	 eax, 232		; 000000e8H
  001b3	66 39 84 3a 90
	00 00 00	 cmp	 WORD PTR [edx+edi+144], ax
  001bb	75 1b		 jne	 SHORT $LN22@AddAllMons

; 648  : 				{
; 649  : 					gObj[result].m_cBloodCastleIndex = g_BloodCastle.GetBridgeLevel(gObj[result].MapNumber);

  001bd	0f b6 c1	 movzx	 eax, cl
  001c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d1	88 84 0f 36 12
	00 00		 mov	 BYTE PTR [edi+ecx+4662], al
$LN22@AddAllMons:

; 650  : 				}
; 651  : 			}
; 652  : 
; 653  : #if (GS_CASTLE == 1)
; 654  : 			if( gObj[result].Class == 216 )

  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001dd	b9 d8 00 00 00	 mov	 ecx, 216		; 000000d8H
  001e2	66 39 8c 07 90
	00 00 00	 cmp	 WORD PTR [edi+eax+144], cx
  001ea	75 0b		 jne	 SHORT $LN23@AddAllMons

; 655  : 			{
; 656  : 				g_CastleSiege.SetCrownIndex(result);

  001ec	56		 push	 esi
  001ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  001f2	e8 00 00 00 00	 call	 ?SetCrownIndex@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetCrownIndex
$LN23@AddAllMons:

; 657  : 			}
; 658  : 
; 659  : 			if( ((gObj[result].MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE) ? TRUE : FALSE) && gObj[result].Type == OBJ_NPC)

  001f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fc	80 bc 07 23 01
	00 00 22	 cmp	 BYTE PTR [edi+eax+291], 34 ; 00000022H
  00204	75 4c		 jne	 SHORT $LN27@AddAllMons
  00206	80 7c 07 50 03	 cmp	 BYTE PTR [edi+eax+80], 3
  0020b	75 45		 jne	 SHORT $LN27@AddAllMons

; 660  : 			{
; 661  : 				if( gObj[result].Class == 406 || gObj[result].Class == 407 )

  0020d	0f b7 84 07 90
	00 00 00	 movzx	 eax, WORD PTR [edi+eax+144]
  00215	b9 96 01 00 00	 mov	 ecx, 406		; 00000196H
  0021a	66 3b c1	 cmp	 ax, cx
  0021d	74 33		 je	 SHORT $LN27@AddAllMons
  0021f	b9 97 01 00 00	 mov	 ecx, 407		; 00000197H
  00224	66 3b c1	 cmp	 ax, cx
  00227	74 29		 je	 SHORT $LN27@AddAllMons

; 662  : 				{
; 663  : 
; 664  : 				}
; 665  : 				else if(CRYWOLF_NPC_CLASS_RANGE(gObj[result].Class) != FALSE)

  00229	b9 cc 00 00 00	 mov	 ecx, 204		; 000000ccH
  0022e	66 3b c1	 cmp	 ax, cx
  00231	72 14		 jb	 SHORT $LN28@AddAllMons
  00233	b9 d1 00 00 00	 mov	 ecx, 209		; 000000d1H
  00238	66 3b c8	 cmp	 cx, ax

; 666  : 				{
; 667  : 					g_Crywolf.m_ObjSpecialNPC.AddObj(result);

  0023b	b9 48 ad 0f 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A+1027400
  00240	1b c0		 sbb	 eax, eax
  00242	83 c0 01	 add	 eax, 1
  00245	75 05		 jne	 SHORT $LN79@AddAllMons
$LN28@AddAllMons:

; 668  : 				}
; 669  : 				else
; 670  : 				{
; 671  : 					g_Crywolf.m_ObjCommonNPC.AddObj(result);

  00247	b9 94 a8 0f 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A+1026196
$LN79@AddAllMons:
  0024c	56		 push	 esi
  0024d	e8 00 00 00 00	 call	 ?AddObj@CCrywolfObjInfo@@QAEHH@Z ; CCrywolfObjInfo::AddObj
$LN27@AddAllMons:

; 672  : 				}
; 673  : 			}
; 674  : 
; 675  : 			if( ((gObj[result].MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE) ? TRUE : FALSE) && gObj[result].Type == OBJ_MONSTER)

  00252	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00257	80 bc 07 23 01
	00 00 22	 cmp	 BYTE PTR [edi+eax+291], 34 ; 00000022H
  0025f	75 12		 jne	 SHORT $LN68@AddAllMons
  00261	80 7c 07 50 02	 cmp	 BYTE PTR [edi+eax+80], 2
  00266	75 0b		 jne	 SHORT $LN68@AddAllMons

; 676  : 			{
; 677  : 				g_Crywolf.m_ObjCommonMonster.AddObj(result);

  00268	56		 push	 esi
  00269	b9 fc b1 0f 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A+1028604
  0026e	e8 00 00 00 00	 call	 ?AddObj@CCrywolfObjInfo@@QAEHH@Z ; CCrywolfObjInfo::AddObj
$LN68@AddAllMons:
  00273	8b 7d fc	 mov	 edi, DWORD PTR _n$1$[ebp]
$LN73@AddAllMons:
  00276	be 7d 01 00 00	 mov	 esi, 381		; 0000017dH
$LN82@AddAllMons:
  0027b	ba e8 00 00 00	 mov	 edx, 232		; 000000e8H
$LN78@AddAllMons:
  00280	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
$LN2@AddAllMons:

; 574  : 	gCurPaintPlayer = 0;
; 575  : 
; 576  : 	int result;
; 577  : 
; 578  : 	for ( int n=0;n< OBJ_MAXMONSTER;n++)

  00283	47		 inc	 edi
  00284	83 c3 14	 add	 ebx, 20			; 00000014H
  00287	89 7d fc	 mov	 DWORD PTR _n$1$[ebp], edi
  0028a	81 ff 04 29 00
	00		 cmp	 edi, 10500		; 00002904H
  00290	0f 8c bc fd ff
	ff		 jl	 $LL4@AddAllMons

; 678  : 			}
; 679  : #endif
; 680  : 		}
; 681  : 	}
; 682  : 
; 683  : #if (GS_CASTLE == 1 && GS_SPEC == 0)
; 684  : 	gDevilSquareEvent = FALSE;
; 685  : 	g_bChaosCastle  = FALSE;
; 686  : #endif
; 687  : 
; 688  : 	g_DevilSquare.Init();

  00296	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0029b	e8 00 00 00 00	 call	 ?Init@CDevilSquare@@QAEXXZ ; CDevilSquare::Init

; 689  : 	g_BloodCastle.LoadItemDropRate();

  002a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  002a5	e8 00 00 00 00	 call	 ?LoadItemDropRate@CBloodCastle@@QAEXXZ ; CBloodCastle::LoadItemDropRate

; 690  : 
; 691  : #if (GS_CASTLE == 1 && GS_SPEC == 0)
; 692  : 	g_bBloodCastle = FALSE;
; 693  : #endif
; 694  : 
; 695  : 	if ( g_bBloodCastle != FALSE )

  002aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle

; 696  : 	{
; 697  : 		g_BloodCastle.Init(TRUE);

  002b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  002b6	5f		 pop	 edi
  002b7	5e		 pop	 esi
  002b8	5b		 pop	 ebx
  002b9	74 04		 je	 SHORT $LN31@AddAllMons
  002bb	6a 01		 push	 1

; 698  : 	}
; 699  : 	else

  002bd	eb 02		 jmp	 SHORT $LN80@AddAllMons
$LN31@AddAllMons:

; 700  : 	{
; 701  : 		g_BloodCastle.Init(FALSE);

  002bf	6a 00		 push	 0
$LN80@AddAllMons:
  002c1	e8 00 00 00 00	 call	 ?Init@CBloodCastle@@QAEX_N@Z ; CBloodCastle::Init

; 702  : 	}
; 703  : 
; 704  : 	if ( g_bChaosCastle != FALSE )

  002c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bChaosCastle@@3HA, 0 ; g_bChaosCastle

; 705  : 	{
; 706  : 		g_ChaosCastle.Init(true);

  002cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  002d2	74 04		 je	 SHORT $LN33@AddAllMons
  002d4	6a 01		 push	 1

; 707  : 	}
; 708  : 	else

  002d6	eb 02		 jmp	 SHORT $LN81@AddAllMons
$LN33@AddAllMons:

; 709  : 	{
; 710  : 		g_ChaosCastle.Init(false);

  002d8	6a 00		 push	 0
$LN81@AddAllMons:
  002da	e8 00 00 00 00	 call	 ?Init@CChaosCastle@@QAEX_N@Z ; CChaosCastle::Init

; 711  : 	}
; 712  : 
; 713  : 	if( g_bIllusionTemple )

  002df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bIllusionTemple@@3HA, 0 ; g_bIllusionTemple
  002e6	74 0a		 je	 SHORT $LN35@AddAllMons

; 714  : 	{
; 715  : 		g_IllusionTemple.Init();

  002e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  002ed	e8 00 00 00 00	 call	 ?Init@CIllusionTempleEvent@@QAEHXZ ; CIllusionTempleEvent::Init
$LN35@AddAllMons:

; 716  : 	}
; 717  : 
; 718  : 	g_Raklion.SetState(RAKLION_STATE_END);

  002f2	6a 0a		 push	 10			; 0000000aH
  002f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Raklion@@3VCRaklion@@A ; g_Raklion
  002f9	e8 00 00 00 00	 call	 ?SetState@CRaklion@@QAEXH@Z ; CRaklion::SetState

; 719  : }

  002fe	8b e5		 mov	 esp, ebp
  00300	5d		 pop	 ebp
  00301	c2 04 00	 ret	 4
?AddAllMonsters@CMonsterSetBase@@QAEXH@Z ENDP		; CMonsterSetBase::AddAllMonsters
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?RemoveMonsterSetBase@CMonsterSetBase@@QAEXH@Z
_TEXT	SEGMENT
_iPosNum$ = 8						; size = 4
?RemoveMonsterSetBase@CMonsterSetBase@@QAEXH@Z PROC	; CMonsterSetBase::RemoveMonsterSetBase, COMDAT
; _this$ = ecx

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	if( iPosNum < 0 || iPosNum >= OBJ_MAXMONSTER )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iPosNum$[ebp]
  00006	3d 03 29 00 00	 cmp	 eax, 10499		; 00002903H
  0000b	77 15		 ja	 SHORT $LN3@RemoveMons

; 67   : 		return;
; 68   : 
; 69   : 	if( this->m_Mp[iPosNum].m_ArrangeType != (BYTE)-1 )

  0000d	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00010	80 7c 81 04 ff	 cmp	 BYTE PTR [ecx+eax*4+4], 255 ; 000000ffH
  00015	74 0b		 je	 SHORT $LN3@RemoveMons

; 70   : 	{
; 71   : 		this->m_Mp[iPosNum].m_ArrangeType = (BYTE)-1;

  00017	c6 44 81 04 ff	 mov	 BYTE PTR [ecx+eax*4+4], 255 ; 000000ffH

; 72   : 		this->m_Count--;

  0001c	ff 89 60 34 03
	00		 dec	 DWORD PTR [ecx+210016]
$LN3@RemoveMons:

; 73   : 	}
; 74   : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?RemoveMonsterSetBase@CMonsterSetBase@@QAEXH@Z ENDP	; CMonsterSetBase::RemoveMonsterSetBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
; File c:\users\michel\desktop\source\gameserver\source\crywolfobjinfo.h
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
; File c:\users\michel\desktop\source\gameserver\source\crywolfobjinfo.h
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?MonsterSetBaseReload@CMonsterSetBase@@QAEXH@Z
_TEXT	SEGMENT
tv850 = -4						; size = 4
_iPosNum$3$ = -4					; size = 4
_iPosNum$1$ = -4					; size = 4
_type$ = 8						; size = 4
?MonsterSetBaseReload@CMonsterSetBase@@QAEXH@Z PROC	; CMonsterSetBase::MonsterSetBaseReload, COMDAT
; _this$ = ecx

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 407  : 	std::map<int,int>::iterator _It;
; 408  : 	int iPosNum;
; 409  : 
; 410  : 	if( type == LOAD_ALLOBJ)

  00004	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	83 fa ff	 cmp	 edx, -1
  0000f	75 7e		 jne	 SHORT $LN14@MonsterSet

; 411  : 	{
; 412  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  00011	33 ff		 xor	 edi, edi
  00013	33 f6		 xor	 esi, esi
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@MonsterSet:

; 413  : 		{
; 414  : 			if ( gObj[n].Type == OBJ_MONSTER || gObj[n].Type == OBJ_NPC )

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	8a 4c 06 50	 mov	 cl, BYTE PTR [esi+eax+80]
  00029	80 f9 02	 cmp	 cl, 2
  0002c	74 05		 je	 SHORT $LN17@MonsterSet
  0002e	80 f9 03	 cmp	 cl, 3
  00031	75 3f		 jne	 SHORT $LN2@MonsterSet
$LN17@MonsterSet:

; 415  : 			{
; 416  : #if (GS_CASTLE == 1)
; 417  : 				if ( gObj[n].m_btCsNpcType != FALSE )

  00033	80 bc 06 50 20
	00 00 00	 cmp	 BYTE PTR [esi+eax+8272], 0
  0003b	75 35		 jne	 SHORT $LN2@MonsterSet

; 418  : 					continue;
; 419  : #endif
; 420  : 
; 421  : 				if ( gObj[n].m_iCurrentAI )

  0003d	83 bc 06 d0 20
	00 00 00	 cmp	 DWORD PTR [esi+eax+8400], 0
  00045	74 22		 je	 SHORT $LN19@MonsterSet

; 422  : 				{
; 423  : 					gObj[n].Live = FALSE;

  00047	c6 44 06 51 00	 mov	 BYTE PTR [esi+eax+81], 0

; 424  : 					gObjViewportListProtocolDestroy(&gObj[n]);

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	03 c6		 add	 eax, esi
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy

; 425  : 					gObjViewportClose(&gObj[n]);

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005e	03 c6		 add	 eax, esi
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose
  00066	83 c4 08	 add	 esp, 8
$LN19@MonsterSet:

; 426  : 				}
; 427  : 
; 428  : 				gObjDel(n);

  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0006f	83 c4 04	 add	 esp, 4
$LN2@MonsterSet:

; 411  : 	{
; 412  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  00072	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00078	47		 inc	 edi
  00079	81 fe 00 dd 49
	06		 cmp	 esi, 105504000		; 0649dd00H
  0007f	7c 9f		 jl	 SHORT $LL4@MonsterSet

; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 		Init();

  00081	8b cb		 mov	 ecx, ebx
  00083	e8 00 00 00 00	 call	 ?Init@CMonsterSetBase@@QAEXXZ ; CMonsterSetBase::Init

; 433  : 		this->LoadSetBase(gDirPath.GetNewPath(FILE_MONSTER_BASE), LOAD_ALLOBJ);

  00088	6a ff		 push	 -1
  0008a	e9 9a 00 00 00	 jmp	 $LN109@MonsterSet
$LN14@MonsterSet:

; 434  : 	}
; 435  : 	else if( type == LOAD_NPCLIST )

  0008f	85 d2		 test	 edx, edx
  00091	0f 85 68 01 00
	00		 jne	 $LN20@MonsterSet

; 436  : 	{
; 437  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  00097	33 ff		 xor	 edi, edi
  00099	33 f6		 xor	 esi, esi
  0009b	0f 1f 44 00 00	 npad	 5
$LL7@MonsterSet:

; 438  : 		{
; 439  : 			if ( gObj[n].Type == OBJ_MONSTER || gObj[n].Type == OBJ_NPC )

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a5	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000a8	8a 41 50	 mov	 al, BYTE PTR [ecx+80]
  000ab	3c 02		 cmp	 al, 2
  000ad	74 04		 je	 SHORT $LN23@MonsterSet
  000af	3c 03		 cmp	 al, 3
  000b1	75 61		 jne	 SHORT $LN5@MonsterSet
$LN23@MonsterSet:

; 440  : 			{
; 441  : #if (GS_CASTLE == 1)
; 442  : 				if ( gObj[n].m_btCsNpcType != FALSE )

  000b3	80 b9 50 20 00
	00 00		 cmp	 BYTE PTR [ecx+8272], 0
  000ba	75 58		 jne	 SHORT $LN5@MonsterSet

; 443  : 					continue;
; 444  : #endif
; 445  : 
; 446  : 				if( gObj[n].m_PosNum == -1 )

  000bc	0f b7 81 98 05
	00 00		 movzx	 eax, WORD PTR [ecx+1432]
  000c3	66 83 f8 ff	 cmp	 ax, -1
  000c7	74 4b		 je	 SHORT $LN5@MonsterSet

; 447  : 					continue;
; 448  : 
; 449  : 				iPosNum = gObj[n].m_PosNum;

  000c9	98		 cwde
  000ca	89 45 fc	 mov	 DWORD PTR _iPosNum$3$[ebp], eax

; 450  : 
; 451  : 				if( this->m_Mp[iPosNum].m_LoadType != type )

  000cd	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000d0	80 7c 83 05 00	 cmp	 BYTE PTR [ebx+eax*4+5], 0
  000d5	75 3d		 jne	 SHORT $LN5@MonsterSet

; 452  : 					continue;
; 453  : 
; 454  : 				if ( gObj[n].m_iCurrentAI )

  000d7	83 b9 d0 20 00
	00 00		 cmp	 DWORD PTR [ecx+8400], 0
  000de	74 21		 je	 SHORT $LN27@MonsterSet

; 455  : 				{
; 456  : 					gObj[n].Live = FALSE;

  000e0	c6 41 51 00	 mov	 BYTE PTR [ecx+81], 0

; 457  : 					gObjViewportListProtocolDestroy(&gObj[n]);

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e9	03 c6		 add	 eax, esi
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy

; 458  : 					gObjViewportClose(&gObj[n]);

  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f6	03 c6		 add	 eax, esi
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose
  000fe	83 c4 08	 add	 esp, 8
$LN27@MonsterSet:

; 459  : 				}
; 460  : 
; 461  : 				gObjDel(n);

  00101	57		 push	 edi
  00102	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00107	83 c4 04	 add	 esp, 4

; 462  : 				RemoveMonsterSetBase(iPosNum);

  0010a	8b cb		 mov	 ecx, ebx
  0010c	ff 75 fc	 push	 DWORD PTR _iPosNum$3$[ebp]
  0010f	e8 00 00 00 00	 call	 ?RemoveMonsterSetBase@CMonsterSetBase@@QAEXH@Z ; CMonsterSetBase::RemoveMonsterSetBase
$LN5@MonsterSet:

; 436  : 	{
; 437  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  00114	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0011a	47		 inc	 edi
  0011b	81 fe 00 dd 49
	06		 cmp	 esi, 105504000		; 0649dd00H
  00121	0f 8c 79 ff ff
	ff		 jl	 $LL7@MonsterSet

; 463  : 			}
; 464  : 		}
; 465  : 
; 466  : 		this->LoadSetBase(gDirPath.GetNewPath(FILE_MONSTER_BASE),LOAD_NPCLIST);

  00127	6a 00		 push	 0
$LN109@MonsterSet:
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GOBDOCKL@Monster?2MonsterSetBase?4xml?$AA@
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00133	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00138	50		 push	 eax
  00139	8b cb		 mov	 ecx, ebx
  0013b	e8 00 00 00 00	 call	 ?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z ; CMonsterSetBase::LoadSetBase
; File c:\users\michel\desktop\source\gameserver\source\crywolfobjinfo.h

; 32   : 		this->m_iObjCount = 0;

  00140	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]

; 29   : 			this->m_iObjIndex[i] = -1;

  00143	83 c8 ff	 or	 eax, -1
  00146	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH
  0014b	bf 98 a8 0f 00	 mov	 edi, OFFSET ?g_Crywolf@@3VCCrywolf@@A+1026200
  00150	f3 ab		 rep stosd
  00152	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH

; 32   : 		this->m_iObjCount = 0;

  00157	c7 05 94 a8 0f
	00 00 00 00 00	 mov	 DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1026196, 0

; 29   : 			this->m_iObjIndex[i] = -1;

  00161	0b c0		 or	 eax, eax
  00163	bf 4c ad 0f 00	 mov	 edi, OFFSET ?g_Crywolf@@3VCCrywolf@@A+1027404
  00168	f3 ab		 rep stosd

; 32   : 		this->m_iObjCount = 0;

  0016a	c7 05 48 ad 0f
	00 00 00 00 00	 mov	 DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1027400, 0
$LN43@MonsterSet:
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp

; 546  : 	if( type == LOAD_ALLOBJ ||

  00174	83 fa ff	 cmp	 edx, -1
  00177	74 05		 je	 SHORT $LN46@MonsterSet
  00179	83 fa 02	 cmp	 edx, 2
  0017c	75 31		 jne	 SHORT $LN45@MonsterSet
$LN46@MonsterSet:
; File c:\users\michel\desktop\source\gameserver\source\crywolfobjinfo.h

; 29   : 			this->m_iObjIndex[i] = -1;

  0017e	83 c8 ff	 or	 eax, -1
  00181	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH
  00186	bf 00 b2 0f 00	 mov	 edi, OFFSET ?g_Crywolf@@3VCCrywolf@@A+1028608
  0018b	f3 ab		 rep stosd
  0018d	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH

; 32   : 		this->m_iObjCount = 0;

  00192	c7 05 fc b1 0f
	00 00 00 00 00	 mov	 DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1028604, 0

; 29   : 			this->m_iObjIndex[i] = -1;

  0019c	0b c0		 or	 eax, eax
  0019e	bf b4 b6 0f 00	 mov	 edi, OFFSET ?g_Crywolf@@3VCCrywolf@@A+1029812
  001a3	f3 ab		 rep stosd

; 32   : 		this->m_iObjCount = 0;

  001a5	c7 05 b0 b6 0f
	00 00 00 00 00	 mov	 DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1029808, 0
$LN45@MonsterSet:
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp

; 555  : 	if( type == LOAD_ALLOBJ )

  001af	83 fa ff	 cmp	 edx, -1
  001b2	75 2e		 jne	 SHORT $LN47@MonsterSet

; 556  : 	{
; 557  : 		gMAttr.LoadAttr(gDirPath.GetNewPath(FILE_MONSTER_MAIN));

  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PFCEFGJO@Monster?2Monster?4xml?$AA@
  001b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001be	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001c3	50		 push	 eax
  001c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  001c9	e8 00 00 00 00	 call	 ?LoadAttr@CMonsterAttr@@QAEXPAD@Z ; CMonsterAttr::LoadAttr

; 558  : 
; 559  : #if( ENABLETEST_MONSTERITEMDROPEX == 1 )
; 560  : 		g_MonsterItemMngEx.Init();

  001ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMngEx@@3VCMonsterItemMngEx@@A ; g_MonsterItemMngEx
  001d3	e8 00 00 00 00	 call	 ?Init@CMonsterItemMngEx@@QAEXXZ ; CMonsterItemMngEx::Init

; 561  : #else
; 562  : 		g_MonsterItemMng.Init();
; 563  : #endif//ENABLETEST_MONSTERITEMDROPEX
; 564  : 
; 565  : 		gObjMonCount = 0;

  001d8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObjMonCount@@3HA, 0 ; gObjMonCount
$LN47@MonsterSet:

; 566  : 	}
; 567  : 
; 568  : 	g_IllusionTemple.ResetObject();

  001e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  001e7	e8 00 00 00 00	 call	 ?ResetObject@CIllusionTempleEvent@@QAEXXZ ; CIllusionTempleEvent::ResetObject

; 569  : 	AddAllMonsters(type);

  001ec	ff 75 08	 push	 DWORD PTR _type$[ebp]
  001ef	8b cb		 mov	 ecx, ebx
  001f1	e8 00 00 00 00	 call	 ?AddAllMonsters@CMonsterSetBase@@QAEXH@Z ; CMonsterSetBase::AddAllMonsters
  001f6	5f		 pop	 edi
  001f7	5e		 pop	 esi
  001f8	5b		 pop	 ebx

; 570  : }

  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c2 04 00	 ret	 4
$LN20@MonsterSet:

; 467  : 	}
; 468  : 	else if( type == LOAD_ELDORADOLIST )

  001ff	83 fa 01	 cmp	 edx, 1
  00202	0f 85 bb 00 00
	00		 jne	 $LN28@MonsterSet

; 469  : 	{
; 470  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  00208	33 ff		 xor	 edi, edi
  0020a	33 f6		 xor	 esi, esi
  0020c	0f 1f 40 00	 npad	 4
$LL10@MonsterSet:

; 471  : 		{
; 472  : 			if ( gObj[n].Type == OBJ_MONSTER || gObj[n].Type == OBJ_NPC )

  00210	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00215	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00218	8a 41 50	 mov	 al, BYTE PTR [ecx+80]
  0021b	3c 02		 cmp	 al, 2
  0021d	74 04		 je	 SHORT $LN31@MonsterSet
  0021f	3c 03		 cmp	 al, 3
  00221	75 65		 jne	 SHORT $LN8@MonsterSet
$LN31@MonsterSet:

; 473  : 			{
; 474  : #if (GS_CASTLE == 1)
; 475  : 				if ( gObj[n].m_btCsNpcType != FALSE )

  00223	80 b9 50 20 00
	00 00		 cmp	 BYTE PTR [ecx+8272], 0
  0022a	75 5c		 jne	 SHORT $LN8@MonsterSet

; 476  : 					continue;
; 477  : #endif
; 478  : 
; 479  : 				if( gObj[n].m_PosNum == -1 )

  0022c	0f b7 81 98 05
	00 00		 movzx	 eax, WORD PTR [ecx+1432]
  00233	89 45 fc	 mov	 DWORD PTR tv850[ebp], eax
  00236	66 83 f8 ff	 cmp	 ax, -1
  0023a	74 4c		 je	 SHORT $LN8@MonsterSet

; 480  : 					continue;
; 481  : 
; 482  : 				iPosNum = gObj[n].m_PosNum;

  0023c	98		 cwde

; 483  : 
; 484  : 				if( this->m_Mp[iPosNum].m_LoadType != type )

  0023d	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00240	80 7c 83 05 01	 cmp	 BYTE PTR [ebx+eax*4+5], 1
  00245	75 41		 jne	 SHORT $LN8@MonsterSet

; 485  : 					continue;
; 486  : 
; 487  : 				if ( gObj[n].m_iCurrentAI )

  00247	83 b9 d0 20 00
	00 00		 cmp	 DWORD PTR [ecx+8400], 0
  0024e	74 21		 je	 SHORT $LN35@MonsterSet

; 488  : 				{
; 489  : 					gObj[n].Live = FALSE;

  00250	c6 41 51 00	 mov	 BYTE PTR [ecx+81], 0

; 490  : 					gObjViewportListProtocolDestroy(&gObj[n]);

  00254	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00259	03 c6		 add	 eax, esi
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy

; 491  : 					gObjViewportClose(&gObj[n]);

  00261	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00266	03 c6		 add	 eax, esi
  00268	50		 push	 eax
  00269	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose
  0026e	83 c4 08	 add	 esp, 8
$LN35@MonsterSet:

; 492  : 				}
; 493  : 
; 494  : 				gObjDel(n);

  00271	57		 push	 edi
  00272	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 495  : 				RemoveMonsterSetBase(iPosNum);

  00277	8b 4d fc	 mov	 ecx, DWORD PTR tv850[ebp]
  0027a	83 c4 04	 add	 esp, 4
  0027d	0f bf c1	 movsx	 eax, cx
  00280	8b cb		 mov	 ecx, ebx
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ?RemoveMonsterSetBase@CMonsterSetBase@@QAEXH@Z ; CMonsterSetBase::RemoveMonsterSetBase
$LN8@MonsterSet:

; 469  : 	{
; 470  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  00288	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0028e	47		 inc	 edi
  0028f	81 fe 00 dd 49
	06		 cmp	 esi, 105504000		; 0649dd00H
  00295	0f 8c 75 ff ff
	ff		 jl	 $LL10@MonsterSet

; 496  : 			}
; 497  : 		}
; 498  : 
; 499  : 		this->m_GoldenCount = 0;
; 500  : 		this->LoadSetBase(gDirPath.GetNewPath(FILE_MONSTER_BASE),LOAD_ELDORADOLIST);

  0029b	6a 01		 push	 1
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GOBDOCKL@Monster?2MonsterSetBase?4xml?$AA@
  002a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  002a7	c7 83 58 34 03
	00 00 00 00 00	 mov	 DWORD PTR [ebx+210008], 0
  002b1	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  002b6	50		 push	 eax
  002b7	8b cb		 mov	 ecx, ebx
  002b9	e8 00 00 00 00	 call	 ?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z ; CMonsterSetBase::LoadSetBase
  002be	e9 1f ff ff ff	 jmp	 $LN47@MonsterSet
$LN28@MonsterSet:

; 501  : 	}
; 502  : 	else if( type == LOAD_MONSTERLIST )

  002c3	83 fa 02	 cmp	 edx, 2
  002c6	0f 85 a8 fe ff
	ff		 jne	 $LN43@MonsterSet

; 503  : 	{
; 504  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  002cc	33 ff		 xor	 edi, edi
  002ce	33 f6		 xor	 esi, esi
$LL13@MonsterSet:

; 505  : 		{
; 506  : 			if ( gObj[n].Type == OBJ_MONSTER || gObj[n].Type == OBJ_NPC )

  002d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d5	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  002d8	8a 41 50	 mov	 al, BYTE PTR [ecx+80]
  002db	3c 02		 cmp	 al, 2
  002dd	74 04		 je	 SHORT $LN38@MonsterSet
  002df	3c 03		 cmp	 al, 3
  002e1	75 61		 jne	 SHORT $LN11@MonsterSet
$LN38@MonsterSet:

; 507  : 			{
; 508  : #if (GS_CASTLE == 1)
; 509  : 				if ( gObj[n].m_btCsNpcType != FALSE )

  002e3	80 b9 50 20 00
	00 00		 cmp	 BYTE PTR [ecx+8272], 0
  002ea	75 58		 jne	 SHORT $LN11@MonsterSet

; 510  : 					continue;
; 511  : #endif
; 512  : 
; 513  : 				if( gObj[n].m_PosNum == -1 )

  002ec	0f b7 81 98 05
	00 00		 movzx	 eax, WORD PTR [ecx+1432]
  002f3	66 83 f8 ff	 cmp	 ax, -1
  002f7	74 4b		 je	 SHORT $LN11@MonsterSet

; 514  : 					continue;
; 515  : 
; 516  : 				iPosNum = gObj[n].m_PosNum;

  002f9	98		 cwde
  002fa	89 45 fc	 mov	 DWORD PTR _iPosNum$1$[ebp], eax

; 517  : 				
; 518  : 				if( this->m_Mp[iPosNum].m_LoadType != type )

  002fd	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00300	80 7c 83 05 02	 cmp	 BYTE PTR [ebx+eax*4+5], 2
  00305	75 3d		 jne	 SHORT $LN11@MonsterSet

; 519  : 					continue;
; 520  : 
; 521  : 				if ( gObj[n].m_iCurrentAI )

  00307	83 b9 d0 20 00
	00 00		 cmp	 DWORD PTR [ecx+8400], 0
  0030e	74 21		 je	 SHORT $LN42@MonsterSet

; 522  : 				{
; 523  : 					gObj[n].Live = FALSE;

  00310	c6 41 51 00	 mov	 BYTE PTR [ecx+81], 0

; 524  : 					gObjViewportListProtocolDestroy(&gObj[n]);

  00314	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00319	03 c6		 add	 eax, esi
  0031b	50		 push	 eax
  0031c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy

; 525  : 					gObjViewportClose(&gObj[n]);

  00321	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00326	03 c6		 add	 eax, esi
  00328	50		 push	 eax
  00329	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose
  0032e	83 c4 08	 add	 esp, 8
$LN42@MonsterSet:

; 526  : 				}
; 527  : 
; 528  : 				gObjDel(n);

  00331	57		 push	 edi
  00332	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00337	83 c4 04	 add	 esp, 4

; 529  : 				RemoveMonsterSetBase(iPosNum);

  0033a	8b cb		 mov	 ecx, ebx
  0033c	ff 75 fc	 push	 DWORD PTR _iPosNum$1$[ebp]
  0033f	e8 00 00 00 00	 call	 ?RemoveMonsterSetBase@CMonsterSetBase@@QAEXH@Z ; CMonsterSetBase::RemoveMonsterSetBase
$LN11@MonsterSet:

; 503  : 	{
; 504  : 		for(int n = 0; n < OBJ_MAXMONSTER; n++)

  00344	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0034a	47		 inc	 edi
  0034b	81 fe 00 dd 49
	06		 cmp	 esi, 105504000		; 0649dd00H
  00351	0f 8c 79 ff ff
	ff		 jl	 $LL13@MonsterSet

; 530  : 			}
; 531  : 		}
; 532  : 
; 533  : 		this->m_MonsterCount = 0;
; 534  : 		this->LoadSetBase(gDirPath.GetNewPath(FILE_MONSTER_BASE), LOAD_MONSTERLIST);

  00357	6a 02		 push	 2
  00359	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GOBDOCKL@Monster?2MonsterSetBase?4xml?$AA@
  0035e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00363	c7 83 5c 34 03
	00 00 00 00 00	 mov	 DWORD PTR [ebx+210012], 0
  0036d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00372	50		 push	 eax
  00373	8b cb		 mov	 ecx, ebx
  00375	e8 00 00 00 00	 call	 ?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z ; CMonsterSetBase::LoadSetBase

; 535  : 	}
; 536  : 
; 537  : #if (GS_CASTLE == 1)
; 538  : 
; 539  : 	if( type == LOAD_ALLOBJ || 

  0037a	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0037d	e9 fc fd ff ff	 jmp	 $LN46@MonsterSet
?MonsterSetBaseReload@CMonsterSetBase@@QAEXH@Z ENDP	; CMonsterSetBase::MonsterSetBaseReload
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z
_TEXT	SEGMENT
$T2 = -384						; size = 8
$T3 = -376						; size = 4
_result$ = -372						; size = 12
$T4 = -360						; size = 4
$T5 = -356						; size = 4
$T6 = -352						; size = 4
$T7 = -348						; size = 4
$T8 = -344						; size = 4
$T9 = -340						; size = 4
$T10 = -336						; size = 4
$T11 = -332						; size = 4
$T12 = -328						; size = 4
$T13 = -324						; size = 4
$T14 = -320						; size = 4
$T15 = -316						; size = 4
$T16 = -312						; size = 4
$T17 = -308						; size = 4
$T18 = -304						; size = 8
$T19 = -296						; size = 4
$T20 = -296						; size = 4
$T21 = -292						; size = 4
$T22 = -292						; size = 4
$T23 = -288						; size = 4
$T24 = -288						; size = 4
_dir$2$ = -284						; size = 4
$T25 = -284						; size = 4
_objectlist$ = -280					; size = 4
_id$2$ = -276						; size = 4
$T26 = -276						; size = 4
_map$2$ = -272						; size = 4
$T27 = -272						; size = 4
_dis$2$ = -268						; size = 4
$T28 = -268						; size = 4
_Element$1$ = -264					; size = 4
$T29 = -264						; size = 4
_attr$1$ = -260						; size = 4
_eldoradolist$30 = -260					; size = 4
_imonstertableindex$1$ = -256				; size = 4
_h$1$ = -256						; size = 4
_izoneindex$1$ = -252					; size = 4
_w$1$ = -252						; size = 4
_Shop$1$ = -248						; size = 4
_dir$1$ = -248						; size = 4
_count$2$ = -244					; size = 4
_y$1$ = -244						; size = 4
_x$2$ = -240						; size = 4
_x$1$ = -240						; size = 4
_w$2$ = -236						; size = 4
$T31 = -236						; size = 4
_y$2$ = -232						; size = 4
$T32 = -232						; size = 4
_dis$1$ = -228						; size = 4
_monsterlist$33 = -228					; size = 4
_h$2$ = -224						; size = 4
_map$1$ = -224						; size = 4
_monster$34 = -220					; size = 4
_monster$35 = -220					; size = 4
_doc$ = -216						; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
_type$ = 12						; size = 4
?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z PROC		; CMonsterSetBase::LoadSetBase, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f1		 mov	 esi, ecx
  00030	8b 7d 08	 mov	 edi, DWORD PTR _filename$[ebp]

; 214  : 	g_ShopManager.Init();

  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopManager@@3VShopManager@@A ; g_ShopManager
  00038	e8 00 00 00 00	 call	 ?Init@ShopManager@@QAEXXZ ; ShopManager::Init

; 215  : 	xml_document doc;

  0003d	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _doc$[ebp]
  00043	e8 00 00 00 00	 call	 ??0xml_document@pugi@@QAE@XZ ; pugi::xml_document::xml_document

; 216  : 	xml_parse_result result = doc.load_file(filename);

  00048	6a 00		 push	 0
  0004a	6a 74		 push	 116			; 00000074H
  0004c	57		 push	 edi
  0004d	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _result$[ebp]
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005a	50		 push	 eax
  0005b	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _doc$[ebp]
  00061	e8 00 00 00 00	 call	 ?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z ; pugi::xml_document::load_file

; 217  : 
; 218  : 	if( result.status != status_ok )

  00066	83 bd 8c fe ff
	ff 00		 cmp	 DWORD PTR _result$[ebp], 0
  0006d	74 1f		 je	 SHORT $LN19@LoadSetBas

; 219  : 	{
; 220  : 		MsgBox("file open error %s\nError description: %s", filename,result.description());

  0006f	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR _result$[ebp]
  00075	e8 00 00 00 00	 call	 ?description@xml_parse_result@pugi@@QBEPBDXZ ; pugi::xml_parse_result::description
  0007a	50		 push	 eax
  0007b	57		 push	 edi
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KBCGKPCD@file?5open?5error?5?$CFs?6Error?5descrip@
  00081	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	e9 69 07 00 00	 jmp	 $LN41@LoadSetBas
$LN19@LoadSetBas:

; 221  : 		return;
; 222  : 	}
; 223  : 
; 224  : 	int id;
; 225  : 	int map;
; 226  : 	int dis;
; 227  : 	int x;
; 228  : 	int y;
; 229  : 	int w;
; 230  : 	int h;
; 231  : 	int dir;
; 232  : 	int count;
; 233  : 	int izoneindex;
; 234  : 	int imonstertableindex;
; 235  : 	int iPosNum;
; 236  : 
; 237  : 	xml_node objectlist = doc.child("monstersetbase");

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JEDDHJC@monstersetbase?$AA@
  00093	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _objectlist$[ebp]
  00099	50		 push	 eax
  0009a	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _doc$[ebp]
  000a0	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 238  : 
; 239  : 	/*if( type == LOAD_ALLOBJ || type == LOAD_NPCLIST )
; 240  : 	{
; 241  : 		this->m_mShopNum.clear();
; 242  : 
; 243  : 		for (xml_node npclist = objectlist.child("shoplist"); npclist; npclist = npclist.next_sibling())
; 244  : 		{
; 245  : 			for( xml_node npc = npclist.child("shop"); npc; npc = npc.next_sibling()){
; 246  : 				id = npc.attribute("id").as_int();
; 247  : 				map = npc.attribute("map").as_int();
; 248  : 				dis = npc.attribute("dis").as_int();
; 249  : 				x = npc.attribute("x").as_int();
; 250  : 				y = npc.attribute("y").as_int();
; 251  : 				dir = npc.attribute("dir").as_int();
; 252  : 				shopid = npc.attribute("shopid").as_int();
; 253  : 				w = 0;
; 254  : 				h = 0;
; 255  : 				int Element = -1;
; 256  : 
; 257  : 				iPosNum = this->SetMonsterSetBase(0,LOAD_NPCLIST,id,map,dis,x,y,dir,w,h, Element);
; 258  : 
; 259  : 				if( iPosNum == -1 )
; 260  : 				{
; 261  : 					MsgBox("Failed to add NPC(%d) Map(%d) Dis(%d) X(%d) Y(%d)",id,map,dis,x,y);
; 262  : 					continue;
; 263  : 				}
; 264  : 				
; 265  : 				if( shopid != -1 )
; 266  : 					this->m_mShopNum.insert(std::pair<int,int>(iPosNum,shopid));
; 267  : 
; 268  : 				this->m_NpcCount++;
; 269  : 			}
; 270  : 		}
; 271  : 	}*/
; 272  : 
; 273  : 	if( type == LOAD_ALLOBJ || type == LOAD_ELDORADOLIST )

  000a5	8b 5d 0c	 mov	 ebx, DWORD PTR _type$[ebp]
  000a8	83 fb ff	 cmp	 ebx, -1
  000ab	74 09		 je	 SHORT $LN21@LoadSetBas
  000ad	83 fb 01	 cmp	 ebx, 1
  000b0	0f 85 3c 02 00
	00		 jne	 $LN3@LoadSetBas
$LN21@LoadSetBas:

; 274  : 	{
; 275  : 		xml_node eldoradolist = objectlist.child("golden");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_06IIMEFKJP@golden?$AA@
  000bb	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _eldoradolist$30[ebp]
  000c1	50		 push	 eax
  000c2	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _objectlist$[ebp]
  000c8	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 276  : 	
; 277  : 			for( xml_node monster = eldoradolist.child("monster"); monster; monster = monster.next_sibling())

  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_07JHAJHILB@monster?$AA@
  000d2	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _monster$35[ebp]
  000d8	50		 push	 eax
  000d9	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _eldoradolist$30[ebp]
  000df	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  000e4	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  000ea	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  000ef	85 c0		 test	 eax, eax
  000f1	0f 84 fb 01 00
	00		 je	 $LN3@LoadSetBas
  000f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@LoadSetBas:

; 278  : 			{
; 279  : 				id = monster.attribute("id").as_int();

  00100	6a 00		 push	 0
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  00107	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  0010d	50		 push	 eax
  0010e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  00114	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00119	8b c8		 mov	 ecx, eax
  0011b	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 280  : 				map = monster.attribute("map").as_int();

  00120	6a 00		 push	 0
  00122	8b d8		 mov	 ebx, eax
  00124	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_03HBNNNHNM@map?$AA@
  0012f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR $T26[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0013b	8b c8		 mov	 ecx, eax
  0013d	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 281  : 				dis = monster.attribute("dis").as_int();

  00142	6a 00		 push	 0
  00144	89 85 20 ff ff
	ff		 mov	 DWORD PTR _map$1$[ebp], eax
  0014a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_03CJOLJKCN@dis?$AA@
  00155	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T27[ebp]
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00161	8b c8		 mov	 ecx, eax
  00163	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 282  : 				x = monster.attribute("x").as_int();

  00168	6a 00		 push	 0
  0016a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _dis$1$[ebp], eax
  00170	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_01FJMABOPO@x?$AA@
  0017b	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00187	8b c8		 mov	 ecx, eax
  00189	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 283  : 				y = monster.attribute("y").as_int();

  0018e	6a 00		 push	 0
  00190	89 85 10 ff ff
	ff		 mov	 DWORD PTR _x$1$[ebp], eax
  00196	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  0019c	68 00 00 00 00	 push	 OFFSET ??_C@_01EANLCPLP@y?$AA@
  001a1	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T29[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001ad	8b c8		 mov	 ecx, eax
  001af	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 284  : 				w = monster.attribute("w").as_int();

  001b4	6a 00		 push	 0
  001b6	89 85 0c ff ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax
  001bc	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  001c7	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001d3	8b c8		 mov	 ecx, eax
  001d5	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 285  : 				h = monster.attribute("h").as_int();

  001da	6a 00		 push	 0
  001dc	89 85 04 ff ff
	ff		 mov	 DWORD PTR _w$1$[ebp], eax
  001e2	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_01BDACAMKP@h?$AA@
  001ed	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T32[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001f9	8b c8		 mov	 ecx, eax
  001fb	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 286  : 				dir = monster.attribute("dir").as_int();

  00200	6a 00		 push	 0
  00202	89 85 00 ff ff
	ff		 mov	 DWORD PTR _h$1$[ebp], eax
  00208	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_03DAPAKLGM@dir?$AA@
  00213	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0021f	8b c8		 mov	 ecx, eax
  00221	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 287  : 				count = monster.attribute("count").as_int();

  00226	6a 00		 push	 0
  00228	89 85 08 ff ff
	ff		 mov	 DWORD PTR _dir$1$[ebp], eax
  0022e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_05IOMEMJEC@count?$AA@
  00239	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00245	8b c8		 mov	 ecx, eax
  00247	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  0024c	8b f8		 mov	 edi, eax

; 288  : 				int Element = -1;
; 289  : 
; 290  : 				for(int n = 0; n < count; n++)

  0024e	85 ff		 test	 edi, edi
  00250	7e 70		 jle	 SHORT $LN2@LoadSetBas
$LL7@LoadSetBas:

; 291  : 				{
; 292  : 					iPosNum = this->SetMonsterSetBase(3,LOAD_ELDORADOLIST,id,map,dis,x,y,dir,w,h, Element);

  00252	6a ff		 push	 -1
  00254	ff b5 00 ff ff
	ff		 push	 DWORD PTR _h$1$[ebp]
  0025a	8b ce		 mov	 ecx, esi
  0025c	ff b5 04 ff ff
	ff		 push	 DWORD PTR _w$1$[ebp]
  00262	ff b5 08 ff ff
	ff		 push	 DWORD PTR _dir$1$[ebp]
  00268	ff b5 0c ff ff
	ff		 push	 DWORD PTR _y$1$[ebp]
  0026e	ff b5 10 ff ff
	ff		 push	 DWORD PTR _x$1$[ebp]
  00274	ff b5 1c ff ff
	ff		 push	 DWORD PTR _dis$1$[ebp]
  0027a	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map$1$[ebp]
  00280	53		 push	 ebx
  00281	6a 01		 push	 1
  00283	6a 03		 push	 3
  00285	e8 00 00 00 00	 call	 ?SetMonsterSetBase@CMonsterSetBase@@QAEHHHHHHHHHHHH@Z ; CMonsterSetBase::SetMonsterSetBase

; 293  : 
; 294  : 					if( iPosNum == -1 )

  0028a	83 f8 ff	 cmp	 eax, -1
  0028d	75 28		 jne	 SHORT $LN22@LoadSetBas

; 295  : 					{
; 296  : 						MsgBox("Failed to add GoldenMonster1(%d) Map(%d) Dis(%d) X(%d) Y(%d)",id,map,dis,x,y);

  0028f	ff b5 0c ff ff
	ff		 push	 DWORD PTR _y$1$[ebp]
  00295	ff b5 10 ff ff
	ff		 push	 DWORD PTR _x$1$[ebp]
  0029b	ff b5 1c ff ff
	ff		 push	 DWORD PTR _dis$1$[ebp]
  002a1	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map$1$[ebp]
  002a7	53		 push	 ebx
  002a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@PDLKLGMA@Failed?5to?5add?5GoldenMonster1?$CI?$CFd?$CJ@
  002ad	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002b2	83 c4 18	 add	 esp, 24			; 00000018H

; 297  : 						continue;

  002b5	eb 06		 jmp	 SHORT $LN5@LoadSetBas
$LN22@LoadSetBas:

; 298  : 					}
; 299  : 
; 300  : 					this->m_GoldenCount++;

  002b7	ff 86 58 34 03
	00		 inc	 DWORD PTR [esi+210008]
$LN5@LoadSetBas:

; 288  : 				int Element = -1;
; 289  : 
; 290  : 				for(int n = 0; n < count; n++)

  002bd	83 ef 01	 sub	 edi, 1
  002c0	75 90		 jne	 SHORT $LL7@LoadSetBas
$LN2@LoadSetBas:

; 276  : 	
; 277  : 			for( xml_node monster = eldoradolist.child("monster"); monster; monster = monster.next_sibling())

  002c2	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  002c8	50		 push	 eax
  002c9	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  002cf	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  002d4	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$35[ebp]
  002da	8b 00		 mov	 eax, DWORD PTR [eax]
  002dc	89 85 24 ff ff
	ff		 mov	 DWORD PTR _monster$35[ebp], eax
  002e2	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  002e7	85 c0		 test	 eax, eax
  002e9	0f 85 11 fe ff
	ff		 jne	 $LL4@LoadSetBas
  002ef	8b 5d 0c	 mov	 ebx, DWORD PTR _type$[ebp]
$LN3@LoadSetBas:

; 301  : 				}
; 302  : 			}
; 303  : 		
; 304  : 	}
; 305  : 
; 306  : 	if( type == LOAD_ALLOBJ || type == LOAD_MONSTERLIST )

  002f2	83 fb ff	 cmp	 ebx, -1
  002f5	74 09		 je	 SHORT $LN24@LoadSetBas
  002f7	83 fb 02	 cmp	 ebx, 2
  002fa	0f 85 d6 04 00
	00		 jne	 $LN9@LoadSetBas
$LN24@LoadSetBas:

; 307  : 	{
; 308  : 		for (xml_node monsterlist = objectlist.child("list"); monsterlist; monsterlist = monsterlist.next_sibling())

  00300	68 00 00 00 00	 push	 OFFSET ??_C@_04DONFEANM@list?$AA@
  00305	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _monsterlist$33[ebp]
  0030b	50		 push	 eax
  0030c	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _objectlist$[ebp]
  00312	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00317	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _monsterlist$33[ebp]
  0031d	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00322	85 c0		 test	 eax, eax
  00324	0f 84 ac 04 00
	00		 je	 $LN9@LoadSetBas
  0032a	66 0f 1f 44 00
	00		 npad	 6
$LL10@LoadSetBas:

; 309  : 		{
; 310  : 			int attr = monsterlist.attribute("type").as_int(-1);

  00330	6a ff		 push	 -1
  00332	68 00 00 00 00	 push	 OFFSET ??_C@_04GPMDFGEJ@type?$AA@
  00337	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  0033d	50		 push	 eax
  0033e	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _monsterlist$33[ebp]
  00344	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00349	8b c8		 mov	 ecx, eax
  0034b	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00350	8b d8		 mov	 ebx, eax

; 311  : 			xml_node monster;

  00352	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00358	89 9d fc fe ff
	ff		 mov	 DWORD PTR _attr$1$[ebp], ebx
  0035e	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node

; 312  : 
; 313  : 			switch( attr )

  00363	83 fb 06	 cmp	 ebx, 6
  00366	0f 87 2f 04 00
	00		 ja	 $LN27@LoadSetBas
  0036c	0f b6 8b 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN81@LoadSetBas[ebx]
  00373	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN86@LoadSetBas[ecx*4]
$LN25@LoadSetBas:

; 314  : 			{
; 315  : 			case 0:
; 316  : 				monster = monsterlist.child("npc");

  0037a	68 00 00 00 00	 push	 OFFSET ??_C@_03BPGDPAOH@npc?$AA@
  0037f	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]

; 317  : 				break;

  00385	eb 0b		 jmp	 SHORT $LN84@LoadSetBas
$LN26@LoadSetBas:

; 318  : 			case 1:
; 319  : 			case 2:
; 320  : 			case 4:
; 321  : 			case 5:
; 322  : 			case 6:
; 323  : 				monster = monsterlist.child("monster");

  00387	68 00 00 00 00	 push	 OFFSET ??_C@_07JHAJHILB@monster?$AA@
  0038c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
$LN84@LoadSetBas:
  00392	50		 push	 eax
  00393	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _monsterlist$33[ebp]
  00399	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 327  : 				continue;
; 328  : 			}
; 329  : 
; 330  : 			for( ; monster; monster = monster.next_sibling())

  0039e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  003a4	8b 00		 mov	 eax, DWORD PTR [eax]
  003a6	89 85 24 ff ff
	ff		 mov	 DWORD PTR _monster$34[ebp], eax
  003ac	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  003b1	85 c0		 test	 eax, eax
  003b3	0f 84 f0 03 00
	00		 je	 $LN8@LoadSetBas
  003b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL15@LoadSetBas:

; 331  : 			{
; 332  : 				id = monster.attribute("id").as_int();

  003c0	6a 00		 push	 0
  003c2	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  003c7	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  003cd	50		 push	 eax
  003ce	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  003d4	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  003d9	8b c8		 mov	 ecx, eax
  003db	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 333  : 				map = monster.attribute("map").as_int();

  003e0	6a 00		 push	 0
  003e2	89 85 ec fe ff
	ff		 mov	 DWORD PTR _id$2$[ebp], eax
  003e8	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  003ee	68 00 00 00 00	 push	 OFFSET ??_C@_03HBNNNHNM@map?$AA@
  003f3	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  003f9	50		 push	 eax
  003fa	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  003ff	8b c8		 mov	 ecx, eax
  00401	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 334  : 				dis = monster.attribute("dis").as_int();

  00406	6a 00		 push	 0
  00408	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _map$2$[ebp], eax
  0040e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00414	68 00 00 00 00	 push	 OFFSET ??_C@_03CJOLJKCN@dis?$AA@
  00419	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  0041f	50		 push	 eax
  00420	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00425	8b c8		 mov	 ecx, eax
  00427	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 335  : 				x = monster.attribute("x").as_int();

  0042c	6a 00		 push	 0
  0042e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _dis$2$[ebp], eax
  00434	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  0043a	68 00 00 00 00	 push	 OFFSET ??_C@_01FJMABOPO@x?$AA@
  0043f	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00445	50		 push	 eax
  00446	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0044b	8b c8		 mov	 ecx, eax
  0044d	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 336  : 				y = monster.attribute("y").as_int();

  00452	6a 00		 push	 0
  00454	89 85 10 ff ff
	ff		 mov	 DWORD PTR _x$2$[ebp], eax
  0045a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00460	68 00 00 00 00	 push	 OFFSET ??_C@_01EANLCPLP@y?$AA@
  00465	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0046b	50		 push	 eax
  0046c	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00471	8b c8		 mov	 ecx, eax
  00473	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 337  : 				dir = monster.attribute("dir").as_int();

  00478	6a 00		 push	 0
  0047a	89 85 18 ff ff
	ff		 mov	 DWORD PTR _y$2$[ebp], eax
  00480	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00486	68 00 00 00 00	 push	 OFFSET ??_C@_03DAPAKLGM@dir?$AA@
  0048b	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00491	50		 push	 eax
  00492	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00497	8b c8		 mov	 ecx, eax
  00499	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 338  : 				int Shop = -1;

  0049e	83 cf ff	 or	 edi, -1
  004a1	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _dir$2$[ebp], eax

; 339  : 				izoneindex = -1;
; 340  : 				imonstertableindex = -1;
; 341  : 				w = 0;

  004a7	33 c9		 xor	 ecx, ecx
  004a9	89 bd 08 ff ff
	ff		 mov	 DWORD PTR _Shop$1$[ebp], edi

; 342  : 				h = 0;

  004af	33 d2		 xor	 edx, edx
  004b1	89 bd 04 ff ff
	ff		 mov	 DWORD PTR _izoneindex$1$[ebp], edi
  004b7	89 bd 00 ff ff
	ff		 mov	 DWORD PTR _imonstertableindex$1$[ebp], edi
  004bd	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _w$2$[ebp], ecx
  004c3	89 95 20 ff ff
	ff		 mov	 DWORD PTR _h$2$[ebp], edx

; 343  : 				count = 1;

  004c9	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _count$2$[ebp], 1

; 344  : 				int Element = -1;

  004d3	89 bd f8 fe ff
	ff		 mov	 DWORD PTR _Element$1$[ebp], edi

; 345  : 				
; 346  : 				if( attr == 0 )

  004d9	85 db		 test	 ebx, ebx
  004db	75 2c		 jne	 SHORT $LN28@LoadSetBas

; 347  : 				{
; 348  : 					Shop = monster.attribute("shop").as_int(-1);

  004dd	57		 push	 edi
  004de	68 00 00 00 00	 push	 OFFSET ??_C@_04BFIJLIPK@shop?$AA@
  004e3	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  004e9	50		 push	 eax
  004ea	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  004f0	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  004f5	8b c8		 mov	 ecx, eax
  004f7	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  004fc	8b f8		 mov	 edi, eax
  004fe	89 bd 08 ff ff
	ff		 mov	 DWORD PTR _Shop$1$[ebp], edi
  00504	e9 5e 01 00 00	 jmp	 $LN85@LoadSetBas
$LN28@LoadSetBas:

; 349  : 				}
; 350  : 				else if( attr == 1 )

  00509	83 fb 01	 cmp	 ebx, 1
  0050c	0f 85 8b 00 00
	00		 jne	 $LN30@LoadSetBas

; 351  : 				{
; 352  : 					w = monster.attribute("w").as_int();

  00512	6a 00		 push	 0
  00514	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00519	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0051f	50		 push	 eax
  00520	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00526	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0052b	8b c8		 mov	 ecx, eax
  0052d	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 353  : 					h = monster.attribute("h").as_int();

  00532	6a 00		 push	 0
  00534	89 85 14 ff ff
	ff		 mov	 DWORD PTR _w$2$[ebp], eax
  0053a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00540	68 00 00 00 00	 push	 OFFSET ??_C@_01BDACAMKP@h?$AA@
  00545	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  0054b	50		 push	 eax
  0054c	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00551	8b c8		 mov	 ecx, eax
  00553	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 354  : 					count = monster.attribute("count").as_int();

  00558	6a 00		 push	 0
  0055a	89 85 20 ff ff
	ff		 mov	 DWORD PTR _h$2$[ebp], eax
  00560	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00566	68 00 00 00 00	 push	 OFFSET ??_C@_05IOMEMJEC@count?$AA@
  0056b	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00571	50		 push	 eax
  00572	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00577	8b c8		 mov	 ecx, eax
  00579	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  0057e	89 85 0c ff ff
	ff		 mov	 DWORD PTR _count$2$[ebp], eax

; 375  : 				}
; 376  : 
; 377  : 				for(int n = 0; n < count; n++)

  00584	85 c0		 test	 eax, eax
  00586	0f 8e e0 01 00
	00		 jle	 $LN13@LoadSetBas
  0058c	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _w$2$[ebp]
  00592	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _h$2$[ebp]
  00598	e9 d2 00 00 00	 jmp	 $LN82@LoadSetBas
$LN30@LoadSetBas:

; 355  : 				}
; 356  : 				else if( attr == 2 )

  0059d	83 fb 02	 cmp	 ebx, 2
  005a0	75 47		 jne	 SHORT $LN32@LoadSetBas

; 357  : 				{
; 358  : 					w = 0;
; 359  : 					h = 0;
; 360  : 					int tmpw = x - 3;
; 361  : 					int tmph = y - 3;
; 362  : 					tmpw += rand() % 7;

  005a2	e8 00 00 00 00	 call	 _rand
  005a7	99		 cdq
  005a8	b9 07 00 00 00	 mov	 ecx, 7
  005ad	f7 f9		 idiv	 ecx

; 363  : 					tmph += rand() % 7;
; 364  : 					w = tmpw;

  005af	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _x$2$[ebp]
  005b5	83 c0 fd	 add	 eax, -3			; fffffffdH
  005b8	03 c2		 add	 eax, edx
  005ba	89 85 14 ff ff
	ff		 mov	 DWORD PTR _w$2$[ebp], eax
  005c0	e8 00 00 00 00	 call	 _rand
  005c5	99		 cdq
  005c6	b9 07 00 00 00	 mov	 ecx, 7
  005cb	f7 f9		 idiv	 ecx

; 365  : 					h = tmph;

  005cd	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _y$2$[ebp]
  005d3	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _w$2$[ebp]
  005d9	83 c2 fd	 add	 edx, -3			; fffffffdH
  005dc	03 d0		 add	 edx, eax
  005de	89 95 20 ff ff
	ff		 mov	 DWORD PTR _h$2$[ebp], edx
  005e4	e9 8c 00 00 00	 jmp	 $LL18@LoadSetBas
$LN32@LoadSetBas:

; 366  : 				}
; 367  : 				else if( attr == 5 )

  005e9	83 fb 05	 cmp	 ebx, 5
  005ec	75 4e		 jne	 SHORT $LN34@LoadSetBas

; 368  : 				{
; 369  : 					izoneindex = monster.attribute("area").as_int();

  005ee	6a 00		 push	 0
  005f0	68 00 00 00 00	 push	 OFFSET ??_C@_04GOEDGNCF@area?$AA@
  005f5	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  005fb	50		 push	 eax
  005fc	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00602	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00607	8b c8		 mov	 ecx, eax
  00609	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 370  : 					imonstertableindex = monster.attribute("day").as_int();

  0060e	6a 00		 push	 0
  00610	89 85 04 ff ff
	ff		 mov	 DWORD PTR _izoneindex$1$[ebp], eax
  00616	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  0061c	68 00 00 00 00	 push	 OFFSET ??_C@_03NNBHCDBP@day?$AA@
  00621	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00627	50		 push	 eax
  00628	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0062d	8b c8		 mov	 ecx, eax
  0062f	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00634	89 85 00 ff ff
	ff		 mov	 DWORD PTR _imonstertableindex$1$[ebp], eax
  0063a	eb 2b		 jmp	 SHORT $LN85@LoadSetBas
$LN34@LoadSetBas:

; 371  : 				}
; 372  : 				else if( attr == 6 )

  0063c	83 fb 06	 cmp	 ebx, 6
  0063f	75 2e		 jne	 SHORT $LN82@LoadSetBas

; 373  : 				{
; 374  : 					Element = monster.attribute("element").as_int();

  00641	6a 00		 push	 0
  00643	68 00 00 00 00	 push	 OFFSET ??_C@_07HCLJNICE@element?$AA@
  00648	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0064e	50		 push	 eax
  0064f	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00655	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0065a	8b c8		 mov	 ecx, eax
  0065c	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00661	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _Element$1$[ebp], eax
$LN85@LoadSetBas:
  00667	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _w$2$[ebp]
  0066d	8b d1		 mov	 edx, ecx
$LN82@LoadSetBas:
  0066f	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _y$2$[ebp]
$LL18@LoadSetBas:

; 378  : 				{
; 379  : 					iPosNum = this->SetMonsterSetBase(attr,LOAD_MONSTERLIST,id,map,dis,x,y,dir,w,h, Element);

  00675	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _Element$1$[ebp]
  0067b	52		 push	 edx
  0067c	51		 push	 ecx
  0067d	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _dir$2$[ebp]
  00683	8b ce		 mov	 ecx, esi
  00685	50		 push	 eax
  00686	ff b5 10 ff ff
	ff		 push	 DWORD PTR _x$2$[ebp]
  0068c	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _dis$2$[ebp]
  00692	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _map$2$[ebp]
  00698	ff b5 ec fe ff
	ff		 push	 DWORD PTR _id$2$[ebp]
  0069e	6a 02		 push	 2
  006a0	53		 push	 ebx
  006a1	e8 00 00 00 00	 call	 ?SetMonsterSetBase@CMonsterSetBase@@QAEHHHHHHHHHHHH@Z ; CMonsterSetBase::SetMonsterSetBase
  006a6	8b d8		 mov	 ebx, eax

; 380  : 
; 381  : 					if( iPosNum == -1 )

  006a8	83 fb ff	 cmp	 ebx, -1
  006ab	75 2e		 jne	 SHORT $LN37@LoadSetBas

; 382  : 					{
; 383  : 						MsgBox("Failed to add GoldenMonster2(%d) Map(%d) Dis(%d) X(%d) Y(%d)",id,map,dis,x,y);

  006ad	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _y$2$[ebp]
  006b3	50		 push	 eax
  006b4	ff b5 10 ff ff
	ff		 push	 DWORD PTR _x$2$[ebp]
  006ba	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _dis$2$[ebp]
  006c0	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _map$2$[ebp]
  006c6	ff b5 ec fe ff
	ff		 push	 DWORD PTR _id$2$[ebp]
  006cc	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@JODMEFJK@Failed?5to?5add?5GoldenMonster2?$CI?$CFd?$CJ@
  006d1	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  006d6	83 c4 18	 add	 esp, 24			; 00000018H

; 384  : 						continue;

  006d9	eb 6c		 jmp	 SHORT $LN16@LoadSetBas
$LN37@LoadSetBas:

; 385  : 					}
; 386  : 
; 387  : 					if( Shop != -1 )

  006db	83 ff ff	 cmp	 edi, -1
  006de	74 48		 je	 SHORT $LN38@LoadSetBas
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1093 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  006e0	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 143  : 		: first(_STD forward<_Other1>(_Val1)),

  006e6	89 9d d0 fe ff
	ff		 mov	 DWORD PTR $T18[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1093 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  006ec	50		 push	 eax
  006ed	8d 8e 64 34 03
	00		 lea	 ecx, DWORD PTR [esi+210020]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 144  : 				second(_STD forward<_Other2>(_Val2))

  006f3	89 bd d4 fe ff
	ff		 mov	 DWORD PTR $T18[ebp+4], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1093 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  006f9	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >

; 1094 : 		return (_Insert_nohint(false,

  006fe	50		 push	 eax

; 602  : 		return ((reference)_Pnode->_Myval);

  006ff	83 c0 10	 add	 eax, 16			; 00000010H

; 1094 : 		return (_Insert_nohint(false,

  00702	8d 8e 64 34 03
	00		 lea	 ecx, DWORD PTR [esi+210020]
  00708	50		 push	 eax
  00709	6a 00		 push	 0
  0070b	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00711	50		 push	 eax
  00712	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp

; 390  : 						g_ShopManager.Read(Shop);

  00717	8b bd 08 ff ff
	ff		 mov	 edi, DWORD PTR _Shop$1$[ebp]
  0071d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopManager@@3VShopManager@@A ; g_ShopManager
  00722	57		 push	 edi
  00723	e8 00 00 00 00	 call	 ?Read@ShopManager@@QAEXH@Z ; ShopManager::Read
$LN38@LoadSetBas:

; 391  : 					}
; 392  : 
; 393  : 					this->m_Mp[iPosNum].m_wZoneIndex = izoneindex;

  00728	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _izoneindex$1$[ebp]
  0072e	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]
  00731	66 89 4c 86 10	 mov	 WORD PTR [esi+eax*4+16], cx

; 394  : 					this->m_Mp[iPosNum].m_wMonsterRegenTableIndex = imonstertableindex;

  00736	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _imonstertableindex$1$[ebp]
  0073c	66 89 4c 86 12	 mov	 WORD PTR [esi+eax*4+18], cx

; 395  : 					this->m_MonsterCount++;

  00741	ff 86 5c 34 03
	00		 inc	 DWORD PTR [esi+210012]
$LN16@LoadSetBas:

; 375  : 				}
; 376  : 
; 377  : 				for(int n = 0; n < count; n++)

  00747	83 ad 0c ff ff
	ff 01		 sub	 DWORD PTR _count$2$[ebp], 1
  0074e	8b 9d fc fe ff
	ff		 mov	 ebx, DWORD PTR _attr$1$[ebp]
  00754	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _y$2$[ebp]
  0075a	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _w$2$[ebp]
  00760	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _h$2$[ebp]
  00766	0f 85 09 ff ff
	ff		 jne	 $LL18@LoadSetBas
$LN13@LoadSetBas:

; 327  : 				continue;
; 328  : 			}
; 329  : 
; 330  : 			for( ; monster; monster = monster.next_sibling())

  0076c	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00772	50		 push	 eax
  00773	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00779	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  0077e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _monster$34[ebp]
  00784	8b 00		 mov	 eax, DWORD PTR [eax]
  00786	89 85 24 ff ff
	ff		 mov	 DWORD PTR _monster$34[ebp], eax
  0078c	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00791	85 c0		 test	 eax, eax
  00793	0f 85 27 fc ff
	ff		 jne	 $LL15@LoadSetBas

; 396  : 				}
; 397  : 			}
; 398  : 		}

  00799	eb 0e		 jmp	 SHORT $LN8@LoadSetBas
$LN27@LoadSetBas:

; 324  : 				break;
; 325  : 			default:
; 326  : 				printf("Unknown attr(%d)\n",attr);

  0079b	53		 push	 ebx
  0079c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BHHJCJLK@Unknown?5attr?$CI?$CFd?$CJ?6?$AA@
  007a1	e8 00 00 00 00	 call	 _printf
  007a6	83 c4 08	 add	 esp, 8
$LN8@LoadSetBas:

; 307  : 	{
; 308  : 		for (xml_node monsterlist = objectlist.child("list"); monsterlist; monsterlist = monsterlist.next_sibling())

  007a9	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  007af	50		 push	 eax
  007b0	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _monsterlist$33[ebp]
  007b6	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  007bb	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _monsterlist$33[ebp]
  007c1	8b 00		 mov	 eax, DWORD PTR [eax]
  007c3	89 85 1c ff ff
	ff		 mov	 DWORD PTR _monsterlist$33[ebp], eax
  007c9	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  007ce	85 c0		 test	 eax, eax
  007d0	0f 85 5a fb ff
	ff		 jne	 $LL10@LoadSetBas
$LN9@LoadSetBas:

; 399  : 	}
; 400  : 
; 401  : 	this->m_Count = this->m_GoldenCount+this->m_MonsterCount;

  007d6	8b 86 58 34 03
	00		 mov	 eax, DWORD PTR [esi+210008]
  007dc	03 86 5c 34 03
	00		 add	 eax, DWORD PTR [esi+210012]

; 402  : 	LogAdd("MonsterSetBase added - %d objects",this->m_Count);

  007e2	50		 push	 eax
  007e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GLIJPBCP@MonsterSetBase?5added?5?9?5?$CFd?5object@
  007e8	89 86 60 34 03
	00		 mov	 DWORD PTR [esi+210016], eax
  007ee	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  007f4	83 c4 08	 add	 esp, 8
$LN41@LoadSetBas:

; 403  : }

  007f7	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _doc$[ebp]
  007fd	e8 00 00 00 00	 call	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
  00802	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00805	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0080c	59		 pop	 ecx
  0080d	5f		 pop	 edi
  0080e	5e		 pop	 esi
  0080f	5b		 pop	 ebx
  00810	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00813	33 cd		 xor	 ecx, ebp
  00815	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0081a	8b e5		 mov	 esp, ebp
  0081c	5d		 pop	 ebp
  0081d	c2 08 00	 ret	 8
$LN86@LoadSetBas:
  00820	00 00 00 00	 DD	 $LN25@LoadSetBas
  00824	00 00 00 00	 DD	 $LN26@LoadSetBas
  00828	00 00 00 00	 DD	 $LN27@LoadSetBas
$LN81@LoadSetBas:
  0082c	00		 DB	 0
  0082d	01		 DB	 1
  0082e	01		 DB	 1
  0082f	02		 DB	 2
  00830	01		 DB	 1
  00831	01		 DB	 1
  00832	01		 DB	 1
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z$0:
  00000	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _doc$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
__ehhandler$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 7c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-388]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadSetBase@CMonsterSetBase@@QAEXPADH@Z ENDP		; CMonsterSetBase::LoadSetBase
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?GetPentagramMainAttribute@CMonsterSetBase@@QAEXHPAH@Z
_TEXT	SEGMENT
_TableNum$ = 8						; size = 4
_iPentagramMainAttribute$ = 12				; size = 4
?GetPentagramMainAttribute@CMonsterSetBase@@QAEXHPAH@Z PROC ; CMonsterSetBase::GetPentagramMainAttribute, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   : 	if( TableNum < 0 || TableNum >= OBJ_MAXMONSTER )

  00003	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00006	3d 03 29 00 00	 cmp	 eax, 10499		; 00002903H
  0000b	77 10		 ja	 SHORT $LN3@GetPentagr

; 79   : 		return;
; 80   : 	
; 81   : 	if( this->m_Mp[TableNum].m_PentagramMainAttribute > 0 )

  0000d	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00010	8b 4c 81 14	 mov	 ecx, DWORD PTR [ecx+eax*4+20]
  00014	85 c9		 test	 ecx, ecx
  00016	7e 05		 jle	 SHORT $LN3@GetPentagr

; 82   : 	{
; 83   : 		*iPentagramMainAttribute = this->m_Mp[TableNum].m_PentagramMainAttribute;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _iPentagramMainAttribute$[ebp]
  0001b	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@GetPentagr:

; 84   : 	}
; 85   : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?GetPentagramMainAttribute@CMonsterSetBase@@QAEXHPAH@Z ENDP ; CMonsterSetBase::GetPentagramMainAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?Init@CMonsterSetBase@@QAEXXZ
_TEXT	SEGMENT
?Init@CMonsterSetBase@@QAEXXZ PROC			; CMonsterSetBase::Init, COMDAT
; _this$ = ecx

; 30   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 31   : 	this->m_mShopNum.clear();

  00003	8d 8e 64 34 03
	00		 lea	 ecx, DWORD PTR [esi+210020]
  00009	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
  0000e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00011	ba 04 29 00 00	 mov	 edx, 10500		; 00002904H
$LL4@Init:

; 32   : 
; 33   : 	for(int i = 0; i < OBJ_MAXMONSTER; i++)
; 34   : 		this->m_Mp[i].m_ArrangeType = (BYTE)-1;

  00016	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  00019	8d 40 14	 lea	 eax, DWORD PTR [eax+20]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	75 f5		 jne	 SHORT $LL4@Init

; 35   : 
; 36   : 	this->m_Count = 0;

  00021	89 96 60 34 03
	00		 mov	 DWORD PTR [esi+210016], edx

; 37   : 	this->m_GoldenCount = 0;

  00027	89 96 58 34 03
	00		 mov	 DWORD PTR [esi+210008], edx

; 38   : 	this->m_MonsterCount = 0;

  0002d	89 96 5c 34 03
	00		 mov	 DWORD PTR [esi+210012], edx
  00033	5e		 pop	 esi

; 39   : }

  00034	c3		 ret	 0
?Init@CMonsterSetBase@@QAEXXZ ENDP			; CMonsterSetBase::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key, COMDAT
; _this$ = ecx

; 2205 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2207 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2200 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2201 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2202 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2139 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2140 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2141 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 582  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2142 : 
; 2143 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Rrotate

; 2144 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2145 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2146 : 
; 2147 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN3@Rrotate

; 2148 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2153 : 
; 2154 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2155 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2156 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN3@Rrotate:

; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2149 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN5@Rrotate

; 2150 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2153 : 
; 2154 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2155 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2156 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN5@Rrotate:

; 2151 : 		else
; 2152 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2153 : 
; 2154 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2155 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2156 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2135 : 		return (this->_Parent(this->_Myhead()));
; 2136 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 597  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2130 : 		return (this->_Right(this->_Myhead()));
; 2131 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2109 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi

; 2110 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2111 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 582  : 		return ((char&)_Pnode->_Isnil);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]

; 2112 : 
; 2113 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Lrotate

; 2114 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2115 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2116 : 
; 2117 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN3@Lrotate

; 2118 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2123 : 
; 2124 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2125 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2126 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN3@Lrotate:

; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2119 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN5@Lrotate

; 2120 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2123 : 
; 2124 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2125 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2126 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@Lrotate:

; 2121 : 		else
; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2123 : 
; 2124 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2125 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2126 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2105 : 		return (this->_Left(this->_Myhead()));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2106 : 		}

  00002	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBE_NABH0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Compare, COMDAT
; _this$ = ecx

; 2074 : 		{	// compare key_type to key_type, with debug checks

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8b 10		 mov	 edx, DWORD PTR [eax]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000f	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2076 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?_Compare@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBE_NABH0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2060 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f7		 mov	 esi, edi

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 1d		 jne	 SHORT $LN3@Erase
$LL4@Erase:

; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));

  00013	ff 76 08	 push	 DWORD PTR [esi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 2065 : 			_Pnode = this->_Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00028	8b fe		 mov	 edi, esi
  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e3		 je	 SHORT $LL4@Erase
$LN3@Erase:
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx

; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1668 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Newnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1673 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1546 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode
; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1549 : 
; 1550 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1551 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1552 : 		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1553 : 		}
; 1554 : 
; 1555 : 	template<class _Other,
; 1556 : 		class _Mycomp = key_compare,
; 1557 : 		class = typename _Mycomp::is_transparent>
; 1558 : 		iterator lower_bound(const _Other& _Keyval)
; 1559 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1560 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1561 : 		}
; 1562 : 
; 1563 : 	template<class _Other,
; 1564 : 		class _Mycomp = key_compare,
; 1565 : 		class = typename _Mycomp::is_transparent>
; 1566 : 		const_iterator lower_bound(const _Other& _Keyval) const
; 1567 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1568 : 		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1569 : 		}
; 1570 : 
; 1571 : 	iterator upper_bound(const key_type& _Keyval)
; 1572 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1573 : 		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1574 : 		}
; 1575 : 
; 1576 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1577 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1578 : 		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1579 : 		}
; 1580 : 
; 1581 : 	template<class _Other,
; 1582 : 		class _Mycomp = key_compare,
; 1583 : 		class = typename _Mycomp::is_transparent>
; 1584 : 		iterator upper_bound(const _Other& _Keyval)
; 1585 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1586 : 		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1587 : 		}
; 1588 : 
; 1589 : 	template<class _Other,
; 1590 : 		class _Mycomp = key_compare,
; 1591 : 		class = typename _Mycomp::is_transparent>
; 1592 : 		const_iterator upper_bound(const _Other& _Keyval) const
; 1593 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1594 : 		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1595 : 		}
; 1596 : 
; 1597 : 	_Pairii equal_range(const key_type& _Keyval)
; 1598 : 		{	// find range equivalent to _Keyval in mutable tree
; 1599 : 		return (_Eqrange(_Keyval));
; 1600 : 		}
; 1601 : 
; 1602 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1603 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1604 : 		return (_Eqrange(_Keyval));
; 1605 : 		}
; 1606 : 
; 1607 : 	template<class _Other,
; 1608 : 		class _Mycomp = key_compare,
; 1609 : 		class = typename _Mycomp::is_transparent>
; 1610 : 		_Pairii equal_range(const _Other& _Keyval)
; 1611 : 		{	// find range equivalent to _Keyval in mutable tree
; 1612 : 		return (_Eqrange(_Keyval));
; 1613 : 		}
; 1614 : 
; 1615 : 	template<class _Other,
; 1616 : 		class _Mycomp = key_compare,
; 1617 : 		class = typename _Mycomp::is_transparent>
; 1618 : 		_Paircc equal_range(const _Other& _Keyval) const
; 1619 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1620 : 		return (_Eqrange(_Keyval));
; 1621 : 		}
; 1622 : 
; 1623 : 	void swap(_Myt& _Right)
; 1624 : 		{	// exchange contents with _Right
; 1625 : 		if (this == &_Right)
; 1626 : 			;	// same object, do nothing
; 1627 : 		else if (this->_Getal() == _Right._Getal())
; 1628 : 			{	// same allocator, swap control information
; 1629 : 			this->_Swap_all(_Right);
; 1630 : 			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
; 1631 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1632 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1633 : 			}
; 1634 : 
; 1635 : 		else if (_Alty::propagate_on_container_swap::value)
; 1636 : 			{	// swap allocators and control information
; 1637 : 			this->_Swap_alloc(_Right);
; 1638 : 			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
; 1639 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1640 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1641 : 			}
; 1642 : 
; 1643 : 		else
; 1644 : 			{	// containers are incompatible
; 1645 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1646 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1647 : 
; 1648 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1649 : 			_XSTD terminate();
; 1650 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : protected:
; 1655 : 	template<class _Valty>
; 1656 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1657 : 		{	// node exists, just return it
; 1658 : 		return (_Node);
; 1659 : 		}
; 1660 : 
; 1661 : 	template<class _Valty>
; 1662 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1663 : 		{	// node doesn't exist, make it
; 1664 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1665 : 		}
; 1666 : 
; 1667 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1668 : 		{	// node exists, destroy it
; 1669 : 		this->_Getal().destroy(
; 1670 : 			_STD addressof(this->_Myval(_Newnode)));
; 1671 : 
; 1672 : 		this->_Getal().deallocate(_Newnode, 1);
; 1673 : 		}
; 1674 : 
; 1675 : 	void _Destroy_if_not_nil(_Nil)
; 1676 : 		{	// node doesn't exist, do nothing
; 1677 : 		}
; 1678 : 
; 1679 : 	template<class _Valty,
; 1680 : 		class _Nodety>
; 1681 : 		iterator _Insert_hint(const_iterator _Where,
; 1682 : 			_Valty&& _Val, _Nodety _Newnode)
; 1683 : 		{	// try to insert node using _Where as a hint
; 1684 : 		const_iterator _Next;
; 1685 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1686 : 
; 1687 : 		_TRY_BEGIN
; 1688 : 
; 1689 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1690 : 		if (_Where._Getcont() != &this->_Get_data())
; 1691 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1692 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1693 : 
; 1694 : 		if (size() == 0)
; 1695 : 			return (_Insert_at(true, this->_Myhead(),
; 1696 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1697 : 		else if (this->_Multi)
; 1698 : 			{	// insert even if duplicate
; 1699 : 			if (_Where == begin())
; 1700 : 				{	// insert at beginning if before first element
; 1701 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1702 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1703 : 					return (_Insert_at(true, _Where._Mynode(),
; 1704 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1705 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1706 : 				}
; 1707 : 			else if (_Where == end())
; 1708 : 				{	// insert at end if after last element
; 1709 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1710 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1711 : 					return (_Insert_at(false, _Rmost(),
; 1712 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1713 : 				}
; 1714 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1715 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1716 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1717 : 					this->_Kfn(_Val),
; 1718 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1719 : 				{	// insert before _Where
; 1720 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1721 : 					return (_Insert_at(false, _Next._Mynode(),
; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				else
; 1724 : 					return (_Insert_at(true, _Where._Mynode(),
; 1725 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1726 : 				}
; 1727 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1729 : 				&& (++(_Next = _Where) == end()
; 1730 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1732 : 				{	// insert after _Where
; 1733 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1734 : 					return (_Insert_at(false, _Where._Mynode(),
; 1735 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1736 : 				else
; 1737 : 					return (_Insert_at(true, _Next._Mynode(),
; 1738 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1739 : 				}
; 1740 : 			else
; 1741 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1742 : 			}
; 1743 : 		else
; 1744 : 			{	// insert only if unique
; 1745 : 			if (_Where == begin())
; 1746 : 				{	// insert at beginning if before first element
; 1747 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_Where == end())
; 1753 : 				{	// insert at end if after last element
; 1754 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1755 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1756 : 					return (_Insert_at(false, _Rmost(),
; 1757 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1758 : 				}
; 1759 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1760 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1761 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1762 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1763 : 					this->_Kfn(_Val)))
; 1764 : 				{	// insert before _Where
; 1765 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1766 : 					return (_Insert_at(false, _Next._Mynode(),
; 1767 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1768 : 				else
; 1769 : 					return (_Insert_at(true, _Where._Mynode(),
; 1770 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1771 : 				}
; 1772 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1773 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1774 : 				&& (++(_Next = _Where) == end()
; 1775 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1776 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1777 : 				{	// insert after _Where
; 1778 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1779 : 					return (_Insert_at(false, _Where._Mynode(),
; 1780 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1781 : 				else
; 1782 : 					return (_Insert_at(true, _Next._Mynode(),
; 1783 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1784 : 				}
; 1785 : 			}
; 1786 : 		_CATCH_ALL
; 1787 : 		_Destroy_if_not_nil(_Newnode);
; 1788 : 		_RERAISE;
; 1789 : 		_CATCH_END
; 1790 : 
; 1791 : 		return (_Insert_nohint(_Leftish,
; 1792 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1793 : 		}
; 1794 : 
; 1795 : 	template<class _Valty,
; 1796 : 		class _Nodety>
; 1797 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1798 : 			_Valty&& _Val, _Nodety _Newnode)
; 1799 : 		{	// try to insert node, on left if _Leftish
; 1800 : 		_TRY_BEGIN
; 1801 : 		_Nodeptr _Trynode = _Root();
; 1802 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1803 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1804 : 
; 1805 : 		while (!this->_Isnil(_Trynode))
; 1806 : 			{	// look for leaf to insert before (_Addleft) or after
; 1807 : 			_Wherenode = _Trynode;
; 1808 : 			if (_Leftish)
; 1809 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1810 : 					this->_Key(_Trynode),
; 1811 : 					this->_Kfn(_Val));	// favor left end
; 1812 : 			else
; 1813 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1814 : 					this->_Kfn(_Val),
; 1815 : 					this->_Key(_Trynode));	// favor right end
; 1816 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1817 : 				: this->_Right(_Trynode);
; 1818 : 			}
; 1819 : 
; 1820 : 		if (this->_Multi)
; 1821 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1822 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1823 : 		else
; 1824 : 			{	// insert only if unique
; 1825 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1826 : 			if (!_Addleft)
; 1827 : 				;	// need to test if insert after is okay
; 1828 : 			else if (_Where == begin())
; 1829 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1830 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1831 : 			else
; 1832 : 				--_Where;	// need to test if insert before is okay
; 1833 : 
; 1834 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1835 : 				this->_Key(_Where._Mynode()),
; 1836 : 				this->_Kfn(_Val)))
; 1837 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1838 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1839 : 			else
; 1840 : 				{	// duplicate, don't insert
; 1841 : 				_Destroy_if_not_nil(_Newnode);
; 1842 : 				return (_Pairib(_Where, false));
; 1843 : 				}
; 1844 : 			}
; 1845 : 		_CATCH_ALL
; 1846 : 		_Destroy_if_not_nil(_Newnode);
; 1847 : 		_RERAISE;
; 1848 : 		_CATCH_END
; 1849 : 		}
; 1850 : 
; 1851 : 	template<class _Valty,
; 1852 : 		class _Nodety>
; 1853 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1854 : 		_Valty&& _Val, _Nodety _Node)
; 1855 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1856 : 		if (max_size() - 1 <= this->_Mysize())
; 1857 : 			{	// tree would get too big, fail
; 1858 : 			_Destroy_if_not_nil(_Node);
; 1859 : 			_Xlength_error("map/set<T> too long");
; 1860 : 			}
; 1861 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1862 : 			_STD forward<_Valty>(_Val));
; 1863 : 
; 1864 : 		++this->_Mysize();
; 1865 : 		_Newnode->_Parent = _Wherenode;
; 1866 : 
; 1867 : 		if (_Wherenode == this->_Myhead())
; 1868 : 			{	// first node in tree, just set head values
; 1869 : 			_Root() = _Newnode;
; 1870 : 			_Lmost() = _Newnode;
; 1871 : 			_Rmost() = _Newnode;
; 1872 : 			}
; 1873 : 		else if (_Addleft)
; 1874 : 			{	// add to left of _Wherenode
; 1875 : 			this->_Left(_Wherenode) = _Newnode;
; 1876 : 			if (_Wherenode == _Lmost())
; 1877 : 				_Lmost() = _Newnode;
; 1878 : 			}
; 1879 : 		else
; 1880 : 			{	// add to right of _Wherenode
; 1881 : 			this->_Right(_Wherenode) = _Newnode;
; 1882 : 			if (_Wherenode == _Rmost())
; 1883 : 				_Rmost() = _Newnode;
; 1884 : 			}
; 1885 : 
; 1886 : 		for (_Nodeptr _Pnode = _Newnode;
; 1887 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1888 : 			if (this->_Parent(_Pnode)
; 1889 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1890 : 				{	// fixup red-red in left subtree
; 1891 : 				_Wherenode =
; 1892 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1894 : 					{	// parent has two red children, blacken both
; 1895 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1896 : 					this->_Color(_Wherenode) = this->_Black;
; 1897 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1898 : 						= this->_Red;
; 1899 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1900 : 					}
; 1901 : 				else
; 1902 : 					{	// parent has red and black children
; 1903 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1904 : 						{	// rotate right child to left
; 1905 : 						_Pnode = this->_Parent(_Pnode);
; 1906 : 						_Lrotate(_Pnode);
; 1907 : 						}
; 1908 : 					this->_Color(this->_Parent(_Pnode)) =
; 1909 : 						this->_Black;	// propagate red up
; 1910 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1911 : 						this->_Red;
; 1912 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1913 : 					}
; 1914 : 				}
; 1915 : 			else
; 1916 : 				{	// fixup red-red in right subtree
; 1917 : 				_Wherenode =
; 1918 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1920 : 					{	// parent has two red children, blacken both
; 1921 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1922 : 					this->_Color(_Wherenode) = this->_Black;
; 1923 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1924 : 						this->_Red;
; 1925 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1926 : 					}
; 1927 : 				else
; 1928 : 					{	// parent has red and black children
; 1929 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1930 : 						{	// rotate left child to right
; 1931 : 						_Pnode = this->_Parent(_Pnode);
; 1932 : 						_Rrotate(_Pnode);
; 1933 : 						}
; 1934 : 					this->_Color(this->_Parent(_Pnode)) =
; 1935 : 						this->_Black;	// propagate red up
; 1936 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1937 : 						this->_Red;
; 1938 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1939 : 					}
; 1940 : 				}
; 1941 : 
; 1942 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1943 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1944 : 		}
; 1945 : 
; 1946 : 	template<class _Moveit>
; 1947 : 		void _Copy(const _Myt& _Right, _Moveit _Movefl)
; 1948 : 		{	// copy or move entire tree from _Right
; 1949 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);
; 1950 : 		this->_Mysize() = _Right.size();
; 1951 : 		if (!this->_Isnil(_Root()))
; 1952 : 			{	// nonempty tree, look for new smallest and largest
; 1953 : 			_Lmost() = this->_Min(_Root());
; 1954 : 			_Rmost() = this->_Max(_Root());
; 1955 : 			}
; 1956 : 		else
; 1957 : 			{	// empty tree, just tidy head pointers
; 1958 : 			_Lmost() = this->_Myhead();
; 1959 : 			_Rmost() = this->_Myhead();
; 1960 : 			}
; 1961 : 		}
; 1962 : 
; 1963 : 	template<class _Ty,
; 1964 : 		class _Is_set>
; 1965 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
; 1966 : 		{	// copy to new node
; 1967 : 		return (this->_Buynode(_Val));
; 1968 : 		}
; 1969 : 
; 1970 : 	template<class _Ty>
; 1971 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
; 1972 : 		{	// move to new node -- set
; 1973 : 		return (this->_Buynode(_STD move(_Val)));
; 1974 : 		}
; 1975 : 
; 1976 : 	template<class _Ty>
; 1977 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
; 1978 : 		{	// move to new node -- map
; 1979 : 		return (this->_Buynode(
; 1980 : 			_STD move(const_cast<key_type&>(_Val.first)),
; 1981 : 			_STD move(_Val.second)));
; 1982 : 		}
; 1983 : 
; 1984 : 	template<class _Moveit>
; 1985 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1986 : 			_Moveit _Movefl)
; 1987 : 		{	// copy entire subtree, recursively
; 1988 : 		_Nodeptr _Newroot = this->_Myhead();	// point at nil node
; 1989 : 
; 1990 : 		if (!this->_Isnil(_Rootnode))
; 1991 : 			{	// copy or move a node, then any subtrees
; 1992 : 			typename is_same<key_type, value_type>::type _Is_set;
; 1993 : 			_Nodeptr _Pnode = _Copy_or_move(
; 1994 : 				this->_Myval(_Rootnode), _Movefl, _Is_set);
; 1995 : 			_Pnode->_Parent = _Wherenode;
; 1996 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1997 : 			if (this->_Isnil(_Newroot))
; 1998 : 				_Newroot = _Pnode;	// memorize new root
; 1999 : 
; 2000 : 			_TRY_BEGIN
; 2001 : 			this->_Left(_Pnode) =
; 2002 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 2003 : 			this->_Right(_Pnode) =
; 2004 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 2005 : 			_CATCH_ALL
; 2006 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 2007 : 			_RERAISE;
; 2008 : 			_CATCH_END
; 2009 : 			}
; 2010 : 
; 2011 : 		return (_Newroot);	// return newly constructed tree
; 2012 : 		}
; 2013 : 
; 2014 : 	template<class _Other>
; 2015 : 		_Paircc _Eqrange(const _Other& _Keyval) const
; 2016 : 		{	// find leftmost node not less than _Keyval
; 2017 : 		_Nodeptr _Pnode = _Root();
; 2018 : 		_Nodeptr _Lonode = this->_Myhead();	// end() if search fails
; 2019 : 		_Nodeptr _Hinode = this->_Myhead();	// end() if search fails
; 2020 : 
; 2021 : 		while (!this->_Isnil(_Pnode))
; 2022 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2023 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2024 : 			else
; 2025 : 				{	// _Pnode not less than _Keyval, remember it
; 2026 : 				if (this->_Isnil(_Hinode)
; 2027 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2028 : 						this->_Key(_Pnode)))
; 2029 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2030 : 				_Lonode = _Pnode;
; 2031 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2032 : 				}
; 2033 : 
; 2034 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2035 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2036 : 		while (!this->_Isnil(_Pnode))
; 2037 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2038 : 				{	// _Pnode greater than _Keyval, remember it
; 2039 : 				_Hinode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 			else
; 2043 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2044 : 
; 2045 : 		const_iterator _First = const_iterator(_Lonode, &this->_Get_data());
; 2046 : 		const_iterator _Last = const_iterator(_Hinode, &this->_Get_data());
; 2047 : 		return (_Paircc(_First, _Last));
; 2048 : 		}
; 2049 : 
; 2050 : 	template<class _Other>
; 2051 : 		_Pairii _Eqrange(const _Other& _Keyval)
; 2052 : 		{	// find leftmost node not less than _Keyval
; 2053 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
; 2054 : 		iterator _First = iterator(_Ans.first._Ptr, &this->_Get_data());
; 2055 : 		iterator _Last = iterator(_Ans.second._Ptr, &this->_Get_data());
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	bool _Compare(const key_type& _Left, const key_type& _Right) const
; 2074 : 		{	// compare key_type to key_type, with debug checks
; 2075 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));
; 2076 : 		}
; 2077 : 
; 2078 : 	template<class _Ty1,
; 2079 : 		class _Ty2>
; 2080 : 		bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
; 2081 : 		{	// compare _Ty1 to _Ty2, without debug checks
; 2082 : 		return (this->_Getcomp()(_Left, _Right));
; 2083 : 		}
; 2084 : 
; 2085 : 	template<class _Other>
; 2086 : 		_Nodeptr _Lbound(const _Other& _Keyval) const
; 2087 : 		{	// find leftmost node not less than _Keyval
; 2088 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2089 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2090 : 
; 2091 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN91@lower_boun
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL13@lower_boun:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2092 : 			if (_Compare(this->_Key(_Pnode), _Keyval))

  00016	7d 05		 jge	 SHORT $LN15@lower_boun

; 2093 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2094 : 			else

  0001b	eb 04		 jmp	 SHORT $LN16@lower_boun
$LN15@lower_boun:

; 2095 : 				{	// _Pnode not less than _Keyval, remember it
; 2096 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2097 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN16@lower_boun:

; 2089 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2090 : 
; 2091 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL13@lower_boun
$LN91@lower_boun:

; 43   : 		: _Ptr(_Pnode)

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 1547 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1548 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 1485 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);
; 588  : 		}
; 589  : 
; 590  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 591  : 		{	// return reference to parent pointer in node
; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1492 : 
; 1493 : 	const_iterator find(const key_type& _Keyval) const
; 1494 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1495 : 		const_iterator _Where = lower_bound(_Keyval);
; 1496 : 		return (_Where == end()
; 1497 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1498 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1499 : 					? end() : _Where);
; 1500 : 		}
; 1501 : 
; 1502 : 	template<class _Other,
; 1503 : 		class _Mycomp = key_compare,
; 1504 : 		class = typename _Mycomp::is_transparent>
; 1505 : 		iterator find(const _Other& _Keyval)
; 1506 : 		{	// find an element in mutable sequence that matches _Keyval
; 1507 : 		iterator _Where = lower_bound(_Keyval);
; 1508 : 		return (_Where == end()
; 1509 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1510 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1511 : 					? end() : _Where);
; 1512 : 		}
; 1513 : 
; 1514 : 	template<class _Other,
; 1515 : 		class _Mycomp = key_compare,
; 1516 : 		class = typename _Mycomp::is_transparent>
; 1517 : 		const_iterator find(const _Other& _Keyval) const
; 1518 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1519 : 		const_iterator _Where = lower_bound(_Keyval);
; 1520 : 		return (_Where == end()
; 1521 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1522 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1523 : 					? end() : _Where);
; 1524 : 		}
; 1525 : 
; 1526 : 	size_type count(const key_type& _Keyval) const
; 1527 : 		{	// count all elements that match _Keyval
; 1528 : 		_Paircc _Ans = equal_range(_Keyval);
; 1529 : 		size_type _Num = 0;
; 1530 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	template<class _Other,
; 1535 : 		class _Mycomp = key_compare,
; 1536 : 		class = typename _Mycomp::is_transparent>
; 1537 : 		size_type count(const _Other& _Keyval) const
; 1538 : 		{	// count all elements that match _Keyval
; 1539 : 		_Paircc _Ans = equal_range(_Keyval);
; 1540 : 		size_type _Num = 0;
; 1541 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1542 : 		return (_Num);
; 1543 : 		}
; 1544 : 
; 1545 : 	iterator lower_bound(const key_type& _Keyval)
; 1546 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1547 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1548 : 		}
; 1549 : 
; 1550 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1551 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1552 : 		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1553 : 		}
; 1554 : 
; 1555 : 	template<class _Other,
; 1556 : 		class _Mycomp = key_compare,
; 1557 : 		class = typename _Mycomp::is_transparent>
; 1558 : 		iterator lower_bound(const _Other& _Keyval)
; 1559 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1560 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1561 : 		}
; 1562 : 
; 1563 : 	template<class _Other,
; 1564 : 		class _Mycomp = key_compare,
; 1565 : 		class = typename _Mycomp::is_transparent>
; 1566 : 		const_iterator lower_bound(const _Other& _Keyval) const
; 1567 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1568 : 		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1569 : 		}
; 1570 : 
; 1571 : 	iterator upper_bound(const key_type& _Keyval)
; 1572 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1573 : 		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1574 : 		}
; 1575 : 
; 1576 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1577 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1578 : 		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1579 : 		}
; 1580 : 
; 1581 : 	template<class _Other,
; 1582 : 		class _Mycomp = key_compare,
; 1583 : 		class = typename _Mycomp::is_transparent>
; 1584 : 		iterator upper_bound(const _Other& _Keyval)
; 1585 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1586 : 		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1587 : 		}
; 1588 : 
; 1589 : 	template<class _Other,
; 1590 : 		class _Mycomp = key_compare,
; 1591 : 		class = typename _Mycomp::is_transparent>
; 1592 : 		const_iterator upper_bound(const _Other& _Keyval) const
; 1593 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1594 : 		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1595 : 		}
; 1596 : 
; 1597 : 	_Pairii equal_range(const key_type& _Keyval)
; 1598 : 		{	// find range equivalent to _Keyval in mutable tree
; 1599 : 		return (_Eqrange(_Keyval));
; 1600 : 		}
; 1601 : 
; 1602 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1603 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1604 : 		return (_Eqrange(_Keyval));
; 1605 : 		}
; 1606 : 
; 1607 : 	template<class _Other,
; 1608 : 		class _Mycomp = key_compare,
; 1609 : 		class = typename _Mycomp::is_transparent>
; 1610 : 		_Pairii equal_range(const _Other& _Keyval)
; 1611 : 		{	// find range equivalent to _Keyval in mutable tree
; 1612 : 		return (_Eqrange(_Keyval));
; 1613 : 		}
; 1614 : 
; 1615 : 	template<class _Other,
; 1616 : 		class _Mycomp = key_compare,
; 1617 : 		class = typename _Mycomp::is_transparent>
; 1618 : 		_Paircc equal_range(const _Other& _Keyval) const
; 1619 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1620 : 		return (_Eqrange(_Keyval));
; 1621 : 		}
; 1622 : 
; 1623 : 	void swap(_Myt& _Right)
; 1624 : 		{	// exchange contents with _Right
; 1625 : 		if (this == &_Right)
; 1626 : 			;	// same object, do nothing
; 1627 : 		else if (this->_Getal() == _Right._Getal())
; 1628 : 			{	// same allocator, swap control information
; 1629 : 			this->_Swap_all(_Right);
; 1630 : 			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
; 1631 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1632 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1633 : 			}
; 1634 : 
; 1635 : 		else if (_Alty::propagate_on_container_swap::value)
; 1636 : 			{	// swap allocators and control information
; 1637 : 			this->_Swap_alloc(_Right);
; 1638 : 			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
; 1639 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1640 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1641 : 			}
; 1642 : 
; 1643 : 		else
; 1644 : 			{	// containers are incompatible
; 1645 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1646 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1647 : 
; 1648 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1649 : 			_XSTD terminate();
; 1650 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : protected:
; 1655 : 	template<class _Valty>
; 1656 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1657 : 		{	// node exists, just return it
; 1658 : 		return (_Node);
; 1659 : 		}
; 1660 : 
; 1661 : 	template<class _Valty>
; 1662 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1663 : 		{	// node doesn't exist, make it
; 1664 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1665 : 		}
; 1666 : 
; 1667 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1668 : 		{	// node exists, destroy it
; 1669 : 		this->_Getal().destroy(
; 1670 : 			_STD addressof(this->_Myval(_Newnode)));
; 1671 : 
; 1672 : 		this->_Getal().deallocate(_Newnode, 1);
; 1673 : 		}
; 1674 : 
; 1675 : 	void _Destroy_if_not_nil(_Nil)
; 1676 : 		{	// node doesn't exist, do nothing
; 1677 : 		}
; 1678 : 
; 1679 : 	template<class _Valty,
; 1680 : 		class _Nodety>
; 1681 : 		iterator _Insert_hint(const_iterator _Where,
; 1682 : 			_Valty&& _Val, _Nodety _Newnode)
; 1683 : 		{	// try to insert node using _Where as a hint
; 1684 : 		const_iterator _Next;
; 1685 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1686 : 
; 1687 : 		_TRY_BEGIN
; 1688 : 
; 1689 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1690 : 		if (_Where._Getcont() != &this->_Get_data())
; 1691 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1692 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1693 : 
; 1694 : 		if (size() == 0)
; 1695 : 			return (_Insert_at(true, this->_Myhead(),
; 1696 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1697 : 		else if (this->_Multi)
; 1698 : 			{	// insert even if duplicate
; 1699 : 			if (_Where == begin())
; 1700 : 				{	// insert at beginning if before first element
; 1701 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1702 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1703 : 					return (_Insert_at(true, _Where._Mynode(),
; 1704 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1705 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1706 : 				}
; 1707 : 			else if (_Where == end())
; 1708 : 				{	// insert at end if after last element
; 1709 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1710 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1711 : 					return (_Insert_at(false, _Rmost(),
; 1712 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1713 : 				}
; 1714 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1715 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1716 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1717 : 					this->_Kfn(_Val),
; 1718 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1719 : 				{	// insert before _Where
; 1720 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1721 : 					return (_Insert_at(false, _Next._Mynode(),
; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				else
; 1724 : 					return (_Insert_at(true, _Where._Mynode(),
; 1725 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1726 : 				}
; 1727 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1729 : 				&& (++(_Next = _Where) == end()
; 1730 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1732 : 				{	// insert after _Where
; 1733 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1734 : 					return (_Insert_at(false, _Where._Mynode(),
; 1735 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1736 : 				else
; 1737 : 					return (_Insert_at(true, _Next._Mynode(),
; 1738 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1739 : 				}
; 1740 : 			else
; 1741 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1742 : 			}
; 1743 : 		else
; 1744 : 			{	// insert only if unique
; 1745 : 			if (_Where == begin())
; 1746 : 				{	// insert at beginning if before first element
; 1747 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_Where == end())
; 1753 : 				{	// insert at end if after last element
; 1754 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1755 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1756 : 					return (_Insert_at(false, _Rmost(),
; 1757 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1758 : 				}
; 1759 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1760 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1761 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1762 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1763 : 					this->_Kfn(_Val)))
; 1764 : 				{	// insert before _Where
; 1765 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1766 : 					return (_Insert_at(false, _Next._Mynode(),
; 1767 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1768 : 				else
; 1769 : 					return (_Insert_at(true, _Where._Mynode(),
; 1770 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1771 : 				}
; 1772 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1773 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1774 : 				&& (++(_Next = _Where) == end()
; 1775 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1776 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1777 : 				{	// insert after _Where
; 1778 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1779 : 					return (_Insert_at(false, _Where._Mynode(),
; 1780 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1781 : 				else
; 1782 : 					return (_Insert_at(true, _Next._Mynode(),
; 1783 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1784 : 				}
; 1785 : 			}
; 1786 : 		_CATCH_ALL
; 1787 : 		_Destroy_if_not_nil(_Newnode);
; 1788 : 		_RERAISE;
; 1789 : 		_CATCH_END
; 1790 : 
; 1791 : 		return (_Insert_nohint(_Leftish,
; 1792 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1793 : 		}
; 1794 : 
; 1795 : 	template<class _Valty,
; 1796 : 		class _Nodety>
; 1797 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1798 : 			_Valty&& _Val, _Nodety _Newnode)
; 1799 : 		{	// try to insert node, on left if _Leftish
; 1800 : 		_TRY_BEGIN
; 1801 : 		_Nodeptr _Trynode = _Root();
; 1802 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1803 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1804 : 
; 1805 : 		while (!this->_Isnil(_Trynode))
; 1806 : 			{	// look for leaf to insert before (_Addleft) or after
; 1807 : 			_Wherenode = _Trynode;
; 1808 : 			if (_Leftish)
; 1809 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1810 : 					this->_Key(_Trynode),
; 1811 : 					this->_Kfn(_Val));	// favor left end
; 1812 : 			else
; 1813 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1814 : 					this->_Kfn(_Val),
; 1815 : 					this->_Key(_Trynode));	// favor right end
; 1816 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1817 : 				: this->_Right(_Trynode);
; 1818 : 			}
; 1819 : 
; 1820 : 		if (this->_Multi)
; 1821 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1822 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1823 : 		else
; 1824 : 			{	// insert only if unique
; 1825 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1826 : 			if (!_Addleft)
; 1827 : 				;	// need to test if insert after is okay
; 1828 : 			else if (_Where == begin())
; 1829 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1830 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1831 : 			else
; 1832 : 				--_Where;	// need to test if insert before is okay
; 1833 : 
; 1834 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1835 : 				this->_Key(_Where._Mynode()),
; 1836 : 				this->_Kfn(_Val)))
; 1837 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1838 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1839 : 			else
; 1840 : 				{	// duplicate, don't insert
; 1841 : 				_Destroy_if_not_nil(_Newnode);
; 1842 : 				return (_Pairib(_Where, false));
; 1843 : 				}
; 1844 : 			}
; 1845 : 		_CATCH_ALL
; 1846 : 		_Destroy_if_not_nil(_Newnode);
; 1847 : 		_RERAISE;
; 1848 : 		_CATCH_END
; 1849 : 		}
; 1850 : 
; 1851 : 	template<class _Valty,
; 1852 : 		class _Nodety>
; 1853 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1854 : 		_Valty&& _Val, _Nodety _Node)
; 1855 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1856 : 		if (max_size() - 1 <= this->_Mysize())
; 1857 : 			{	// tree would get too big, fail
; 1858 : 			_Destroy_if_not_nil(_Node);
; 1859 : 			_Xlength_error("map/set<T> too long");
; 1860 : 			}
; 1861 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1862 : 			_STD forward<_Valty>(_Val));
; 1863 : 
; 1864 : 		++this->_Mysize();
; 1865 : 		_Newnode->_Parent = _Wherenode;
; 1866 : 
; 1867 : 		if (_Wherenode == this->_Myhead())
; 1868 : 			{	// first node in tree, just set head values
; 1869 : 			_Root() = _Newnode;
; 1870 : 			_Lmost() = _Newnode;
; 1871 : 			_Rmost() = _Newnode;
; 1872 : 			}
; 1873 : 		else if (_Addleft)
; 1874 : 			{	// add to left of _Wherenode
; 1875 : 			this->_Left(_Wherenode) = _Newnode;
; 1876 : 			if (_Wherenode == _Lmost())
; 1877 : 				_Lmost() = _Newnode;
; 1878 : 			}
; 1879 : 		else
; 1880 : 			{	// add to right of _Wherenode
; 1881 : 			this->_Right(_Wherenode) = _Newnode;
; 1882 : 			if (_Wherenode == _Rmost())
; 1883 : 				_Rmost() = _Newnode;
; 1884 : 			}
; 1885 : 
; 1886 : 		for (_Nodeptr _Pnode = _Newnode;
; 1887 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1888 : 			if (this->_Parent(_Pnode)
; 1889 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1890 : 				{	// fixup red-red in left subtree
; 1891 : 				_Wherenode =
; 1892 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1894 : 					{	// parent has two red children, blacken both
; 1895 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1896 : 					this->_Color(_Wherenode) = this->_Black;
; 1897 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1898 : 						= this->_Red;
; 1899 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1900 : 					}
; 1901 : 				else
; 1902 : 					{	// parent has red and black children
; 1903 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1904 : 						{	// rotate right child to left
; 1905 : 						_Pnode = this->_Parent(_Pnode);
; 1906 : 						_Lrotate(_Pnode);
; 1907 : 						}
; 1908 : 					this->_Color(this->_Parent(_Pnode)) =
; 1909 : 						this->_Black;	// propagate red up
; 1910 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1911 : 						this->_Red;
; 1912 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1913 : 					}
; 1914 : 				}
; 1915 : 			else
; 1916 : 				{	// fixup red-red in right subtree
; 1917 : 				_Wherenode =
; 1918 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1920 : 					{	// parent has two red children, blacken both
; 1921 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1922 : 					this->_Color(_Wherenode) = this->_Black;
; 1923 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1924 : 						this->_Red;
; 1925 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1926 : 					}
; 1927 : 				else
; 1928 : 					{	// parent has red and black children
; 1929 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1930 : 						{	// rotate left child to right
; 1931 : 						_Pnode = this->_Parent(_Pnode);
; 1932 : 						_Rrotate(_Pnode);
; 1933 : 						}
; 1934 : 					this->_Color(this->_Parent(_Pnode)) =
; 1935 : 						this->_Black;	// propagate red up
; 1936 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1937 : 						this->_Red;
; 1938 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1939 : 					}
; 1940 : 				}
; 1941 : 
; 1942 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1943 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1944 : 		}
; 1945 : 
; 1946 : 	template<class _Moveit>
; 1947 : 		void _Copy(const _Myt& _Right, _Moveit _Movefl)
; 1948 : 		{	// copy or move entire tree from _Right
; 1949 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);
; 1950 : 		this->_Mysize() = _Right.size();
; 1951 : 		if (!this->_Isnil(_Root()))
; 1952 : 			{	// nonempty tree, look for new smallest and largest
; 1953 : 			_Lmost() = this->_Min(_Root());
; 1954 : 			_Rmost() = this->_Max(_Root());
; 1955 : 			}
; 1956 : 		else
; 1957 : 			{	// empty tree, just tidy head pointers
; 1958 : 			_Lmost() = this->_Myhead();
; 1959 : 			_Rmost() = this->_Myhead();
; 1960 : 			}
; 1961 : 		}
; 1962 : 
; 1963 : 	template<class _Ty,
; 1964 : 		class _Is_set>
; 1965 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
; 1966 : 		{	// copy to new node
; 1967 : 		return (this->_Buynode(_Val));
; 1968 : 		}
; 1969 : 
; 1970 : 	template<class _Ty>
; 1971 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
; 1972 : 		{	// move to new node -- set
; 1973 : 		return (this->_Buynode(_STD move(_Val)));
; 1974 : 		}
; 1975 : 
; 1976 : 	template<class _Ty>
; 1977 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
; 1978 : 		{	// move to new node -- map
; 1979 : 		return (this->_Buynode(
; 1980 : 			_STD move(const_cast<key_type&>(_Val.first)),
; 1981 : 			_STD move(_Val.second)));
; 1982 : 		}
; 1983 : 
; 1984 : 	template<class _Moveit>
; 1985 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1986 : 			_Moveit _Movefl)
; 1987 : 		{	// copy entire subtree, recursively
; 1988 : 		_Nodeptr _Newroot = this->_Myhead();	// point at nil node
; 1989 : 
; 1990 : 		if (!this->_Isnil(_Rootnode))
; 1991 : 			{	// copy or move a node, then any subtrees
; 1992 : 			typename is_same<key_type, value_type>::type _Is_set;
; 1993 : 			_Nodeptr _Pnode = _Copy_or_move(
; 1994 : 				this->_Myval(_Rootnode), _Movefl, _Is_set);
; 1995 : 			_Pnode->_Parent = _Wherenode;
; 1996 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1997 : 			if (this->_Isnil(_Newroot))
; 1998 : 				_Newroot = _Pnode;	// memorize new root
; 1999 : 
; 2000 : 			_TRY_BEGIN
; 2001 : 			this->_Left(_Pnode) =
; 2002 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 2003 : 			this->_Right(_Pnode) =
; 2004 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 2005 : 			_CATCH_ALL
; 2006 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 2007 : 			_RERAISE;
; 2008 : 			_CATCH_END
; 2009 : 			}
; 2010 : 
; 2011 : 		return (_Newroot);	// return newly constructed tree
; 2012 : 		}
; 2013 : 
; 2014 : 	template<class _Other>
; 2015 : 		_Paircc _Eqrange(const _Other& _Keyval) const
; 2016 : 		{	// find leftmost node not less than _Keyval
; 2017 : 		_Nodeptr _Pnode = _Root();
; 2018 : 		_Nodeptr _Lonode = this->_Myhead();	// end() if search fails
; 2019 : 		_Nodeptr _Hinode = this->_Myhead();	// end() if search fails
; 2020 : 
; 2021 : 		while (!this->_Isnil(_Pnode))
; 2022 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2023 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2024 : 			else
; 2025 : 				{	// _Pnode not less than _Keyval, remember it
; 2026 : 				if (this->_Isnil(_Hinode)
; 2027 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2028 : 						this->_Key(_Pnode)))
; 2029 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2030 : 				_Lonode = _Pnode;
; 2031 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2032 : 				}
; 2033 : 
; 2034 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2035 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2036 : 		while (!this->_Isnil(_Pnode))
; 2037 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2038 : 				{	// _Pnode greater than _Keyval, remember it
; 2039 : 				_Hinode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 			else
; 2043 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2044 : 
; 2045 : 		const_iterator _First = const_iterator(_Lonode, &this->_Get_data());
; 2046 : 		const_iterator _Last = const_iterator(_Hinode, &this->_Get_data());
; 2047 : 		return (_Paircc(_First, _Last));
; 2048 : 		}
; 2049 : 
; 2050 : 	template<class _Other>
; 2051 : 		_Pairii _Eqrange(const _Other& _Keyval)
; 2052 : 		{	// find leftmost node not less than _Keyval
; 2053 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
; 2054 : 		iterator _First = iterator(_Ans.first._Ptr, &this->_Get_data());
; 2055 : 		iterator _Last = iterator(_Ans.second._Ptr, &this->_Get_data());
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	bool _Compare(const key_type& _Left, const key_type& _Right) const
; 2074 : 		{	// compare key_type to key_type, with debug checks
; 2075 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));
; 2076 : 		}
; 2077 : 
; 2078 : 	template<class _Ty1,
; 2079 : 		class _Ty2>
; 2080 : 		bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
; 2081 : 		{	// compare _Ty1 to _Ty2, without debug checks
; 2082 : 		return (this->_Getcomp()(_Left, _Right));
; 2083 : 		}
; 2084 : 
; 2085 : 	template<class _Other>
; 2086 : 		_Nodeptr _Lbound(const _Other& _Keyval) const
; 2087 : 		{	// find leftmost node not less than _Keyval
; 2088 : 		_Nodeptr _Pnode = _Root();
; 2089 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails

  00005	8b d0		 mov	 edx, eax
  00007	57		 push	 edi

; 2090 : 
; 2091 : 		while (!this->_Isnil(_Pnode))

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00012	75 18		 jne	 SHORT $LN18@find
  00014	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL17@find:
  00017	39 71 10	 cmp	 DWORD PTR [ecx+16], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2092 : 			if (_Compare(this->_Key(_Pnode), _Keyval))

  0001a	7d 05		 jge	 SHORT $LN19@find

; 2093 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 2094 : 			else

  0001f	eb 04		 jmp	 SHORT $LN20@find
$LN19@find:

; 2095 : 				{	// _Pnode not less than _Keyval, remember it
; 2096 : 				_Wherenode = _Pnode;

  00021	8b d1		 mov	 edx, ecx

; 2097 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00023	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN20@find:

; 2090 : 
; 2091 : 		while (!this->_Isnil(_Pnode))

  00025	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00029	74 ec		 je	 SHORT $LL17@find
  0002b	5e		 pop	 esi
$LN18@find:

; 334  : 		return (this->_Ptr == _Right._Ptr);

  0002c	3b d0		 cmp	 edx, eax

; 1487 : 		return (_Where == end()

  0002e	74 11		 je	 SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		return (_Left < _Right);

  00030	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00032	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1487 : 		return (_Where == end()

  00035	7c 0a		 jl	 SHORT $LN3@find
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	5f		 pop	 edi
  0003b	89 10		 mov	 DWORD PTR [eax], edx

; 1488 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1489 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1490 : 					? end() : _Where);
; 1491 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN3@find:

; 1487 : 		return (_Where == end()

  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	5f		 pop	 edi
  00045	89 01		 mov	 DWORD PTR [ecx], eax
  00047	8b c1		 mov	 eax, ecx

; 1488 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1489 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1490 : 					? end() : _Where);
; 1491 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 1472 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 		this->_Orphan_ptr(0);
; 1475 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1476 : 
; 1477 : 		_Erase(_Root());

  00027	8b 07		 mov	 eax, DWORD PTR [edi]
  00029	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 1483 : 
; 1484 : 	iterator find(const key_type& _Keyval)
; 1485 : 		{	// find an element in mutable sequence that matches _Keyval
; 1486 : 		iterator _Where = lower_bound(_Keyval);
; 1487 : 		return (_Where == end()
; 1488 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1489 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1490 : 					? end() : _Where);
; 1491 : 		}
; 1492 : 
; 1493 : 	const_iterator find(const key_type& _Keyval) const
; 1494 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1495 : 		const_iterator _Where = lower_bound(_Keyval);
; 1496 : 		return (_Where == end()
; 1497 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1498 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1499 : 					? end() : _Where);
; 1500 : 		}
; 1501 : 
; 1502 : 	template<class _Other,
; 1503 : 		class _Mycomp = key_compare,
; 1504 : 		class = typename _Mycomp::is_transparent>
; 1505 : 		iterator find(const _Other& _Keyval)
; 1506 : 		{	// find an element in mutable sequence that matches _Keyval
; 1507 : 		iterator _Where = lower_bound(_Keyval);
; 1508 : 		return (_Where == end()
; 1509 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1510 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1511 : 					? end() : _Where);
; 1512 : 		}
; 1513 : 
; 1514 : 	template<class _Other,
; 1515 : 		class _Mycomp = key_compare,
; 1516 : 		class = typename _Mycomp::is_transparent>
; 1517 : 		const_iterator find(const _Other& _Keyval) const
; 1518 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1519 : 		const_iterator _Where = lower_bound(_Keyval);
; 1520 : 		return (_Where == end()
; 1521 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1522 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1523 : 					? end() : _Where);
; 1524 : 		}
; 1525 : 
; 1526 : 	size_type count(const key_type& _Keyval) const
; 1527 : 		{	// count all elements that match _Keyval
; 1528 : 		_Paircc _Ans = equal_range(_Keyval);
; 1529 : 		size_type _Num = 0;
; 1530 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	template<class _Other,
; 1535 : 		class _Mycomp = key_compare,
; 1536 : 		class = typename _Mycomp::is_transparent>
; 1537 : 		size_type count(const _Other& _Keyval) const
; 1538 : 		{	// count all elements that match _Keyval
; 1539 : 		_Paircc _Ans = equal_range(_Keyval);
; 1540 : 		size_type _Num = 0;
; 1541 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1542 : 		return (_Num);
; 1543 : 		}
; 1544 : 
; 1545 : 	iterator lower_bound(const key_type& _Keyval)
; 1546 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1547 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1548 : 		}
; 1549 : 
; 1550 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1551 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1552 : 		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1553 : 		}
; 1554 : 
; 1555 : 	template<class _Other,
; 1556 : 		class _Mycomp = key_compare,
; 1557 : 		class = typename _Mycomp::is_transparent>
; 1558 : 		iterator lower_bound(const _Other& _Keyval)
; 1559 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1560 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1561 : 		}
; 1562 : 
; 1563 : 	template<class _Other,
; 1564 : 		class _Mycomp = key_compare,
; 1565 : 		class = typename _Mycomp::is_transparent>
; 1566 : 		const_iterator lower_bound(const _Other& _Keyval) const
; 1567 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1568 : 		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
; 1569 : 		}
; 1570 : 
; 1571 : 	iterator upper_bound(const key_type& _Keyval)
; 1572 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1573 : 		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1574 : 		}
; 1575 : 
; 1576 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1577 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1578 : 		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1579 : 		}
; 1580 : 
; 1581 : 	template<class _Other,
; 1582 : 		class _Mycomp = key_compare,
; 1583 : 		class = typename _Mycomp::is_transparent>
; 1584 : 		iterator upper_bound(const _Other& _Keyval)
; 1585 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1586 : 		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1587 : 		}
; 1588 : 
; 1589 : 	template<class _Other,
; 1590 : 		class _Mycomp = key_compare,
; 1591 : 		class = typename _Mycomp::is_transparent>
; 1592 : 		const_iterator upper_bound(const _Other& _Keyval) const
; 1593 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1594 : 		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
; 1595 : 		}
; 1596 : 
; 1597 : 	_Pairii equal_range(const key_type& _Keyval)
; 1598 : 		{	// find range equivalent to _Keyval in mutable tree
; 1599 : 		return (_Eqrange(_Keyval));
; 1600 : 		}
; 1601 : 
; 1602 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1603 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1604 : 		return (_Eqrange(_Keyval));
; 1605 : 		}
; 1606 : 
; 1607 : 	template<class _Other,
; 1608 : 		class _Mycomp = key_compare,
; 1609 : 		class = typename _Mycomp::is_transparent>
; 1610 : 		_Pairii equal_range(const _Other& _Keyval)
; 1611 : 		{	// find range equivalent to _Keyval in mutable tree
; 1612 : 		return (_Eqrange(_Keyval));
; 1613 : 		}
; 1614 : 
; 1615 : 	template<class _Other,
; 1616 : 		class _Mycomp = key_compare,
; 1617 : 		class = typename _Mycomp::is_transparent>
; 1618 : 		_Paircc equal_range(const _Other& _Keyval) const
; 1619 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1620 : 		return (_Eqrange(_Keyval));
; 1621 : 		}
; 1622 : 
; 1623 : 	void swap(_Myt& _Right)
; 1624 : 		{	// exchange contents with _Right
; 1625 : 		if (this == &_Right)
; 1626 : 			;	// same object, do nothing
; 1627 : 		else if (this->_Getal() == _Right._Getal())
; 1628 : 			{	// same allocator, swap control information
; 1629 : 			this->_Swap_all(_Right);
; 1630 : 			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
; 1631 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1632 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1633 : 			}
; 1634 : 
; 1635 : 		else if (_Alty::propagate_on_container_swap::value)
; 1636 : 			{	// swap allocators and control information
; 1637 : 			this->_Swap_alloc(_Right);
; 1638 : 			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
; 1639 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1640 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1641 : 			}
; 1642 : 
; 1643 : 		else
; 1644 : 			{	// containers are incompatible
; 1645 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1646 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1647 : 
; 1648 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1649 : 			_XSTD terminate();
; 1650 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : protected:
; 1655 : 	template<class _Valty>
; 1656 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1657 : 		{	// node exists, just return it
; 1658 : 		return (_Node);
; 1659 : 		}
; 1660 : 
; 1661 : 	template<class _Valty>
; 1662 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1663 : 		{	// node doesn't exist, make it
; 1664 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1665 : 		}
; 1666 : 
; 1667 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1668 : 		{	// node exists, destroy it
; 1669 : 		this->_Getal().destroy(
; 1670 : 			_STD addressof(this->_Myval(_Newnode)));
; 1671 : 
; 1672 : 		this->_Getal().deallocate(_Newnode, 1);
; 1673 : 		}
; 1674 : 
; 1675 : 	void _Destroy_if_not_nil(_Nil)
; 1676 : 		{	// node doesn't exist, do nothing
; 1677 : 		}
; 1678 : 
; 1679 : 	template<class _Valty,
; 1680 : 		class _Nodety>
; 1681 : 		iterator _Insert_hint(const_iterator _Where,
; 1682 : 			_Valty&& _Val, _Nodety _Newnode)
; 1683 : 		{	// try to insert node using _Where as a hint
; 1684 : 		const_iterator _Next;
; 1685 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1686 : 
; 1687 : 		_TRY_BEGIN
; 1688 : 
; 1689 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1690 : 		if (_Where._Getcont() != &this->_Get_data())
; 1691 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1692 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1693 : 
; 1694 : 		if (size() == 0)
; 1695 : 			return (_Insert_at(true, this->_Myhead(),
; 1696 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1697 : 		else if (this->_Multi)
; 1698 : 			{	// insert even if duplicate
; 1699 : 			if (_Where == begin())
; 1700 : 				{	// insert at beginning if before first element
; 1701 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1702 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1703 : 					return (_Insert_at(true, _Where._Mynode(),
; 1704 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1705 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1706 : 				}
; 1707 : 			else if (_Where == end())
; 1708 : 				{	// insert at end if after last element
; 1709 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1710 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1711 : 					return (_Insert_at(false, _Rmost(),
; 1712 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1713 : 				}
; 1714 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1715 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1716 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1717 : 					this->_Kfn(_Val),
; 1718 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1719 : 				{	// insert before _Where
; 1720 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1721 : 					return (_Insert_at(false, _Next._Mynode(),
; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				else
; 1724 : 					return (_Insert_at(true, _Where._Mynode(),
; 1725 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1726 : 				}
; 1727 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1729 : 				&& (++(_Next = _Where) == end()
; 1730 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1732 : 				{	// insert after _Where
; 1733 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1734 : 					return (_Insert_at(false, _Where._Mynode(),
; 1735 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1736 : 				else
; 1737 : 					return (_Insert_at(true, _Next._Mynode(),
; 1738 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1739 : 				}
; 1740 : 			else
; 1741 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1742 : 			}
; 1743 : 		else
; 1744 : 			{	// insert only if unique
; 1745 : 			if (_Where == begin())
; 1746 : 				{	// insert at beginning if before first element
; 1747 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_Where == end())
; 1753 : 				{	// insert at end if after last element
; 1754 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1755 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1756 : 					return (_Insert_at(false, _Rmost(),
; 1757 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1758 : 				}
; 1759 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1760 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1761 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1762 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1763 : 					this->_Kfn(_Val)))
; 1764 : 				{	// insert before _Where
; 1765 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1766 : 					return (_Insert_at(false, _Next._Mynode(),
; 1767 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1768 : 				else
; 1769 : 					return (_Insert_at(true, _Where._Mynode(),
; 1770 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1771 : 				}
; 1772 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1773 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1774 : 				&& (++(_Next = _Where) == end()
; 1775 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1776 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1777 : 				{	// insert after _Where
; 1778 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1779 : 					return (_Insert_at(false, _Where._Mynode(),
; 1780 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1781 : 				else
; 1782 : 					return (_Insert_at(true, _Next._Mynode(),
; 1783 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1784 : 				}
; 1785 : 			}
; 1786 : 		_CATCH_ALL
; 1787 : 		_Destroy_if_not_nil(_Newnode);
; 1788 : 		_RERAISE;
; 1789 : 		_CATCH_END
; 1790 : 
; 1791 : 		return (_Insert_nohint(_Leftish,
; 1792 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1793 : 		}
; 1794 : 
; 1795 : 	template<class _Valty,
; 1796 : 		class _Nodety>
; 1797 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1798 : 			_Valty&& _Val, _Nodety _Newnode)
; 1799 : 		{	// try to insert node, on left if _Leftish
; 1800 : 		_TRY_BEGIN
; 1801 : 		_Nodeptr _Trynode = _Root();
; 1802 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1803 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1804 : 
; 1805 : 		while (!this->_Isnil(_Trynode))
; 1806 : 			{	// look for leaf to insert before (_Addleft) or after
; 1807 : 			_Wherenode = _Trynode;
; 1808 : 			if (_Leftish)
; 1809 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1810 : 					this->_Key(_Trynode),
; 1811 : 					this->_Kfn(_Val));	// favor left end
; 1812 : 			else
; 1813 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1814 : 					this->_Kfn(_Val),
; 1815 : 					this->_Key(_Trynode));	// favor right end
; 1816 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1817 : 				: this->_Right(_Trynode);
; 1818 : 			}
; 1819 : 
; 1820 : 		if (this->_Multi)
; 1821 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1822 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1823 : 		else
; 1824 : 			{	// insert only if unique
; 1825 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1826 : 			if (!_Addleft)
; 1827 : 				;	// need to test if insert after is okay
; 1828 : 			else if (_Where == begin())
; 1829 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1830 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1831 : 			else
; 1832 : 				--_Where;	// need to test if insert before is okay
; 1833 : 
; 1834 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1835 : 				this->_Key(_Where._Mynode()),
; 1836 : 				this->_Kfn(_Val)))
; 1837 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1838 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1839 : 			else
; 1840 : 				{	// duplicate, don't insert
; 1841 : 				_Destroy_if_not_nil(_Newnode);
; 1842 : 				return (_Pairib(_Where, false));
; 1843 : 				}
; 1844 : 			}
; 1845 : 		_CATCH_ALL
; 1846 : 		_Destroy_if_not_nil(_Newnode);
; 1847 : 		_RERAISE;
; 1848 : 		_CATCH_END
; 1849 : 		}
; 1850 : 
; 1851 : 	template<class _Valty,
; 1852 : 		class _Nodety>
; 1853 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1854 : 		_Valty&& _Val, _Nodety _Node)
; 1855 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1856 : 		if (max_size() - 1 <= this->_Mysize())
; 1857 : 			{	// tree would get too big, fail
; 1858 : 			_Destroy_if_not_nil(_Node);
; 1859 : 			_Xlength_error("map/set<T> too long");
; 1860 : 			}
; 1861 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1862 : 			_STD forward<_Valty>(_Val));
; 1863 : 
; 1864 : 		++this->_Mysize();
; 1865 : 		_Newnode->_Parent = _Wherenode;
; 1866 : 
; 1867 : 		if (_Wherenode == this->_Myhead())
; 1868 : 			{	// first node in tree, just set head values
; 1869 : 			_Root() = _Newnode;
; 1870 : 			_Lmost() = _Newnode;
; 1871 : 			_Rmost() = _Newnode;
; 1872 : 			}
; 1873 : 		else if (_Addleft)
; 1874 : 			{	// add to left of _Wherenode
; 1875 : 			this->_Left(_Wherenode) = _Newnode;
; 1876 : 			if (_Wherenode == _Lmost())
; 1877 : 				_Lmost() = _Newnode;
; 1878 : 			}
; 1879 : 		else
; 1880 : 			{	// add to right of _Wherenode
; 1881 : 			this->_Right(_Wherenode) = _Newnode;
; 1882 : 			if (_Wherenode == _Rmost())
; 1883 : 				_Rmost() = _Newnode;
; 1884 : 			}
; 1885 : 
; 1886 : 		for (_Nodeptr _Pnode = _Newnode;
; 1887 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1888 : 			if (this->_Parent(_Pnode)
; 1889 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1890 : 				{	// fixup red-red in left subtree
; 1891 : 				_Wherenode =
; 1892 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1894 : 					{	// parent has two red children, blacken both
; 1895 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1896 : 					this->_Color(_Wherenode) = this->_Black;
; 1897 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1898 : 						= this->_Red;
; 1899 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1900 : 					}
; 1901 : 				else
; 1902 : 					{	// parent has red and black children
; 1903 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1904 : 						{	// rotate right child to left
; 1905 : 						_Pnode = this->_Parent(_Pnode);
; 1906 : 						_Lrotate(_Pnode);
; 1907 : 						}
; 1908 : 					this->_Color(this->_Parent(_Pnode)) =
; 1909 : 						this->_Black;	// propagate red up
; 1910 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1911 : 						this->_Red;
; 1912 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1913 : 					}
; 1914 : 				}
; 1915 : 			else
; 1916 : 				{	// fixup red-red in right subtree
; 1917 : 				_Wherenode =
; 1918 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1920 : 					{	// parent has two red children, blacken both
; 1921 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1922 : 					this->_Color(_Wherenode) = this->_Black;
; 1923 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1924 : 						this->_Red;
; 1925 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1926 : 					}
; 1927 : 				else
; 1928 : 					{	// parent has red and black children
; 1929 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1930 : 						{	// rotate left child to right
; 1931 : 						_Pnode = this->_Parent(_Pnode);
; 1932 : 						_Rrotate(_Pnode);
; 1933 : 						}
; 1934 : 					this->_Color(this->_Parent(_Pnode)) =
; 1935 : 						this->_Black;	// propagate red up
; 1936 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1937 : 						this->_Red;
; 1938 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1939 : 					}
; 1940 : 				}
; 1941 : 
; 1942 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1943 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1944 : 		}
; 1945 : 
; 1946 : 	template<class _Moveit>
; 1947 : 		void _Copy(const _Myt& _Right, _Moveit _Movefl)
; 1948 : 		{	// copy or move entire tree from _Right
; 1949 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);
; 1950 : 		this->_Mysize() = _Right.size();
; 1951 : 		if (!this->_Isnil(_Root()))
; 1952 : 			{	// nonempty tree, look for new smallest and largest
; 1953 : 			_Lmost() = this->_Min(_Root());
; 1954 : 			_Rmost() = this->_Max(_Root());
; 1955 : 			}
; 1956 : 		else
; 1957 : 			{	// empty tree, just tidy head pointers
; 1958 : 			_Lmost() = this->_Myhead();
; 1959 : 			_Rmost() = this->_Myhead();
; 1960 : 			}
; 1961 : 		}
; 1962 : 
; 1963 : 	template<class _Ty,
; 1964 : 		class _Is_set>
; 1965 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
; 1966 : 		{	// copy to new node
; 1967 : 		return (this->_Buynode(_Val));
; 1968 : 		}
; 1969 : 
; 1970 : 	template<class _Ty>
; 1971 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
; 1972 : 		{	// move to new node -- set
; 1973 : 		return (this->_Buynode(_STD move(_Val)));
; 1974 : 		}
; 1975 : 
; 1976 : 	template<class _Ty>
; 1977 : 		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
; 1978 : 		{	// move to new node -- map
; 1979 : 		return (this->_Buynode(
; 1980 : 			_STD move(const_cast<key_type&>(_Val.first)),
; 1981 : 			_STD move(_Val.second)));
; 1982 : 		}
; 1983 : 
; 1984 : 	template<class _Moveit>
; 1985 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1986 : 			_Moveit _Movefl)
; 1987 : 		{	// copy entire subtree, recursively
; 1988 : 		_Nodeptr _Newroot = this->_Myhead();	// point at nil node
; 1989 : 
; 1990 : 		if (!this->_Isnil(_Rootnode))
; 1991 : 			{	// copy or move a node, then any subtrees
; 1992 : 			typename is_same<key_type, value_type>::type _Is_set;
; 1993 : 			_Nodeptr _Pnode = _Copy_or_move(
; 1994 : 				this->_Myval(_Rootnode), _Movefl, _Is_set);
; 1995 : 			_Pnode->_Parent = _Wherenode;
; 1996 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1997 : 			if (this->_Isnil(_Newroot))
; 1998 : 				_Newroot = _Pnode;	// memorize new root
; 1999 : 
; 2000 : 			_TRY_BEGIN
; 2001 : 			this->_Left(_Pnode) =
; 2002 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 2003 : 			this->_Right(_Pnode) =
; 2004 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 2005 : 			_CATCH_ALL
; 2006 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 2007 : 			_RERAISE;
; 2008 : 			_CATCH_END
; 2009 : 			}
; 2010 : 
; 2011 : 		return (_Newroot);	// return newly constructed tree
; 2012 : 		}
; 2013 : 
; 2014 : 	template<class _Other>
; 2015 : 		_Paircc _Eqrange(const _Other& _Keyval) const
; 2016 : 		{	// find leftmost node not less than _Keyval
; 2017 : 		_Nodeptr _Pnode = _Root();
; 2018 : 		_Nodeptr _Lonode = this->_Myhead();	// end() if search fails
; 2019 : 		_Nodeptr _Hinode = this->_Myhead();	// end() if search fails
; 2020 : 
; 2021 : 		while (!this->_Isnil(_Pnode))
; 2022 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2023 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2024 : 			else
; 2025 : 				{	// _Pnode not less than _Keyval, remember it
; 2026 : 				if (this->_Isnil(_Hinode)
; 2027 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2028 : 						this->_Key(_Pnode)))
; 2029 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2030 : 				_Lonode = _Pnode;
; 2031 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2032 : 				}
; 2033 : 
; 2034 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2035 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2036 : 		while (!this->_Isnil(_Pnode))
; 2037 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2038 : 				{	// _Pnode greater than _Keyval, remember it
; 2039 : 				_Hinode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 			else
; 2043 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2044 : 
; 2045 : 		const_iterator _First = const_iterator(_Lonode, &this->_Get_data());
; 2046 : 		const_iterator _Last = const_iterator(_Hinode, &this->_Get_data());
; 2047 : 		return (_Paircc(_First, _Last));
; 2048 : 		}
; 2049 : 
; 2050 : 	template<class _Other>
; 2051 : 		_Pairii _Eqrange(const _Other& _Keyval)
; 2052 : 		{	// find leftmost node not less than _Keyval
; 2053 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
; 2054 : 		iterator _First = iterator(_Ans.first._Ptr, &this->_Get_data());
; 2055 : 		iterator _Last = iterator(_Ans.second._Ptr, &this->_Get_data());
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;

  0002c	8b f3		 mov	 esi, ebx

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0002e	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  00032	75 1d		 jne	 SHORT $LN23@clear
$LL24@clear:

; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));

  00034	ff 76 08	 push	 DWORD PTR [esi+8]
  00037	8b cf		 mov	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 2065 : 			_Pnode = this->_Left(_Pnode);

  0003e	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00040	53		 push	 ebx
  00041	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00046	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00049	8b de		 mov	 ebx, esi
  0004b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004f	74 e3		 je	 SHORT $LL24@clear
$LN23@clear:

; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00051	8b 07		 mov	 eax, DWORD PTR [edi]

; 1478 : 		_Root() = this->_Myhead();

  00053	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1479 : 		_Lmost() = this->_Myhead();

  00056	8b 07		 mov	 eax, DWORD PTR [edi]
  00058	89 00		 mov	 DWORD PTR [eax], eax

; 593  : 		}
; 594  : 
; 595  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 596  : 		{	// return reference to right pointer in node
; 597  : 		return ((_Nodepref)_Pnode->_Right);

  0005a	8b 07		 mov	 eax, DWORD PTR [edi]

; 1480 : 		_Rmost() = this->_Myhead();

  0005c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1481 : 		this->_Mysize() = 0;

  0005f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1482 : 		}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1212 : 		return (this->_Getal().max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1213 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 1156 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1157 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1158 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 1146 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode
; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() != _Right._Getcont())
; 325  : 			{	// report error
; 326  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 327  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 			}
; 329  : 
; 330  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 331  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 332  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 333  : 
; 334  : 		return (this->_Ptr == _Right._Ptr);
; 335  : 		}
; 336  : 
; 337  : 	bool operator!=(const _Myiter& _Right) const
; 338  : 		{	// test for iterator inequality
; 339  : 		return (!(*this == _Right));
; 340  : 		}
; 341  : 	};
; 342  : 
; 343  : template<class _Mytree> inline
; 344  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 345  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 346  : 	{	// convert to unchecked
; 347  : 	return (_Iter._Unchecked());
; 348  : 	}
; 349  : 
; 350  : template<class _Mytree> inline
; 351  : 	_Tree_const_iterator<_Mytree>&
; 352  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 353  : 			typename _Tree_const_iterator<_Mytree>
; 354  : 				::_Unchecked_type _Right)
; 355  : 	{	// convert to checked
; 356  : 	return (_Iter._Rechecked(_Right));
; 357  : 	}
; 358  : 
; 359  : 	// TEMPLATE CLASS _Tree_iterator
; 360  : template<class _Mytree>
; 361  : 	class _Tree_iterator
; 362  : 		: public _Tree_const_iterator<_Mytree>
; 363  : 	{	// iterator for mutable tree
; 364  : public:
; 365  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 366  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 367  : 	typedef bidirectional_iterator_tag iterator_category;
; 368  : 
; 369  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 370  : 	typedef typename _Mytree::value_type value_type;
; 371  : 	typedef typename _Mytree::difference_type difference_type;
; 372  : 
; 373  : 	typedef typename _Mytree::pointer pointer;
; 374  : 	typedef typename _Mytree::reference reference;
; 375  : 
; 376  : 	_Tree_iterator()
; 377  : 		{	// construct with null node
; 378  : 		}
; 379  : 
; 380  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 381  : 		: _Mybase(_Pnode, _Plist)
; 382  : 		{	// construct with node pointer _Pnode
; 383  : 		}
; 384  : 
; 385  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 386  : 
; 387  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 388  : 		{	// reset from unchecked iterator
; 389  : 		this->_Ptr = _Right._Ptr;
; 390  : 		return (*this);
; 391  : 		}
; 392  : 
; 393  : 	_Unchecked_type _Unchecked() const
; 394  : 		{	// make an unchecked iterator
; 395  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 396  : 		}
; 397  : 
; 398  : 	reference operator*() const
; 399  : 		{	// return designated value
; 400  : 		return ((reference)**(_Mybase *)this);
; 401  : 		}
; 402  : 
; 403  : 	pointer operator->() const
; 404  : 		{	// return pointer to class object
; 405  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 406  : 		}
; 407  : 
; 408  : 	_Myiter& operator++()
; 409  : 		{	// preincrement
; 410  : 		++(*(_Mybase *)this);
; 411  : 		return (*this);
; 412  : 		}
; 413  : 
; 414  : 	_Myiter operator++(int)
; 415  : 		{	// postincrement
; 416  : 		_Myiter _Tmp = *this;
; 417  : 		++*this;
; 418  : 		return (_Tmp);
; 419  : 		}
; 420  : 
; 421  : 	_Myiter& operator--()
; 422  : 		{	// predecrement
; 423  : 		--(*(_Mybase *)this);
; 424  : 		return (*this);
; 425  : 		}
; 426  : 
; 427  : 	_Myiter operator--(int)
; 428  : 		{	// postdecrement
; 429  : 		_Myiter _Tmp = *this;
; 430  : 		--*this;
; 431  : 		return (_Tmp);
; 432  : 		}
; 433  : 	};
; 434  : 
; 435  : template<class _Mytree> inline
; 436  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 437  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 438  : 	{	// convert to unchecked
; 439  : 	return (_Iter._Unchecked());
; 440  : 	}
; 441  : 
; 442  : template<class _Mytree> inline
; 443  : 	_Tree_iterator<_Mytree>&
; 444  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 445  : 			typename _Tree_iterator<_Mytree>
; 446  : 				::_Unchecked_type _Right)
; 447  : 	{	// convert to checked
; 448  : 	return (_Iter._Rechecked(_Right));
; 449  : 	}
; 450  : 
; 451  : 		// tree TYPE WRAPPERS
; 452  : template<class _Value_type,
; 453  : 	class _Size_type,
; 454  : 	class _Difference_type,
; 455  : 	class _Pointer,
; 456  : 	class _Const_pointer,
; 457  : 	class _Reference,
; 458  : 	class _Const_reference,
; 459  : 	class _Nodeptr_type>
; 460  : 	struct _Tree_iter_types
; 461  : 	{	// wraps types needed by iterators
; 462  : 	typedef _Value_type value_type;
; 463  : 	typedef _Size_type size_type;
; 464  : 	typedef _Difference_type difference_type;
; 465  : 	typedef _Pointer pointer;
; 466  : 	typedef _Const_pointer const_pointer;
; 467  : 	typedef _Reference reference;
; 468  : 	typedef _Const_reference const_reference;
; 469  : 	typedef _Nodeptr_type _Nodeptr;
; 470  : 	};
; 471  : 
; 472  : template<class _Value_type,
; 473  : 	class _Voidptr>
; 474  : 	struct _Tree_node
; 475  : 		{	// tree node
; 476  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 477  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 478  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 479  : 		char _Color;	// _Red or _Black, _Black if head
; 480  : 		char _Isnil;	// true only if head (also nil) node
; 481  : 		_Value_type _Myval;	// the stored value, unused if head
; 482  : 
; 483  : 	private:
; 484  : 		_Tree_node& operator=(const _Tree_node&);
; 485  : 		};
; 486  : 
; 487  : template<class _Value_type>
; 488  : 	struct _Tree_node<_Value_type, void *>
; 489  : 		{	// tree node
; 490  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 491  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 492  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 493  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 494  : 		char _Color;	// _Red or _Black, _Black if head
; 495  : 		char _Isnil;	// true only if head (also nil) node
; 496  : 		_Value_type _Myval;	// the stored value, unused if head
; 497  : 
; 498  : 	private:
; 499  : 		_Tree_node& operator=(const _Tree_node&);
; 500  : 		};
; 501  : 
; 502  : template<class _Ty>
; 503  : 	struct _Tree_simple_types
; 504  : 		: public _Simple_types<_Ty>
; 505  : 	{	// wraps types needed by iterators
; 506  : 	typedef _Tree_node<_Ty, void *> _Node;
; 507  : 	typedef _Node *_Nodeptr;
; 508  : 	};
; 509  : 
; 510  : template<class _Ty,
; 511  : 	class _Alloc0>
; 512  : 	struct _Tree_base_types
; 513  : 	{	// types needed for a container base
; 514  : 	typedef _Alloc0 _Alloc;
; 515  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 516  : 
; 517  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 518  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 519  : 
; 520  : 
; 521  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 522  : 		_Voidptr;
; 523  : 	typedef _Tree_node<typename _Alty::value_type,
; 524  : 		_Voidptr> _Node;
; 525  : 
; 526  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 527  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 528  : 	typedef _Nodeptr& _Nodepref;
; 529  : 
; 530  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 531  : 		_Tree_simple_types<typename _Alty::value_type>,
; 532  : 		_Tree_iter_types<typename _Alty::value_type,
; 533  : 			typename _Alty::size_type,
; 534  : 			typename _Alty::difference_type,
; 535  : 			typename _Alty::pointer,
; 536  : 			typename _Alty::const_pointer,
; 537  : 			typename _Alty::reference,
; 538  : 			typename _Alty::const_reference,
; 539  : 			_Nodeptr> >::type
; 540  : 		_Val_types;
; 541  : 	};
; 542  : 
; 543  : 		// TEMPLATE CLASS _Tree_val
; 544  : template<class _Val_types>
; 545  : 	class _Tree_val
; 546  : 		: public _Container_base
; 547  : 	{	// base class for tree to hold data
; 548  : public:
; 549  : 	typedef _Tree_val<_Val_types> _Myt;
; 550  : 
; 551  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 552  : 	typedef _Nodeptr& _Nodepref;
; 553  : 
; 554  : 	typedef typename _Val_types::value_type value_type;
; 555  : 	typedef typename _Val_types::size_type size_type;
; 556  : 	typedef typename _Val_types::difference_type difference_type;
; 557  : 	typedef typename _Val_types::pointer pointer;
; 558  : 	typedef typename _Val_types::const_pointer const_pointer;
; 559  : 	typedef typename _Val_types::reference reference;
; 560  : 	typedef typename _Val_types::const_reference const_reference;
; 561  : 
; 562  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 563  : 	typedef _Tree_iterator<_Myt> iterator;
; 564  : 
; 565  : 	_Tree_val()
; 566  : 		{	// initialize data
; 567  : 		this->_Myhead = 0;
; 568  : 		this->_Mysize = 0;
; 569  : 		}
; 570  : 
; 571  : 	enum _Redbl
; 572  : 		{	// colors for link to parent
; 573  : 		_Red, _Black};
; 574  : 
; 575  : 	static char& _Color(_Nodeptr _Pnode)
; 576  : 		{	// return reference to color in node
; 577  : 		return ((char&)_Pnode->_Color);
; 578  : 		}
; 579  : 
; 580  : 	static char& _Isnil(_Nodeptr _Pnode)
; 581  : 		{	// return reference to nil flag in node
; 582  : 		return ((char&)_Pnode->_Isnil);
; 583  : 		}
; 584  : 
; 585  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 586  : 		{	// return reference to left pointer in node
; 587  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1147 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1148 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Max, COMDAT

; 606  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 582  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 607  : 		while (!_Isnil(_Right(_Pnode)))

  00009	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000d	75 0c		 jne	 SHORT $LN15@Max
  0000f	90		 npad	 1
$LL2@Max:

; 608  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 582  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 607  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 609  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 610  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Myval, COMDAT

; 601  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 602  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 603  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Right, COMDAT

; 596  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 597  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 598  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Parent, COMDAT

; 591  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 593  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Left, COMDAT

; 586  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 587  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 588  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Isnil, COMDAT

; 581  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 582  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 583  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Color, COMDAT

; 576  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 577  : 		return ((char&)_Pnode->_Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 578  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 948  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 949  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 943  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 944  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 938  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 939  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 933  : 		return (_Mypair._Get_second()._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 934  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 928  : 		return (_Mypair._Get_second()._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 929  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 923  : 		return (_Mypair._Get_second()._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 924  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 918  : 		return (_Mypair._Get_second()._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 919  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$less@H@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 913  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 914  : 		}

  00002	c3		 ret	 0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAU?$less@H@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAU?$less@H@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 908  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 909  : 		}

  00002	c3		 ret	 0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEAAU?$less@H@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Freenode0, COMDAT
; _this$ = ecx

; 875  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 883  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 856  : 		{	// allocate a non-value node

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00001	6a 18		 push	 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 856  : 		{	// allocate a non-value node

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	8b d0		 mov	 edx, eax
  0000c	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0000f	85 d2		 test	 edx, edx
  00011	74 1e		 je	 SHORT $LN208@Buynode0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00015	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 04		 je	 SHORT $LN126@Buynode0
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	89 01		 mov	 DWORD PTR [ecx], eax
$LN126@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 597  : 		return ((_Nodepref)_Pnode->_Right);

  00022	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	85 c9		 test	 ecx, ecx
  00027	74 04		 je	 SHORT $LN176@Buynode0
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$LN176@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 871  : 		return (_Pnode);

  0002d	8b c2		 mov	 eax, edx
  0002f	5e		 pop	 esi

; 872  : 		}

  00030	c3		 ret	 0
$LN208@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN210@Buynode0:
$LN207@Buynode0:
  00036	cc		 int	 3
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval, COMDAT

; 686  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 602  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 687  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 688  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right, COMDAT

; 681  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 597  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 682  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 683  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent, COMDAT

; 676  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 592  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 677  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 678  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left, COMDAT

; 671  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 672  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 673  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil, COMDAT

; 666  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 582  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 667  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 668  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color, COMDAT

; 661  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 577  : 		return ((char&)_Pnode->_Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 662  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 663  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00013	77 3f		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00018	c1 e0 03	 shl	 eax, 3

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0000e	77 34		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00013	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 639  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 239  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 240  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8b 10		 mov	 edx, DWORD PTR [eax]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000f	0f 9c c0	 setl	 al

; 241  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);
; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000e	83 c4 04	 add	 esp, 4

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00014	51		 push	 ecx
  00015	6a 00		 push	 0
  00017	56		 push	 esi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	5e		 pop	 esi

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 640  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 733  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monstersetbase.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 733  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
