; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\MapClass.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?VerifyThatOnPath@PATH@@AAEHHH@Z		; PATH::VerifyThatOnPath
PUBLIC	?FindNextDir@PATH@@AAEHHHHHH_N0@Z		; PATH::FindNextDir
PUBLIC	?FindNextDir2@PATH@@AAEHHHHHH_N0@Z		; PATH::FindNextDir2
PUBLIC	?FindNextDir3@PATH@@AAEHHHHHH_N0@Z		; PATH::FindNextDir3
PUBLIC	?FindPath@PATH@@QAE_NHHHH_N@Z			; PATH::FindPath
PUBLIC	?FindPath2@PATH@@QAE_NHHHH_N@Z			; PATH::FindPath2
PUBLIC	?FindPath3@PATH@@QAE_NHHHH_N@Z			; PATH::FindPath3
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?SaveItemInfo@MapClass@@QAEXXZ			; MapClass::SaveItemInfo
PUBLIC	?GetLevelPos@MapClass@@QAEXAAE0@Z		; MapClass::GetLevelPos
PUBLIC	?GetMapPos@MapClass@@QAEXAAE0@Z			; MapClass::GetMapPos
PUBLIC	?GetRandomLengthPos@MapClass@@QAEXAAE0H@Z	; MapClass::GetRandomLengthPos
PUBLIC	?SearchStandAttr@MapClass@@QAEXAAE0@Z		; MapClass::SearchStandAttr
PUBLIC	?AttrLoad@MapClass@@QAEHPAD@Z			; MapClass::AttrLoad
PUBLIC	?LoadMapAttr@MapClass@@QAEXPADH@Z		; MapClass::LoadMapAttr
PUBLIC	?CheckWall@MapClass@@QAEHHHHH@Z			; MapClass::CheckWall
PUBLIC	?CheckWall2@MapClass@@QAEEHHHH@Z		; MapClass::CheckWall2
PUBLIC	?ItemInit@MapClass@@QAEXXZ			; MapClass::ItemInit
PUBLIC	?ItemGive@MapClass@@QAEHHH_N@Z			; MapClass::ItemGive
PUBLIC	?ClearItem@MapClass@@QAEHPAUOBJECTSTRUCT@@H@Z	; MapClass::ClearItem
PUBLIC	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z	; MapClass::ItemDrop
PUBLIC	?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEPAEE@Z ; MapClass::MonsterItemDrop
PUBLIC	?MoneyItemDrop@MapClass@@QAEHHHH@Z		; MapClass::MoneyItemDrop
PUBLIC	?WeatherVariationProcess@MapClass@@QAEXXZ	; MapClass::WeatherVariationProcess
PUBLIC	?GetWeather@MapClass@@QAEEXZ			; MapClass::GetWeather
PUBLIC	?SetWeather@MapClass@@QAEXEE@Z			; MapClass::SetWeather
PUBLIC	?StateSetDestroy@MapClass@@QAEXXZ		; MapClass::StateSetDestroy
PUBLIC	?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z	; MapClass::PathFinding2
PUBLIC	?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z	; MapClass::PathFinding3
PUBLIC	?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z	; MapClass::PathFinding4
PUBLIC	?SetStandAttr@MapClass@@QAEXHH@Z		; MapClass::SetStandAttr
PUBLIC	?ClearStandAttr@MapClass@@QAEXHH@Z		; MapClass::ClearStandAttr
PUBLIC	?GetStandAttr@MapClass@@QAEHHH@Z		; MapClass::GetStandAttr
PUBLIC	?GetAttr@MapClass@@QAEEHH@Z			; MapClass::GetAttr
PUBLIC	?SetRegentRect@MapClass@@QAEXH@Z		; MapClass::SetRegentRect
PUBLIC	?init@MapClass@@QAEXXZ				; MapClass::init
PUBLIC	??0MapClass@@QAE@XZ				; MapClass::MapClass
PUBLIC	??1MapClass@@UAE@XZ				; MapClass::~MapClass
PUBLIC	??_GMapClass@@UAEPAXI@Z				; MapClass::`scalar deleting destructor'
PUBLIC	?MapNumberCheck@@YAHH@Z				; MapNumberCheck
PUBLIC	??0MapAttribute@@QAE@XZ				; MapAttribute::MapAttribute
PUBLIC	??1MapAttribute@@QAE@XZ				; MapAttribute::~MapAttribute
PUBLIC	?Init@MapAttribute@@QAEXXZ			; MapAttribute::Init
PUBLIC	?Load@MapAttribute@@QAEXXZ			; MapAttribute::Load
PUBLIC	?Read@MapAttribute@@QAEXPAD@Z			; MapAttribute::Read
PUBLIC	?GetFile@MapAttribute@@QAEPADHE@Z		; MapAttribute::GetFile
PUBLIC	?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::deallocate
PUBLIC	?allocate@?$allocator@UMapAttrInfo@@@std@@QAEPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::allocate
PUBLIC	?push_back@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXABUMapAttrInfo@@@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::push_back
PUBLIC	?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reserve
PUBLIC	?TERRAIN_INDEX_REPEAT@@YAHHH@Z			; TERRAIN_INDEX_REPEAT
PUBLIC	??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::allocator<MapAttrInfo>,MapAttrInfo>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7MapClass@@6B@				; MapClass::`vftable'
PUBLIC	?g_MapAttrInfo@@3VMapAttribute@@A		; g_MapAttrInfo
PUBLIC	??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@		; `string'
PUBLIC	??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BH@JNEGMM@World?2MapAttribute?4xml?$AA@	; `string'
PUBLIC	??_C@_0CB@HFCBCMHL@?$FLMapAttribute?$FN?5Loading?5fail?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0N@OPJMKHEJ@mapattribute?$AA@		; `string'
PUBLIC	??_C@_06IKLLLDHL@normal?$AA@			; `string'
PUBLIC	??_C@_05GFHEIIDD@event?$AA@			; `string'
PUBLIC	??_C@_07JBFDOFDL@terrain?$AA@			; `string'
PUBLIC	??_C@_03HBNNNHNM@map?$AA@			; `string'
PUBLIC	??_C@_0CH@FPNPGDOD@?$FLMapAttribute?$FN?5Invalid?5map?5numbe@ ; `string'
PUBLIC	??_C@_0P@GPLLIGLO@World?2Terrain?2?$AA@		; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_05HDBKIDE@state?$AA@			; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4MapClass@@6B@				; MapClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMapClass@@@8				; MapClass `RTTI Type Descriptor'
PUBLIC	??_R3MapClass@@8				; MapClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MapClass@@8				; MapClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MapClass@@8			; MapClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@0000000000000001ffffffff00000001
PUBLIC	__xmm@00000000ffffffff00000001ffffffff
PUBLIC	__xmm@00000001000000000000000100000001
PUBLIC	__xmm@ffffffff00000000ffffffffffffffff
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_rand:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?CGWeatherSend@@YAXHE@Z:PROC			; CGWeatherSend
EXTRN	??0CMapItem@@QAE@XZ:PROC			; CMapItem::CMapItem
EXTRN	??1CMapItem@@UAE@XZ:PROC			; CMapItem::~CMapItem
EXTRN	?CreateItem@CMapItem@@QAEXHHHHMEEEEEKEPAEE@Z:PROC ; CMapItem::CreateItem
EXTRN	?DropCreateItem@CMapItem@@QAEXHHHHMEEEEEKHHEPAEE@Z:PROC ; CMapItem::DropCreateItem
EXTRN	??_EMapClass@@UAEPAXI@Z:PROC			; MapClass::`vector deleting destructor'
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?GetBridgeLevel@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetBridgeLevel
EXTRN	?SetStatueTime@CIllusionTempleEvent@@QAEXE@Z:PROC ; CIllusionTempleEvent::SetStatueTime
EXTRN	?as_int@xml_attribute@pugi@@QBEHH@Z:PROC	; pugi::xml_attribute::as_int
EXTRN	??0xml_node@pugi@@QAE@XZ:PROC			; pugi::xml_node::xml_node
EXTRN	??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ:PROC	; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
EXTRN	?next_sibling@xml_node@pugi@@QBE?AV12@XZ:PROC	; pugi::xml_node::next_sibling
EXTRN	?text@xml_node@pugi@@QBE?AVxml_text@2@XZ:PROC	; pugi::xml_node::text
EXTRN	?child@xml_node@pugi@@QBE?AV12@PBD@Z:PROC	; pugi::xml_node::child
EXTRN	?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z:PROC ; pugi::xml_node::attribute
EXTRN	?as_string@xml_text@pugi@@QBEPBDPBD@Z:PROC	; pugi::xml_text::as_string
EXTRN	??0xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::xml_document
EXTRN	??1xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::~xml_document
EXTRN	?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z:PROC ; pugi::xml_document::load_file
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__except_handler4:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?gLootingTime@@3HA:DWORD			; gLootingTime
EXTRN	?gZenDurationTime@@3HA:DWORD			; gZenDurationTime
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_MapAttrInfo@@3VMapAttribute@@A DB 0cH DUP (?)	; g_MapAttrInfo
_BSS	ENDS
CRT$XCU	SEGMENT
?g_MapAttrInfo$initializer$@@3P6AXXZA DD FLAT:??__Eg_MapAttrInfo@@YAXXZ ; g_MapAttrInfo$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@ffffffff00000000ffffffffffffffff
CONST	SEGMENT
__xmm@ffffffff00000000ffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 00H, 00H, 00H, 00H, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __xmm@00000001000000000000000100000001
CONST	SEGMENT
__xmm@00000001000000000000000100000001 DB 01H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000ffffffff00000001ffffffff
CONST	SEGMENT
__xmm@00000000ffffffff00000001ffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 01H, 00H
	DB	00H, 00H, 0ffH, 0ffH, 0ffH, 0ffH, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000000000001ffffffff00000001
CONST	SEGMENT
__xmm@0000000000000001ffffffff00000001 DB 01H, 00H, 00H, 00H, 0ffH, 0ffH, 0ffH
	DB	0ffH, 01H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@MapClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MapClass@@8 DD FLAT:??_R0?AVMapClass@@@8	; MapClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MapClass@@8
rdata$r	ENDS
;	COMDAT ??_R2MapClass@@8
rdata$r	SEGMENT
??_R2MapClass@@8 DD FLAT:??_R1A@?0A@EA@MapClass@@8	; MapClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MapClass@@8
rdata$r	SEGMENT
??_R3MapClass@@8 DD 00H					; MapClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MapClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMapClass@@@8
data$r	SEGMENT
??_R0?AVMapClass@@@8 DD FLAT:??_7type_info@@6B@		; MapClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMapClass@@', 00H
data$r	ENDS
;	COMDAT ??_R4MapClass@@6B@
rdata$r	SEGMENT
??_R4MapClass@@6B@ DD 00H				; MapClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMapClass@@@8
	DD	FLAT:??_R3MapClass@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDBKIDE@state?$AA@
CONST	SEGMENT
??_C@_05HDBKIDE@state?$AA@ DB 'state', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GPLLIGLO@World?2Terrain?2?$AA@
CONST	SEGMENT
??_C@_0P@GPLLIGLO@World?2Terrain?2?$AA@ DB 'World\Terrain\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FPNPGDOD@?$FLMapAttribute?$FN?5Invalid?5map?5numbe@
CONST	SEGMENT
??_C@_0CH@FPNPGDOD@?$FLMapAttribute?$FN?5Invalid?5map?5numbe@ DB '[MapAtt'
	DB	'ribute] Invalid map number (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map?$AA@
CONST	SEGMENT
??_C@_03HBNNNHNM@map?$AA@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JBFDOFDL@terrain?$AA@
CONST	SEGMENT
??_C@_07JBFDOFDL@terrain?$AA@ DB 'terrain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFHEIIDD@event?$AA@
CONST	SEGMENT
??_C@_05GFHEIIDD@event?$AA@ DB 'event', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT
??_C@_06IKLLLDHL@normal?$AA@ DB 'normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OPJMKHEJ@mapattribute?$AA@
CONST	SEGMENT
??_C@_0N@OPJMKHEJ@mapattribute?$AA@ DB 'mapattribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HFCBCMHL@?$FLMapAttribute?$FN?5Loading?5fail?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CB@HFCBCMHL@?$FLMapAttribute?$FN?5Loading?5fail?5?$FL?$CFs?$FN@ DB '['
	DB	'MapAttribute] Loading fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNEGMM@World?2MapAttribute?4xml?$AA@
CONST	SEGMENT
??_C@_0BH@JNEGMM@World?2MapAttribute?4xml?$AA@ DB 'World\MapAttribute.xml'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) Dropped Angel King'''
	DB	's Weapon (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@
CONST	SEGMENT
??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@ DB 'MapClass.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7MapClass@@6B@
CONST	SEGMENT
??_7MapClass@@6B@ DD FLAT:??_R4MapClass@@6B@		; MapClass::`vftable'
	DD	FLAT:??_EMapClass@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z$50 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z$50
__ehfuncinfo$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Read@MapAttribute@@QAEXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@MapAttribute@@QAEXPAD@Z$0
__ehfuncinfo$?Read@MapAttribute@@QAEXPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@MapAttribute@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MapClass@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MapClass@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MapClass@@QAE@XZ$0
__ehfuncinfo$??0MapClass@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MapClass@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetMapPos@MapClass@@QAEXAAE0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetMapPos
	DD	FLAT:$LN9@GetMapPos
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetLevelPos@MapClass@@QAEXAAE0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetLevelPo
	DD	FLAT:$LN9@GetLevelPo
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@U1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UMapAttrInfo@@U1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@$$QAU2@@Z PROC ; std::allocator<MapAttrInfo>::construct<MapAttrInfo,MapAttrInfo>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct:
  00017	5f		 pop	 edi

; 656  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@UMapAttrInfo@@U1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@$$QAU2@@Z ENDP ; std::allocator<MapAttrInfo>::construct<MapAttrInfo,MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@U1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UMapAttrInfo@@U1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN8@construct
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN8@construct:
  00017	5f		 pop	 edi

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@UMapAttrInfo@@U1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UMapAttrInfo@@@std@@YA$$QAUMapAttrInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UMapAttrInfo@@@std@@YA$$QAUMapAttrInfo@@AAU1@@Z PROC ; std::forward<MapAttrInfo>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UMapAttrInfo@@@std@@YA$$QAUMapAttrInfo@@AAU1@@Z ENDP ; std::forward<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@U1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UMapAttrInfo@@U1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN13@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN13@construct:
  00017	5f		 pop	 edi

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@UMapAttrInfo@@U1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UMapAttrInfo@@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UMapAttrInfo@@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@@Z PROC ; std::allocator<MapAttrInfo>::destroy<MapAttrInfo>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UMapAttrInfo@@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@@Z ENDP ; std::allocator<MapAttrInfo>::destroy<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::allocator<MapAttrInfo>,MapAttrInfo>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 22		 je	 SHORT $LN3@Uninit_mov
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL4@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	85 c0		 test	 eax, eax
  00015	74 0b		 je	 SHORT $LN2@Uninit_mov
  00017	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  0001c	8b f2		 mov	 esi, edx
  0001e	8b f8		 mov	 edi, eax
  00020	f3 a5		 rep movsd
$LN2@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00022	81 c2 0c 01 00
	00		 add	 edx, 268		; 0000010cH
  00028	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  0002d	3b d3		 cmp	 edx, ebx
  0002f	75 e2		 jne	 SHORT $LL4@Uninit_mov
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
$LN3@Uninit_mov:
  00033	5b		 pop	 ebx

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);
; 450  : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::allocator<MapAttrInfo>,MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUMapAttrInfo@@@std@@YAPAUMapAttrInfo@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUMapAttrInfo@@@std@@YAPAUMapAttrInfo@@PAU1@@Z PROC ; std::_Val_type<MapAttrInfo *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUMapAttrInfo@@@std@@YAPAUMapAttrInfo@@PAU1@@Z ENDP ; std::_Val_type<MapAttrInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UMapAttrInfo@@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UMapAttrInfo@@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@@Z PROC ; std::allocator_traits<std::allocator<MapAttrInfo> >::destroy<MapAttrInfo>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@UMapAttrInfo@@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@@Z ENDP ; std::allocator_traits<std::allocator<MapAttrInfo> >::destroy<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UMapAttrInfo@@@std@@YAPAUMapAttrInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UMapAttrInfo@@@std@@YAPAUMapAttrInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<MapAttrInfo>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UMapAttrInfo@@@std@@YAPAUMapAttrInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUMapAttrInfo@@PAU1@@std@@YAAAPAUMapAttrInfo@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUMapAttrInfo@@PAU1@@std@@YAAAPAUMapAttrInfo@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<MapAttrInfo *,MapAttrInfo *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUMapAttrInfo@@PAU1@@std@@YAAAPAUMapAttrInfo@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<MapAttrInfo *,MapAttrInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUMapAttrInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUMapAttrInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z PROC ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::_Wrap_alloc<std::allocator<MapAttrInfo> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::allocator<MapAttrInfo>,MapAttrInfo>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUMapAttrInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z ENDP ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::_Wrap_alloc<std::allocator<MapAttrInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUMapAttrInfo@@@std@@YAPAUMapAttrInfo@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUMapAttrInfo@@@std@@YAPAUMapAttrInfo@@PAU1@@Z PROC ; std::_Unchecked<MapAttrInfo *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUMapAttrInfo@@@std@@YAPAUMapAttrInfo@@PAU1@@Z ENDP ; std::_Unchecked<MapAttrInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UMapAttrInfo@@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UMapAttrInfo@@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::destroy<MapAttrInfo>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UMapAttrInfo@@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::destroy<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UMapAttrInfo@@@std@@YAPAUMapAttrInfo@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UMapAttrInfo@@@std@@YAPAUMapAttrInfo@@AAU1@@Z PROC ; std::addressof<MapAttrInfo>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UMapAttrInfo@@@std@@YAPAUMapAttrInfo@@AAU1@@Z ENDP ; std::addressof<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@ABU1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UMapAttrInfo@@ABU1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@ABU2@@Z PROC ; std::allocator<MapAttrInfo>::construct<MapAttrInfo,MapAttrInfo const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct:
  00017	5f		 pop	 edi

; 656  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@UMapAttrInfo@@ABU1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@ABU2@@Z ENDP ; std::allocator<MapAttrInfo>::construct<MapAttrInfo,MapAttrInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@AAU1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UMapAttrInfo@@AAU1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@AAU2@@Z PROC ; std::allocator<MapAttrInfo>::construct<MapAttrInfo,MapAttrInfo &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct:
  00017	5f		 pop	 edi

; 656  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@UMapAttrInfo@@AAU1@@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@AAU2@@Z ENDP ; std::allocator<MapAttrInfo>::construct<MapAttrInfo,MapAttrInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUMapAttrInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUMapAttrInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z PROC ; std::_Uninitialized_move<MapAttrInfo *,MapAttrInfo *,std::_Wrap_alloc<std::allocator<MapAttrInfo> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::allocator<MapAttrInfo>,MapAttrInfo>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUMapAttrInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<MapAttrInfo *,MapAttrInfo *,std::_Wrap_alloc<std::allocator<MapAttrInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAXPAUMapAttrInfo@@0AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAXPAUMapAttrInfo@@0AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MapAttrInfo> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAXPAUMapAttrInfo@@0AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MapAttrInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UMapAttrInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMapAttrInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UMapAttrInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMapAttrInfo@@0@Z PROC ; std::_Ptr_cat<MapAttrInfo,MapAttrInfo>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UMapAttrInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMapAttrInfo@@0@Z ENDP ; std::_Ptr_cat<MapAttrInfo,MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UMapAttrInfo@@@std@@@std@@YAABV?$allocator@UMapAttrInfo@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UMapAttrInfo@@@std@@@std@@YAABV?$allocator@UMapAttrInfo@@@0@ABV10@@Z PROC ; std::forward<std::allocator<MapAttrInfo> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UMapAttrInfo@@@std@@@std@@YAABV?$allocator@UMapAttrInfo@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<MapAttrInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@ABU1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UMapAttrInfo@@ABU1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN8@construct
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN8@construct:
  00017	5f		 pop	 edi

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@UMapAttrInfo@@ABU1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUMapAttrInfo@@@std@@YAABUMapAttrInfo@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUMapAttrInfo@@@std@@YAABUMapAttrInfo@@ABU1@@Z PROC ; std::forward<MapAttrInfo const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUMapAttrInfo@@@std@@YAABUMapAttrInfo@@ABU1@@Z ENDP ; std::forward<MapAttrInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@AAU1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UMapAttrInfo@@AAU1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN8@construct
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN8@construct:
  00017	5f		 pop	 edi

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@UMapAttrInfo@@AAU1@@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAXAAV?$allocator@UMapAttrInfo@@@1@PAUMapAttrInfo@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUMapAttrInfo@@@std@@YAAAUMapAttrInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUMapAttrInfo@@@std@@YAAAUMapAttrInfo@@AAU1@@Z PROC ; std::forward<MapAttrInfo &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUMapAttrInfo@@@std@@YAAAUMapAttrInfo@@AAU1@@Z ENDP ; std::forward<MapAttrInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBUMapAttrInfo@@@std@@YAPBUMapAttrInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBUMapAttrInfo@@@std@@YAPBUMapAttrInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<MapAttrInfo const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBUMapAttrInfo@@@std@@YAPBUMapAttrInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<MapAttrInfo const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUMapAttrInfo@@@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEPAUMapAttrInfo@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUMapAttrInfo@@@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEPAUMapAttrInfo@@PAU2@00@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Umove<MapAttrInfo *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::allocator<MapAttrInfo>,MapAttrInfo>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUMapAttrInfo@@@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEPAUMapAttrInfo@@PAU2@00@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Umove<MapAttrInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAXPAUMapAttrInfo@@0AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAXPAUMapAttrInfo@@0AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MapAttrInfo> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@YAXPAUMapAttrInfo@@0AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MapAttrInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UMapAttrInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UMapAttrInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UMapAttrInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UMapAttrInfo@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1><std::allocator<MapAttrInfo> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UMapAttrInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UMapAttrInfo@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1><std::allocator<MapAttrInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UMapAttrInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN13@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN13@construct:
  00017	5f		 pop	 edi

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@UMapAttrInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UMapAttrInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UMapAttrInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN13@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN13@construct:
  00017	5f		 pop	 edi

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@UMapAttrInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::construct<MapAttrInfo,MapAttrInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUMapAttrInfo@@@std@@YAPBUMapAttrInfo@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUMapAttrInfo@@@std@@YAPBUMapAttrInfo@@ABU1@@Z PROC ; std::addressof<MapAttrInfo const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUMapAttrInfo@@@std@@YAPBUMapAttrInfo@@ABU1@@Z ENDP ; std::addressof<MapAttrInfo const >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_MapAttrInfo@@YAXXZ
text$yd	SEGMENT
??__Fg_MapAttrInfo@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MapAttrInfo'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapAttrInfo@@3VMapAttribute@@A ; g_MapAttrInfo
  00005	e9 00 00 00 00	 jmp	 ??1MapAttribute@@QAE@XZ	; MapAttribute::~MapAttribute
??__Fg_MapAttrInfo@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MapAttrInfo''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ??__Eg_MapAttrInfo@@YAXXZ
text$di	SEGMENT
??__Eg_MapAttrInfo@@YAXXZ PROC				; `dynamic initializer for 'g_MapAttrInfo'', COMDAT

; 1175 : MapAttribute g_MapAttrInfo;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapAttrInfo@@3VMapAttribute@@A ; g_MapAttrInfo
  00005	e8 00 00 00 00	 call	 ??0MapAttribute@@QAE@XZ	; MapAttribute::MapAttribute
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_MapAttrInfo@@YAXXZ ; `dynamic atexit destructor for 'g_MapAttrInfo''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_MapAttrInfo@@YAXXZ ENDP				; `dynamic initializer for 'g_MapAttrInfo''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?TERRAIN_INDEX_REPEAT@@YAHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?TERRAIN_INDEX_REPEAT@@YAHHH@Z PROC			; TERRAIN_INDEX_REPEAT, COMDAT

; 1008 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1009 : 	return (BYTE)y * 256 + (BYTE)x;

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _y$[ebp]
  00007	0f b6 4d 08	 movzx	 ecx, BYTE PTR _x$[ebp]
  0000b	c1 e0 08	 shl	 eax, 8
  0000e	03 c1		 add	 eax, ecx

; 1010 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?TERRAIN_INDEX_REPEAT@@YAHHH@Z ENDP			; TERRAIN_INDEX_REPEAT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEXPAUMapAttrInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEXPAUMapAttrInfo@@0@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEXPAUMapAttrInfo@@0@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 33		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	c1 fa 03	 sar	 edx, 3
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00035	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0003c	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0003d	c3		 ret	 0
?_Tidy@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv202 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00006	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 1646 : 		if (_Unused_capacity() < _Count)

  0000d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00010	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00013	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	c1 fa 03	 sar	 edx, 3
  0001d	8b c2		 mov	 eax, edx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx

; 1646 : 		if (_Unused_capacity() < _Count)

  00024	3b c7		 cmp	 eax, edi
  00026	73 61		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00028	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002a	2b f0		 sub	 esi, eax
  0002c	89 45 08	 mov	 DWORD PTR tv202[ebp], eax
  0002f	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00034	f7 ee		 imul	 esi

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00036	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003b	c1 fa 03	 sar	 edx, 3
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00043	03 ca		 add	 ecx, edx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00045	2b c1		 sub	 eax, ecx
  00047	3b c7		 cmp	 eax, edi
  00049	72 45		 jb	 SHORT $LN134@Reserve

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	03 f9		 add	 edi, ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0004d	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00052	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00055	2b 4d 08	 sub	 ecx, DWORD PTR tv202[ebp]
  00058	f7 e9		 imul	 ecx
  0005a	c1 fa 03	 sar	 edx, 3
  0005d	8b f2		 mov	 esi, edx
  0005f	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00062	03 f2		 add	 esi, edx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00064	ba 8d 89 f4 00	 mov	 edx, 16025997		; 00f4898dH
  00069	8b c6		 mov	 eax, esi
  0006b	d1 e8		 shr	 eax, 1
  0006d	2b d0		 sub	 edx, eax
  0006f	3b d6		 cmp	 edx, esi
  00071	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00074	b8 00 00 00 00	 mov	 eax, 0
  00079	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  0007c	3b cf		 cmp	 ecx, edi
  0007e	0f 42 cf	 cmovb	 ecx, edi

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00081	51		 push	 ecx
  00082	8b cb		 mov	 ecx, ebx
  00084	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reallocate
$LN2@Reserve:
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1651 : 			}
; 1652 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  0009a	cc		 int	 3
?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UMapAttrInfo@@@std@@QAEPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	8b f8		 mov	 edi, eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00044	6a 00		 push	 0
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	ff 76 04	 push	 DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0004b	89 7d ec	 mov	 DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004e	ff 36		 push	 DWORD PTR [esi]
  00050	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUMapAttrInfo@@PAU1@V?$allocator@UMapAttrInfo@@@std@@U1@@std@@YAPAUMapAttrInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MapAttrInfo *,MapAttrInfo *,std::allocator<MapAttrInfo>,MapAttrInfo>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00055	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00058	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0005d	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0005f	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00062	f7 e9		 imul	 ecx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00064	8b 06		 mov	 eax, DWORD PTR [esi]

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00066	c1 fa 03	 sar	 edx, 3
  00069	8b da		 mov	 ebx, edx
  0006b	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0006e	03 da		 add	 ebx, edx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00070	85 c0		 test	 eax, eax
  00072	74 20		 je	 SHORT $LN3@Reallocate

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00074	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00077	2b c8		 sub	 ecx, eax
  00079	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0007e	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00080	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00082	c1 fa 03	 sar	 edx, 3
  00085	8b c2		 mov	 eax, edx
  00087	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0008c	50		 push	 eax
  0008d	ff 36		 push	 DWORD PTR [esi]
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1639 : 		this->_Myend() = _Ptr + _Count;

  00094	69 45 08 0c 01
	00 00		 imul	 eax, DWORD PTR __Count$[ebp], 268
  0009b	03 c7		 add	 eax, edi
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  000a0	69 c3 0c 01 00
	00		 imul	 eax, ebx, 268
  000a6	03 c7		 add	 eax, edi
  000a8	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  000ab	89 3e		 mov	 DWORD PTR [esi], edi

; 1642 : 		}

  000ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b7	59		 pop	 ecx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000c1	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000c4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000ca	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1627 : 		_RERAISE;

  000cf	6a 00		 push	 0
  000d1	6a 00		 push	 0
  000d3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN179@Reallocate:
$LN178@Reallocate:
  000d8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBE_NPBUMapAttrInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBE_NPBUMapAttrInfo@@@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBE_NPBUMapAttrInfo@@@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0000d	b9 8d 89 f4 00	 mov	 ecx, 16025997		; 00f4898dH

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00012	f7 ea		 imul	 edx
  00014	56		 push	 esi
  00015	c1 fa 03	 sar	 edx, 3
  00018	8b f2		 mov	 esi, edx
  0001a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001d	03 f2		 add	 esi, edx

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001f	8b c6		 mov	 eax, esi
  00021	d1 e8		 shr	 eax, 1
  00023	57		 push	 edi
  00024	2b c8		 sub	 ecx, eax
  00026	33 ff		 xor	 edi, edi
  00028	3b ce		 cmp	 ecx, esi
  0002a	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0002d	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00030	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00033	5f		 pop	 edi
  00034	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  00038	8b c2		 mov	 eax, edx
  0003a	5e		 pop	 esi

; 1612 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXPAUMapAttrInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXPAUMapAttrInfo@@0@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXPAUMapAttrInfo@@0@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1543 : 		}

  00005	c3		 ret	 0
?clear@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXABUMapAttrInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXABUMapAttrInfo@@@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	56		 push	 esi

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Val$[ebp]
  0000a	57		 push	 edi
  0000b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000e	3b f1		 cmp	 esi, ecx
  00010	73 38		 jae	 SHORT $LN2@push_back
  00012	8b 03		 mov	 eax, DWORD PTR [ebx]
  00014	3b c6		 cmp	 eax, esi
  00016	77 32		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00018	2b f0		 sub	 esi, eax
  0001a	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0001f	f7 ee		 imul	 esi
  00021	c1 fa 03	 sar	 edx, 3
  00024	8b f2		 mov	 esi, edx
  00026	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00029	03 f2		 add	 esi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  0002b	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  0002e	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  00030	6a 01		 push	 1
  00032	8b cb		 mov	 ecx, ebx
  00034	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00039	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0003c	85 ff		 test	 edi, edi
  0003e	74 26		 je	 SHORT $LN205@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00040	69 f6 0c 01 00
	00		 imul	 esi, esi, 268
  00046	03 33		 add	 esi, DWORD PTR [ebx]

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else

  00048	eb 15		 jmp	 SHORT $LN222@push_back
$LN2@push_back:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  0004a	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  0004d	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b cb		 mov	 ecx, ebx
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00058	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0005b	85 ff		 test	 edi, edi
  0005d	74 07		 je	 SHORT $LN205@push_back
$LN222@push_back:
  0005f	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00064	f3 a5		 rep movsd
$LN205@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00066	81 43 04 0c 01
	00 00		 add	 DWORD PTR [ebx+4], 268	; 0000010cH
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx

; 1293 : 			}
; 1294 : 		}

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
?push_back@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXABUMapAttrInfo@@@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEAAUMapAttrInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEAAUMapAttrInfo@@I@Z PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00003	69 45 08 0c 01
	00 00		 imul	 eax, DWORD PTR __Pos$[ebp], 268
  0000a	03 01		 add	 eax, DWORD PTR [ecx]

; 1241 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??A?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEAAUMapAttrInfo@@I@Z ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1180 : 		}

  00016	c3		 ret	 0
?size@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 03	 sar	 edx, 3
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx

; 1048 : 		}

  00017	c3		 ret	 0
?_Unused_capacity@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1043 : 		}

  00016	c3		 ret	 0
?capacity@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::~vector<MapAttrInfo,std::allocator<MapAttrInfo> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 33		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	c1 fa 03	 sar	 edx, 3
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00035	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0003c	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0003d	c3		 ret	 0
??1?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::~vector<MapAttrInfo,std::allocator<MapAttrInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::vector<MapAttrInfo,std::allocator<MapAttrInfo> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::vector<MapAttrInfo,std::allocator<MapAttrInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MapAttrInfo> >,std::_Vector_val<std::_Simple_types<MapAttrInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<MapAttrInfo> >::_Vector_val<std::_Simple_types<MapAttrInfo> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<MapAttrInfo> >::_Vector_val<std::_Simple_types<MapAttrInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABQAUMapAttrInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAPAUMapAttrInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UMapAttrInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UMapAttrInfo@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UMapAttrInfo@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >::_Vector_alloc<std::_Vec_base_types<MapAttrInfo,std::allocator<MapAttrInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXPAUMapAttrInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEPAUMapAttrInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEPAUMapAttrInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UMapAttrInfo@@@std@@QAEPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEPAUMapAttrInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@ABV?$allocator@UMapAttrInfo@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@ABV?$allocator@UMapAttrInfo@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::_Wrap_alloc<std::allocator<MapAttrInfo> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UMapAttrInfo@@@std@@@std@@QAE@ABV?$allocator@UMapAttrInfo@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<MapAttrInfo> >::_Wrap_alloc<std::allocator<MapAttrInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAIABV?$allocator@UMapAttrInfo@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAIABV?$allocator@UMapAttrInfo@@@2@@Z PROC ; std::allocator_traits<std::allocator<MapAttrInfo> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UMapAttrInfo@@@std@@@std@@SAIABV?$allocator@UMapAttrInfo@@@2@@Z ENDP ; std::allocator_traits<std::allocator<MapAttrInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UMapAttrInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UMapAttrInfo@@@std@@QBEIXZ PROC	; std::allocator<MapAttrInfo>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 8d 89 f4 00	 mov	 eax, 16025997		; 00f4898dH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UMapAttrInfo@@@std@@QBEIXZ ENDP	; std::allocator<MapAttrInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UMapAttrInfo@@@std@@QAEPAUMapAttrInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UMapAttrInfo@@@std@@QAEPAUMapAttrInfo@@I@Z PROC ; std::allocator<MapAttrInfo>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d 8d 89 f4 00	 cmp	 eax, 16025997		; 00f4898dH
  00013	77 3f		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	69 c0 0c 01 00
	00		 imul	 eax, eax, 268

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@UMapAttrInfo@@@std@@QAEPAUMapAttrInfo@@I@Z ENDP ; std::allocator<MapAttrInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z PROC ; std::allocator<MapAttrInfo>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d 8d 89 f4 00	 cmp	 eax, 16025997		; 00f4898dH
  0000e	77 34		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	69 c0 0c 01 00
	00		 imul	 eax, eax, 268

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 639  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ENDP ; std::allocator<MapAttrInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UMapAttrInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UMapAttrInfo@@@std@@QAE@ABV01@@Z PROC	; std::allocator<MapAttrInfo>::allocator<MapAttrInfo>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UMapAttrInfo@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<MapAttrInfo>::allocator<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UMapAttrInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UMapAttrInfo@@@std@@QAE@XZ PROC		; std::allocator<MapAttrInfo>::allocator<MapAttrInfo>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UMapAttrInfo@@@std@@QAE@XZ ENDP		; std::allocator<MapAttrInfo>::allocator<MapAttrInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?GetFile@MapAttribute@@QAEPADHE@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 4
_EventState$ = 12					; size = 1
?GetFile@MapAttribute@@QAEPADHE@Z PROC			; MapAttribute::GetFile, COMDAT
; _this$ = ecx

; 1265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00004	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00006	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  0000b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000e	2b cb		 sub	 ecx, ebx
  00010	f7 e9		 imul	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	c1 fa 03	 sar	 edx, 3
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1266 : 	for( int i = 0; i < this->m_Attribute.size(); i++ )

  00017	33 f6		 xor	 esi, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00019	8b fa		 mov	 edi, edx
  0001b	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0001e	03 fa		 add	 edi, edx
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1266 : 	for( int i = 0; i < this->m_Attribute.size(); i++ )

  00020	74 2a		 je	 SHORT $LN92@GetFile
  00022	8a 4d 0c	 mov	 cl, BYTE PTR _EventState$[ebp]
  00025	8b c3		 mov	 eax, ebx
  00027	8b 55 08	 mov	 edx, DWORD PTR _MapNumber$[ebp]
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL4@GetFile:

; 1267 : 	{
; 1268 : 		if( EventState == 255 )

  00030	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00033	75 04		 jne	 SHORT $LN5@GetFile

; 1269 : 		{
; 1270 : 			if( this->m_Attribute[i].MapNumber == MapNumber )

  00035	39 10		 cmp	 DWORD PTR [eax], edx

; 1273 : 			}
; 1274 : 		}
; 1275 : 		else

  00037	eb 07		 jmp	 SHORT $LN93@GetFile
$LN5@GetFile:

; 1276 : 		{
; 1277 : 			if( this->m_Attribute[i].MapNumber == MapNumber 
; 1278 : 				&& this->m_Attribute[i].State == EventState )

  00039	39 10		 cmp	 DWORD PTR [eax], edx
  0003b	75 05		 jne	 SHORT $LN2@GetFile
  0003d	38 48 04	 cmp	 BYTE PTR [eax+4], cl
$LN93@GetFile:
  00040	74 16		 je	 SHORT $LN87@GetFile
$LN2@GetFile:

; 1266 : 	for( int i = 0; i < this->m_Attribute.size(); i++ )

  00042	46		 inc	 esi
  00043	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  00048	3b f7		 cmp	 esi, edi
  0004a	72 e4		 jb	 SHORT $LL4@GetFile
$LN92@GetFile:
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 1279 : 			{
; 1280 : 				return m_Attribute[i].FileName;
; 1281 : 			}
; 1282 : 		}
; 1283 : 	}
; 1284 : 	// ----
; 1285 : 	return "";

  0004e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00053	5b		 pop	 ebx

; 1286 : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
$LN87@GetFile:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00058	69 c6 0c 01 00
	00		 imul	 eax, esi, 268
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1272 : 				return m_Attribute[i].FileName;

  00060	83 c0 05	 add	 eax, 5
  00063	03 c3		 add	 eax, ebx
  00065	5b		 pop	 ebx

; 1286 : }

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?GetFile@MapAttribute@@QAEPADHE@Z ENDP			; MapAttribute::GetFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?Read@MapAttribute@@QAEXPAD@Z
_TEXT	SEGMENT
_Result$ = -528						; size = 12
$T2 = -516						; size = 4
$T3 = -512						; size = 4
$T4 = -512						; size = 4
_EventMap$ = -508					; size = 4
_NormalMap$ = -504					; size = 4
$T5 = -500						; size = 4
$T6 = -500						; size = 4
$T7 = -500						; size = 4
$T8 = -496						; size = 4
$T9 = -496						; size = 4
$T10 = -496						; size = 4
_MapAttribute$ = -492					; size = 4
_Terrain$ = -488					; size = 4
_Document$ = -484					; size = 200
_lpMap$11 = -284					; size = 268
_lpMap$12 = -284					; size = 268
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_File$ = 8						; size = 4
?Read@MapAttribute@@QAEXPAD@Z PROC			; MapAttribute::Read, COMDAT
; _this$ = ecx

; 1215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Read@MapAttribute@@QAEXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	8b 75 08	 mov	 esi, DWORD PTR _File$[ebp]

; 1216 : 	xml_document Document;

  00033	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00039	e8 00 00 00 00	 call	 ??0xml_document@pugi@@QAE@XZ ; pugi::xml_document::xml_document

; 1217 : 	xml_parse_result Result = Document.load_file(File);

  0003e	6a 00		 push	 0
  00040	6a 74		 push	 116			; 00000074H
  00042	56		 push	 esi
  00043	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _Result$[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	50		 push	 eax
  00051	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00057	e8 00 00 00 00	 call	 ?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z ; pugi::xml_document::load_file

; 1218 : 	// ----
; 1219 : 	if( Result.status != status_ok )

  0005c	83 bd f0 fd ff
	ff 00		 cmp	 DWORD PTR _Result$[ebp], 0
  00063	74 0b		 je	 SHORT $LN8@Read

; 1220 : 	{
; 1221 : 		MsgBox("[MapAttribute] Loading fail [%s]", File);

  00065	56		 push	 esi
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HFCBCMHL@?$FLMapAttribute?$FN?5Loading?5fail?5?$FL?$CFs?$FN@
  0006b	e9 be 02 00 00	 jmp	 $LN256@Read
$LN8@Read:

; 1222 : 		return;
; 1223 : 	}
; 1224 : 	// ----
; 1225 : 	xml_node MapAttribute	= Document.child("mapattribute");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OPJMKHEJ@mapattribute?$AA@
  00075	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _MapAttribute$[ebp]
  0007b	50		 push	 eax
  0007c	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00082	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 1226 : 	xml_node NormalMap		= MapAttribute.child("normal");

  00087	68 00 00 00 00	 push	 OFFSET ??_C@_06IKLLLDHL@normal?$AA@
  0008c	8d 85 08 fe ff
	ff		 lea	 eax, DWORD PTR _NormalMap$[ebp]
  00092	50		 push	 eax
  00093	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR _MapAttribute$[ebp]
  00099	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 1227 : 	xml_node EventMap		= MapAttribute.child("event");

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_05GFHEIIDD@event?$AA@
  000a3	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR _EventMap$[ebp]
  000a9	50		 push	 eax
  000aa	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR _MapAttribute$[ebp]
  000b0	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 1228 : 	xml_node Terrain;

  000b5	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  000bb	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node

; 1229 : 	// ----
; 1230 : 	for( Terrain = NormalMap.child("terrain"); Terrain; Terrain = Terrain.next_sibling())

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_07JBFDOFDL@terrain?$AA@
  000c5	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  000cb	50		 push	 eax
  000cc	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR _NormalMap$[ebp]
  000d2	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  000d7	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  000dd	8b 00		 mov	 eax, DWORD PTR [eax]
  000df	89 85 18 fe ff
	ff		 mov	 DWORD PTR _Terrain$[ebp], eax
  000e5	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  000ea	85 c0		 test	 eax, eax
  000ec	0f 84 b8 00 00
	00		 je	 $LN3@Read
$LL4@Read:

; 1231 : 	{
; 1232 : 		MapAttrInfo lpMap;
; 1233 : 		lpMap.MapNumber = Terrain.attribute("map").as_int(-1);

  000f2	6a ff		 push	 -1
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_03HBNNNHNM@map?$AA@
  000f9	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  000ff	50		 push	 eax
  00100	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  00106	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0010b	8b c8		 mov	 ecx, eax
  0010d	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00112	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lpMap$12[ebp], eax

; 1234 : 		lpMap.State		= 255;

  00118	c6 85 e8 fe ff
	ff ff		 mov	 BYTE PTR _lpMap$12[ebp+4], 255 ; 000000ffH

; 1235 : 		// ----
; 1236 : 		if( !MAX_MAP_RANGE(lpMap.MapNumber) )

  0011f	85 c0		 test	 eax, eax
  00121	0f 88 a6 01 00
	00		 js	 $LN242@Read
  00127	33 c9		 xor	 ecx, ecx
  00129	83 f8 63	 cmp	 eax, 99			; 00000063H
  0012c	0f 9e c1	 setle	 cl
  0012f	85 c9		 test	 ecx, ecx
  00131	0f 84 96 01 00
	00		 je	 $LN242@Read

; 1239 : 			return;
; 1240 : 		}
; 1241 : 		// ----
; 1242 : 		sprintf(lpMap.FileName, "%s%s", FOLDER_WORLD_TERRAIN, Terrain.text().as_string());

  00137	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0013c	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00142	50		 push	 eax
  00143	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  00149	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0014e	8b c8		 mov	 ecx, eax
  00150	e8 00 00 00 00	 call	 ?as_string@xml_text@pugi@@QBEPBDPBD@Z ; pugi::xml_text::as_string
  00155	50		 push	 eax
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GPLLIGLO@World?2Terrain?2?$AA@
  0015b	8d 85 e9 fe ff
	ff		 lea	 eax, DWORD PTR _lpMap$12[ebp+5]
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _sprintf
  0016c	83 c4 10	 add	 esp, 16			; 00000010H

; 1243 : 		this->m_Attribute.push_back(lpMap);

  0016f	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _lpMap$12[ebp]
  00175	8b cb		 mov	 ecx, ebx
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ?push_back@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@QAEXABUMapAttrInfo@@@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::push_back
  0017d	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00183	50		 push	 eax
  00184	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  0018a	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  0018f	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  00195	8b 00		 mov	 eax, DWORD PTR [eax]
  00197	89 85 18 fe ff
	ff		 mov	 DWORD PTR _Terrain$[ebp], eax
  0019d	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  001a2	85 c0		 test	 eax, eax
  001a4	0f 85 48 ff ff
	ff		 jne	 $LL4@Read
$LN3@Read:

; 1246 : 	for( Terrain = EventMap.child("terrain"); Terrain; Terrain = Terrain.next_sibling())

  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_07JBFDOFDL@terrain?$AA@
  001af	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  001b5	50		 push	 eax
  001b6	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _EventMap$[ebp]
  001bc	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  001c1	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  001c7	8b 00		 mov	 eax, DWORD PTR [eax]
  001c9	89 85 18 fe ff
	ff		 mov	 DWORD PTR _Terrain$[ebp], eax
  001cf	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  001d4	85 c0		 test	 eax, eax
  001d6	0f 84 5a 01 00
	00		 je	 $LN18@Read
  001dc	0f 1f 40 00	 npad	 4
$LL7@Read:

; 1247 : 	{
; 1248 : 		MapAttrInfo lpMap;
; 1249 : 		lpMap.MapNumber = Terrain.attribute("map").as_int(-1);

  001e0	6a ff		 push	 -1
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_03HBNNNHNM@map?$AA@
  001e7	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001ed	50		 push	 eax
  001ee	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  001f4	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001f9	8b c8		 mov	 ecx, eax
  001fb	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 1250 : 		lpMap.State		= Terrain.attribute("state").as_int();

  00200	6a 00		 push	 0
  00202	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lpMap$11[ebp], eax
  00208	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_05HDBKIDE@state?$AA@
  00213	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0021f	8b c8		 mov	 ecx, eax
  00221	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 1251 : 		// ----
; 1252 : 		if( !MAX_MAP_RANGE(lpMap.MapNumber) )

  00226	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMap$11[ebp]
  0022c	88 85 e8 fe ff
	ff		 mov	 BYTE PTR _lpMap$11[ebp+4], al
  00232	85 c9		 test	 ecx, ecx
  00234	0f 88 ee 00 00
	00		 js	 $LN243@Read
  0023a	33 c0		 xor	 eax, eax
  0023c	83 f9 63	 cmp	 ecx, 99			; 00000063H
  0023f	0f 9e c0	 setle	 al
  00242	85 c0		 test	 eax, eax
  00244	0f 84 de 00 00
	00		 je	 $LN243@Read

; 1258 : 		sprintf(lpMap.FileName, "%s%s", FOLDER_WORLD_TERRAIN, Terrain.text().as_string());

  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0024f	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00255	50		 push	 eax
  00256	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  0025c	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00261	8b c8		 mov	 ecx, eax
  00263	e8 00 00 00 00	 call	 ?as_string@xml_text@pugi@@QBEPBDPBD@Z ; pugi::xml_text::as_string
  00268	50		 push	 eax
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GPLLIGLO@World?2Terrain?2?$AA@
  0026e	8d 85 e9 fe ff
	ff		 lea	 eax, DWORD PTR _lpMap$11[ebp+5]
  00274	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 _sprintf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  0027f	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00282	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _lpMap$11[ebp]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1258 : 		sprintf(lpMap.FileName, "%s%s", FOLDER_WORLD_TERRAIN, Terrain.text().as_string());

  00288	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  0028b	3b c7		 cmp	 eax, edi
  0028d	73 41		 jae	 SHORT $LN21@Read
  0028f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00291	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _lpMap$11[ebp]
  00297	3b c1		 cmp	 eax, ecx
  00299	77 35		 ja	 SHORT $LN21@Read

; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  0029b	2b c8		 sub	 ecx, eax
  0029d	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  002a2	f7 e9		 imul	 ecx
  002a4	c1 fa 03	 sar	 edx, 3
  002a7	8b f2		 mov	 esi, edx
  002a9	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  002ac	03 f2		 add	 esi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  002ae	3b 7b 08	 cmp	 edi, DWORD PTR [ebx+8]
  002b1	75 09		 jne	 SHORT $LN23@Read

; 1279 : 				_Reserve(1);

  002b3	6a 01		 push	 1
  002b5	8b cb		 mov	 ecx, ebx
  002b7	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reserve
$LN23@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  002bc	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  002bf	85 ff		 test	 edi, edi
  002c1	74 2f		 je	 SHORT $LN224@Read
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  002c3	69 f6 0c 01 00
	00		 imul	 esi, esi, 268
  002c9	03 33		 add	 esi, DWORD PTR [ebx]

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else

  002cb	eb 1e		 jmp	 SHORT $LN258@Read
$LN242@Read:
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1238 : 			MsgBox("[MapAttribute] Invalid map number (%d)", lpMap.MapNumber);

  002cd	50		 push	 eax
  002ce	eb 59		 jmp	 SHORT $LN257@Read
$LN21@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1287 : 			if (this->_Mylast() == this->_Myend())

  002d0	3b 7b 08	 cmp	 edi, DWORD PTR [ebx+8]
  002d3	75 09		 jne	 SHORT $LN24@Read

; 1288 : 				_Reserve(1);

  002d5	6a 01		 push	 1
  002d7	8b cb		 mov	 ecx, ebx
  002d9	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMapAttrInfo@@V?$allocator@UMapAttrInfo@@@std@@@std@@IAEXI@Z ; std::vector<MapAttrInfo,std::allocator<MapAttrInfo> >::_Reserve
$LN24@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  002de	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  002e1	85 ff		 test	 edi, edi
  002e3	74 0d		 je	 SHORT $LN224@Read
  002e5	8d b5 e4 fe ff
	ff		 lea	 esi, DWORD PTR _lpMap$11[ebp]
$LN258@Read:
  002eb	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  002f0	f3 a5		 rep movsd
$LN224@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  002f2	81 43 04 0c 01
	00 00		 add	 DWORD PTR [ebx+4], 268	; 0000010cH
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1246 : 	for( Terrain = EventMap.child("terrain"); Terrain; Terrain = Terrain.next_sibling())

  002f9	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  002ff	50		 push	 eax
  00300	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  00306	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  0030b	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _Terrain$[ebp]
  00311	8b 00		 mov	 eax, DWORD PTR [eax]
  00313	89 85 18 fe ff
	ff		 mov	 DWORD PTR _Terrain$[ebp], eax
  00319	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  0031e	85 c0		 test	 eax, eax
  00320	0f 85 ba fe ff
	ff		 jne	 $LL7@Read
  00326	eb 0e		 jmp	 SHORT $LN18@Read
$LN243@Read:

; 1253 : 		{
; 1254 : 			MsgBox("[MapAttribute] Invalid map number (%d)", lpMap.MapNumber);

  00328	51		 push	 ecx
$LN257@Read:
  00329	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FPNPGDOD@?$FLMapAttribute?$FN?5Invalid?5map?5numbe@
$LN256@Read:
  0032e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00333	83 c4 08	 add	 esp, 8
$LN18@Read:

; 1259 : 		this->m_Attribute.push_back(lpMap);
; 1260 : 	}
; 1261 : }

  00336	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  0033c	e8 00 00 00 00	 call	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
  00341	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00344	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0034b	59		 pop	 ecx
  0034c	5f		 pop	 edi
  0034d	5e		 pop	 esi
  0034e	5b		 pop	 ebx
  0034f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00352	33 cd		 xor	 ecx, ebp
  00354	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00359	8b e5		 mov	 esp, ebp
  0035b	5d		 pop	 ebp
  0035c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@MapAttribute@@QAEXPAD@Z$0:
  00000	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
__ehhandler$?Read@MapAttribute@@QAEXPAD@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a ec fd ff
	ff		 mov	 ecx, DWORD PTR [edx-532]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Read@MapAttribute@@QAEXPAD@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Read@MapAttribute@@QAEXPAD@Z ENDP			; MapAttribute::Read
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?Load@MapAttribute@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Load@MapAttribute@@QAEXXZ PROC				; MapAttribute::Load, COMDAT
; _this$ = ecx

; 1197 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx
  00008	57		 push	 edi
  00009	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx

; 1198 : 	this->Init();

  0000c	e8 00 00 00 00	 call	 ?Init@MapAttribute@@QAEXXZ ; MapAttribute::Init

; 1199 : 	this->Read(gDirPath.GetNewPath(FILE_WORLD_MAPATTRIBUTE));

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JNEGMM@World?2MapAttribute?4xml?$AA@
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0001b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00020	50		 push	 eax
  00021	8b cb		 mov	 ecx, ebx
  00023	e8 00 00 00 00	 call	 ?Read@MapAttribute@@QAEXPAD@Z ; MapAttribute::Read

; 1200 : 	// ----
; 1201 : 	for( int i = 0; i < MAX_NUMBER_MAP; i++ )

  00028	33 ff		 xor	 edi, edi
  0002a	bb 00 00 00 00	 mov	 ebx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0002f	90		 npad	 1
$LL4@Load:

; 1202 : 	{
; 1203 : 		if( strcmp(this->GetFile(i, 255), "") == 0 )

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00033	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00038	68 ff 00 00 00	 push	 255			; 000000ffH
  0003d	57		 push	 edi
  0003e	e8 00 00 00 00	 call	 ?GetFile@MapAttribute@@QAEPADHE@Z ; MapAttribute::GetFile
$LL11@Load:
  00043	8a 08		 mov	 cl, BYTE PTR [eax]
  00045	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00047	75 1a		 jne	 SHORT $LN12@Load
  00049	84 c9		 test	 cl, cl
  0004b	74 12		 je	 SHORT $LN13@Load
  0004d	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00050	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00053	75 0e		 jne	 SHORT $LN12@Load
  00055	83 c0 02	 add	 eax, 2
  00058	83 c6 02	 add	 esi, 2
  0005b	84 c9		 test	 cl, cl
  0005d	75 e4		 jne	 SHORT $LL11@Load
$LN13@Load:
  0005f	33 c0		 xor	 eax, eax
  00061	eb 05		 jmp	 SHORT $LN14@Load
$LN12@Load:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
$LN14@Load:
  00068	85 c0		 test	 eax, eax
  0006a	74 22		 je	 SHORT $LN2@Load

; 1204 : 		{
; 1205 : 			continue;
; 1206 : 		}
; 1207 : 		// ----
; 1208 : 		MapC[i].ItemInit();
; 1209 : 		MapC[i].LoadMapAttr(gDirPath.GetNewPath(this->GetFile(i, 255)), i);

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0006f	57		 push	 edi
  00070	68 ff 00 00 00	 push	 255			; 000000ffH
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ?GetFile@MapAttribute@@QAEPADHE@Z ; MapAttribute::GetFile
  0007b	50		 push	 eax
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00081	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00086	50		 push	 eax
  00087	8b cb		 mov	 ecx, ebx
  00089	e8 00 00 00 00	 call	 ?LoadMapAttr@MapClass@@QAEXPADH@Z ; MapClass::LoadMapAttr
$LN2@Load:

; 1200 : 	// ----
; 1201 : 	for( int i = 0; i < MAX_NUMBER_MAP; i++ )

  0008e	81 c3 28 38 05
	00		 add	 ebx, 342056		; 00053828H
  00094	47		 inc	 edi
  00095	81 fb a0 ef 09
	02		 cmp	 ebx, OFFSET ?MapC@@3PAVMapClass@@A+34205600
  0009b	7c 93		 jl	 SHORT $LL4@Load
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx

; 1210 : 	}
; 1211 : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?Load@MapAttribute@@QAEXXZ ENDP				; MapAttribute::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?Init@MapAttribute@@QAEXXZ
_TEXT	SEGMENT
?Init@MapAttribute@@QAEXXZ PROC				; MapAttribute::Init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1193 : }

  00005	c3		 ret	 0
?Init@MapAttribute@@QAEXXZ ENDP				; MapAttribute::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ??1MapAttribute@@QAE@XZ
_TEXT	SEGMENT
??1MapAttribute@@QAE@XZ PROC				; MapAttribute::~MapAttribute, COMDAT
; _this$ = ecx

; 1185 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 33		 je	 SHORT $LN7@MapAttribu

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 6b 4c a4 07	 mov	 eax, 128207979		; 07a44c6bH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	c1 fa 03	 sar	 edx, 3
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMapAttrInfo@@@std@@QAEXPAUMapAttrInfo@@I@Z ; std::allocator<MapAttrInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00035	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN7@MapAttribu:
  0003c	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1187 : }

  0003d	c3		 ret	 0
??1MapAttribute@@QAE@XZ ENDP				; MapAttribute::~MapAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ??0MapAttribute@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MapAttribute@@QAE@XZ PROC				; MapAttribute::MapAttribute, COMDAT
; _this$ = ecx

; 1179 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 481  : 		_Mylast = pointer();

  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 482  : 		_Myend = pointer();

  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1180 : 	this->Init();

  0001e	e8 00 00 00 00	 call	 ?Init@MapAttribute@@QAEXXZ ; MapAttribute::Init

; 1181 : }

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0MapAttribute@@QAE@XZ ENDP				; MapAttribute::MapAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?MapNumberCheck@@YAHH@Z
_TEXT	SEGMENT
_map$ = 8						; size = 4
?MapNumberCheck@@YAHH@Z PROC				; MapNumberCheck, COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16   : 	if ( map < 0 || map > MAX_NUMBER_MAP-1 )

  00003	b8 63 00 00 00	 mov	 eax, 99			; 00000063H
  00008	3b 45 08	 cmp	 eax, DWORD PTR _map$[ebp]
  0000b	1b c0		 sbb	 eax, eax
  0000d	40		 inc	 eax

; 17   : 	{
; 18   : 		return FALSE;
; 19   : 	}
; 20   : 	return TRUE;
; 21   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?MapNumberCheck@@YAHH@Z ENDP				; MapNumberCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GMapClass@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMapClass@@UAEPAXI@Z PROC				; MapClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1MapClass@@UAE@XZ	; MapClass::~MapClass
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 28 38 05 00	 push	 342056			; 00053828H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GMapClass@@UAEPAXI@Z ENDP				; MapClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ??1MapClass@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MapClass@@UAE@XZ PROC				; MapClass::~MapClass, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1MapClass@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h

; 56   : 		if( this->m_attrbuf != 0 )

  00025	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 36   : {

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7MapClass@@6B@
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h

; 56   : 		if( this->m_attrbuf != 0 )

  0002e	85 c0		 test	 eax, eax
  00030	74 0e		 je	 SHORT $LN4@MapClass

; 57   : 		{
; 58   : 			GlobalFree(this->m_attrbuf);

  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 59   : 			this->m_attrbuf = 0;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN4@MapClass:

; 60   : 		}
; 61   : 		// ----
; 62   : 		if( this->path != 0 )

  00040	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00043	85 c0		 test	 eax, eax
  00045	74 15		 je	 SHORT $LN5@MapClass
  00047	68 54 04 00 00	 push	 1108			; 00000454H
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00052	83 c4 08	 add	 esp, 8

; 63   : 		{
; 64   : 			delete this->path;
; 65   : 			this->path = 0;

  00055	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN5@MapClass:
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 38   : }

  0005c	68 00 00 00 00	 push	 OFFSET ??1CMapItem@@UAE@XZ ; CMapItem::~CMapItem
  00061	68 2c 01 00 00	 push	 300			; 0000012cH
  00066	68 74 04 00 00	 push	 1140			; 00000474H
  0006b	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5e		 pop	 esi
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1MapClass@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1MapClass@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1MapClass@@UAE@XZ ENDP				; MapClass::~MapClass
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ??0MapClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0MapClass@@QAE@XZ PROC				; MapClass::MapClass, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0MapClass@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	68 00 00 00 00	 push	 OFFSET ??1CMapItem@@UAE@XZ ; CMapItem::~CMapItem
  0002e	68 00 00 00 00	 push	 OFFSET ??0CMapItem@@QAE@XZ ; CMapItem::CMapItem
  00033	68 2c 01 00 00	 push	 300			; 0000012cH
  00038	68 74 04 00 00	 push	 1140			; 00000474H
  0003d	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00040	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7MapClass@@6B@
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 26   : 	this->m_Weather =0;

  00053	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0

; 27   : 	this->m_WeatherTimer=GetTickCount();

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0005d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 28   : 	this->m_NextWeatherTimer=(rand()%10000)+10000;

  00060	e8 00 00 00 00	 call	 _rand
  00065	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0006a	99		 cdq
  0006b	f7 f9		 idiv	 ecx
  0006d	03 d1		 add	 edx, ecx

; 29   : 	this->init();

  0006f	8b ce		 mov	 ecx, esi
  00071	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00074	e8 00 00 00 00	 call	 ?init@MapClass@@QAEXXZ	; MapClass::init

; 30   : 
; 31   : 	this->m_ItemCount=0;

  00079	c7 86 10 38 05
	00 00 00 00 00	 mov	 DWORD PTR [esi+342032], 0

; 32   : }

  00083	8b c6		 mov	 eax, esi
  00085	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00088	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008f	59		 pop	 ecx
  00090	5e		 pop	 esi
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MapClass@@QAE@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1CMapItem@@UAE@XZ ; CMapItem::~CMapItem
  00005	68 2c 01 00 00	 push	 300			; 0000012cH
  0000a	68 74 04 00 00	 push	 1140			; 00000474H
  0000f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 20	 add	 eax, 32			; 00000020H
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0001b	c3		 ret	 0
__ehhandler$??0MapClass@@QAE@XZ:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0MapClass@@QAE@XZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0MapClass@@QAE@XZ ENDP				; MapClass::MapClass
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h
;	COMDAT ?free@MapClass@@QAEXXZ
_TEXT	SEGMENT
?free@MapClass@@QAEXXZ PROC				; MapClass::free, COMDAT
; _this$ = ecx

; 55   : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 56   : 		if( this->m_attrbuf != 0 )

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	85 c0		 test	 eax, eax
  00008	74 0e		 je	 SHORT $LN2@free

; 57   : 		{
; 58   : 			GlobalFree(this->m_attrbuf);

  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 59   : 			this->m_attrbuf = 0;

  00011	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN2@free:

; 60   : 		}
; 61   : 		// ----
; 62   : 		if( this->path != 0 )

  00018	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0001b	85 c0		 test	 eax, eax
  0001d	74 15		 je	 SHORT $LN3@free

; 63   : 		{
; 64   : 			delete this->path;
; 65   : 			this->path = 0;

  0001f	68 54 04 00 00	 push	 1108			; 00000454H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
  0002d	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN3@free:
  00034	5e		 pop	 esi

; 66   : 		}
; 67   : 	}

  00035	c3		 ret	 0
?free@MapClass@@QAEXXZ ENDP				; MapClass::free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h
;	COMDAT ?init@MapClass@@QAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?init@MapClass@@QAEXXZ PROC				; MapClass::init, COMDAT
; _this$ = ecx

; 47   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 49   : 		this->path = new PATH;

  00007	68 54 04 00 00	 push	 1108			; 00000454H
  0000c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	83 c4 04	 add	 esp, 4
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	85 c0		 test	 eax, eax
  00020	74 3a		 je	 SHORT $LN3@init
  00022	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffff00000000ffffffffffffffff
  00029	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@0000000000000001ffffffff00000001
  00030	0f 28 15 00 00
	00 00		 movaps	 xmm2, XMMWORD PTR __xmm@00000001000000000000000100000001
  00037	0f 28 1d 00 00
	00 00		 movaps	 xmm3, XMMWORD PTR __xmm@00000000ffffffff00000001ffffffff
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 538  : 		memcpy(this->Dir, dir, sizeof(dir));

  0003e	0f 11 80 f4 03
	00 00		 movups	 XMMWORD PTR [eax+1012], xmm0
  00045	0f 11 88 04 04
	00 00		 movups	 XMMWORD PTR [eax+1028], xmm1
  0004c	0f 11 90 14 04
	00 00		 movups	 XMMWORD PTR [eax+1044], xmm2
  00053	0f 11 98 24 04
	00 00		 movups	 XMMWORD PTR [eax+1060], xmm3
; File c:\users\michel\desktop\source\gameserver\source\mapclass.h

; 49   : 		this->path = new PATH;

  0005a	eb 02		 jmp	 SHORT $LN4@init
$LN3@init:
  0005c	33 c0		 xor	 eax, eax
$LN4@init:
  0005e	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 50   : 		this->m_width = 0;

  00061	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 51   : 		this->m_height = 0;

  00068	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0006f	5e		 pop	 esi

; 52   : 	}

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?init@MapClass@@QAEXXZ ENDP				; MapClass::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?SetRegentRect@MapClass@@QAEXH@Z
_TEXT	SEGMENT
_map$ = 8						; size = 4
?SetRegentRect@MapClass@@QAEXH@Z PROC			; MapClass::SetRegentRect, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 	switch(map)

  00003	8b 45 08	 mov	 eax, DWORD PTR _map$[ebp]
  00006	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00009	0f 87 eb 01 00
	00		 ja	 $LN2@SetRegentR
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN21@SetRegentR[eax]
  00016	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@SetRegentR[eax*4]
$LN4@SetRegentR:

; 43   : 	{
; 44   : 	case MAP_INDEX_RORENCIA:
; 45   : 		SetRect(&this->gRegenRect, 130, 116, 151, 137);

  0001d	68 89 00 00 00	 push	 137			; 00000089H
  00022	68 97 00 00 00	 push	 151			; 00000097H
  00027	6a 74		 push	 116			; 00000074H
  00029	68 82 00 00 00	 push	 130			; 00000082H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  0002e	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
$LN5@SetRegentR:

; 46   : 		break;
; 47   : 	case MAP_INDEX_DUNGEON:
; 48   : 		SetRect(&this->gRegenRect, 106, 236, 112, 243);

  0003f	68 f3 00 00 00	 push	 243			; 000000f3H
  00044	6a 70		 push	 112			; 00000070H
  00046	68 ec 00 00 00	 push	 236			; 000000ecH
  0004b	6a 6a		 push	 106			; 0000006aH

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  0004d	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN6@SetRegentR:

; 49   : 		break;
; 50   : 	case MAP_INDEX_DEVIAS:
; 51   : 		SetRect(&this->gRegenRect, 197, 35, 218, 50);

  0005e	6a 32		 push	 50			; 00000032H
  00060	68 da 00 00 00	 push	 218			; 000000daH
  00065	6a 23		 push	 35			; 00000023H
  00067	68 c5 00 00 00	 push	 197			; 000000c5H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  0006c	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  00072	50		 push	 eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
$LN7@SetRegentR:

; 52   : 		break;
; 53   : 	case MAP_INDEX_NORIA:
; 54   : 		SetRect(&this->gRegenRect, 174, 101, 187, 125);

  0007d	6a 7d		 push	 125			; 0000007dH
  0007f	68 bb 00 00 00	 push	 187			; 000000bbH
  00084	6a 65		 push	 101			; 00000065H
  00086	68 ae 00 00 00	 push	 174			; 000000aeH

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  0008b	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
$LN8@SetRegentR:

; 55   : 		break;
; 56   : 	case MAP_INDEX_LOSTTOWER:
; 57   : 		SetRect(&this->gRegenRect, 201, 70, 213, 81);

  0009c	6a 51		 push	 81			; 00000051H
  0009e	68 d5 00 00 00	 push	 213			; 000000d5H
  000a3	6a 46		 push	 70			; 00000046H
  000a5	68 c9 00 00 00	 push	 201			; 000000c9H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  000aa	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  000b0	50		 push	 eax
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
$LN9@SetRegentR:

; 58   : 		break;
; 59   : 	case MAP_INDEX_BATTLESOCCER:
; 60   : 		SetRect(&this->gRegenRect, 89, 135, 90, 136);

  000bb	68 88 00 00 00	 push	 136			; 00000088H
  000c0	6a 5a		 push	 90			; 0000005aH
  000c2	68 87 00 00 00	 push	 135			; 00000087H
  000c7	6a 59		 push	 89			; 00000059H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  000c9	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
$LN10@SetRegentR:

; 61   : 		break;
; 62   : 	case MAP_INDEX_ATHLANSE:
; 63   : 		SetRect(&this->gRegenRect, 14, 11, 27, 23);

  000da	6a 17		 push	 23			; 00000017H
  000dc	6a 1b		 push	 27			; 0000001bH
  000de	6a 0b		 push	 11			; 0000000bH
  000e0	6a 0e		 push	 14			; 0000000eH

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  000e2	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  000e8	50		 push	 eax
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
$LN11@SetRegentR:

; 64   : 		break;
; 65   : 	case MAP_INDEX_TARKAN:
; 66   : 		SetRect(&this->gRegenRect, 187, 54, 203, 69);

  000f3	6a 45		 push	 69			; 00000045H
  000f5	68 cb 00 00 00	 push	 203			; 000000cbH
  000fa	6a 36		 push	 54			; 00000036H
  000fc	68 bb 00 00 00	 push	 187			; 000000bbH

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  00101	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  00107	50		 push	 eax
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  0010e	5d		 pop	 ebp
  0010f	c2 04 00	 ret	 4
$LN12@SetRegentR:

; 67   : 		break;
; 68   : 	case MAP_INDEX_AIDA:
; 69   : 		SetRect(&this->gRegenRect, 82, 8, 87, 14);

  00112	6a 0e		 push	 14			; 0000000eH
  00114	6a 57		 push	 87			; 00000057H
  00116	6a 08		 push	 8
  00118	6a 52		 push	 82			; 00000052H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  0011a	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  00120	50		 push	 eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  00127	5d		 pop	 ebp
  00128	c2 04 00	 ret	 4
$LN13@SetRegentR:

; 70   : 		break;
; 71   : 	case MAP_INDEX_CRYWOLF_FIRSTZONE:
; 72   : 		SetRect(&this->gRegenRect, 133, 41, 140, 44);

  0012b	6a 2c		 push	 44			; 0000002cH
  0012d	68 8c 00 00 00	 push	 140			; 0000008cH
  00132	6a 29		 push	 41			; 00000029H
  00134	68 85 00 00 00	 push	 133			; 00000085H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  00139	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  0013f	50		 push	 eax
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  00146	5d		 pop	 ebp
  00147	c2 04 00	 ret	 4
$LN14@SetRegentR:

; 73   : 		break;
; 74   : 	case MAP_INDEX_ELBELAND:
; 75   : 		SetRect(&this->gRegenRect, 46, 208, 51, 230 );

  0014a	68 e6 00 00 00	 push	 230			; 000000e6H
  0014f	6a 33		 push	 51			; 00000033H
  00151	68 d0 00 00 00	 push	 208			; 000000d0H
  00156	6a 2e		 push	 46			; 0000002eH

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  00158	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  0015e	50		 push	 eax
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  00165	5d		 pop	 ebp
  00166	c2 04 00	 ret	 4
$LN15@SetRegentR:

; 76   : 		break;
; 77   : 	case MAP_INDEX_SANTAVILLAGE:
; 78   : 		SetRect(&this->gRegenRect, 211,24,211,24 );

  00169	6a 18		 push	 24			; 00000018H
  0016b	68 d3 00 00 00	 push	 211			; 000000d3H
  00170	6a 18		 push	 24			; 00000018H
  00172	68 d3 00 00 00	 push	 211			; 000000d3H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  00177	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  0017d	50		 push	 eax
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  00184	5d		 pop	 ebp
  00185	c2 04 00	 ret	 4
$LN16@SetRegentR:

; 79   : 		break;
; 80   : 	case MAP_INDEX_VULCANUS:
; 81   : 		SetRect(&this->gRegenRect, 120,129,126,130 );

  00188	68 82 00 00 00	 push	 130			; 00000082H
  0018d	6a 7e		 push	 126			; 0000007eH
  0018f	68 81 00 00 00	 push	 129			; 00000081H
  00194	6a 78		 push	 120			; 00000078H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  00196	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  0019c	50		 push	 eax
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  001a3	5d		 pop	 ebp
  001a4	c2 04 00	 ret	 4
$LN17@SetRegentR:

; 82   : 		break;
; 83   : 	case MAP_INDEX_KARUTAN1:
; 84   : 		SetRect(&this->gRegenRect, 124,123,127,125 );

  001a7	6a 7d		 push	 125			; 0000007dH
  001a9	6a 7f		 push	 127			; 0000007fH
  001ab	6a 7b		 push	 123			; 0000007bH
  001ad	6a 7c		 push	 124			; 0000007cH

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  001af	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  001b5	50		 push	 eax
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  001bc	5d		 pop	 ebp
  001bd	c2 04 00	 ret	 4
$LN18@SetRegentR:

; 85   : 		break;
; 86   : 	case MAP_INDEX_KARUTAN2:
; 87   : 		SetRect(&this->gRegenRect, 162,16, 163,17 );

  001c0	6a 11		 push	 17			; 00000011H
  001c2	68 a3 00 00 00	 push	 163			; 000000a3H
  001c7	6a 10		 push	 16			; 00000010H
  001c9	68 a2 00 00 00	 push	 162			; 000000a2H

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  001ce	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  001d4	50		 push	 eax
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 92   : 		break;
; 93   : 	}
; 94   : }

  001db	5d		 pop	 ebp
  001dc	c2 04 00	 ret	 4
$LN19@SetRegentR:

; 88   : 		break;
; 89   : 	case MAP_INDEX_ACHERON:
; 90   : 	case MAP_INDEX_ACHERON_ARCABATTLE:
; 91   : 		SetRect(&this->gRegenRect, 39, 167, 59,207);

  001df	68 cf 00 00 00	 push	 207			; 000000cfH
  001e4	6a 3b		 push	 59			; 0000003bH
  001e6	68 a7 00 00 00	 push	 167			; 000000a7H
  001eb	6a 27		 push	 39			; 00000027H
  001ed	8d 81 14 38 05
	00		 lea	 eax, DWORD PTR [ecx+342036]
  001f3	50		 push	 eax
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
$LN2@SetRegentR:

; 92   : 		break;
; 93   : 	}
; 94   : }

  001fa	5d		 pop	 ebp
  001fb	c2 04 00	 ret	 4
  001fe	66 90		 npad	 2
$LN24@SetRegentR:
  00200	00 00 00 00	 DD	 $LN4@SetRegentR
  00204	00 00 00 00	 DD	 $LN5@SetRegentR
  00208	00 00 00 00	 DD	 $LN6@SetRegentR
  0020c	00 00 00 00	 DD	 $LN7@SetRegentR
  00210	00 00 00 00	 DD	 $LN8@SetRegentR
  00214	00 00 00 00	 DD	 $LN9@SetRegentR
  00218	00 00 00 00	 DD	 $LN10@SetRegentR
  0021c	00 00 00 00	 DD	 $LN11@SetRegentR
  00220	00 00 00 00	 DD	 $LN12@SetRegentR
  00224	00 00 00 00	 DD	 $LN13@SetRegentR
  00228	00 00 00 00	 DD	 $LN14@SetRegentR
  0022c	00 00 00 00	 DD	 $LN15@SetRegentR
  00230	00 00 00 00	 DD	 $LN16@SetRegentR
  00234	00 00 00 00	 DD	 $LN17@SetRegentR
  00238	00 00 00 00	 DD	 $LN18@SetRegentR
  0023c	00 00 00 00	 DD	 $LN19@SetRegentR
  00240	00 00 00 00	 DD	 $LN2@SetRegentR
$LN21@SetRegentR:
  00244	00		 DB	 0
  00245	01		 DB	 1
  00246	02		 DB	 2
  00247	03		 DB	 3
  00248	04		 DB	 4
  00249	10		 DB	 16			; 00000010H
  0024a	05		 DB	 5
  0024b	06		 DB	 6
  0024c	07		 DB	 7
  0024d	10		 DB	 16			; 00000010H
  0024e	10		 DB	 16			; 00000010H
  0024f	10		 DB	 16			; 00000010H
  00250	10		 DB	 16			; 00000010H
  00251	10		 DB	 16			; 00000010H
  00252	10		 DB	 16			; 00000010H
  00253	10		 DB	 16			; 00000010H
  00254	10		 DB	 16			; 00000010H
  00255	10		 DB	 16			; 00000010H
  00256	10		 DB	 16			; 00000010H
  00257	10		 DB	 16			; 00000010H
  00258	10		 DB	 16			; 00000010H
  00259	10		 DB	 16			; 00000010H
  0025a	10		 DB	 16			; 00000010H
  0025b	10		 DB	 16			; 00000010H
  0025c	10		 DB	 16			; 00000010H
  0025d	10		 DB	 16			; 00000010H
  0025e	10		 DB	 16			; 00000010H
  0025f	10		 DB	 16			; 00000010H
  00260	10		 DB	 16			; 00000010H
  00261	10		 DB	 16			; 00000010H
  00262	10		 DB	 16			; 00000010H
  00263	10		 DB	 16			; 00000010H
  00264	10		 DB	 16			; 00000010H
  00265	08		 DB	 8
  00266	09		 DB	 9
  00267	10		 DB	 16			; 00000010H
  00268	10		 DB	 16			; 00000010H
  00269	10		 DB	 16			; 00000010H
  0026a	10		 DB	 16			; 00000010H
  0026b	10		 DB	 16			; 00000010H
  0026c	10		 DB	 16			; 00000010H
  0026d	10		 DB	 16			; 00000010H
  0026e	10		 DB	 16			; 00000010H
  0026f	10		 DB	 16			; 00000010H
  00270	10		 DB	 16			; 00000010H
  00271	10		 DB	 16			; 00000010H
  00272	10		 DB	 16			; 00000010H
  00273	10		 DB	 16			; 00000010H
  00274	10		 DB	 16			; 00000010H
  00275	10		 DB	 16			; 00000010H
  00276	10		 DB	 16			; 00000010H
  00277	0a		 DB	 10			; 0000000aH
  00278	10		 DB	 16			; 00000010H
  00279	10		 DB	 16			; 00000010H
  0027a	10		 DB	 16			; 00000010H
  0027b	10		 DB	 16			; 00000010H
  0027c	10		 DB	 16			; 00000010H
  0027d	10		 DB	 16			; 00000010H
  0027e	10		 DB	 16			; 00000010H
  0027f	10		 DB	 16			; 00000010H
  00280	10		 DB	 16			; 00000010H
  00281	10		 DB	 16			; 00000010H
  00282	0b		 DB	 11			; 0000000bH
  00283	0c		 DB	 12			; 0000000cH
  00284	10		 DB	 16			; 00000010H
  00285	10		 DB	 16			; 00000010H
  00286	10		 DB	 16			; 00000010H
  00287	10		 DB	 16			; 00000010H
  00288	10		 DB	 16			; 00000010H
  00289	10		 DB	 16			; 00000010H
  0028a	10		 DB	 16			; 00000010H
  0028b	10		 DB	 16			; 00000010H
  0028c	10		 DB	 16			; 00000010H
  0028d	10		 DB	 16			; 00000010H
  0028e	10		 DB	 16			; 00000010H
  0028f	10		 DB	 16			; 00000010H
  00290	10		 DB	 16			; 00000010H
  00291	10		 DB	 16			; 00000010H
  00292	10		 DB	 16			; 00000010H
  00293	10		 DB	 16			; 00000010H
  00294	0d		 DB	 13			; 0000000dH
  00295	0e		 DB	 14			; 0000000eH
  00296	10		 DB	 16			; 00000010H
  00297	10		 DB	 16			; 00000010H
  00298	10		 DB	 16			; 00000010H
  00299	10		 DB	 16			; 00000010H
  0029a	10		 DB	 16			; 00000010H
  0029b	10		 DB	 16			; 00000010H
  0029c	10		 DB	 16			; 00000010H
  0029d	10		 DB	 16			; 00000010H
  0029e	10		 DB	 16			; 00000010H
  0029f	0f		 DB	 15			; 0000000fH
  002a0	0f		 DB	 15			; 0000000fH
?SetRegentRect@MapClass@@QAEXH@Z ENDP			; MapClass::SetRegentRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?GetAttr@MapClass@@QAEEHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetAttr@MapClass@@QAEEHH@Z PROC			; MapClass::GetAttr, COMDAT
; _this$ = ecx

; 744  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 745  : 	if ( x < 0 )

  00003	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	79 07		 jns	 SHORT $LN2@GetAttr
$LN7@GetAttr:

; 746  : 	{
; 747  : 		return 4;

  0000d	b0 04		 mov	 al, 4
  0000f	5e		 pop	 esi

; 766  : 
; 767  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
$LN2@GetAttr:

; 748  : 	}
; 749  : 
; 750  : 	if ( y < 0 )

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00017	85 c9		 test	 ecx, ecx
  00019	78 f2		 js	 SHORT $LN7@GetAttr

; 751  : 	{
; 752  : 		return 4;
; 753  : 	}
; 754  : 
; 755  : 	if ( x > this->m_width -1 )

  0001b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001e	48		 dec	 eax
  0001f	3b d0		 cmp	 edx, eax
  00021	7f ea		 jg	 SHORT $LN7@GetAttr

; 756  : 	{
; 757  : 		return 4;
; 758  : 	}
; 759  : 
; 760  : 	if ( y > this->m_height -1 )

  00023	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00026	48		 dec	 eax
  00027	3b c8		 cmp	 ecx, eax
  00029	7f e2		 jg	 SHORT $LN7@GetAttr

; 761  : 	{
; 762  : 		return 4;
; 763  : 	}
; 764  : 
; 765  : 	return this->m_attrbuf[y*256 + x];

  0002b	c1 e1 08	 shl	 ecx, 8
  0002e	03 4e 10	 add	 ecx, DWORD PTR [esi+16]
  00031	5e		 pop	 esi
  00032	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]

; 766  : 
; 767  : }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?GetAttr@MapClass@@QAEEHH@Z ENDP			; MapClass::GetAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?GetStandAttr@MapClass@@QAEHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetStandAttr@MapClass@@QAEHHH@Z PROC			; MapClass::GetStandAttr, COMDAT
; _this$ = ecx

; 773  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 774  : 	if ( x > (this->m_width-1) )

  00006	8b 75 08	 mov	 esi, DWORD PTR _x$[ebp]
  00009	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0000c	48		 dec	 eax
  0000d	3b f0		 cmp	 esi, eax
  0000f	7e 07		 jle	 SHORT $LN2@GetStandAt
$LN8@GetStandAt:

; 775  : 	{
; 776  : 		return FALSE;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 797  : 	{
; 798  : 		return FALSE;
; 799  : 	}
; 800  : 
; 801  : 	return TRUE;
; 802  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@GetStandAt:

; 777  : 	}
; 778  : 
; 779  : 	if ( y > (this->m_height-1) )

  00018	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0001e	48		 dec	 eax
  0001f	3b c8		 cmp	 ecx, eax
  00021	7f ee		 jg	 SHORT $LN8@GetStandAt

; 780  : 	{
; 781  : 		return FALSE;
; 782  : 	}
; 783  : 
; 784  : 	BYTE attr = this->m_attrbuf[(y * 256 + x)];

  00023	c1 e1 08	 shl	 ecx, 8
  00026	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00029	8a 04 31	 mov	 al, BYTE PTR [ecx+esi]

; 785  : 
; 786  : 	if ( (attr&2) == 2 )

  0002c	a8 02		 test	 al, 2
  0002e	75 e1		 jne	 SHORT $LN8@GetStandAt

; 787  : 	{
; 788  : 		return FALSE;
; 789  : 	}
; 790  : 
; 791  : 	if ( (attr&4) == 4 )

  00030	a8 04		 test	 al, 4
  00032	75 dd		 jne	 SHORT $LN8@GetStandAt

; 792  : 	{
; 793  : 		return FALSE;
; 794  : 	}
; 795  : 
; 796  : 	if ( (attr&8) == 8 )

  00034	f6 d0		 not	 al
  00036	0f b6 c0	 movzx	 eax, al
  00039	c1 e8 03	 shr	 eax, 3
  0003c	83 e0 01	 and	 eax, 1
  0003f	5e		 pop	 esi

; 797  : 	{
; 798  : 		return FALSE;
; 799  : 	}
; 800  : 
; 801  : 	return TRUE;
; 802  : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?GetStandAttr@MapClass@@QAEHHH@Z ENDP			; MapClass::GetStandAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?ClearStandAttr@MapClass@@QAEXHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?ClearStandAttr@MapClass@@QAEXHH@Z PROC			; MapClass::ClearStandAttr, COMDAT
; _this$ = ecx

; 867  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 868  : 	if ( ((x<0)?FALSE:(x>(this->m_width-1))?FALSE:TRUE) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _x$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 37		 js	 SHORT $LN4@ClearStand
  0000e	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00011	33 d2		 xor	 edx, edx
  00013	48		 dec	 eax
  00014	3b f0		 cmp	 esi, eax
  00016	0f 9e c2	 setle	 dl
  00019	85 d2		 test	 edx, edx
  0001b	74 28		 je	 SHORT $LN4@ClearStand

; 869  : 	{
; 870  : 		return;
; 871  : 	}
; 872  : 
; 873  : 	if ( ((y<0)?FALSE:(y>(this->m_height-1))?FALSE:TRUE) == FALSE )

  0001d	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00020	85 d2		 test	 edx, edx
  00022	78 21		 js	 SHORT $LN4@ClearStand
  00024	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00027	33 c9		 xor	 ecx, ecx
  00029	48		 dec	 eax
  0002a	3b d0		 cmp	 edx, eax
  0002c	0f 9e c1	 setle	 cl
  0002f	85 c9		 test	 ecx, ecx
  00031	74 12		 je	 SHORT $LN4@ClearStand

; 874  : 	{
; 875  : 		return;
; 876  : 	}
; 877  : 
; 878  : 	if ( (this->m_attrbuf[y*256+x]&2)==2 )

  00033	c1 e2 08	 shl	 edx, 8
  00036	03 57 10	 add	 edx, DWORD PTR [edi+16]
  00039	8a 04 32	 mov	 al, BYTE PTR [edx+esi]
  0003c	a8 02		 test	 al, 2
  0003e	74 05		 je	 SHORT $LN4@ClearStand

; 879  : 	{
; 880  : 		this->m_attrbuf[y*256+x] &= 0xFD;

  00040	24 fd		 and	 al, 253			; 000000fdH
  00042	88 04 32	 mov	 BYTE PTR [edx+esi], al
$LN4@ClearStand:
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 881  : 	}
; 882  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
?ClearStandAttr@MapClass@@QAEXHH@Z ENDP			; MapClass::ClearStandAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?SetStandAttr@MapClass@@QAEXHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetStandAttr@MapClass@@QAEXHH@Z PROC			; MapClass::SetStandAttr, COMDAT
; _this$ = ecx

; 848  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 849  : 	if ( x > this->m_width-1 )

  00006	8b 75 08	 mov	 esi, DWORD PTR _x$[ebp]
  00009	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0000c	48		 dec	 eax
  0000d	3b f0		 cmp	 esi, eax
  0000f	7f 15		 jg	 SHORT $LN1@SetStandAt

; 850  : 	{
; 851  : 		return;
; 852  : 	}
; 853  : 
; 854  : 	if ( y > this->m_height-1 )

  00011	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00017	48		 dec	 eax
  00018	3b c8		 cmp	 ecx, eax
  0001a	7f 0a		 jg	 SHORT $LN1@SetStandAt

; 855  : 	{
; 856  : 		return;
; 857  : 	}
; 858  : 
; 859  : 	this->m_attrbuf[y*256+x] |= 2;

  0001c	c1 e1 08	 shl	 ecx, 8
  0001f	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00022	80 0c 31 02	 or	 BYTE PTR [ecx+esi], 2
$LN1@SetStandAt:
  00026	5e		 pop	 esi

; 860  : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?SetStandAttr@MapClass@@QAEXHH@Z ENDP			; MapClass::SetStandAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z
_TEXT	SEGMENT
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
_a$ = 24						; size = 4
?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z PROC	; MapClass::PathFinding4, COMDAT
; _this$ = ecx

; 1052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1053 : 	bool Success = this->path->FindPath3(sx, sy, tx, ty, true);

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _tx$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 14	 mov	 edi, DWORD PTR _ty$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	6a 01		 push	 1
  00010	57		 push	 edi
  00011	53		 push	 ebx
  00012	ff 75 0c	 push	 DWORD PTR _sy$[ebp]
  00015	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00018	ff 75 08	 push	 DWORD PTR _sx$[ebp]
  0001b	e8 00 00 00 00	 call	 ?FindPath3@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath3

; 1054 : 
; 1055 : 	if ( Success == false )

  00020	84 c0		 test	 al, al
  00022	75 16		 jne	 SHORT $LN19@PathFindin

; 1056 : 	{
; 1057 : 		Success = this->path->FindPath3(sx, sy, tx, ty, false);

  00024	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00027	6a 00		 push	 0
  00029	57		 push	 edi
  0002a	53		 push	 ebx
  0002b	ff 75 0c	 push	 DWORD PTR _sy$[ebp]
  0002e	ff 75 08	 push	 DWORD PTR _sx$[ebp]
  00031	e8 00 00 00 00	 call	 ?FindPath3@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath3

; 1058 : 	}
; 1059 : 
; 1060 : 	if ( Success != false )

  00036	84 c0		 test	 al, al
  00038	74 50		 je	 SHORT $LN7@PathFindin
$LN19@PathFindin:
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 761  : 		return this->NumPath;

  0003a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0003d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1064 : 		if ( lc3 > 1 )

  00040	83 fa 01	 cmp	 edx, 1
  00043	7e 45		 jle	 SHORT $LN7@PathFindin

; 1065 : 		{
; 1066 : 			a->PathNum = lc3;

  00045	8b 7d 18	 mov	 edi, DWORD PTR _a$[ebp]
  00048	89 17		 mov	 DWORD PTR [edi], edx
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 766  : 		return this->PathX;

  0004a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1070 : 			for (int n=0;n<a->PathNum;n++)

  0004d	33 f6		 xor	 esi, esi
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 766  : 		return this->PathX;

  0004f	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]

; 767  : 	};
; 768  : 
; 769  : 	unsigned char * GetPathY()	// line : 368
; 770  : 	{
; 771  : 		return this->PathY;

  00052	8d 88 00 02 00
	00		 lea	 ecx, DWORD PTR [eax+512]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1070 : 			for (int n=0;n<a->PathNum;n++)

  00058	85 d2		 test	 edx, edx
  0005a	7e 1e		 jle	 SHORT $LN3@PathFindin
  0005c	8d 57 40	 lea	 edx, DWORD PTR [edi+64]
  0005f	2b d9		 sub	 ebx, ecx
$LL4@PathFindin:

; 1071 : 			{
; 1072 : 				a->PathX[n] = px[n];

  00061	0f b6 04 0b	 movzx	 eax, BYTE PTR [ebx+ecx]
  00065	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  00068	89 42 c0	 mov	 DWORD PTR [edx-64], eax
  0006b	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 1073 : 				a->PathY[n] = py[n];

  0006e	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00072	46		 inc	 esi
  00073	89 42 fc	 mov	 DWORD PTR [edx-4], eax
  00076	3b 37		 cmp	 esi, DWORD PTR [edi]
  00078	7c e7		 jl	 SHORT $LL4@PathFindin
$LN3@PathFindin:

; 1074 : 			}
; 1075 : 
; 1076 : 			a->CurrentPath = 0;

  0007a	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], 0

; 1077 : 			return 1;

  00081	b0 01		 mov	 al, 1
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 1083 : }

  00086	5d		 pop	 ebp
  00087	c2 14 00	 ret	 20			; 00000014H
$LN7@PathFindin:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 1078 : 		}
; 1079 : 
; 1080 : 	}
; 1081 : 
; 1082 : 	return false;

  0008c	32 c0		 xor	 al, al
  0008e	5b		 pop	 ebx

; 1083 : }

  0008f	5d		 pop	 ebp
  00090	c2 14 00	 ret	 20			; 00000014H
?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ENDP	; MapClass::PathFinding4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z
_TEXT	SEGMENT
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
_a$ = 24						; size = 4
?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z PROC	; MapClass::PathFinding3, COMDAT
; _this$ = ecx

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1018 : 	bool Success = this->path->FindPath2(sx, sy, tx, ty, TRUE);

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _tx$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 14	 mov	 edi, DWORD PTR _ty$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	6a 01		 push	 1
  00010	57		 push	 edi
  00011	53		 push	 ebx
  00012	ff 75 0c	 push	 DWORD PTR _sy$[ebp]
  00015	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00018	ff 75 08	 push	 DWORD PTR _sx$[ebp]
  0001b	e8 00 00 00 00	 call	 ?FindPath2@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath2

; 1019 : 
; 1020 : 	if ( Success == false )

  00020	84 c0		 test	 al, al
  00022	75 16		 jne	 SHORT $LN19@PathFindin

; 1021 : 	{
; 1022 : 		Success = this->path->FindPath2(sx, sy, tx, ty, FALSE);

  00024	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00027	6a 00		 push	 0
  00029	57		 push	 edi
  0002a	53		 push	 ebx
  0002b	ff 75 0c	 push	 DWORD PTR _sy$[ebp]
  0002e	ff 75 08	 push	 DWORD PTR _sx$[ebp]
  00031	e8 00 00 00 00	 call	 ?FindPath2@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath2

; 1023 : 	}
; 1024 : 
; 1025 : 	if ( Success != false )

  00036	84 c0		 test	 al, al
  00038	74 50		 je	 SHORT $LN7@PathFindin
$LN19@PathFindin:
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 761  : 		return this->NumPath;

  0003a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0003d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1029 : 		if ( lc3 > 1 )

  00040	83 fa 01	 cmp	 edx, 1
  00043	7e 45		 jle	 SHORT $LN7@PathFindin

; 1030 : 		{
; 1031 : 			a->PathNum = lc3;

  00045	8b 7d 18	 mov	 edi, DWORD PTR _a$[ebp]
  00048	89 17		 mov	 DWORD PTR [edi], edx
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 766  : 		return this->PathX;

  0004a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1035 : 			for (int n=0;n<a->PathNum;n++)

  0004d	33 f6		 xor	 esi, esi
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 766  : 		return this->PathX;

  0004f	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]

; 767  : 	};
; 768  : 
; 769  : 	unsigned char * GetPathY()	// line : 368
; 770  : 	{
; 771  : 		return this->PathY;

  00052	8d 88 00 02 00
	00		 lea	 ecx, DWORD PTR [eax+512]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 1035 : 			for (int n=0;n<a->PathNum;n++)

  00058	85 d2		 test	 edx, edx
  0005a	7e 1e		 jle	 SHORT $LN3@PathFindin
  0005c	8d 57 40	 lea	 edx, DWORD PTR [edi+64]
  0005f	2b d9		 sub	 ebx, ecx
$LL4@PathFindin:

; 1036 : 			{
; 1037 : 				a->PathX[n] = px[n];

  00061	0f b6 04 0b	 movzx	 eax, BYTE PTR [ebx+ecx]
  00065	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  00068	89 42 c0	 mov	 DWORD PTR [edx-64], eax
  0006b	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 1038 : 				a->PathY[n] = py[n];

  0006e	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00072	46		 inc	 esi
  00073	89 42 fc	 mov	 DWORD PTR [edx-4], eax
  00076	3b 37		 cmp	 esi, DWORD PTR [edi]
  00078	7c e7		 jl	 SHORT $LL4@PathFindin
$LN3@PathFindin:

; 1039 : 			}
; 1040 : 
; 1041 : 			a->CurrentPath = 0;

  0007a	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], 0

; 1042 : 			return 1;

  00081	b0 01		 mov	 al, 1
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 1048 : }

  00086	5d		 pop	 ebp
  00087	c2 14 00	 ret	 20			; 00000014H
$LN7@PathFindin:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 1043 : 		}
; 1044 : 
; 1045 : 	}
; 1046 : 
; 1047 : 	return false;

  0008c	32 c0		 xor	 al, al
  0008e	5b		 pop	 ebx

; 1048 : }

  0008f	5d		 pop	 ebp
  00090	c2 14 00	 ret	 20			; 00000014H
?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ENDP	; MapClass::PathFinding3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z
_TEXT	SEGMENT
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
_a$ = 24						; size = 4
?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z PROC	; MapClass::PathFinding2, COMDAT
; _this$ = ecx

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 891  : 	bool Success = this->path->FindPath(sx, sy, tx, ty, true);

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _tx$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 14	 mov	 edi, DWORD PTR _ty$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	6a 01		 push	 1
  00010	57		 push	 edi
  00011	53		 push	 ebx
  00012	ff 75 0c	 push	 DWORD PTR _sy$[ebp]
  00015	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00018	ff 75 08	 push	 DWORD PTR _sx$[ebp]
  0001b	e8 00 00 00 00	 call	 ?FindPath@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath

; 892  : 
; 893  : 	if ( Success == false )

  00020	84 c0		 test	 al, al
  00022	75 16		 jne	 SHORT $LN19@PathFindin

; 894  : 	{
; 895  : 		Success = this->path->FindPath(sx, sy, tx, ty, false);

  00024	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00027	6a 00		 push	 0
  00029	57		 push	 edi
  0002a	53		 push	 ebx
  0002b	ff 75 0c	 push	 DWORD PTR _sy$[ebp]
  0002e	ff 75 08	 push	 DWORD PTR _sx$[ebp]
  00031	e8 00 00 00 00	 call	 ?FindPath@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath

; 896  : 	}
; 897  : 
; 898  : 	if ( Success != false )

  00036	84 c0		 test	 al, al
  00038	74 50		 je	 SHORT $LN7@PathFindin
$LN19@PathFindin:
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 761  : 		return this->NumPath;

  0003a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0003d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 902  : 		if ( path > 1 )

  00040	83 fa 01	 cmp	 edx, 1
  00043	7e 45		 jle	 SHORT $LN7@PathFindin

; 903  : 		{
; 904  : 			a->PathNum = path;

  00045	8b 7d 18	 mov	 edi, DWORD PTR _a$[ebp]
  00048	89 17		 mov	 DWORD PTR [edi], edx
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 766  : 		return this->PathX;

  0004a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 908  : 			for (int n=0;n<a->PathNum;n++)

  0004d	33 f6		 xor	 esi, esi
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 766  : 		return this->PathX;

  0004f	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]

; 767  : 	};
; 768  : 
; 769  : 	unsigned char * GetPathY()	// line : 368
; 770  : 	{
; 771  : 		return this->PathY;

  00052	8d 88 00 02 00
	00		 lea	 ecx, DWORD PTR [eax+512]
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 908  : 			for (int n=0;n<a->PathNum;n++)

  00058	85 d2		 test	 edx, edx
  0005a	7e 1e		 jle	 SHORT $LN3@PathFindin
  0005c	8d 57 40	 lea	 edx, DWORD PTR [edi+64]
  0005f	2b d9		 sub	 ebx, ecx
$LL4@PathFindin:

; 909  : 			{
; 910  : 				a->PathX[n] = px[n];

  00061	0f b6 04 0b	 movzx	 eax, BYTE PTR [ebx+ecx]
  00065	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  00068	89 42 c0	 mov	 DWORD PTR [edx-64], eax
  0006b	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 911  : 				a->PathY[n] = py[n];

  0006e	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00072	46		 inc	 esi
  00073	89 42 fc	 mov	 DWORD PTR [edx-4], eax
  00076	3b 37		 cmp	 esi, DWORD PTR [edi]
  00078	7c e7		 jl	 SHORT $LL4@PathFindin
$LN3@PathFindin:

; 912  : 			}
; 913  : 
; 914  : 			a->CurrentPath = 0;

  0007a	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], 0

; 915  : 			return 1;

  00081	b0 01		 mov	 al, 1
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 921  : }

  00086	5d		 pop	 ebp
  00087	c2 14 00	 ret	 20			; 00000014H
$LN7@PathFindin:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 916  : 		}
; 917  : 
; 918  : 	}
; 919  : 
; 920  : 	return false;

  0008c	32 c0		 xor	 al, al
  0008e	5b		 pop	 ebx

; 921  : }

  0008f	5d		 pop	 ebp
  00090	c2 14 00	 ret	 20			; 00000014H
?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ENDP	; MapClass::PathFinding2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?StateSetDestroy@MapClass@@QAEXXZ
_TEXT	SEGMENT
_CurTime$1$ = -4					; size = 4
?StateSetDestroy@MapClass@@QAEXXZ PROC			; MapClass::StateSetDestroy, COMDAT
; _this$ = ecx

; 661  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b d9		 mov	 ebx, ecx

; 662  : 	DWORD CurTime = GetTickCount();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000f	89 45 fc	 mov	 DWORD PTR _CurTime$1$[ebp], eax
  00012	8d 73 24	 lea	 esi, DWORD PTR [ebx+36]
  00015	bf 2c 01 00 00	 mov	 edi, 300		; 0000012cH
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@StateSetDe:

; 665  : 	{
; 666  : 		if ( this->m_cItem[n].IsItem() != FALSE )

  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00027	85 c0		 test	 eax, eax
  00029	74 2c		 je	 SHORT $LN8@StateSetDe

; 667  : 		{
; 668  : 			if ( this->m_cItem[n].m_State == 1 )

  0002b	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  00031	83 f8 01	 cmp	 eax, 1
  00034	75 0c		 jne	 SHORT $LN6@StateSetDe

; 669  : 			{
; 670  : 				this->m_cItem[n].m_State = 2;

  00036	c7 86 d8 00 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+216], 2
  00040	eb 15		 jmp	 SHORT $LN8@StateSetDe
$LN6@StateSetDe:

; 671  : 			}
; 672  : 			else if ( this->m_cItem[n].m_State == 8 )

  00042	83 f8 08	 cmp	 eax, 8
  00045	75 10		 jne	 SHORT $LN8@StateSetDe

; 673  : 			{
; 674  : 				this->m_cItem[n].Clear();

  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 675  : 				this->m_cItem[n].live = 0;

  0004e	66 c7 86 d6 00
	00 00 00 01	 mov	 WORD PTR [esi+214], 256	; 00000100H
$LN8@StateSetDe:

; 676  : 				this->m_cItem[n].Give = 1;
; 677  : 			}
; 678  : 		}
; 679  : 
; 680  : 		if ( this->m_cItem[n].IsItem() != FALSE )

  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	85 c0		 test	 eax, eax
  00060	74 6d		 je	 SHORT $LN2@StateSetDe

; 681  : 		{
; 682  : 			if ( this->m_cItem[n].m_State != 8 )

  00062	83 be d8 00 00
	00 08		 cmp	 DWORD PTR [esi+216], 8
  00069	74 64		 je	 SHORT $LN2@StateSetDe

; 683  : 			{
; 684  : 				if ( CurTime > this->m_cItem[n].m_Time )

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _CurTime$1$[ebp]
  0006e	3b 86 dc 00 00
	00		 cmp	 eax, DWORD PTR [esi+220]
  00074	76 59		 jbe	 SHORT $LN2@StateSetDe

; 685  : 				{
; 686  : 					LogAddTD(lMsg.Get(MSGGET(4, 76)), this->m_cItem[n].GetName(), this->m_cItem[n].m_Type, this->m_cItem[n].m_Level, this->m_cItem[n].m_Special[0] , this->m_cItem[n].m_Number);

  00076	ff 36		 push	 DWORD PTR [esi]
  00078	0f b7 46 32	 movzx	 eax, WORD PTR [esi+50]
  0007c	8b ce		 mov	 ecx, esi
  0007e	50		 push	 eax
  0007f	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]
  00083	50		 push	 eax
  00084	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0008e	50		 push	 eax
  0008f	68 4c 04 00 00	 push	 1100			; 0000044cH
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00099	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 687  : 					this->m_cItem[n].m_State = 8;
; 688  : 
; 689  : 					if( this->m_cItem[n].m_Type == ITEMGET(14,64) )

  000a5	b8 40 1c 00 00	 mov	 eax, 7232		; 00001c40H
  000aa	c7 86 d8 00 00
	00 08 00 00 00	 mov	 DWORD PTR [esi+216], 8
  000b4	83 c4 18	 add	 esp, 24			; 00000018H
  000b7	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  000bb	75 12		 jne	 SHORT $LN2@StateSetDe

; 690  : 					{
; 691  : 						g_IllusionTemple.SetStatueTime(this->thisMapNumber);

  000bd	0f b6 83 24 38
	05 00		 movzx	 eax, BYTE PTR [ebx+342052]
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?SetStatueTime@CIllusionTempleEvent@@QAEXE@Z ; CIllusionTempleEvent::SetStatueTime
$LN2@StateSetDe:

; 663  : 
; 664  : 	for (int n=0;n<MAX_MAPITEM;n++)

  000cf	81 c6 74 04 00
	00		 add	 esi, 1140		; 00000474H
  000d5	83 ef 01	 sub	 edi, 1
  000d8	0f 85 42 ff ff
	ff		 jne	 $LL4@StateSetDe
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 692  : 					}
; 693  : 				}
; 694  : 			}
; 695  : 		}
; 696  : 	}
; 697  : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?StateSetDestroy@MapClass@@QAEXXZ ENDP			; MapClass::StateSetDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?SetWeather@MapClass@@QAEXEE@Z
_TEXT	SEGMENT
_weather$ = 8						; size = 1
_a_weather$ = 8						; size = 1
_a_variation$ = 12					; size = 1
?SetWeather@MapClass@@QAEXEE@Z PROC			; MapClass::SetWeather, COMDAT
; _this$ = ecx

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 240  : 	LPOBJ lpObj;
; 241  : 	BYTE weather;
; 242  : 	int n;
; 243  : 
; 244  : 	this->m_Weather = a_weather;

  00003	8a 55 08	 mov	 dl, BYTE PTR _a_weather$[ebp]

; 245  : 	this->m_WeatherVariation = a_variation;

  00006	8a 45 0c	 mov	 al, BYTE PTR _a_variation$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 246  : 	weather = this->m_Weather * 16;	// like << 4
; 247  : 	weather |= this->m_WeatherVariation;
; 248  : 	
; 249  : 	for ( n=OBJ_STARTUSERINDEX ; n<OBJMAX ; n++ )

  0000e	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00013	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  00018	88 53 04	 mov	 BYTE PTR [ebx+4], dl
  0001b	c0 e2 04	 shl	 dl, 4
  0001e	0a d0		 or	 dl, al
  00020	88 43 05	 mov	 BYTE PTR [ebx+5], al
  00023	88 55 08	 mov	 BYTE PTR _weather$[ebp], dl
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@SetWeather:

; 250  : 	{
; 251  : 		lpObj = &gObj[n];

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 252  : 
; 253  : 		if ( lpObj->Connected > PLAYER_CONNECTED && lpObj->Live != 0 && lpObj->MapNumber == this->thisMapNumber )

  00035	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1
  0003a	7e 23		 jle	 SHORT $LN2@SetWeather
  0003c	80 7c 06 51 00	 cmp	 BYTE PTR [esi+eax+81], 0
  00041	74 1c		 je	 SHORT $LN2@SetWeather
  00043	0f b6 84 06 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+291]
  0004b	3b 83 24 38 05
	00		 cmp	 eax, DWORD PTR [ebx+342052]
  00051	75 0c		 jne	 SHORT $LN2@SetWeather

; 254  : 		{
; 255  : 			CGWeatherSend(n, weather);

  00053	ff 75 08	 push	 DWORD PTR _weather$[ebp]
  00056	57		 push	 edi
  00057	e8 00 00 00 00	 call	 ?CGWeatherSend@@YAXHE@Z	; CGWeatherSend
  0005c	83 c4 08	 add	 esp, 8
$LN2@SetWeather:

; 246  : 	weather = this->m_Weather * 16;	// like << 4
; 247  : 	weather |= this->m_WeatherVariation;
; 248  : 	
; 249  : 	for ( n=OBJ_STARTUSERINDEX ; n<OBJMAX ; n++ )

  0005f	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00065	47		 inc	 edi
  00066	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0006c	7c c2		 jl	 SHORT $LL4@SetWeather
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 256  : 		}
; 257  : 	}
; 258  : }

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
?SetWeather@MapClass@@QAEXEE@Z ENDP			; MapClass::SetWeather
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?GetWeather@MapClass@@QAEEXZ
_TEXT	SEGMENT
?GetWeather@MapClass@@QAEEXZ PROC			; MapClass::GetWeather, COMDAT
; _this$ = ecx

; 230  : 	BYTE weather = this->m_Weather *16;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	c0 e0 04	 shl	 al, 4

; 231  : 	weather |= this->m_WeatherVariation ;

  00006	0a 41 05	 or	 al, BYTE PTR [ecx+5]

; 232  : 	return weather;
; 233  : }

  00009	c3		 ret	 0
?GetWeather@MapClass@@QAEEXZ ENDP			; MapClass::GetWeather
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?WeatherVariationProcess@MapClass@@QAEXXZ
_TEXT	SEGMENT
_weather$ = -4						; size = 1
?WeatherVariationProcess@MapClass@@QAEXXZ PROC		; MapClass::WeatherVariationProcess, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 262  : 	LPOBJ lpObj;
; 263  : 	BYTE weather;
; 264  : 
; 265  : 	if ( (GetTickCount() - this->m_WeatherTimer) > this->m_NextWeatherTimer)

  00006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0000c	8b d9		 mov	 ebx, ecx
  0000e	ff d6		 call	 esi
  00010	2b 43 08	 sub	 eax, DWORD PTR [ebx+8]
  00013	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  00016	0f 86 93 00 00
	00		 jbe	 $LN3@WeatherVar

; 266  : 	{
; 267  : 		this->m_WeatherTimer = GetTickCount();

  0001c	57		 push	 edi
  0001d	ff d6		 call	 esi
  0001f	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 268  : 		this->m_NextWeatherTimer = (rand()%10000) + 10000;

  00022	e8 00 00 00 00	 call	 _rand
  00027	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0002c	99		 cdq
  0002d	f7 f9		 idiv	 ecx
  0002f	03 d1		 add	 edx, ecx
  00031	89 53 0c	 mov	 DWORD PTR [ebx+12], edx

; 269  : 		this->m_WeatherVariation = rand()%10;

  00034	e8 00 00 00 00	 call	 _rand
  00039	99		 cdq
  0003a	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0003f	f7 f9		 idiv	 ecx
  00041	88 53 05	 mov	 BYTE PTR [ebx+5], dl

; 270  : 		this->m_Weather = rand()%3;

  00044	e8 00 00 00 00	 call	 _rand
  00049	99		 cdq
  0004a	b9 03 00 00 00	 mov	 ecx, 3
  0004f	f7 f9		 idiv	 ecx

; 271  : 
; 272  : 		weather = this->m_Weather*16;
; 273  : 		weather |= this->m_WeatherVariation;
; 274  : 
; 275  : 		for (int n=OBJ_STARTUSERINDEX ; n<OBJMAX ; n++ )

  00051	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00056	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  0005b	88 53 04	 mov	 BYTE PTR [ebx+4], dl
  0005e	c0 e2 04	 shl	 dl, 4
  00061	0a 53 05	 or	 dl, BYTE PTR [ebx+5]
  00064	88 55 fc	 mov	 BYTE PTR _weather$[ebp], dl
  00067	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@WeatherVar:

; 276  : 		{
; 277  : 			lpObj = &gObj[n];

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 278  : 
; 279  : 			if ( lpObj->Connected > PLAYER_CONNECTED && lpObj->Live != 0 && lpObj->MapNumber == this->thisMapNumber )

  00075	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1
  0007a	7e 23		 jle	 SHORT $LN2@WeatherVar
  0007c	80 7c 06 51 00	 cmp	 BYTE PTR [esi+eax+81], 0
  00081	74 1c		 je	 SHORT $LN2@WeatherVar
  00083	0f b6 84 06 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+291]
  0008b	3b 83 24 38 05
	00		 cmp	 eax, DWORD PTR [ebx+342052]
  00091	75 0c		 jne	 SHORT $LN2@WeatherVar

; 280  : 			{
; 281  : 				CGWeatherSend(n, weather);

  00093	ff 75 fc	 push	 DWORD PTR _weather$[ebp]
  00096	57		 push	 edi
  00097	e8 00 00 00 00	 call	 ?CGWeatherSend@@YAXHE@Z	; CGWeatherSend
  0009c	83 c4 08	 add	 esp, 8
$LN2@WeatherVar:

; 271  : 
; 272  : 		weather = this->m_Weather*16;
; 273  : 		weather |= this->m_WeatherVariation;
; 274  : 
; 275  : 		for (int n=OBJ_STARTUSERINDEX ; n<OBJMAX ; n++ )

  0009f	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  000a5	47		 inc	 edi
  000a6	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  000ac	7c c2		 jl	 SHORT $LL4@WeatherVar
  000ae	5f		 pop	 edi
$LN3@WeatherVar:
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 282  : 			}
; 283  : 		}
; 284  : 	}
; 285  : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?WeatherVariationProcess@MapClass@@QAEXXZ ENDP		; MapClass::WeatherVariationProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?MoneyItemDrop@MapClass@@QAEHHHH@Z
_TEXT	SEGMENT
_money$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?MoneyItemDrop@MapClass@@QAEHHHH@Z PROC			; MapClass::MoneyItemDrop, COMDAT
; _this$ = ecx

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 458  : 	int count;
; 459  : 	int counttot = 0;
; 460  : 
; 461  : 	BYTE attr = this->GetAttr(x, y);

  00005	ff 75 10	 push	 DWORD PTR _y$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	33 ff		 xor	 edi, edi
  0000c	ff 75 0c	 push	 DWORD PTR _x$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00014	a8 0c		 test	 al, 12			; 0000000cH

; 462  : 
; 463  : 	if ( (attr&4) == 4 || (attr&8) == 8 )

  00016	0f 85 e0 00 00
	00		 jne	 $LN5@MoneyItemD

; 466  : 	}
; 467  : 
; 468  : 	count = this->m_ItemCount;

  0001c	56		 push	 esi
  0001d	8b b3 10 38 05
	00		 mov	 esi, DWORD PTR [ebx+342032]

; 469  : 
; 470  : 	while ( true )
; 471  : 	{
; 472  : 		if ( this->m_cItem[count].IsItem() == FALSE )

  00023	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00026	69 c6 74 04 00
	00		 imul	 eax, esi, 1140
  0002c	03 c8		 add	 ecx, eax
  0002e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00033	85 c0		 test	 eax, eax
  00035	74 2d		 je	 SHORT $LN12@MoneyItemD
$LL2@MoneyItemD:

; 492  : 		}
; 493  : 
; 494  : 		count++;

  00037	46		 inc	 esi

; 495  : 
; 496  : 		if ( count > MAX_MAPITEM-1 )

  00038	33 c0		 xor	 eax, eax
  0003a	81 fe 2b 01 00
	00		 cmp	 esi, 299		; 0000012bH
  00040	0f 4f f0	 cmovg	 esi, eax

; 497  : 		{
; 498  : 			count = 0;
; 499  : 		}
; 500  : 
; 501  : 		counttot++;

  00043	47		 inc	 edi

; 502  : 
; 503  : 		if ( counttot > MAX_MAPITEM-1 )

  00044	81 ff 2b 01 00
	00		 cmp	 edi, 299		; 0000012bH
  0004a	0f 8f a3 00 00
	00		 jg	 $LN13@MoneyItemD

; 469  : 
; 470  : 	while ( true )
; 471  : 	{
; 472  : 		if ( this->m_cItem[count].IsItem() == FALSE )

  00050	69 c6 74 04 00
	00		 imul	 eax, esi, 1140
  00056	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00059	03 c8		 add	 ecx, eax
  0005b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00060	85 c0		 test	 eax, eax
  00062	75 d3		 jne	 SHORT $LL2@MoneyItemD
$LN12@MoneyItemD:

; 473  : 		{
; 474  : 			this->m_cItem[count].m_Type = ITEMGET(14,15);

  00064	69 f6 74 04 00
	00		 imul	 esi, esi, 1140
  0006a	b8 0f 1c 00 00	 mov	 eax, 7183		; 00001c0fH
  0006f	03 f3		 add	 esi, ebx
  00071	66 89 46 2a	 mov	 WORD PTR [esi+42], ax

; 475  : 			this->m_cItem[count].m_SellMoney = money;

  00075	8b 45 08	 mov	 eax, DWORD PTR _money$[ebp]
  00078	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax

; 476  : 			this->m_cItem[count].m_BuyMoney = money;

  0007e	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax

; 477  : 			this->m_cItem[count].px = x;

  00084	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00087	88 86 f8 00 00
	00		 mov	 BYTE PTR [esi+248], al

; 478  : 			this->m_cItem[count].py = y;

  0008d	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00090	88 86 f9 00 00
	00		 mov	 BYTE PTR [esi+249], al

; 479  : 			this->m_cItem[count].live = 1;

  00096	66 c7 86 fa 00
	00 00 01 00	 mov	 WORD PTR [esi+250], 1

; 480  : 			this->m_cItem[count].Give = 0;
; 481  : 			this->m_cItem[count].m_State = 1;

  0009f	c7 86 fc 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+252], 1

; 482  : 			this->m_cItem[count].m_Time = GetTickCount() + ::gZenDurationTime * 1000;

  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000af	69 0d 00 00 00
	00 e8 03 00 00	 imul	 ecx, DWORD PTR ?gZenDurationTime@@3HA, 1000 ; gZenDurationTime

; 483  : 			this->m_cItem[count].m_LootTime = 0;

  000b9	c7 86 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+264], 0
  000c3	03 c1		 add	 eax, ecx
  000c5	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax

; 484  : 			this->m_ItemCount++;

  000cb	ff 83 10 38 05
	00		 inc	 DWORD PTR [ebx+342032]

; 485  : 
; 486  : 			if ( this->m_ItemCount > MAX_MAPITEM-1 )

  000d1	81 bb 10 38 05
	00 2b 01 00 00	 cmp	 DWORD PTR [ebx+342032], 299 ; 0000012bH
  000db	7e 0a		 jle	 SHORT $LN7@MoneyItemD

; 487  : 			{
; 488  : 				this->m_ItemCount = 0;

  000dd	c7 83 10 38 05
	00 00 00 00 00	 mov	 DWORD PTR [ebx+342032], 0
$LN7@MoneyItemD:
  000e7	5e		 pop	 esi
  000e8	5f		 pop	 edi

; 489  : 			}
; 490  : 
; 491  : 			return TRUE;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	5b		 pop	 ebx

; 506  : 		}
; 507  : 	}
; 508  : 
; 509  : 	return FALSE;
; 510  : }

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH
$LN13@MoneyItemD:
  000f3	5e		 pop	 esi
  000f4	5f		 pop	 edi

; 504  : 		{
; 505  : 			return FALSE;

  000f5	33 c0		 xor	 eax, eax
  000f7	5b		 pop	 ebx

; 506  : 		}
; 507  : 	}
; 508  : 
; 509  : 	return FALSE;
; 510  : }

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN5@MoneyItemD:
  000fc	5f		 pop	 edi

; 464  : 	{
; 465  : 		return FALSE;

  000fd	33 c0		 xor	 eax, eax
  000ff	5b		 pop	 ebx

; 506  : 		}
; 507  : 	}
; 508  : 
; 509  : 	return FALSE;
; 510  : }

  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
?MoneyItemDrop@MapClass@@QAEHHHH@Z ENDP			; MapClass::MoneyItemDrop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEPAEE@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_level$ = 12						; size = 4
_dur$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_Option1$ = 28						; size = 1
_Option2$ = 32						; size = 1
_Option3$ = 36						; size = 1
_NOption$ = 40						; size = 1
_SOption$ = 44						; size = 1
_aIndex$ = 48						; size = 4
_number$ = 52						; size = 4
_ItemEffectEx$ = 56					; size = 1
_SocketOption$ = 60					; size = 4
_SocketBonus$ = 64					; size = 1
?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEPAEE@Z PROC	; MapClass::MonsterItemDrop, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 311  : 	int count;
; 312  : 	int counttot=0;
; 313  : 	BYTE attr = this->GetAttr(x, y);

  00005	ff 75 18	 push	 DWORD PTR _y$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	33 f6		 xor	 esi, esi
  0000c	ff 75 14	 push	 DWORD PTR _x$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00014	a8 0c		 test	 al, 12			; 0000000cH

; 314  : 
; 315  : 	if ( (attr & 4) == 4  || (attr & 8) == 8 )

  00016	0f 85 e6 00 00
	00		 jne	 $LN5@MonsterIte

; 318  : 	}
; 319  : 	count = this->m_ItemCount;

  0001c	57		 push	 edi
  0001d	8b bb 10 38 05
	00		 mov	 edi, DWORD PTR [ebx+342032]

; 320  : 
; 321  : 	while ( true )
; 322  : 	{
; 323  : 		if ( this->m_cItem[count].IsItem() == FALSE )

  00023	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00026	69 c7 74 04 00
	00		 imul	 eax, edi, 1140
  0002c	03 c8		 add	 ecx, eax
  0002e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00033	85 c0		 test	 eax, eax
  00035	74 2d		 je	 SHORT $LN12@MonsterIte
$LL2@MonsterIte:

; 335  : 
; 336  : 		}
; 337  : 
; 338  : 		count++;

  00037	47		 inc	 edi

; 339  : 
; 340  : 		if ( count > MAX_MAPITEM-1 )

  00038	33 c0		 xor	 eax, eax
  0003a	81 ff 2b 01 00
	00		 cmp	 edi, 299		; 0000012bH
  00040	0f 4f f8	 cmovg	 edi, eax

; 341  : 		{
; 342  : 			count = 0;
; 343  : 		}
; 344  : 
; 345  : 		counttot++;

  00043	46		 inc	 esi

; 346  : 
; 347  : 		if ( counttot > MAX_MAPITEM-1 )

  00044	81 fe 2b 01 00
	00		 cmp	 esi, 299		; 0000012bH
  0004a	0f 8f 85 00 00
	00		 jg	 $LN13@MonsterIte

; 320  : 
; 321  : 	while ( true )
; 322  : 	{
; 323  : 		if ( this->m_cItem[count].IsItem() == FALSE )

  00050	69 c7 74 04 00
	00		 imul	 eax, edi, 1140
  00056	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00059	03 c8		 add	 ecx, eax
  0005b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00060	85 c0		 test	 eax, eax
  00062	75 d3		 jne	 SHORT $LL2@MonsterIte
$LN12@MonsterIte:

; 324  : 		{
; 325  : 			this->m_cItem[count].CreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number, ItemEffectEx,SocketOption,SocketBonus);

  00064	ff 75 40	 push	 DWORD PTR _SocketBonus$[ebp]
  00067	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _dur$[ebp]
  0006c	ff 75 3c	 push	 DWORD PTR _SocketOption$[ebp]
  0006f	69 f7 74 04 00
	00		 imul	 esi, edi, 1140
  00075	ff 75 38	 push	 DWORD PTR _ItemEffectEx$[ebp]
  00078	ff 75 34	 push	 DWORD PTR _number$[ebp]
  0007b	ff 75 2c	 push	 DWORD PTR _SOption$[ebp]
  0007e	ff 75 28	 push	 DWORD PTR _NOption$[ebp]
  00081	ff 75 24	 push	 DWORD PTR _Option3$[ebp]
  00084	ff 75 20	 push	 DWORD PTR _Option2$[ebp]
  00087	ff 75 1c	 push	 DWORD PTR _Option1$[ebp]
  0008a	51		 push	 ecx
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  00093	ff 75 18	 push	 DWORD PTR _y$[ebp]
  00096	03 ce		 add	 ecx, esi
  00098	ff 75 14	 push	 DWORD PTR _x$[ebp]
  0009b	ff 75 0c	 push	 DWORD PTR _level$[ebp]
  0009e	ff 75 08	 push	 DWORD PTR _type$[ebp]
  000a1	e8 00 00 00 00	 call	 ?CreateItem@CMapItem@@QAEXHHHHMEEEEEKEPAEE@Z ; CMapItem::CreateItem

; 326  : 			this->m_cItem[count].m_UserIndex = aIndex;

  000a6	8b 4d 30	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000a9	89 8c 1e 04 01
	00 00		 mov	 DWORD PTR [esi+ebx+260], ecx

; 327  : 			this->m_ItemCount++;

  000b0	ff 83 10 38 05
	00		 inc	 DWORD PTR [ebx+342032]

; 328  : 
; 329  : 			if ( this->m_ItemCount > MAX_MAPITEM-1 )

  000b6	81 bb 10 38 05
	00 2b 01 00 00	 cmp	 DWORD PTR [ebx+342032], 299 ; 0000012bH
  000c0	7e 0a		 jle	 SHORT $LN7@MonsterIte

; 330  : 			{
; 331  : 				this->m_ItemCount = 0;

  000c2	c7 83 10 38 05
	00 00 00 00 00	 mov	 DWORD PTR [ebx+342032], 0
$LN7@MonsterIte:

; 332  : 			}
; 333  : 
; 334  : 			return count;

  000cc	8b c7		 mov	 eax, edi
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx

; 362  : }

  000d1	5d		 pop	 ebp
  000d2	c2 3c 00	 ret	 60			; 0000003cH
$LN13@MonsterIte:

; 348  : 		{
; 349  : 			break;
; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : #if( DEBUG_DROP == 1 )
; 354  : 	DROP_LOG_DEBUG.Output(LogAdd(lMsg.Get(MSGGET(1, 205)), __FILE__, __LINE__ );
; 355  : #else
; 356  : 	LogAdd(lMsg.Get(MSGGET(1, 205)), __FILE__, __LINE__ );

  000d5	68 64 01 00 00	 push	 356			; 00000164H
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@
  000df	68 cd 01 00 00	 push	 461			; 000001cdH
  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000e9	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000ee	50		 push	 eax
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 357  : #endif
; 358  : 
; 359  : 	
; 360  : 
; 361  : 	return -1;

  000f8	83 c8 ff	 or	 eax, -1
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 362  : }

  000fe	5d		 pop	 ebp
  000ff	c2 3c 00	 ret	 60			; 0000003cH
$LN5@MonsterIte:
  00102	5e		 pop	 esi

; 316  : 	{
; 317  : 		return -1;

  00103	83 c8 ff	 or	 eax, -1
  00106	5b		 pop	 ebx

; 362  : }

  00107	5d		 pop	 ebp
  00108	c2 3c 00	 ret	 60			; 0000003cH
?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEPAEE@Z ENDP	; MapClass::MonsterItemDrop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_level$ = 12						; size = 4
_dur$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_Option1$ = 28						; size = 1
_Option2$ = 32						; size = 1
_Option3$ = 36						; size = 1
_NOption$ = 40						; size = 1
_SOption$ = 44						; size = 1
_number$ = 48						; size = 4
_aIndex$ = 52						; size = 4
_PetLevel$ = 56						; size = 4
_PetExp$ = 60						; size = 4
_ItemEffectEx$ = 64					; size = 1
_SocketOption$ = 68					; size = 4
_SocketBonus$ = 72					; size = 1
?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z PROC	; MapClass::ItemDrop, COMDAT
; _this$ = ecx

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 372  : 	int count;
; 373  : 	int counttot = 0;
; 374  : 	BYTE attr = this->GetAttr(x, y);

  00005	ff 75 18	 push	 DWORD PTR _y$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	33 ff		 xor	 edi, edi
  0000c	ff 75 14	 push	 DWORD PTR _x$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00014	a8 0c		 test	 al, 12			; 0000000cH

; 375  : 
; 376  : 	if ( (attr&4) == 4 || (attr&8) == 8 )

  00016	0f 85 7e 01 00
	00		 jne	 $LN5@ItemDrop

; 379  : 	}
; 380  : 
; 381  : 	count = this->m_ItemCount;

  0001c	56		 push	 esi
  0001d	8b b3 10 38 05
	00		 mov	 esi, DWORD PTR [ebx+342032]

; 382  : 
; 383  : 	while ( true )
; 384  : 	{
; 385  : 		if ( this->m_cItem[count].IsItem() == FALSE )

  00023	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00026	69 c6 74 04 00
	00		 imul	 eax, esi, 1140
  0002c	03 c8		 add	 ecx, eax
  0002e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00033	85 c0		 test	 eax, eax
  00035	74 2d		 je	 SHORT $LN24@ItemDrop
$LL2@ItemDrop:

; 427  : 		}
; 428  : 
; 429  : 		count++;

  00037	46		 inc	 esi

; 430  : 
; 431  : 		if ( count > MAX_MAPITEM-1 )

  00038	33 c0		 xor	 eax, eax
  0003a	81 fe 2b 01 00
	00		 cmp	 esi, 299		; 0000012bH
  00040	0f 4f f0	 cmovg	 esi, eax

; 432  : 		{
; 433  : 			count = 0;
; 434  : 		}
; 435  : 
; 436  : 		counttot++;

  00043	47		 inc	 edi

; 437  : 
; 438  : 		if ( counttot > MAX_MAPITEM-1 )

  00044	81 ff 2b 01 00
	00		 cmp	 edi, 299		; 0000012bH
  0004a	0f 8f 41 01 00
	00		 jg	 $LN25@ItemDrop

; 382  : 
; 383  : 	while ( true )
; 384  : 	{
; 385  : 		if ( this->m_cItem[count].IsItem() == FALSE )

  00050	69 c6 74 04 00
	00		 imul	 eax, esi, 1140
  00056	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00059	03 c8		 add	 ecx, eax
  0005b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00060	85 c0		 test	 eax, eax
  00062	75 d3		 jne	 SHORT $LL2@ItemDrop
$LN24@ItemDrop:

; 386  : 		{
; 387  : 			this->m_cItem[count].DropCreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number, PetLevel, PetExp, ItemEffectEx,SocketOption,SocketBonus);

  00064	ff 75 48	 push	 DWORD PTR _SocketBonus$[ebp]
  00067	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _dur$[ebp]
  0006c	ff 75 44	 push	 DWORD PTR _SocketOption$[ebp]
  0006f	8b 7d 0c	 mov	 edi, DWORD PTR _level$[ebp]
  00072	ff 75 40	 push	 DWORD PTR _ItemEffectEx$[ebp]
  00075	69 f6 74 04 00
	00		 imul	 esi, esi, 1140
  0007b	ff 75 3c	 push	 DWORD PTR _PetExp$[ebp]
  0007e	ff 75 38	 push	 DWORD PTR _PetLevel$[ebp]
  00081	ff 75 30	 push	 DWORD PTR _number$[ebp]
  00084	ff 75 2c	 push	 DWORD PTR _SOption$[ebp]
  00087	ff 75 28	 push	 DWORD PTR _NOption$[ebp]
  0008a	ff 75 24	 push	 DWORD PTR _Option3$[ebp]
  0008d	ff 75 20	 push	 DWORD PTR _Option2$[ebp]
  00090	ff 75 1c	 push	 DWORD PTR _Option1$[ebp]
  00093	51		 push	 ecx
  00094	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00099	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  0009c	ff 75 18	 push	 DWORD PTR _y$[ebp]
  0009f	03 ce		 add	 ecx, esi
  000a1	ff 75 14	 push	 DWORD PTR _x$[ebp]
  000a4	57		 push	 edi
  000a5	ff 75 08	 push	 DWORD PTR _type$[ebp]
  000a8	e8 00 00 00 00	 call	 ?DropCreateItem@CMapItem@@QAEXHHHHMEEEEEKHHEPAEE@Z ; CMapItem::DropCreateItem

; 388  : 			this->m_cItem[count].m_UserIndex = aIndex;

  000ad	8b 45 34	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000b0	89 84 1e 04 01
	00 00		 mov	 DWORD PTR [esi+ebx+260], eax

; 389  : 			this->m_ItemCount++;

  000b7	ff 83 10 38 05
	00		 inc	 DWORD PTR [ebx+342032]

; 390  : 
; 391  : 			if ( this->m_ItemCount > MAX_MAPITEM-1 )

  000bd	81 bb 10 38 05
	00 2b 01 00 00	 cmp	 DWORD PTR [ebx+342032], 299 ; 0000012bH
  000c7	7e 0a		 jle	 SHORT $LN7@ItemDrop

; 392  : 			{
; 393  : 				this->m_ItemCount = 0;

  000c9	c7 83 10 38 05
	00 00 00 00 00	 mov	 DWORD PTR [ebx+342032], 0
$LN7@ItemDrop:

; 394  : 			}
; 395  : 
; 396  : 			if ( BC_MAP_RANGE(this->thisMapNumber) != FALSE )

  000d3	8b 8b 24 38 05
	00		 mov	 ecx, DWORD PTR [ebx+342052]
  000d9	83 f9 34	 cmp	 ecx, 52			; 00000034H
  000dc	74 19		 je	 SHORT $LN28@ItemDrop
  000de	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000e1	0f 8c 9e 00 00
	00		 jl	 $LN13@ItemDrop
  000e7	33 c0		 xor	 eax, eax
  000e9	83 f9 11	 cmp	 ecx, 17			; 00000011H
  000ec	0f 9e c0	 setle	 al
  000ef	85 c0		 test	 eax, eax
  000f1	0f 84 8e 00 00
	00		 je	 $LN13@ItemDrop
$LN28@ItemDrop:

; 397  : 			{
; 398  : 				if ( type == ITEMGET(13,19) )

  000f7	81 7d 08 13 1a
	00 00		 cmp	 DWORD PTR _type$[ebp], 6675 ; 00001a13H
  000fe	0f 85 81 00 00
	00		 jne	 $LN13@ItemDrop

; 399  : 				{
; 400  : 					if ( ((level<0)?FALSE:(level>2)?FALSE:TRUE) != FALSE )

  00104	85 ff		 test	 edi, edi
  00106	78 7d		 js	 SHORT $LN13@ItemDrop
  00108	33 c0		 xor	 eax, eax
  0010a	83 ff 02	 cmp	 edi, 2
  0010d	0f 9e c0	 setle	 al
  00110	85 c0		 test	 eax, eax
  00112	74 71		 je	 SHORT $LN13@ItemDrop

; 401  : 					{
; 402  : 						int iBridgeIndex = g_BloodCastle.GetBridgeLevel(this->thisMapNumber);

  00114	51		 push	 ecx
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0011a	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  0011f	8b f8		 mov	 edi, eax

; 403  : 
; 404  : 						if ( g_BloodCastle.m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1 )

  00121	69 f7 0c 02 00
	00		 imul	 esi, edi, 524
  00127	8b 8e 90 01 00
	00		 mov	 ecx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[esi+400]
  0012d	83 f9 ff	 cmp	 ecx, -1
  00130	74 53		 je	 SHORT $LN13@ItemDrop

; 405  : 						{
; 406  : 							if ( number == g_BloodCastle.m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL )

  00132	39 4d 30	 cmp	 DWORD PTR _number$[ebp], ecx
  00135	75 4e		 jne	 SHORT $LN13@ItemDrop

; 407  : 							{
; 408  : 								if ( g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX != -1 )

  00137	8b 86 94 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[esi+404]
  0013d	83 f8 ff	 cmp	 eax, -1
  00140	74 43		 je	 SHORT $LN13@ItemDrop

; 409  : 								{
; 410  : 									LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Dropped Angel King's Weapon (%d)",

  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00148	69 d0 40 27 00
	00		 imul	 edx, eax, 10048
  0014e	0f b6 86 98 01
	00 00		 movzx	 eax, BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[esi+408]
  00155	50		 push	 eax
  00156	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00159	03 c2		 add	 eax, edx
  0015b	50		 push	 eax
  0015c	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0015f	03 c2		 add	 eax, edx
  00161	50		 push	 eax
  00162	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00165	50		 push	 eax
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00171	83 c4 14	 add	 esp, 20			; 00000014H

; 411  : 										iBridgeIndex+1, gObj[g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX ].AccountID,
; 412  : 										gObj[g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX].Name,
; 413  : 										g_BloodCastle.m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER);
; 414  : 									
; 415  : 									g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  00174	c7 86 94 01 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[esi+404], -1

; 416  : 									g_BloodCastle.m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER = 0;

  0017e	c6 86 98 01 00
	00 00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[esi+408], 0
$LN13@ItemDrop:

; 417  : 
; 418  : 									
; 419  : 								}
; 420  : 							}
; 421  : 						}
; 422  : 					}
; 423  : 				}
; 424  : 			}
; 425  : 
; 426  : 			return TRUE;

  00185	5e		 pop	 esi
  00186	5f		 pop	 edi
  00187	b8 01 00 00 00	 mov	 eax, 1
  0018c	5b		 pop	 ebx

; 441  : 		}
; 442  : 	}
; 443  : 
; 444  : 	LogAdd(lMsg.Get(MSGGET(1, 205)), __FILE__, __LINE__ );
; 445  : 
; 446  : 	return FALSE;
; 447  : }

  0018d	5d		 pop	 ebp
  0018e	c2 44 00	 ret	 68			; 00000044H
$LN25@ItemDrop:
  00191	5e		 pop	 esi
  00192	5f		 pop	 edi

; 439  : 		{
; 440  : 			return FALSE;

  00193	33 c0		 xor	 eax, eax
  00195	5b		 pop	 ebx

; 441  : 		}
; 442  : 	}
; 443  : 
; 444  : 	LogAdd(lMsg.Get(MSGGET(1, 205)), __FILE__, __LINE__ );
; 445  : 
; 446  : 	return FALSE;
; 447  : }

  00196	5d		 pop	 ebp
  00197	c2 44 00	 ret	 68			; 00000044H
$LN5@ItemDrop:
  0019a	5f		 pop	 edi

; 377  : 	{
; 378  : 		return false;

  0019b	33 c0		 xor	 eax, eax
  0019d	5b		 pop	 ebx

; 441  : 		}
; 442  : 	}
; 443  : 
; 444  : 	LogAdd(lMsg.Get(MSGGET(1, 205)), __FILE__, __LINE__ );
; 445  : 
; 446  : 	return FALSE;
; 447  : }

  0019e	5d		 pop	 ebp
  0019f	c2 44 00	 ret	 68			; 00000044H
?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z ENDP	; MapClass::ItemDrop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?ClearItem@MapClass@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_distance$ = 12						; size = 4
?ClearItem@MapClass@@QAEHPAUOBJECTSTRUCT@@H@Z PROC	; MapClass::ClearItem, COMDAT
; _this$ = ecx

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	8b c1		 mov	 eax, ecx

; 627  : 	int itemcount = 0;

  0000a	33 db		 xor	 ebx, ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 628  : 
; 629  : 	for(int i = 0; i < this->m_ItemCount; i++)

  0000e	33 ff		 xor	 edi, edi
  00010	89 44 24 0c	 mov	 DWORD PTR _this$1$[esp+16], eax
  00014	39 98 10 38 05
	00		 cmp	 DWORD PTR [eax+342032], ebx
  0001a	0f 8e 99 00 00
	00		 jle	 $LN19@ClearItem

; 627  : 	int itemcount = 0;

  00020	8d b0 f8 00 00
	00		 lea	 esi, DWORD PTR [eax+248]
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@ClearItem:

; 630  : 	{
; 631  : 		CMapItem * lpMapItem = &this->m_cItem[i];
; 632  : 
; 633  : 		if ( lpMapItem->IsItem() != FALSE )

  00030	8d 8e 2c ff ff
	ff		 lea	 ecx, DWORD PTR [esi-212]
  00036	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003b	85 c0		 test	 eax, eax
  0003d	74 63		 je	 SHORT $LN2@ClearItem

; 634  : 		{
; 635  : 			if ( lpMapItem->Give == 0 && lpMapItem->live != 0)

  0003f	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00043	75 5d		 jne	 SHORT $LN2@ClearItem
  00045	80 7e 02 00	 cmp	 BYTE PTR [esi+2], 0
  00049	74 57		 je	 SHORT $LN2@ClearItem

; 636  : 			{
; 637  : 				if(gLootingTime > 0)

  0004b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLootingTime@@3HA, 0 ; gLootingTime
  00052	7e 4e		 jle	 SHORT $LN2@ClearItem

; 638  : 				{
; 639  : 					int tx = lpObj->X - lpMapItem->px;

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00057	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0005a	0f b6 91 20 01
	00 00		 movzx	 edx, BYTE PTR [ecx+288]

; 640  : 					int ty = lpObj->Y - lpMapItem->py;

  00061	0f b6 89 21 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+289]
  00068	2b d0		 sub	 edx, eax
  0006a	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0006e	2b c8		 sub	 ecx, eax

; 642  : 					int dis = sqrt((float) (tx*tx+ty*ty));

  00070	0f af d2	 imul	 edx, edx
  00073	0f af c9	 imul	 ecx, ecx
  00076	03 ca		 add	 ecx, edx
  00078	66 0f 6e c1	 movd	 xmm0, ecx
  0007c	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  0007f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00082	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00087	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 642  : 					int dis = sqrt((float) (tx*tx+ty*ty));

  0008b	f3 0f 2c c0	 cvttss2si eax, xmm0

; 643  : 
; 644  : 					if( dis <= distance)

  0008f	3b 45 0c	 cmp	 eax, DWORD PTR _distance$[ebp]
  00092	7f 0e		 jg	 SHORT $LN2@ClearItem

; 645  : 					{
; 646  : 						lpMapItem->m_State = 8;

  00094	c7 46 04 08 00
	00 00		 mov	 DWORD PTR [esi+4], 8

; 647  : 						lpMapItem->Give = true;
; 648  : 						lpMapItem->live = false;
; 649  : 
; 650  : 						itemcount++;

  0009b	43		 inc	 ebx
  0009c	66 c7 46 02 00
	01		 mov	 WORD PTR [esi+2], 256	; 00000100H
$LN2@ClearItem:

; 628  : 
; 629  : 	for(int i = 0; i < this->m_ItemCount; i++)

  000a2	8b 44 24 0c	 mov	 eax, DWORD PTR _this$1$[esp+16]
  000a6	47		 inc	 edi
  000a7	81 c6 74 04 00
	00		 add	 esi, 1140		; 00000474H
  000ad	3b b8 10 38 05
	00		 cmp	 edi, DWORD PTR [eax+342032]
  000b3	0f 8c 77 ff ff
	ff		 jl	 $LL4@ClearItem
$LN19@ClearItem:

; 651  : 					}
; 652  : 				}	
; 653  : 			}
; 654  : 		}
; 655  : 	}
; 656  : 
; 657  : 	return itemcount;
; 658  : }

  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	8b c3		 mov	 eax, ebx
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 08 00	 ret	 8
?ClearItem@MapClass@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP	; MapClass::ClearItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?ItemGive@MapClass@@QAEHHH_N@Z
_TEXT	SEGMENT
_disy$1$ = -264						; size = 4
_szTemp$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item_num$ = 12						; size = 4
_bFailNotSend$ = 16					; size = 1
?ItemGive@MapClass@@QAEHHH_N@Z PROC			; MapClass::ItemGive, COMDAT
; _this$ = ecx

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 0c	 mov	 edx, DWORD PTR _item_num$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx

; 518  : 	if ( ((item_num<0)?FALSE:(item_num>MAX_MAPITEM-1)?FALSE:TRUE) == FALSE ) 

  0001d	85 d2		 test	 edx, edx
  0001f	0f 88 29 02 00
	00		 js	 $LN35@ItemGive
  00025	33 c0		 xor	 eax, eax
  00027	81 fa 2b 01 00
	00		 cmp	 edx, 299		; 0000012bH
  0002d	0f 9e c0	 setle	 al
  00030	85 c0		 test	 eax, eax
  00032	0f 84 16 02 00
	00		 je	 $LN35@ItemGive

; 521  : 		return FALSE;
; 522  : 	}
; 523  : 
; 524  : 	if ( gObj[aIndex].MapNumber != this->thisMapNumber )

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	57		 push	 edi
  0003e	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00044	03 c7		 add	 eax, edi
  00046	0f b6 88 23 01
	00 00		 movzx	 ecx, BYTE PTR [eax+291]
  0004d	3b 8e 24 38 05
	00		 cmp	 ecx, DWORD PTR [esi+342052]
  00053	74 3d		 je	 SHORT $LN3@ItemGive

; 525  : 	{
; 526  : 		LogAdd(lMsg.Get(MSGGET(1, 207)), __FILE__, __LINE__, gObj[aIndex].MapNumber, gObj[aIndex].Name);

  00055	83 c0 5d	 add	 eax, 93			; 0000005dH
  00058	50		 push	 eax
  00059	51		 push	 ecx
  0005a	68 0e 02 00 00	 push	 526			; 0000020eH
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@
  00064	68 cf 01 00 00	 push	 463			; 000001cfH
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0006e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00073	50		 push	 eax
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0007a	83 c4 14	 add	 esp, 20			; 00000014H
$LN25@ItemGive:

; 533  : 		return FALSE;

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	33 c0		 xor	 eax, eax
  00081	5b		 pop	 ebx

; 620  : 	}
; 621  : }

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 0c 00	 ret	 12			; 0000000cH
$LN3@ItemGive:

; 527  : 		return FALSE;
; 528  : 	}
; 529  : 
; 530  : 	if ( this->m_cItem[item_num].IsItem() == FALSE )

  00092	69 c2 74 04 00
	00		 imul	 eax, edx, 1140
  00098	03 f0		 add	 esi, eax
  0009a	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0009d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000a2	85 c0		 test	 eax, eax
  000a4	75 30		 jne	 SHORT $LN4@ItemGive

; 531  : 	{
; 532  : 		LogAdd(lMsg.Get(MSGGET(1, 208)), __FILE__, __LINE__,gObj[aIndex].Name);	// Apply Deathway Fix herw

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000b0	83 c0 5d	 add	 eax, 93			; 0000005dH
  000b3	03 c7		 add	 eax, edi
  000b5	50		 push	 eax
  000b6	68 14 02 00 00	 push	 532			; 00000214H
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@
  000c0	68 d0 01 00 00	 push	 464			; 000001d0H
  000c5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000ca	50		 push	 eax
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d1	83 c4 10	 add	 esp, 16			; 00000010H

; 533  : 		return FALSE;

  000d4	eb a7		 jmp	 SHORT $LN25@ItemGive
$LN4@ItemGive:

; 534  : 	}
; 535  : 
; 536  : 	if ( this->m_cItem[item_num].Give == true )

  000d6	80 be fb 00 00
	00 01		 cmp	 BYTE PTR [esi+251], 1
  000dd	74 9e		 je	 SHORT $LN25@ItemGive

; 537  : 	{
; 538  : 		return FALSE;
; 539  : 	}
; 540  : 
; 541  : 	if ( this->m_cItem[item_num].live == false )

  000df	80 be fa 00 00
	00 00		 cmp	 BYTE PTR [esi+250], 0
  000e6	74 95		 je	 SHORT $LN25@ItemGive

; 542  : 	{
; 543  : 		return FALSE;
; 544  : 	}
; 545  : 
; 546  : 	int disx = this->m_cItem[item_num].px - gObj[aIndex].X;

  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	0f b6 96 f8 00
	00 00		 movzx	 edx, BYTE PTR [esi+248]
  000f5	0f b6 84 39 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edi+288]
  000fd	2b d0		 sub	 edx, eax

; 547  : 	int disy = this->m_cItem[item_num].py - gObj[aIndex].Y;

  000ff	0f b6 86 f9 00
	00 00		 movzx	 eax, BYTE PTR [esi+249]
  00106	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _disy$1$[ebp], eax
  0010c	0f b6 84 39 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edi+289]
  00114	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _disy$1$[ebp]
  0011a	2b c8		 sub	 ecx, eax

; 548  : 
; 549  : 	if ( disx > 2 || disx < -2 )

  0011c	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0011f	83 f8 04	 cmp	 eax, 4
  00122	0f 87 55 ff ff
	ff		 ja	 $LN25@ItemGive

; 550  : 	{
; 551  : 		return FALSE;
; 552  : 	}
; 553  : 
; 554  : 	if ( disy > 2 || disy < -2 )

  00128	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  0012b	83 f8 04	 cmp	 eax, 4
  0012e	0f 87 49 ff ff
	ff		 ja	 $LN25@ItemGive

; 555  : 	{
; 556  : 		return FALSE;
; 557  : 	}
; 558  : 
; 559  : 	int lootresult = 1;
; 560  : 
; 561  : 	if ( gLootingTime > 0 )

  00134	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLootingTime@@3HA, 0 ; gLootingTime
  0013b	0f 8e e2 00 00
	00		 jle	 $LN23@ItemGive

; 562  : 	{
; 563  : 		if ( this->m_cItem[item_num].m_UserIndex != -1 )

  00141	83 be 04 01 00
	00 ff		 cmp	 DWORD PTR [esi+260], -1
  00148	0f 84 d5 00 00
	00		 je	 $LN23@ItemGive

; 564  : 		{
; 565  : 			if ( GetTickCount() < this->m_cItem[item_num].m_LootTime )

  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00154	3b 86 08 01 00
	00		 cmp	 eax, DWORD PTR [esi+264]
  0015a	0f 83 c3 00 00
	00		 jae	 $LN23@ItemGive

; 566  : 			{
; 567  : 				if ( aIndex != this->m_cItem[item_num].m_UserIndex )

  00160	8b 86 04 01 00
	00		 mov	 eax, DWORD PTR [esi+260]
  00166	3b d8		 cmp	 ebx, eax
  00168	0f 84 b5 00 00
	00		 je	 $LN23@ItemGive

; 568  : 				{
; 569  : 					lootresult = 0;
; 570  : 
; 571  : 					if ( this->m_cItem[item_num].m_QuestItem == false )

  0016e	80 be cd 00 00
	00 00		 cmp	 BYTE PTR [esi+205], 0
  00175	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017b	75 62		 jne	 SHORT $LN36@ItemGive

; 572  : 					{
; 573  : 						if ( gObj[aIndex].PartyNumber >= 0 )

  0017d	8b 8c 17 0c 06
	00 00		 mov	 ecx, DWORD PTR [edi+edx+1548]
  00184	85 c9		 test	 ecx, ecx
  00186	78 57		 js	 SHORT $LN36@ItemGive

; 574  : 						{
; 575  : 							if ( gObj[aIndex].PartyNumber == gObj[this->m_cItem[item_num].m_UserIndex].PartyNumber )

  00188	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0018e	3b 8c 10 0c 06
	00 00		 cmp	 ecx, DWORD PTR [eax+edx+1548]
  00195	75 48		 jne	 SHORT $LN36@ItemGive

; 576  : 							{
; 577  : 								if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  00197	8a 84 17 23 01
	00 00		 mov	 al, BYTE PTR [edi+edx+291]
  0019e	3c 34		 cmp	 al, 52			; 00000034H
  001a0	74 0f		 je	 SHORT $LN37@ItemGive
  001a2	3c 0b		 cmp	 al, 11			; 0000000bH
  001a4	72 7d		 jb	 SHORT $LN23@ItemGive
  001a6	b1 11		 mov	 cl, 17			; 00000011H
  001a8	3a c8		 cmp	 cl, al
  001aa	1b c0		 sbb	 eax, eax
  001ac	83 c0 01	 add	 eax, 1
  001af	74 72		 je	 SHORT $LN23@ItemGive
$LN37@ItemGive:

; 578  : 								{
; 579  : 									if ( this->m_cItem[item_num].m_Type == ITEMGET(12,15) ||( this->m_cItem[item_num].m_Type == ITEMGET(13,19) && ((this->m_cItem[item_num].m_Level < 0)?FALSE:(this->m_cItem[item_num].m_Level > 2)?FALSE:TRUE) != FALSE ) )

  001b1	0f b7 46 2a	 movzx	 eax, WORD PTR [esi+42]
  001b5	b9 0f 18 00 00	 mov	 ecx, 6159		; 0000180fH
  001ba	66 3b c1	 cmp	 ax, cx
  001bd	74 20		 je	 SHORT $LN36@ItemGive
  001bf	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  001c4	66 3b c1	 cmp	 ax, cx
  001c7	75 5a		 jne	 SHORT $LN23@ItemGive
  001c9	0f b7 4e 2c	 movzx	 ecx, WORD PTR [esi+44]
  001cd	66 85 c9	 test	 cx, cx
  001d0	78 51		 js	 SHORT $LN23@ItemGive
  001d2	33 c0		 xor	 eax, eax
  001d4	66 83 f9 02	 cmp	 cx, 2
  001d8	0f 9e c0	 setle	 al
  001db	85 c0		 test	 eax, eax
  001dd	74 44		 je	 SHORT $LN23@ItemGive
$LN36@ItemGive:

; 580  : 									{
; 581  : 										lootresult = 0;
; 582  : 									}
; 583  : 									else
; 584  : 									{
; 585  : 										lootresult = 1;
; 586  : 									}
; 587  : 								}
; 588  : 								else
; 589  : 								{
; 590  : 									lootresult = 1;
; 591  : 								}
; 592  : 							}
; 593  : 						}
; 594  : 					}
; 595  : 				}
; 596  : 			}
; 597  : 		}
; 598  : 	}
; 599  : 
; 600  : 	if ( lootresult == 0 )
; 601  : 	{
; 602  : 		if ( bFailNotSend == false )

  001df	80 7d 10 00	 cmp	 BYTE PTR _bFailNotSend$[ebp], 0
  001e3	0f 85 94 fe ff
	ff		 jne	 $LN25@ItemGive

; 603  : 		{
; 604  : 			char szTemp[256];
; 605  : 
; 606  : 			wsprintf(szTemp, lMsg.Get(MSGGET(4, 128)), gObj[aIndex].Name );

  001e9	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001f1	03 c7		 add	 eax, edi
  001f3	50		 push	 eax
  001f4	68 80 04 00 00	 push	 1152			; 00000480H
  001f9	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001fe	50		 push	 eax
  001ff	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  00205	50		 push	 eax
  00206	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 607  : 			::GCServerMsgStringSend(szTemp, aIndex, 1);

  0020c	6a 01		 push	 1
  0020e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  00214	53		 push	 ebx
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0021b	83 c4 18	 add	 esp, 24			; 00000018H

; 608  : 			
; 609  : 		}
; 610  : 
; 611  : 		return FALSE;

  0021e	e9 5a fe ff ff	 jmp	 $LN25@ItemGive
$LN23@ItemGive:
  00223	5f		 pop	 edi

; 612  : 	}
; 613  : 	else
; 614  : 	{
; 615  : 		this->m_cItem[item_num].m_State = 8;

  00224	c7 86 fc 00 00
	00 08 00 00 00	 mov	 DWORD PTR [esi+252], 8

; 616  : 		this->m_cItem[item_num].Give = true;
; 617  : 		this->m_cItem[item_num].live = false;
; 618  : 
; 619  : 		return TRUE;

  0022e	b8 01 00 00 00	 mov	 eax, 1
  00233	66 c7 86 fa 00
	00 00 00 01	 mov	 WORD PTR [esi+250], 256	; 00000100H
  0023c	5e		 pop	 esi
  0023d	5b		 pop	 ebx

; 620  : 	}
; 621  : }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	33 cd		 xor	 ecx, ebp
  00243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00248	8b e5		 mov	 esp, ebp
  0024a	5d		 pop	 ebp
  0024b	c2 0c 00	 ret	 12			; 0000000cH
$LN35@ItemGive:

; 519  : 	{
; 520  : 		LogAdd(lMsg.Get(MSGGET(1, 206)), __FILE__, __LINE__);

  0024e	68 08 02 00 00	 push	 520			; 00000208H
  00253	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@
  00258	68 ce 01 00 00	 push	 462			; 000001ceH
  0025d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00262	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00267	50		 push	 eax
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 620  : 	}
; 621  : }

  0026e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00271	83 c4 0c	 add	 esp, 12			; 0000000cH
  00274	33 cd		 xor	 ecx, ebp
  00276	33 c0		 xor	 eax, eax
  00278	5e		 pop	 esi
  00279	5b		 pop	 ebx
  0027a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027f	8b e5		 mov	 esp, ebp
  00281	5d		 pop	 ebp
  00282	c2 0c 00	 ret	 12			; 0000000cH
?ItemGive@MapClass@@QAEHHH_N@Z ENDP			; MapClass::ItemGive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?ItemInit@MapClass@@QAEXXZ
_TEXT	SEGMENT
?ItemInit@MapClass@@QAEXXZ PROC				; MapClass::ItemInit, COMDAT
; _this$ = ecx

; 302  : 	return; // Here goes a Macro
; 303  : }

  00000	c3		 ret	 0
?ItemInit@MapClass@@QAEXXZ ENDP				; MapClass::ItemInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?CheckWall2@MapClass@@QAEEHHHH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_d2$1$ = 8						; size = 4
_sx1$ = 8						; size = 4
_len1$1$ = 12						; size = 4
_sy1$ = 12						; size = 4
_d1$1$ = 16						; size = 4
_sx2$ = 16						; size = 4
_start$1$ = 20						; size = 4
_sy2$ = 20						; size = 4
?CheckWall2@MapClass@@QAEEHHHH@Z PROC			; MapClass::CheckWall2, COMDAT
; _this$ = ecx

; 1088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1089 : 	int Index = TERRAIN_INDEX_REPEAT(sx1,sy1);

  00006	8b 75 08	 mov	 esi, DWORD PTR _sx1$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _sy1$[ebp]
  0000d	57		 push	 edi
  0000e	56		 push	 esi
  0000f	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00012	e8 00 00 00 00	 call	 ?TERRAIN_INDEX_REPEAT@@YAHHH@Z ; TERRAIN_INDEX_REPEAT

; 1090 : 	int nx1;
; 1091 : 	int ny1;
; 1092 : 	int d1;
; 1093 : 	int d2;
; 1094 : 	int len1;
; 1095 : 	int len2;
; 1096 : 	int px1 = sx2 - sx1;
; 1097 : 	int py1 = sy2 - sy1;

  00017	8b 5d 14	 mov	 ebx, DWORD PTR _sy2$[ebp]
  0001a	8b c8		 mov	 ecx, eax
  0001c	8b 45 10	 mov	 eax, DWORD PTR _sx2$[ebp]
  0001f	83 c4 08	 add	 esp, 8
  00022	2b df		 sub	 ebx, edi
  00024	2b c6		 sub	 eax, esi

; 1098 : 
; 1099 : 	if ( px1 < 0 )

  00026	79 07		 jns	 SHORT $LN5@CheckWall2

; 1100 : 	{
; 1101 : 		px1 = -px1;

  00028	f7 d8		 neg	 eax

; 1102 : 		nx1 = -1;

  0002a	83 cf ff	 or	 edi, -1

; 1103 : 	}
; 1104 : 	else

  0002d	eb 05		 jmp	 SHORT $LN24@CheckWall2
$LN5@CheckWall2:

; 1105 : 	{
; 1106 : 		nx1 = 1;

  0002f	bf 01 00 00 00	 mov	 edi, 1
$LN24@CheckWall2:
  00034	89 7d 08	 mov	 DWORD PTR _d2$1$[ebp], edi

; 1107 : 	}
; 1108 : 
; 1109 : 	if ( py1 < 0 )

  00037	85 db		 test	 ebx, ebx
  00039	79 09		 jns	 SHORT $LN7@CheckWall2

; 1110 : 	{
; 1111 : 		py1 = -py1;

  0003b	f7 db		 neg	 ebx

; 1112 : 		ny1 = -256;

  0003d	be 00 ff ff ff	 mov	 esi, -256		; ffffff00H

; 1113 : 	}
; 1114 : 	else

  00042	eb 05		 jmp	 SHORT $LN8@CheckWall2
$LN7@CheckWall2:

; 1115 : 	{
; 1116 : 		ny1 = 256;

  00044	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN8@CheckWall2:

; 1117 : 	}
; 1118 : 
; 1119 : 	if ( px1 > py1 )

  00049	3b c3		 cmp	 eax, ebx
  0004b	7e 0a		 jle	 SHORT $LN9@CheckWall2

; 1120 : 	{
; 1121 : 		len1 = px1;

  0004d	8b d0		 mov	 edx, eax

; 1122 : 		len2= py1;
; 1123 : 		d1 = ny1;

  0004f	89 75 10	 mov	 DWORD PTR _d1$1$[ebp], esi
  00052	89 55 0c	 mov	 DWORD PTR _len1$1$[ebp], edx

; 1124 : 		d2 = nx1;
; 1125 : 	}
; 1126 : 	else

  00055	eb 0d		 jmp	 SHORT $LN10@CheckWall2
$LN9@CheckWall2:

; 1127 : 	{
; 1128 : 		len1 = py1;

  00057	8b d3		 mov	 edx, ebx
  00059	89 5d 0c	 mov	 DWORD PTR _len1$1$[ebp], ebx

; 1129 : 		len2 = px1;

  0005c	8b d8		 mov	 ebx, eax

; 1130 : 		d1 = nx1;

  0005e	89 7d 10	 mov	 DWORD PTR _d1$1$[ebp], edi

; 1131 : 		d2 = ny1;

  00061	89 75 08	 mov	 DWORD PTR _d2$1$[ebp], esi
$LN10@CheckWall2:

; 1132 : 	}
; 1133 : 
; 1134 : 	int start = 0;

  00064	33 c0		 xor	 eax, eax

; 1135 : 	BOOL error = FALSE;

  00066	33 f6		 xor	 esi, esi
  00068	89 45 14	 mov	 DWORD PTR _start$1$[ebp], eax

; 1136 : 	int count = 0;

  0006b	33 ff		 xor	 edi, edi
  0006d	0f 1f 00	 npad	 3
$LL4@CheckWall2:

; 1137 : 	int Shadow = 0;
; 1138 : 
; 1139 : 	do
; 1140 : 	{
; 1141 : 		if ( start == 0 )

  00070	85 c0		 test	 eax, eax
  00072	75 17		 jne	 SHORT $LN11@CheckWall2

; 1142 : 		{
; 1143 : 			if ( (this->m_attrbuf[Index]&2) == 2 )

  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00077	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0007a	f6 04 01 02	 test	 BYTE PTR [ecx+eax], 2
  0007e	74 12		 je	 SHORT $LN12@CheckWall2

; 1144 : 			{
; 1145 : 				return 2;

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	b0 02		 mov	 al, 2
  00084	5b		 pop	 ebx

; 1172 : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 10 00	 ret	 16			; 00000010H
$LN11@CheckWall2:

; 1146 : 			}
; 1147 : 		}
; 1148 : 		else
; 1149 : 		{
; 1150 : 			start = 1;

  0008b	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _start$1$[ebp], 1
$LN12@CheckWall2:

; 1151 : 		}
; 1152 : 
; 1153 : 		if ( (this->m_attrbuf[Index]&4) == 4 )

  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00095	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00098	f6 04 01 04	 test	 BYTE PTR [ecx+eax], 4
  0009c	75 2d		 jne	 SHORT $LN20@CheckWall2

; 1156 : 		}
; 1157 : 
; 1158 : 		error +=len2;
; 1159 : 
; 1160 : 		if ( error > (len1/2) )

  0009e	8b c2		 mov	 eax, edx
  000a0	03 f3		 add	 esi, ebx
  000a2	99		 cdq
  000a3	2b c2		 sub	 eax, edx

; 1161 : 		{
; 1162 : 			Index += d1;
; 1163 : 			error -= len1;

  000a5	8b 55 0c	 mov	 edx, DWORD PTR _len1$1$[ebp]
  000a8	d1 f8		 sar	 eax, 1
  000aa	3b f0		 cmp	 esi, eax
  000ac	7e 05		 jle	 SHORT $LN15@CheckWall2
  000ae	03 4d 10	 add	 ecx, DWORD PTR _d1$1$[ebp]
  000b1	2b f2		 sub	 esi, edx
$LN15@CheckWall2:

; 1164 : 		}
; 1165 : 
; 1166 : 		Index += d2;

  000b3	03 4d 08	 add	 ecx, DWORD PTR _d2$1$[ebp]

; 1167 : 		count++;

  000b6	47		 inc	 edi

; 1168 : 	}
; 1169 : 	while ( count <= len1 );

  000b7	3b fa		 cmp	 edi, edx
  000b9	7f 05		 jg	 SHORT $LN19@CheckWall2
  000bb	8b 45 14	 mov	 eax, DWORD PTR _start$1$[ebp]
  000be	eb b0		 jmp	 SHORT $LL4@CheckWall2
$LN19@CheckWall2:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi

; 1170 : 	
; 1171 : 	return 1;

  000c2	b0 01		 mov	 al, 1
  000c4	5b		 pop	 ebx

; 1172 : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 10 00	 ret	 16			; 00000010H
$LN20@CheckWall2:
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi

; 1154 : 		{
; 1155 : 			return 4;

  000cd	b0 04		 mov	 al, 4
  000cf	5b		 pop	 ebx

; 1172 : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 10 00	 ret	 16			; 00000010H
?CheckWall2@MapClass@@QAEEHHHH@Z ENDP			; MapClass::CheckWall2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?CheckWall@MapClass@@QAEHHHHH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_d1$1$ = 8						; size = 4
_sx1$ = 8						; size = 4
_d2$1$ = 12						; size = 4
_sy1$ = 12						; size = 4
tv192 = 16						; size = 4
_sx2$ = 16						; size = 4
_sy2$ = 20						; size = 4
?CheckWall@MapClass@@QAEHHHHH@Z PROC			; MapClass::CheckWall, COMDAT
; _this$ = ecx

; 931  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 932  : 	int Index = TERRAIN_INDEX_REPEAT(sx1,sy1);

  00006	8b 75 08	 mov	 esi, DWORD PTR _sx1$[ebp]
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _sy1$[ebp]
  0000d	57		 push	 edi
  0000e	56		 push	 esi
  0000f	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00012	e8 00 00 00 00	 call	 ?TERRAIN_INDEX_REPEAT@@YAHHH@Z ; TERRAIN_INDEX_REPEAT

; 933  : 	int nx1;
; 934  : 	int ny1;
; 935  : 	int d1;
; 936  : 	int d2;
; 937  : 	int len1;
; 938  : 	int len2;
; 939  : 	int px1 = sx2 - sx1;

  00017	8b 55 10	 mov	 edx, DWORD PTR _sx2$[ebp]
  0001a	8b c8		 mov	 ecx, eax

; 940  : 	int py1 = sy2 - sy1;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _sy2$[ebp]
  0001f	83 c4 08	 add	 esp, 8
  00022	2b c7		 sub	 eax, edi
  00024	2b d6		 sub	 edx, esi
  00026	89 45 14	 mov	 DWORD PTR _sy2$[ebp], eax

; 941  : 
; 942  : 	if ( px1 < 0 )

  00029	79 07		 jns	 SHORT $LN5@CheckWall

; 943  : 	{
; 944  : 		px1 = -px1;

  0002b	f7 da		 neg	 edx

; 945  : 		nx1 = -1;

  0002d	83 ce ff	 or	 esi, -1

; 946  : 	}
; 947  : 	else

  00030	eb 05		 jmp	 SHORT $LN19@CheckWall
$LN5@CheckWall:

; 948  : 	{
; 949  : 		nx1 = 1;

  00032	be 01 00 00 00	 mov	 esi, 1
$LN19@CheckWall:
  00037	89 75 0c	 mov	 DWORD PTR _d2$1$[ebp], esi

; 950  : 	}
; 951  : 
; 952  : 	if ( py1 < 0 )

  0003a	85 c0		 test	 eax, eax
  0003c	79 0c		 jns	 SHORT $LN7@CheckWall

; 953  : 	{
; 954  : 		py1 = -py1;

  0003e	f7 d8		 neg	 eax

; 955  : 		ny1 = -256;

  00040	bf 00 ff ff ff	 mov	 edi, -256		; ffffff00H
  00045	89 45 14	 mov	 DWORD PTR _sy2$[ebp], eax

; 956  : 	}
; 957  : 	else

  00048	eb 05		 jmp	 SHORT $LN8@CheckWall
$LN7@CheckWall:

; 958  : 	{
; 959  : 		ny1 = 256;

  0004a	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
$LN8@CheckWall:

; 960  : 	}
; 961  : 
; 962  : 	if ( px1 > py1 )

  0004f	3b d0		 cmp	 edx, eax
  00051	7e 07		 jle	 SHORT $LN9@CheckWall

; 963  : 	{
; 964  : 		len1 = px1;

  00053	8b da		 mov	 ebx, edx

; 965  : 		len2= py1;
; 966  : 		d1 = ny1;

  00055	89 7d 08	 mov	 DWORD PTR _d1$1$[ebp], edi

; 967  : 		d2 = nx1;
; 968  : 	}
; 969  : 	else

  00058	eb 0d		 jmp	 SHORT $LN10@CheckWall
$LN9@CheckWall:

; 970  : 	{
; 971  : 		len1 = py1;

  0005a	8b d8		 mov	 ebx, eax

; 972  : 		len2 = px1;
; 973  : 		d1 = nx1;

  0005c	89 75 08	 mov	 DWORD PTR _d1$1$[ebp], esi
  0005f	8b c2		 mov	 eax, edx

; 974  : 		d2 = ny1;

  00061	89 7d 0c	 mov	 DWORD PTR _d2$1$[ebp], edi
  00064	89 45 14	 mov	 DWORD PTR _sy2$[ebp], eax
$LN10@CheckWall:

; 975  : 	}
; 976  : 
; 977  : 	int error = 0;
; 978  : 	int count = 0;
; 979  : 	int Shadow = 0;
; 980  : 
; 981  : 	do
; 982  : 	{
; 983  : 		if ( (this->m_attrbuf[Index]&4) == 4 )

  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  0006a	33 f6		 xor	 esi, esi
  0006c	33 ff		 xor	 edi, edi
  0006e	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  00071	89 55 10	 mov	 DWORD PTR tv192[ebp], edx
$LL4@CheckWall:
  00074	f6 04 0a 04	 test	 BYTE PTR [edx+ecx], 4
  00078	75 2e		 jne	 SHORT $LN15@CheckWall

; 986  : 		}
; 987  : 
; 988  : 		error += len2;

  0007a	03 f0		 add	 esi, eax

; 989  : 
; 990  : 		if ( error > len1/2 )

  0007c	8b c3		 mov	 eax, ebx
  0007e	99		 cdq
  0007f	2b c2		 sub	 eax, edx
  00081	d1 f8		 sar	 eax, 1
  00083	3b f0		 cmp	 esi, eax
  00085	7e 05		 jle	 SHORT $LN12@CheckWall

; 991  : 		{
; 992  : 			Index += d1;

  00087	03 4d 08	 add	 ecx, DWORD PTR _d1$1$[ebp]

; 993  : 			error -= len1;

  0008a	2b f3		 sub	 esi, ebx
$LN12@CheckWall:

; 994  : 		}
; 995  : 		
; 996  : 		Index += d2;

  0008c	03 4d 0c	 add	 ecx, DWORD PTR _d2$1$[ebp]

; 997  : 		count++;	

  0008f	47		 inc	 edi

; 998  : 	}
; 999  : 	while ( count <= len1 );

  00090	8b 45 14	 mov	 eax, DWORD PTR _sy2$[ebp]
  00093	8b 55 10	 mov	 edx, DWORD PTR tv192[ebp]
  00096	3b fb		 cmp	 edi, ebx
  00098	7e da		 jle	 SHORT $LL4@CheckWall

; 1000 : 
; 1001 : 	return TRUE;

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	b8 01 00 00 00	 mov	 eax, 1
  000a1	5b		 pop	 ebx

; 1002 : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 10 00	 ret	 16			; 00000010H
$LN15@CheckWall:
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi

; 984  : 		{
; 985  : 			return FALSE;

  000aa	33 c0		 xor	 eax, eax
  000ac	5b		 pop	 ebx

; 1002 : }

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 10 00	 ret	 16			; 00000010H
?CheckWall@MapClass@@QAEHHHHH@Z ENDP			; MapClass::CheckWall
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?LoadMapAttr@MapClass@@QAEXPADH@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_MapNumber$ = 12					; size = 4
?LoadMapAttr@MapClass@@QAEXPADH@Z PROC			; MapClass::LoadMapAttr, COMDAT
; _this$ = ecx

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 216  : 	if (this->AttrLoad(filename) == FALSE )

  00004	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?AttrLoad@MapClass@@QAEHPAD@Z ; MapClass::AttrLoad
  0000e	85 c0		 test	 eax, eax
  00010	75 18		 jne	 SHORT $LN2@LoadMapAtt

; 217  : 	{
; 218  : 		MsgBox( lMsg.Get( MSGGET ( 2, 52 )));

  00012	68 34 02 00 00	 push	 564			; 00000234H
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0001c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00027	83 c4 04	 add	 esp, 4
$LN2@LoadMapAtt:

; 219  : 	}
; 220  : 
; 221  : 	this->thisMapNumber = MapNumber;

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _MapNumber$[ebp]

; 222  : 	this->SetRegentRect( MapNumber );

  0002d	8b ce		 mov	 ecx, esi
  0002f	50		 push	 eax
  00030	89 86 24 38 05
	00		 mov	 DWORD PTR [esi+342052], eax
  00036	e8 00 00 00 00	 call	 ?SetRegentRect@MapClass@@QAEXH@Z ; MapClass::SetRegentRect
  0003b	5e		 pop	 esi

; 223  : }

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?LoadMapAttr@MapClass@@QAEXPADH@Z ENDP			; MapClass::LoadMapAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?AttrLoad@MapClass@@QAEHPAD@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_head$ = 11						; size = 1
?AttrLoad@MapClass@@QAEHPAD@Z PROC			; MapClass::AttrLoad, COMDAT
; _this$ = ecx

; 704  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 705  : 	FILE * fp;
; 706  : 	unsigned char head;
; 707  : 
; 708  : 	fp = fopen(filename,"rb");

  00005	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0000a	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  0000d	8b d9		 mov	 ebx, ecx
  0000f	e8 00 00 00 00	 call	 _fopen
  00014	8b f8		 mov	 edi, eax
  00016	83 c4 08	 add	 esp, 8

; 709  : 
; 710  : 	if ( fp == NULL )

  00019	85 ff		 test	 edi, edi
  0001b	75 06		 jne	 SHORT $LN2@AttrLoad
  0001d	5f		 pop	 edi
  0001e	5b		 pop	 ebx

; 737  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN2@AttrLoad:
  00023	56		 push	 esi

; 711  : 	{
; 712  : 		return false;
; 713  : 	}
; 714  : 	
; 715  : 	fread(&head, sizeof(head), 1, fp);

  00024	57		 push	 edi
  00025	6a 01		 push	 1
  00027	8d 45 0b	 lea	 eax, DWORD PTR _head$[ebp]
  0002a	6a 01		 push	 1
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _fread

; 716  : 	fread(&this->m_width, sizeof(char), 1, fp);

  00032	57		 push	 edi
  00033	6a 01		 push	 1
  00035	8d 73 14	 lea	 esi, DWORD PTR [ebx+20]
  00038	6a 01		 push	 1
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 _fread

; 717  : 	fread(&this->m_height, sizeof(char), 1, fp);

  00040	57		 push	 edi
  00041	6a 01		 push	 1
  00043	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  00046	6a 01		 push	 1
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _fread
  0004e	83 c4 30	 add	 esp, 48			; 00000030H

; 718  : 
; 719  : 	if ( this->m_width > 255 || this->m_height > 255 )

  00051	81 3e ff 00 00
	00		 cmp	 DWORD PTR [esi], 255	; 000000ffH
  00057	7f 7d		 jg	 SHORT $LN4@AttrLoad
  00059	81 7b 18 ff 00
	00 00		 cmp	 DWORD PTR [ebx+24], 255	; 000000ffH
  00060	7f 74		 jg	 SHORT $LN4@AttrLoad

; 724  : 	}
; 725  : 
; 726  : 	if ( this->m_attrbuf != NULL )

  00062	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00065	85 c0		 test	 eax, eax
  00067	74 0e		 je	 SHORT $LN5@AttrLoad

; 727  : 	{
; 728  : 		GlobalFree(this->m_attrbuf);

  00069	50		 push	 eax
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 729  : 		this->m_attrbuf = NULL;

  00070	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
$LN5@AttrLoad:

; 730  : 	}
; 731  : 
; 732  : 	this->m_attrbuf = (UCHAR*)GlobalAlloc(GPTR, 65536);

  00077	68 00 00 01 00	 push	 65536			; 00010000H
  0007c	6a 40		 push	 64			; 00000040H
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8

; 733  : 	fread(this->m_attrbuf, 256, 256, fp);

  00084	57		 push	 edi
  00085	68 00 01 00 00	 push	 256			; 00000100H
  0008a	68 00 01 00 00	 push	 256			; 00000100H
  0008f	50		 push	 eax
  00090	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00093	e8 00 00 00 00	 call	 _fread

; 734  : 	fclose(fp);

  00098	57		 push	 edi
  00099	e8 00 00 00 00	 call	 _fclose

; 735  : 	this->path->SetMapDimensions( 256, 256, (UCHAR *)this->m_attrbuf);

  0009e	8b 73 1c	 mov	 esi, DWORD PTR [ebx+28]
  000a1	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h

; 756  : 		this->HitMap = new unsigned char [this->Width * this->Height];

  000a4	68 00 00 01 00	 push	 65536			; 00010000H
  000a9	c7 06 00 01 00
	00		 mov	 DWORD PTR [esi], 256	; 00000100H
  000af	c7 46 04 00 01
	00 00		 mov	 DWORD PTR [esi+4], 256	; 00000100H
  000b6	89 86 3c 04 00
	00		 mov	 DWORD PTR [esi+1084], eax
  000bc	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000c1	83 c4 18	 add	 esp, 24			; 00000018H
  000c4	89 86 40 04 00
	00		 mov	 DWORD PTR [esi+1088], eax
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp

; 736  : 	return true;

  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	5e		 pop	 esi
  000d0	5f		 pop	 edi
  000d1	5b		 pop	 ebx

; 737  : }

  000d2	5d		 pop	 ebp
  000d3	c2 04 00	 ret	 4
$LN4@AttrLoad:

; 720  : 	{
; 721  : 		MsgBox(lMsg.Get( MSGGET(2, 51)));

  000d6	68 33 02 00 00	 push	 563			; 00000233H
  000db	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000e0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 722  : 		fclose(fp);

  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 _fclose
  000f1	83 c4 08	 add	 esp, 8

; 723  : 		return false;

  000f4	33 c0		 xor	 eax, eax
  000f6	5e		 pop	 esi
  000f7	5f		 pop	 edi
  000f8	5b		 pop	 ebx

; 737  : }

  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?AttrLoad@MapClass@@QAEHPAD@Z ENDP			; MapClass::AttrLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?SearchStandAttr@MapClass@@QAEXAAE0@Z
_TEXT	SEGMENT
_ty$1$ = -8						; size = 4
tv216 = -4						; size = 4
tv213 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SearchStandAttr@MapClass@@QAEXAAE0@Z PROC		; MapClass::SearchStandAttr, COMDAT
; _this$ = ecx

; 810  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 811  : 	int scount = 10;
; 812  : 	int tx;
; 813  : 	int ty;
; 814  : 	int tindex;
; 815  : 	int subx = 1;
; 816  : 
; 817  : 	tx = x;

  00006	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 818  : 	ty = y;
; 819  : 	tindex = y * 256;
; 820  : 
; 821  : 	if ( (tx-10) < 0 )
; 822  : 	{
; 823  : 		subx = 1;
; 824  : 	}
; 825  : 
; 826  : 	if ( (tx+10) > 255 )

  0000d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR tv216[ebp], -1
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0001a	57		 push	 edi
  0001b	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00020	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00023	8b d1		 mov	 edx, ecx
  00025	89 4d f8	 mov	 DWORD PTR _ty$1$[ebp], ecx
  00028	c1 e2 08	 shl	 edx, 8
  0002b	8d 48 f6	 lea	 ecx, DWORD PTR [eax-10]
  0002e	85 c9		 test	 ecx, ecx
  00030	8d 5f f7	 lea	 ebx, DWORD PTR [edi-9]
  00033	8d 48 0a	 lea	 ecx, DWORD PTR [eax+10]
  00036	0f 48 db	 cmovs	 ebx, ebx
  00039	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH

; 827  : 	{
; 828  : 		subx = -1;
; 829  : 	}
; 830  : 
; 831  : 	while ( scount-- != 0 )
; 832  : 	{
; 833  : 		if ( ((this->m_attrbuf[tindex + tx]&4)!= 4) && ((this->m_attrbuf[tindex + tx]&2)!= 2) && ((this->m_attrbuf[tindex + tx]&8)!= 8) )

  0003f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00042	0f 4f 5d fc	 cmovg	 ebx, DWORD PTR tv216[ebp]
  00046	03 ca		 add	 ecx, edx
$LL2@SearchStan:
  00048	4f		 dec	 edi
  00049	f6 04 01 0e	 test	 BYTE PTR [ecx+eax], 14	; 0000000eH
  0004d	74 0f		 je	 SHORT $LN9@SearchStan

; 837  : 			break;
; 838  : 		}
; 839  : 
; 840  : 		tx += subx;

  0004f	03 c3		 add	 eax, ebx
  00051	85 ff		 test	 edi, edi
  00053	75 f3		 jne	 SHORT $LL2@SearchStan
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx

; 841  : 	}
; 842  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
$LN9@SearchStan:

; 834  : 		{
; 835  : 			x = tx;

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	88 01		 mov	 BYTE PTR [ecx], al

; 836  : 			y = ty;

  00066	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _ty$1$[ebp]
  0006c	88 08		 mov	 BYTE PTR [eax], cl

; 841  : 	}
; 842  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
?SearchStandAttr@MapClass@@QAEXAAE0@Z ENDP		; MapClass::SearchStandAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?GetRandomLengthPos@MapClass@@QAEXAAE0H@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_py$1$ = 16						; size = 4
_length$ = 16						; size = 4
?GetRandomLengthPos@MapClass@@QAEXAAE0H@Z PROC		; MapClass::GetRandomLengthPos, COMDAT
; _this$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 143  : 	int lc = 10;	// loopcount
; 144  : 	int px;
; 145  : 	int py;
; 146  : 	BYTE attr;
; 147  : 	int maxlen;
; 148  : 
; 149  : 	if ( length < 1 )

  00007	8b 7d 10	 mov	 edi, DWORD PTR _length$[ebp]
  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	3b f8		 cmp	 edi, eax
  00011	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00014	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  00019	0f 4c f8	 cmovl	 edi, eax

; 150  : 	{
; 151  : 		length = 1;
; 152  : 	}
; 153  : 
; 154  : 	maxlen = length*2;

  0001c	8d 1c 3f	 lea	 ebx, DWORD PTR [edi+edi]
  0001f	90		 npad	 1
$LL2@GetRandomL:

; 155  : 
; 156  : 	while ( lc-- != 0 )

  00020	4e		 dec	 esi

; 157  : 	{
; 158  : 		px = (x-length)+(rand()%maxlen);

  00021	e8 00 00 00 00	 call	 _rand
  00026	99		 cdq
  00027	f7 fb		 idiv	 ebx
  00029	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002c	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  0002f	03 da		 add	 ebx, edx
  00031	2b df		 sub	 ebx, edi

; 159  : 		py = (y-length)+(rand()%maxlen);

  00033	e8 00 00 00 00	 call	 _rand
  00038	99		 cdq
  00039	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  0003c	f7 f9		 idiv	 ecx
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00041	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00044	03 ca		 add	 ecx, edx
  00046	2b cf		 sub	 ecx, edi

; 160  : 
; 161  : 		attr = this->GetAttr(px, py);

  00048	51		 push	 ecx
  00049	89 4d 10	 mov	 DWORD PTR _py$1$[ebp], ecx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00055	a8 0c		 test	 al, 12			; 0000000cH

; 162  : 
; 163  : 		if ( (attr & 4) != 4  && (attr & 8) != 8 )

  00057	74 10		 je	 SHORT $LN8@GetRandomL

; 155  : 
; 156  : 	while ( lc-- != 0 )

  00059	8d 1c 3f	 lea	 ebx, DWORD PTR [edi+edi]
  0005c	85 f6		 test	 esi, esi
  0005e	75 c0		 jne	 SHORT $LL2@GetRandomL
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 167  : 			return;
; 168  : 		}
; 169  : 	}
; 170  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
$LN8@GetRandomL:

; 164  : 		{
; 165  : 			x = px;

  00069	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]

; 166  : 			y = py;

  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	88 18		 mov	 BYTE PTR [eax], bl
  00073	8b 45 10	 mov	 eax, DWORD PTR _py$1$[ebp]
  00076	88 01		 mov	 BYTE PTR [ecx], al
  00078	5b		 pop	 ebx

; 167  : 			return;
; 168  : 		}
; 169  : 	}
; 170  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
?GetRandomLengthPos@MapClass@@QAEXAAE0H@Z ENDP		; MapClass::GetRandomLengthPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?GetMapPos@MapClass@@QAEXAAE0@Z
_TEXT	SEGMENT
_y$ = -48						; size = 4
_loopcount$ = -44					; size = 4
_this$ = -40						; size = 4
_x$ = -36						; size = 4
_h$ = -32						; size = 4
_w$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_ox$ = 8						; size = 4
_oy$ = 12						; size = 4
?GetMapPos@MapClass@@QAEXAAE0@Z PROC			; MapClass::GetMapPos, COMDAT
; _this$ = ecx

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetMapPos@MapClass@@QAEXAAE0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 20	 sub	 esp, 32			; 00000020H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	8b f1		 mov	 esi, ecx
  00035	89 75 d8	 mov	 DWORD PTR _this$[ebp], esi

; 177  : 	int x;
; 178  : 	int y;
; 179  : 	int loopcount=50;

  00038	bf 32 00 00 00	 mov	 edi, 50			; 00000032H
  0003d	0f 1f 00	 npad	 3
$LL2@GetMapPos:

; 180  : 	BYTE attr;
; 181  : 	int w;
; 182  : 	int h;
; 183  : 
; 184  : 	while ( loopcount-- != 0 )

  00040	8b c7		 mov	 eax, edi
  00042	4f		 dec	 edi
  00043	89 7d d4	 mov	 DWORD PTR _loopcount$[ebp], edi
  00046	85 c0		 test	 eax, eax
  00048	0f 84 b7 00 00
	00		 je	 $LN3@GetMapPos

; 185  : 	{
; 186  : 		w = this->gRegenRect.right - this->gRegenRect.left;

  0004e	8b 86 1c 38 05
	00		 mov	 eax, DWORD PTR [esi+342044]
  00054	2b 86 14 38 05
	00		 sub	 eax, DWORD PTR [esi+342036]
  0005a	89 45 e4	 mov	 DWORD PTR _w$[ebp], eax

; 187  : 		h = this->gRegenRect.bottom - this->gRegenRect.top;

  0005d	8b 86 20 38 05
	00		 mov	 eax, DWORD PTR [esi+342048]
  00063	2b 86 18 38 05
	00		 sub	 eax, DWORD PTR [esi+342040]
  00069	89 45 e0	 mov	 DWORD PTR _h$[ebp], eax

; 188  : 
; 189  : 		__try

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 190  : 		{
; 191  : 			x = (BYTE)(this->gRegenRect.left + (rand()%w));

  00073	e8 00 00 00 00	 call	 _rand
  00078	8b 4d e4	 mov	 ecx, DWORD PTR _w$[ebp]
  0007b	99		 cdq
  0007c	f7 f9		 idiv	 ecx
  0007e	02 96 14 38 05
	00		 add	 dl, BYTE PTR [esi+342036]
  00084	0f b6 c2	 movzx	 eax, dl
  00087	89 45 dc	 mov	 DWORD PTR _x$[ebp], eax

; 192  : 			y = (BYTE)(this->gRegenRect.top  + (rand()%h));

  0008a	e8 00 00 00 00	 call	 _rand
  0008f	8b 4d e0	 mov	 ecx, DWORD PTR _h$[ebp]
  00092	99		 cdq
  00093	f7 f9		 idiv	 ecx
  00095	02 96 18 38 05
	00		 add	 dl, BYTE PTR [esi+342040]
  0009b	0f b6 da	 movzx	 ebx, dl
  0009e	89 5d d0	 mov	 DWORD PTR _y$[ebp], ebx

; 193  : 		}

  000a1	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000a8	eb 27		 jmp	 SHORT $LN11@GetMapPos
$LN8@GetMapPos:
$LN16@GetMapPos:

; 194  : 		__except(w=1,h=1,1)

  000aa	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
  000b1	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
  000b8	b8 01 00 00 00	 mov	 eax, 1
$LN15@GetMapPos:
$LN10@GetMapPos:
  000bd	c3		 ret	 0
$LN9@GetMapPos:
  000be	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 193  : 		}

  000c1	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000c8	8b 75 d8	 mov	 esi, DWORD PTR _this$[ebp]
  000cb	8b 7d d4	 mov	 edi, DWORD PTR _loopcount$[ebp]
  000ce	8b 5d d0	 mov	 ebx, DWORD PTR _y$[ebp]
$LN11@GetMapPos:

; 195  : 		{
; 196  : 		}
; 197  : 		attr = this->GetAttr(x, y);

  000d1	53		 push	 ebx
  000d2	ff 75 dc	 push	 DWORD PTR _x$[ebp]
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000dc	a8 0c		 test	 al, 12			; 0000000cH

; 198  : 
; 199  : 		if ( (attr & 4) != 4  && (attr & 8) != 8 )

  000de	0f 85 5c ff ff
	ff		 jne	 $LL2@GetMapPos

; 200  : 		{
; 201  : 			ox = x;

  000e4	8b 45 08	 mov	 eax, DWORD PTR _ox$[ebp]
  000e7	8b 4d dc	 mov	 ecx, DWORD PTR _x$[ebp]
  000ea	88 08		 mov	 BYTE PTR [eax], cl

; 202  : 			oy = y;

  000ec	8b 45 0c	 mov	 eax, DWORD PTR _oy$[ebp]
  000ef	88 18		 mov	 BYTE PTR [eax], bl

; 208  : 	x = this->gRegenRect.left;
; 209  : 	y = this->gRegenRect.top;
; 210  : }

  000f1	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fb	59		 pop	 ecx
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 08 00	 ret	 8
$LN3@GetMapPos:

; 203  : 			return;
; 204  : 		}
; 205  : 	}
; 206  : 				
; 207  : 	LogAdd( lMsg.Get( MSGGET(1, 204 )) , __FILE__, __LINE__);

  00105	68 cf 00 00 00	 push	 207			; 000000cfH
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@
  0010f	68 cc 01 00 00	 push	 460			; 000001ccH
  00114	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00119	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH

; 208  : 	x = this->gRegenRect.left;
; 209  : 	y = this->gRegenRect.top;
; 210  : }

  00128	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0012b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00132	59		 pop	 ecx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 08 00	 ret	 8
?GetMapPos@MapClass@@QAEXAAE0@Z ENDP			; MapClass::GetMapPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?GetLevelPos@MapClass@@QAEXAAE0@Z
_TEXT	SEGMENT
_y$ = -48						; size = 4
_loopcount$ = -44					; size = 4
_this$ = -40						; size = 4
_x$ = -36						; size = 4
_h$ = -32						; size = 4
_w$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_ox$ = 8						; size = 4
_oy$ = 12						; size = 4
?GetLevelPos@MapClass@@QAEXAAE0@Z PROC			; MapClass::GetLevelPos, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetLevelPos@MapClass@@QAEXAAE0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 20	 sub	 esp, 32			; 00000020H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	8b f1		 mov	 esi, ecx
  00035	89 75 d8	 mov	 DWORD PTR _this$[ebp], esi

; 99   : 
; 100  : 	int x;
; 101  : 	int y;
; 102  : 	int loopcount = 50;

  00038	bf 32 00 00 00	 mov	 edi, 50			; 00000032H
  0003d	0f 1f 00	 npad	 3
$LL2@GetLevelPo:

; 103  : 	BYTE attr;
; 104  : 	int w;
; 105  : 	int h;
; 106  : 
; 107  : 	while ( loopcount-- != 0 )

  00040	8b c7		 mov	 eax, edi
  00042	4f		 dec	 edi
  00043	89 7d d4	 mov	 DWORD PTR _loopcount$[ebp], edi
  00046	85 c0		 test	 eax, eax
  00048	0f 84 b9 00 00
	00		 je	 $LN3@GetLevelPo

; 108  : 	{
; 109  : 		w = this->gRegenRect.right - this->gRegenRect.left;

  0004e	8b 86 1c 38 05
	00		 mov	 eax, DWORD PTR [esi+342044]
  00054	2b 86 14 38 05
	00		 sub	 eax, DWORD PTR [esi+342036]
  0005a	89 45 e4	 mov	 DWORD PTR _w$[ebp], eax

; 110  : 		h = this->gRegenRect.bottom - this->gRegenRect.top;

  0005d	8b 86 20 38 05
	00		 mov	 eax, DWORD PTR [esi+342048]
  00063	2b 86 18 38 05
	00		 sub	 eax, DWORD PTR [esi+342040]
  00069	89 45 e0	 mov	 DWORD PTR _h$[ebp], eax

; 111  : 
; 112  : 		__try

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 113  : 		{
; 114  : 			x = (short)(this->gRegenRect.left + (rand()%w));

  00073	e8 00 00 00 00	 call	 _rand
  00078	8b 4d e4	 mov	 ecx, DWORD PTR _w$[ebp]
  0007b	99		 cdq
  0007c	f7 f9		 idiv	 ecx
  0007e	66 03 96 14 38
	05 00		 add	 dx, WORD PTR [esi+342036]
  00085	0f bf c2	 movsx	 eax, dx
  00088	89 45 dc	 mov	 DWORD PTR _x$[ebp], eax

; 115  : 			y = (short)(this->gRegenRect.top  + (rand()%h));

  0008b	e8 00 00 00 00	 call	 _rand
  00090	8b 4d e0	 mov	 ecx, DWORD PTR _h$[ebp]
  00093	99		 cdq
  00094	f7 f9		 idiv	 ecx
  00096	66 03 96 18 38
	05 00		 add	 dx, WORD PTR [esi+342040]
  0009d	0f bf da	 movsx	 ebx, dx
  000a0	89 5d d0	 mov	 DWORD PTR _y$[ebp], ebx

; 116  : 		}

  000a3	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000aa	eb 27		 jmp	 SHORT $LN11@GetLevelPo
$LN8@GetLevelPo:
$LN16@GetLevelPo:

; 117  : 		__except(w=1, h=1,1)

  000ac	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
  000b3	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
  000ba	b8 01 00 00 00	 mov	 eax, 1
$LN15@GetLevelPo:
$LN10@GetLevelPo:
  000bf	c3		 ret	 0
$LN9@GetLevelPo:
  000c0	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 116  : 		}

  000c3	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000ca	8b 75 d8	 mov	 esi, DWORD PTR _this$[ebp]
  000cd	8b 7d d4	 mov	 edi, DWORD PTR _loopcount$[ebp]
  000d0	8b 5d d0	 mov	 ebx, DWORD PTR _y$[ebp]
$LN11@GetLevelPo:

; 118  : 		{
; 119  : 		}
; 120  : 
; 121  : 		attr = this->GetAttr(x, y);

  000d3	53		 push	 ebx
  000d4	ff 75 dc	 push	 DWORD PTR _x$[ebp]
  000d7	8b ce		 mov	 ecx, esi
  000d9	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000de	a8 0c		 test	 al, 12			; 0000000cH

; 122  : 
; 123  : 		if ( (attr & 4) != 4  && (attr & 8) != 8 ) 

  000e0	0f 85 5a ff ff
	ff		 jne	 $LL2@GetLevelPo

; 124  : 		{
; 125  : 			ox = x;

  000e6	8b 45 08	 mov	 eax, DWORD PTR _ox$[ebp]
  000e9	8b 4d dc	 mov	 ecx, DWORD PTR _x$[ebp]
  000ec	88 08		 mov	 BYTE PTR [eax], cl

; 126  : 			oy = y;

  000ee	8b 45 0c	 mov	 eax, DWORD PTR _oy$[ebp]
  000f1	88 18		 mov	 BYTE PTR [eax], bl

; 132  : 	x = this->gRegenRect.left;
; 133  : 	y = this->gRegenRect.top;
; 134  : }

  000f3	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fd	59		 pop	 ecx
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
$LN3@GetLevelPo:

; 127  : 			return;
; 128  : 		}
; 129  : 	}
; 130  : 	
; 131  : 	LogAdd( lMsg.Get( MSGGET(1, 204 )) , __FILE__, __LINE__);

  00107	68 83 00 00 00	 push	 131			; 00000083H
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIPODJPN@MapClass?4cpp?$AA@
  00111	68 cc 01 00 00	 push	 460			; 000001ccH
  00116	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0011b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00120	50		 push	 eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH

; 132  : 	x = this->gRegenRect.left;
; 133  : 	y = this->gRegenRect.top;
; 134  : }

  0012a	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0012d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00134	59		 pop	 ecx
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	5b		 pop	 ebx
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 08 00	 ret	 8
?GetLevelPos@MapClass@@QAEXAAE0@Z ENDP			; MapClass::GetLevelPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?SaveItemInfo@MapClass@@QAEXXZ
_TEXT	SEGMENT
?SaveItemInfo@MapClass@@QAEXXZ PROC			; MapClass::SaveItemInfo, COMDAT
; _this$ = ecx

; 293  : 	return;	// Here goes a Macro
; 294  : }

  00000	c3		 ret	 0
?SaveItemInfo@MapClass@@QAEXXZ ENDP			; MapClass::SaveItemInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GPATH@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPATH@@QAEPAXI@Z PROC				; PATH::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 0e		 je	 SHORT $LN7@scalar
  0000c	68 54 04 00 00	 push	 1108			; 00000454H
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GPATH@@QAEPAXI@Z ENDP				; PATH::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?GetPathY@PATH@@QAEPAEXZ
_TEXT	SEGMENT
?GetPathY@PATH@@QAEPAEXZ PROC				; PATH::GetPathY, COMDAT
; _this$ = ecx

; 771  : 		return this->PathY;

  00000	8d 81 00 02 00
	00		 lea	 eax, DWORD PTR [ecx+512]

; 772  : 	};

  00006	c3		 ret	 0
?GetPathY@PATH@@QAEPAEXZ ENDP				; PATH::GetPathY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?GetPathX@PATH@@QAEPAEXZ
_TEXT	SEGMENT
?GetPathX@PATH@@QAEPAEXZ PROC				; PATH::GetPathX, COMDAT
; _this$ = ecx

; 766  : 		return this->PathX;

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 767  : 	};

  00003	c3		 ret	 0
?GetPathX@PATH@@QAEPAEXZ ENDP				; PATH::GetPathX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?GetPath@PATH@@QAEHXZ
_TEXT	SEGMENT
?GetPath@PATH@@QAEHXZ PROC				; PATH::GetPath, COMDAT
; _this$ = ecx

; 761  : 		return this->NumPath;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 762  : 	};

  00003	c3		 ret	 0
?GetPath@PATH@@QAEHXZ ENDP				; PATH::GetPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?SetMapDimensions@PATH@@QAEXHHPAE@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_map$ = 16						; size = 4
?SetMapDimensions@PATH@@QAEXHHPAE@Z PROC		; PATH::SetMapDimensions, COMDAT
; _this$ = ecx

; 752  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 753  : 		this->Width = w;
; 754  : 		this->Height = h;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]

; 755  : 		this->Map = (unsigned char*)map;

  00006	8b 45 10	 mov	 eax, DWORD PTR _map$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _w$[ebp]
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	89 37		 mov	 DWORD PTR [edi], esi

; 756  : 		this->HitMap = new unsigned char [this->Width * this->Height];

  00012	0f af f2	 imul	 esi, edx
  00015	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00018	89 87 3c 04 00
	00		 mov	 DWORD PTR [edi+1084], eax
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00024	83 c4 04	 add	 esp, 4
  00027	89 87 40 04 00
	00		 mov	 DWORD PTR [edi+1088], eax
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 757  : 	};

  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
?SetMapDimensions@PATH@@QAEXHHPAE@Z ENDP		; PATH::SetMapDimensions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?FindPath3@PATH@@QAE_NHHHH_N@Z
_TEXT	SEGMENT
_NumFails$1$ = -8					; size = 4
_First$ = -4						; size = 1
_startx$ = 8						; size = 4
_starty$ = 12						; size = 4
_endx$ = 16						; size = 4
_endy$ = 20						; size = 4
_ErrorCheck$ = 24					; size = 1
?FindPath3@PATH@@QAE_NHHHH_N@Z PROC			; PATH::FindPath3, COMDAT
; _this$ = ecx

; 683  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 684  : 		this->NumPath = 0;
; 685  : 
; 686  : 		int WhichDir=0;

  0000b	33 ff		 xor	 edi, edi

; 687  : 		int NumFails=0;

  0000d	89 7d f8	 mov	 DWORD PTR _NumFails$1$[ebp], edi

; 688  : 		bool First;
; 689  : 
; 690  : 		
; 691  : 		memset(this->HitMap, 0, this->Width * this->Height);

  00010	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00013	0f af 06	 imul	 eax, DWORD PTR [esi]
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	50		 push	 eax
  0001e	57		 push	 edi
  0001f	ff b6 40 04 00
	00		 push	 DWORD PTR [esi+1088]
  00025	e8 00 00 00 00	 call	 _memset

; 692  : 		First = true;

  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR _starty$[ebp]
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  00033	c6 45 fc 01	 mov	 BYTE PTR _First$[ebp], 1
$LN20@FindPath3:
  00037	8b 55 10	 mov	 edx, DWORD PTR _endx$[ebp]
  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _endy$[ebp]

; 693  : 
; 694  : 		while ( (startx != endx) || (starty != endy) )

  0003d	3b c2		 cmp	 eax, edx
  0003f	75 04		 jne	 SHORT $LN4@FindPath3
  00041	3b d9		 cmp	 ebx, ecx
  00043	74 52		 je	 SHORT $LN8@FindPath3
$LN4@FindPath3:

; 695  : 		{
; 696  : 			WhichDir = this->FindNextDir3(startx, starty, endx, endy, WhichDir, First, ErrorCheck);

  00045	ff 75 18	 push	 DWORD PTR _ErrorCheck$[ebp]
  00048	ff 75 fc	 push	 DWORD PTR _First$[ebp]
  0004b	57		 push	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	53		 push	 ebx
  0004f	50		 push	 eax
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?FindNextDir3@PATH@@AAEHHHHHH_N0@Z ; PATH::FindNextDir3
  00057	8b f8		 mov	 edi, eax

; 697  : 			First = 0;

  00059	c6 45 fc 00	 mov	 BYTE PTR _First$[ebp], 0

; 698  : 			
; 699  : 			if ( WhichDir >= 0 )

  0005d	85 ff		 test	 edi, edi
  0005f	78 5d		 js	 SHORT $LN5@FindPath3

; 700  : 			{
; 701  : 				this->PathX[this->NumPath] = startx;

  00061	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00064	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  00067	88 44 0e 0c	 mov	 BYTE PTR [esi+ecx+12], al

; 702  : 				this->PathY[this->NumPath] = starty;

  0006b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006e	88 9c 0e 00 02
	00 00		 mov	 BYTE PTR [esi+ecx+512], bl

; 703  : 				startx += this->Dir[WhichDir*2];

  00075	03 84 fe f4 03
	00 00		 add	 eax, DWORD PTR [esi+edi*8+1012]

; 704  : 				starty += this->Dir[WhichDir*2+1];

  0007c	03 9c fe f8 03
	00 00		 add	 ebx, DWORD PTR [esi+edi*8+1016]

; 705  : 				this->NumPath++;

  00083	ff 46 08	 inc	 DWORD PTR [esi+8]
  00086	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00089	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax

; 706  : 
; 707  : 				if ( this->NumPath >= 14 )

  0008c	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  0008f	7c a6		 jl	 SHORT $LN20@FindPath3

; 708  : 				{
; 709  : 					this->NumPath--;

  00091	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00094	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN8@FindPath3:

; 727  : 				{
; 728  : 					return false;
; 729  : 				}
; 730  : 			}
; 731  : 			else
; 732  : 			{
; 733  : 				break;
; 734  : 			}
; 735  : 			
; 736  : 		}
; 737  : 
; 738  : 		this->PathX[this->NumPath] = startx;

  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _startx$[ebp]
  0009d	5f		 pop	 edi
  0009e	88 4c 06 0c	 mov	 BYTE PTR [esi+eax+12], cl

; 739  : 		this->PathY[this->NumPath] = starty;

  000a2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a5	88 9c 06 00 02
	00 00		 mov	 BYTE PTR [esi+eax+512], bl

; 740  : 		this->NumPath++;

  000ac	ff 46 08	 inc	 DWORD PTR [esi+8]

; 741  : 
; 742  : 		if ( this->NumPath >= 15 )

  000af	83 7e 08 0f	 cmp	 DWORD PTR [esi+8], 15	; 0000000fH
  000b3	5e		 pop	 esi
  000b4	0f 9c c0	 setl	 al
  000b7	5b		 pop	 ebx

; 743  : 		{
; 744  : 			return false;
; 745  : 		}
; 746  : 
; 747  : 		return true;
; 748  : 	};

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 14 00	 ret	 20			; 00000014H
$LN5@FindPath3:

; 710  : 					break;
; 711  : 				}
; 712  : 			}
; 713  : 			else if ( ErrorCheck != FALSE )

  000be	80 7d 18 00	 cmp	 BYTE PTR _ErrorCheck$[ebp], 0
  000c2	74 d3		 je	 SHORT $LN8@FindPath3

; 714  : 			{
; 715  : 				this->NumPath--;

  000c4	83 46 08 ff	 add	 DWORD PTR [esi+8], -1
  000c8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 716  : 
; 717  : 				if ( this->NumPath < 0 )

  000cb	78 20		 js	 SHORT $LN16@FindPath3

; 720  : 				}
; 721  : 
; 722  : 				startx = this->PathX[this->NumPath];

  000cd	0f b6 44 31 0c	 movzx	 eax, BYTE PTR [ecx+esi+12]

; 723  : 				starty = this->PathY[this->NumPath];

  000d2	0f b6 9c 31 00
	02 00 00	 movzx	 ebx, BYTE PTR [ecx+esi+512]

; 724  : 				NumFails++;

  000da	8b 4d f8	 mov	 ecx, DWORD PTR _NumFails$1$[ebp]
  000dd	41		 inc	 ecx
  000de	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax
  000e1	89 4d f8	 mov	 DWORD PTR _NumFails$1$[ebp], ecx

; 725  : 
; 726  : 				if ( NumFails >= 10 )

  000e4	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000e7	0f 8c 4a ff ff
	ff		 jl	 $LN20@FindPath3
$LN16@FindPath3:
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi

; 718  : 				{
; 719  : 					return false;

  000ef	32 c0		 xor	 al, al
  000f1	5b		 pop	 ebx

; 743  : 		{
; 744  : 			return false;
; 745  : 		}
; 746  : 
; 747  : 		return true;
; 748  : 	};

  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 14 00	 ret	 20			; 00000014H
?FindPath3@PATH@@QAE_NHHHH_N@Z ENDP			; PATH::FindPath3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?FindPath2@PATH@@QAE_NHHHH_N@Z
_TEXT	SEGMENT
_NumFails$1$ = -8					; size = 4
_First$ = -4						; size = 1
_startx$ = 8						; size = 4
_starty$ = 12						; size = 4
_endx$ = 16						; size = 4
_endy$ = 20						; size = 4
_ErrorCheck$ = 24					; size = 1
?FindPath2@PATH@@QAE_NHHHH_N@Z PROC			; PATH::FindPath2, COMDAT
; _this$ = ecx

; 614  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 615  : 		this->NumPath = 0;
; 616  : 
; 617  : 		int WhichDir=0;

  0000b	33 ff		 xor	 edi, edi

; 618  : 		int NumFails=0;

  0000d	89 7d f8	 mov	 DWORD PTR _NumFails$1$[ebp], edi

; 619  : 		bool First;
; 620  : 
; 621  : 		
; 622  : 		memset(this->HitMap, 0, this->Width * this->Height);

  00010	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00013	0f af 06	 imul	 eax, DWORD PTR [esi]
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	50		 push	 eax
  0001e	57		 push	 edi
  0001f	ff b6 40 04 00
	00		 push	 DWORD PTR [esi+1088]
  00025	e8 00 00 00 00	 call	 _memset

; 623  : 		First = true;

  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR _starty$[ebp]
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  00033	c6 45 fc 01	 mov	 BYTE PTR _First$[ebp], 1
$LN20@FindPath2:
  00037	8b 55 10	 mov	 edx, DWORD PTR _endx$[ebp]
  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _endy$[ebp]

; 624  : 
; 625  : 		while ( (startx != endx) || (starty != endy) )

  0003d	3b c2		 cmp	 eax, edx
  0003f	75 04		 jne	 SHORT $LN4@FindPath2
  00041	3b d9		 cmp	 ebx, ecx
  00043	74 52		 je	 SHORT $LN8@FindPath2
$LN4@FindPath2:

; 626  : 		{
; 627  : 			WhichDir = this->FindNextDir2(startx, starty, endx, endy, WhichDir, First, ErrorCheck);

  00045	ff 75 18	 push	 DWORD PTR _ErrorCheck$[ebp]
  00048	ff 75 fc	 push	 DWORD PTR _First$[ebp]
  0004b	57		 push	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	53		 push	 ebx
  0004f	50		 push	 eax
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?FindNextDir2@PATH@@AAEHHHHHH_N0@Z ; PATH::FindNextDir2
  00057	8b f8		 mov	 edi, eax

; 628  : 			First = 0;

  00059	c6 45 fc 00	 mov	 BYTE PTR _First$[ebp], 0

; 629  : 			
; 630  : 			if ( WhichDir >= 0 )

  0005d	85 ff		 test	 edi, edi
  0005f	78 5d		 js	 SHORT $LN5@FindPath2

; 631  : 			{
; 632  : 				this->PathX[this->NumPath] = startx;

  00061	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00064	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  00067	88 44 0e 0c	 mov	 BYTE PTR [esi+ecx+12], al

; 633  : 				this->PathY[this->NumPath] = starty;

  0006b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006e	88 9c 0e 00 02
	00 00		 mov	 BYTE PTR [esi+ecx+512], bl

; 634  : 				startx += this->Dir[WhichDir*2];

  00075	03 84 fe f4 03
	00 00		 add	 eax, DWORD PTR [esi+edi*8+1012]

; 635  : 				starty += this->Dir[WhichDir*2+1];

  0007c	03 9c fe f8 03
	00 00		 add	 ebx, DWORD PTR [esi+edi*8+1016]

; 636  : 				this->NumPath++;

  00083	ff 46 08	 inc	 DWORD PTR [esi+8]
  00086	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00089	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax

; 637  : 
; 638  : 				if ( this->NumPath >= 14 )

  0008c	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  0008f	7c a6		 jl	 SHORT $LN20@FindPath2

; 639  : 				{
; 640  : 					this->NumPath--;

  00091	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00094	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN8@FindPath2:

; 658  : 				{
; 659  : 					return false;
; 660  : 				}
; 661  : 			}
; 662  : 			else
; 663  : 			{
; 664  : 				break;
; 665  : 			}
; 666  : 			
; 667  : 		}
; 668  : 
; 669  : 		this->PathX[this->NumPath] = startx;

  00097	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _startx$[ebp]
  0009d	5f		 pop	 edi
  0009e	88 4c 06 0c	 mov	 BYTE PTR [esi+eax+12], cl

; 670  : 		this->PathY[this->NumPath] = starty;

  000a2	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a5	88 9c 06 00 02
	00 00		 mov	 BYTE PTR [esi+eax+512], bl

; 671  : 		this->NumPath++;

  000ac	ff 46 08	 inc	 DWORD PTR [esi+8]

; 672  : 
; 673  : 		if ( this->NumPath >= 15 )

  000af	83 7e 08 0f	 cmp	 DWORD PTR [esi+8], 15	; 0000000fH
  000b3	5e		 pop	 esi
  000b4	0f 9c c0	 setl	 al
  000b7	5b		 pop	 ebx

; 674  : 		{
; 675  : 			return false;
; 676  : 		}
; 677  : 
; 678  : 		return true;
; 679  : 	};	// line : 351

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 14 00	 ret	 20			; 00000014H
$LN5@FindPath2:

; 641  : 					break;
; 642  : 				}
; 643  : 			}
; 644  : 			else if ( ErrorCheck != FALSE )

  000be	80 7d 18 00	 cmp	 BYTE PTR _ErrorCheck$[ebp], 0
  000c2	74 d3		 je	 SHORT $LN8@FindPath2

; 645  : 			{
; 646  : 				this->NumPath--;

  000c4	83 46 08 ff	 add	 DWORD PTR [esi+8], -1
  000c8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 647  : 
; 648  : 				if ( this->NumPath < 0 )

  000cb	78 20		 js	 SHORT $LN16@FindPath2

; 651  : 				}
; 652  : 
; 653  : 				startx = this->PathX[this->NumPath];

  000cd	0f b6 44 31 0c	 movzx	 eax, BYTE PTR [ecx+esi+12]

; 654  : 				starty = this->PathY[this->NumPath];

  000d2	0f b6 9c 31 00
	02 00 00	 movzx	 ebx, BYTE PTR [ecx+esi+512]

; 655  : 				NumFails++;

  000da	8b 4d f8	 mov	 ecx, DWORD PTR _NumFails$1$[ebp]
  000dd	41		 inc	 ecx
  000de	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax
  000e1	89 4d f8	 mov	 DWORD PTR _NumFails$1$[ebp], ecx

; 656  : 
; 657  : 				if ( NumFails >= 10 )

  000e4	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000e7	0f 8c 4a ff ff
	ff		 jl	 $LN20@FindPath2
$LN16@FindPath2:
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi

; 649  : 				{
; 650  : 					return false;

  000ef	32 c0		 xor	 al, al
  000f1	5b		 pop	 ebx

; 674  : 		{
; 675  : 			return false;
; 676  : 		}
; 677  : 
; 678  : 		return true;
; 679  : 	};	// line : 351

  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 14 00	 ret	 20			; 00000014H
?FindPath2@PATH@@QAE_NHHHH_N@Z ENDP			; PATH::FindPath2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?FindPath@PATH@@QAE_NHHHH_N@Z
_TEXT	SEGMENT
_NumFails$1$ = -8					; size = 4
_First$ = -4						; size = 1
_startx$ = 8						; size = 4
_starty$ = 12						; size = 4
_endx$ = 16						; size = 4
_endy$ = 20						; size = 4
_ErrorCheck$ = 24					; size = 1
?FindPath@PATH@@QAE_NHHHH_N@Z PROC			; PATH::FindPath, COMDAT
; _this$ = ecx

; 547  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 548  : 		this->NumPath = 0;
; 549  : 
; 550  : 		int WhichDir = 0;

  0000b	33 ff		 xor	 edi, edi

; 551  : 		int NumFails = 0;

  0000d	89 7d f8	 mov	 DWORD PTR _NumFails$1$[ebp], edi

; 552  : 		bool First;
; 553  : 
; 554  : 		
; 555  : 		memset(this->HitMap, 0, this->Width * this->Height);

  00010	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00013	0f af 06	 imul	 eax, DWORD PTR [esi]
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	50		 push	 eax
  0001e	57		 push	 edi
  0001f	ff b6 40 04 00
	00		 push	 DWORD PTR [esi+1088]
  00025	e8 00 00 00 00	 call	 _memset

; 556  : 		First = true;

  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR _starty$[ebp]
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  00033	c6 45 fc 01	 mov	 BYTE PTR _First$[ebp], 1
$LN20@FindPath:
  00037	8b 55 10	 mov	 edx, DWORD PTR _endx$[ebp]
  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _endy$[ebp]

; 557  : 
; 558  : 		while ( (startx != endx) || (starty != endy) )

  0003d	3b c2		 cmp	 eax, edx
  0003f	75 08		 jne	 SHORT $LN4@FindPath
  00041	3b d9		 cmp	 ebx, ecx
  00043	0f 84 86 00 00
	00		 je	 $LN8@FindPath
$LN4@FindPath:

; 559  : 		{
; 560  : 			WhichDir = this->FindNextDir( startx, starty, endx, endy, WhichDir, First, ErrorCheck);

  00049	ff 75 18	 push	 DWORD PTR _ErrorCheck$[ebp]
  0004c	ff 75 fc	 push	 DWORD PTR _First$[ebp]
  0004f	57		 push	 edi
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	53		 push	 ebx
  00053	50		 push	 eax
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?FindNextDir@PATH@@AAEHHHHHH_N0@Z ; PATH::FindNextDir
  0005b	8b f8		 mov	 edi, eax

; 561  : 			First = 0;

  0005d	c6 45 fc 00	 mov	 BYTE PTR _First$[ebp], 0

; 562  : 			
; 563  : 			if ( WhichDir >= 0 )

  00061	85 ff		 test	 edi, edi
  00063	78 30		 js	 SHORT $LN5@FindPath

; 564  : 			{
; 565  : 				this->PathX[this->NumPath] = startx;

  00065	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00068	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  0006b	88 44 0e 0c	 mov	 BYTE PTR [esi+ecx+12], al

; 566  : 				this->PathY[this->NumPath] = starty;

  0006f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00072	88 9c 0e 00 02
	00 00		 mov	 BYTE PTR [esi+ecx+512], bl

; 567  : 				startx += this->Dir[WhichDir*2];

  00079	03 84 fe f4 03
	00 00		 add	 eax, DWORD PTR [esi+edi*8+1012]

; 568  : 				starty += this->Dir[WhichDir*2+1];

  00080	03 9c fe f8 03
	00 00		 add	 ebx, DWORD PTR [esi+edi*8+1016]

; 569  : 				this->NumPath++;

  00087	ff 46 08	 inc	 DWORD PTR [esi+8]

; 570  : 
; 571  : 				if ( this->NumPath >= 15 )

  0008a	83 7e 08 0f	 cmp	 DWORD PTR [esi+8], 15	; 0000000fH
  0008e	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax
  00091	7d 31		 jge	 SHORT $LN15@FindPath

; 574  : 				}
; 575  : 			}

  00093	eb a2		 jmp	 SHORT $LN20@FindPath
$LN5@FindPath:

; 576  : 			else if ( ErrorCheck != false )

  00095	80 7d 18 00	 cmp	 BYTE PTR _ErrorCheck$[ebp], 0
  00099	74 34		 je	 SHORT $LN8@FindPath

; 577  : 			{
; 578  : 				this->NumPath--;

  0009b	83 46 08 ff	 add	 DWORD PTR [esi+8], -1
  0009f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 579  : 
; 580  : 				if ( this->NumPath < 0 )

  000a2	78 20		 js	 SHORT $LN15@FindPath

; 581  : 				{
; 582  : 					return false;
; 583  : 				}
; 584  : 
; 585  : 				startx = this->PathX[this->NumPath];

  000a4	0f b6 44 31 0c	 movzx	 eax, BYTE PTR [ecx+esi+12]

; 586  : 				starty = this->PathY[this->NumPath];

  000a9	0f b6 9c 31 00
	02 00 00	 movzx	 ebx, BYTE PTR [ecx+esi+512]

; 587  : 				NumFails++;

  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _NumFails$1$[ebp]
  000b4	41		 inc	 ecx
  000b5	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax
  000b8	89 4d f8	 mov	 DWORD PTR _NumFails$1$[ebp], ecx

; 588  : 
; 589  : 				if ( NumFails >= 10 )

  000bb	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000be	0f 8c 73 ff ff
	ff		 jl	 $LN20@FindPath
$LN15@FindPath:
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi

; 572  : 				{
; 573  : 					return false;

  000c6	32 c0		 xor	 al, al
  000c8	5b		 pop	 ebx

; 606  : 		{
; 607  : 			return false;
; 608  : 		}
; 609  : 
; 610  : 		return true;
; 611  : 	};	// line : 302

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 14 00	 ret	 20			; 00000014H
$LN8@FindPath:

; 590  : 				{
; 591  : 					return false;
; 592  : 				}
; 593  : 			}
; 594  : 			else
; 595  : 			{
; 596  : 				break;
; 597  : 			}
; 598  : 			
; 599  : 		}
; 600  : 
; 601  : 		this->PathX[this->NumPath] = startx;

  000cf	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _startx$[ebp]
  000d5	5f		 pop	 edi
  000d6	88 4c 06 0c	 mov	 BYTE PTR [esi+eax+12], cl

; 602  : 		this->PathY[this->NumPath] = starty;

  000da	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000dd	88 9c 06 00 02
	00 00		 mov	 BYTE PTR [esi+eax+512], bl

; 603  : 		this->NumPath++;

  000e4	ff 46 08	 inc	 DWORD PTR [esi+8]

; 604  : 
; 605  : 		if ( this->NumPath >= 15 )

  000e7	83 7e 08 0f	 cmp	 DWORD PTR [esi+8], 15	; 0000000fH
  000eb	5e		 pop	 esi
  000ec	0f 9c c0	 setl	 al
  000ef	5b		 pop	 ebx

; 606  : 		{
; 607  : 			return false;
; 608  : 		}
; 609  : 
; 610  : 		return true;
; 611  : 	};	// line : 302

  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 14 00	 ret	 20			; 00000014H
?FindPath@PATH@@QAE_NHHHH_N@Z ENDP			; PATH::FindPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ??1PATH@@QAE@XZ
_TEXT	SEGMENT
??1PATH@@QAE@XZ PROC					; PATH::~PATH, COMDAT
; _this$ = ecx

; 543  : 		return;
; 544  : 	};	// line : 255

  00000	c3		 ret	 0
??1PATH@@QAE@XZ ENDP					; PATH::~PATH
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ??0PATH@@QAE@XZ
_TEXT	SEGMENT
??0PATH@@QAE@XZ PROC					; PATH::PATH, COMDAT
; _this$ = ecx

; 527  : 	PATH() // line : 250

  00000	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffff00000000ffffffffffffffff

; 528  : 	{
; 529  : 		 int dir[16] = {-1, -1,
; 530  : 						0, -1,
; 531  : 						1, -1,
; 532  : 						1, 0,
; 533  : 						1, 1,
; 534  : 						0, 1,
; 535  : 						-1, 1,
; 536  : 						-1, 0} ;
; 537  : 
; 538  : 		memcpy(this->Dir, dir, sizeof(dir));
; 539  : 	};	// line : 252

  00007	8b c1		 mov	 eax, ecx
  00009	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@0000000000000001ffffffff00000001
  00010	0f 28 15 00 00
	00 00		 movaps	 xmm2, XMMWORD PTR __xmm@00000001000000000000000100000001
  00017	0f 28 1d 00 00
	00 00		 movaps	 xmm3, XMMWORD PTR __xmm@00000000ffffffff00000001ffffffff
  0001e	0f 11 81 f4 03
	00 00		 movups	 XMMWORD PTR [ecx+1012], xmm0
  00025	0f 11 89 04 04
	00 00		 movups	 XMMWORD PTR [ecx+1028], xmm1
  0002c	0f 11 91 14 04
	00 00		 movups	 XMMWORD PTR [ecx+1044], xmm2
  00033	0f 11 99 24 04
	00 00		 movups	 XMMWORD PTR [ecx+1060], xmm3
  0003a	c3		 ret	 0
??0PATH@@QAE@XZ ENDP					; PATH::PATH
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?FindNextDir3@PATH@@AAEHHHHHH_N0@Z
_TEXT	SEGMENT
_dist$1$ = -16						; size = 4
_ldir$2$ = -16						; size = 4
_dist$1$ = -12						; size = 4
_ldir$3$ = -12						; size = 4
_ldir$1$ = -12						; size = 4
_WhichDir$1$ = -8					; size = 4
_MinDist$1$ = -4					; size = 4
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_i$1$ = 24						; size = 4
_dirstart$ = 24						; size = 4
_dir$1$ = 28						; size = 4
tv975 = 28						; size = 4
tv974 = 28						; size = 4
tv973 = 28						; size = 4
_First$ = 28						; size = 1
_ErrorCheck$ = 32					; size = 1
?FindNextDir3@PATH@@AAEHHHHHH_N0@Z PROC			; PATH::FindNextDir3, COMDAT
; _this$ = ecx

; 402  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 403  : 		int MinDist = 10000000;
; 404  : 		long ldir;
; 405  : 		int WhichDir = 0;
; 406  : 		int i;
; 407  : 
; 408  : 		if ( First != 0 )

  00006	80 7d 1c 00	 cmp	 BYTE PTR _First$[ebp], 0
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _WhichDir$1$[ebp], 0
  00015	b9 80 96 98 00	 mov	 ecx, 10000000		; 00989680H
  0001a	57		 push	 edi
  0001b	89 4d fc	 mov	 DWORD PTR _MinDist$1$[ebp], ecx
  0001e	0f 84 aa 00 00
	00		 je	 $LN11@FindNextDi

; 409  : 		{
; 410  : 			for ( i = 0 ; i<8 ; i++ )

  00024	33 c0		 xor	 eax, eax
  00026	89 45 18	 mov	 DWORD PTR _i$1$[ebp], eax
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@FindNextDi:

; 51   : 		int disty = y2 - y1;

  00030	8b 5d 14	 mov	 ebx, DWORD PTR _dy$[ebp]

; 411  : 			{
; 412  : 				ldir = i % 8 ;

  00033	83 e0 07	 and	 eax, 7
  00036	89 45 f4	 mov	 DWORD PTR _ldir$1$[ebp], eax

; 413  : 				int endx = sx + this->Dir[ldir*2];

  00039	8b 94 c6 f4 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1012]

; 414  : 				int endy = sy + this->Dir[ldir*2+1];

  00040	8b bc c6 f8 03
	00 00		 mov	 edi, DWORD PTR [esi+eax*8+1016]
  00047	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]
  0004a	03 7d 0c	 add	 edi, DWORD PTR _sy$[ebp]

; 50   : 		int distx = x2 - x1;

  0004d	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]

; 51   : 		int disty = y2 - y1;

  00050	2b df		 sub	 ebx, edi
  00052	2b c2		 sub	 eax, edx

; 52   : 		return (distx * distx) + (disty * disty);

  00054	0f af db	 imul	 ebx, ebx
  00057	0f af c0	 imul	 eax, eax
  0005a	03 d8		 add	 ebx, eax

; 415  : 				int dist = this->GetDist(endx, endy, dx, dy);
; 416  : 
; 417  : 				if ( MinDist > dist )

  0005c	3b cb		 cmp	 ecx, ebx
  0005e	7e 56		 jle	 SHORT $LN2@FindNextDi

; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  00060	85 d2		 test	 edx, edx
  00062	78 52		 js	 SHORT $LN2@FindNextDi
  00064	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00066	3b d1		 cmp	 edx, ecx
  00068	7d 49		 jge	 SHORT $LN154@FindNextDi
  0006a	85 ff		 test	 edi, edi
  0006c	78 45		 js	 SHORT $LN154@FindNextDi
  0006e	3b f9		 cmp	 edi, ecx
  00070	7d 41		 jge	 SHORT $LN154@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  00072	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00078	0f af cf	 imul	 ecx, edi
  0007b	03 c1		 add	 eax, ecx
  0007d	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00081	75 30		 jne	 SHORT $LN154@FindNextDi

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  00083	03 ca		 add	 ecx, edx

; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00085	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00088	7d 29		 jge	 SHORT $LN154@FindNextDi

; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  0008a	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00090	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  00094	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0009a	73 13		 jae	 SHORT $LN40@FindNextDi
  0009c	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  000a0	75 0d		 jne	 SHORT $LN40@FindNextDi

; 418  : 				{
; 419  : 					if ( this->IsThisSpotOK(endx, endy) != FALSE && this->CanWeMoveForward3(endx, endy) != FALSE)
; 420  : 					{
; 421  : 						MinDist = dist;

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _ldir$1$[ebp]
  000a5	8b cb		 mov	 ecx, ebx
  000a7	89 4d fc	 mov	 DWORD PTR _MinDist$1$[ebp], ecx

; 422  : 						WhichDir = ldir;

  000aa	89 45 f8	 mov	 DWORD PTR _WhichDir$1$[ebp], eax
  000ad	eb 07		 jmp	 SHORT $LN2@FindNextDi
$LN40@FindNextDi:

; 111  : 		{
; 112  : 			this->HitMap[which] = 1;

  000af	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1
$LN154@FindNextDi:
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _MinDist$1$[ebp]
$LN2@FindNextDi:

; 409  : 		{
; 410  : 			for ( i = 0 ; i<8 ; i++ )

  000b6	8b 45 18	 mov	 eax, DWORD PTR _i$1$[ebp]
  000b9	40		 inc	 eax
  000ba	89 45 18	 mov	 DWORD PTR _i$1$[ebp], eax
  000bd	83 f8 08	 cmp	 eax, 8
  000c0	0f 8c 6a ff ff
	ff		 jl	 $LL4@FindNextDi

; 423  : 					}
; 424  : 				}
; 425  : 			}
; 426  : 		}
; 427  : 		else

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _MinDist$1$[ebp]
  000c9	e9 79 01 00 00	 jmp	 $LN9@FindNextDi
$LN11@FindNextDi:

; 428  : 		{
; 429  : 			for ( i = dirstart+7 ; i <= dirstart+9 ; i++ )

  000ce	8b 4d 18	 mov	 ecx, DWORD PTR _dirstart$[ebp]
  000d1	8d 41 09	 lea	 eax, DWORD PTR [ecx+9]
  000d4	8d 59 07	 lea	 ebx, DWORD PTR [ecx+7]
  000d7	3b d8		 cmp	 ebx, eax
  000d9	0f 8f b5 00 00
	00		 jg	 $LN122@FindNextDi
  000df	90		 npad	 1
$LL7@FindNextDi:

; 430  : 			{
; 431  : 				ldir = i % 8;

  000e0	8b c3		 mov	 eax, ebx
  000e2	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000e7	79 05		 jns	 SHORT $LN159@FindNextDi
  000e9	48		 dec	 eax
  000ea	83 c8 f8	 or	 eax, -8			; fffffff8H
  000ed	40		 inc	 eax
$LN159@FindNextDi:

; 432  : 				int endx = sx + this->Dir[ldir*2];

  000ee	8b 94 c6 f4 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1012]

; 433  : 				int endy = sy + this->Dir[ldir*2+1];

  000f5	8b bc c6 f8 03
	00 00		 mov	 edi, DWORD PTR [esi+eax*8+1016]
  000fc	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]
  000ff	03 7d 0c	 add	 edi, DWORD PTR _sy$[ebp]

; 51   : 		int disty = y2 - y1;

  00102	8b 4d 14	 mov	 ecx, DWORD PTR _dy$[ebp]

; 430  : 			{
; 431  : 				ldir = i % 8;

  00105	89 45 f0	 mov	 DWORD PTR _ldir$2$[ebp], eax

; 51   : 		int disty = y2 - y1;

  00108	2b cf		 sub	 ecx, edi
  0010a	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]
  0010d	2b c2		 sub	 eax, edx

; 52   : 		return (distx * distx) + (disty * disty);

  0010f	0f af c9	 imul	 ecx, ecx
  00112	0f af c0	 imul	 eax, eax
  00115	03 c8		 add	 ecx, eax
  00117	89 4d f4	 mov	 DWORD PTR _dist$1$[ebp], ecx

; 434  : 				int dist = this->GetDist(endx, endy, dx, dy);
; 435  : 
; 436  : 				if ( MinDist > dist )

  0011a	39 4d fc	 cmp	 DWORD PTR _MinDist$1$[ebp], ecx
  0011d	7e 54		 jle	 SHORT $LN149@FindNextDi

; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  0011f	85 d2		 test	 edx, edx
  00121	78 50		 js	 SHORT $LN149@FindNextDi
  00123	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00125	3b d1		 cmp	 edx, ecx
  00127	7d 4a		 jge	 SHORT $LN149@FindNextDi
  00129	85 ff		 test	 edi, edi
  0012b	78 46		 js	 SHORT $LN149@FindNextDi
  0012d	3b f9		 cmp	 edi, ecx
  0012f	7d 42		 jge	 SHORT $LN149@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  00131	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00137	0f af cf	 imul	 ecx, edi
  0013a	03 c1		 add	 eax, ecx
  0013c	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00140	75 31		 jne	 SHORT $LN149@FindNextDi

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  00142	03 ca		 add	 ecx, edx

; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00144	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00147	7d 2a		 jge	 SHORT $LN149@FindNextDi

; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  00149	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  0014f	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  00153	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00159	73 14		 jae	 SHORT $LN53@FindNextDi
  0015b	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  0015f	75 0e		 jne	 SHORT $LN53@FindNextDi

; 437  : 				{
; 438  : 					if ( this->IsThisSpotOK(endx, endy) != FALSE && this->CanWeMoveForward3(endx, endy) != FALSE)
; 439  : 					{
; 440  : 						MinDist = dist;
; 441  : 						WhichDir = ldir;

  00161	8b 4d f4	 mov	 ecx, DWORD PTR _dist$1$[ebp]
  00164	8b 55 f0	 mov	 edx, DWORD PTR _ldir$2$[ebp]
  00167	89 4d fc	 mov	 DWORD PTR _MinDist$1$[ebp], ecx
  0016a	89 55 f8	 mov	 DWORD PTR _WhichDir$1$[ebp], edx
  0016d	eb 07		 jmp	 SHORT $LN5@FindNextDi
$LN53@FindNextDi:

; 111  : 		{
; 112  : 			this->HitMap[which] = 1;

  0016f	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1
$LN149@FindNextDi:
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _MinDist$1$[ebp]
$LN5@FindNextDi:

; 428  : 		{
; 429  : 			for ( i = dirstart+7 ; i <= dirstart+9 ; i++ )

  00176	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  00179	43		 inc	 ebx
  0017a	83 c0 09	 add	 eax, 9
  0017d	3b d8		 cmp	 ebx, eax
  0017f	0f 8e 5b ff ff
	ff		 jle	 $LL7@FindNextDi

; 442  : 					}
; 443  : 				}
; 444  : 			}
; 445  : 
; 446  : 			if ( MinDist == 10000000 )

  00185	81 f9 80 96 98
	00		 cmp	 ecx, 10000000		; 00989680H
  0018b	0f 85 c1 00 00
	00		 jne	 $LN20@FindNextDi
  00191	8b 4d 18	 mov	 ecx, DWORD PTR _dirstart$[ebp]
$LN122@FindNextDi:

; 447  : 			{
; 448  : 				for ( i = dirstart+2 ; i <= dirstart+6 ; i++ )

  00194	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]
  00197	8d 59 02	 lea	 ebx, DWORD PTR [ecx+2]
  0019a	3b d8		 cmp	 ebx, eax
  0019c	0f 8f df 02 00
	00		 jg	 $LN125@FindNextDi
$LL10@FindNextDi:

; 449  : 				{
; 450  : 					ldir = i % 8;

  001a2	8b c3		 mov	 eax, ebx
  001a4	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  001a9	79 05		 jns	 SHORT $LN160@FindNextDi
  001ab	48		 dec	 eax
  001ac	83 c8 f8	 or	 eax, -8			; fffffff8H
  001af	40		 inc	 eax
$LN160@FindNextDi:

; 451  : 					int endx = sx + this->Dir[ldir*2];

  001b0	8b 94 c6 f4 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1012]

; 452  : 					int endy = sy + this->Dir[ldir*2+1];

  001b7	8b bc c6 f8 03
	00 00		 mov	 edi, DWORD PTR [esi+eax*8+1016]
  001be	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]
  001c1	03 7d 0c	 add	 edi, DWORD PTR _sy$[ebp]

; 51   : 		int disty = y2 - y1;

  001c4	8b 4d 14	 mov	 ecx, DWORD PTR _dy$[ebp]

; 449  : 				{
; 450  : 					ldir = i % 8;

  001c7	89 45 f4	 mov	 DWORD PTR _ldir$3$[ebp], eax

; 51   : 		int disty = y2 - y1;

  001ca	2b cf		 sub	 ecx, edi
  001cc	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]
  001cf	2b c2		 sub	 eax, edx

; 52   : 		return (distx * distx) + (disty * disty);

  001d1	0f af c9	 imul	 ecx, ecx
  001d4	0f af c0	 imul	 eax, eax
  001d7	03 c8		 add	 ecx, eax
  001d9	89 4d f0	 mov	 DWORD PTR _dist$1$[ebp], ecx

; 453  : 					int dist = this->GetDist(endx, endy, dx, dy);
; 454  : 
; 455  : 					if ( MinDist > dist )

  001dc	39 4d fc	 cmp	 DWORD PTR _MinDist$1$[ebp], ecx
  001df	7e 54		 jle	 SHORT $LN142@FindNextDi

; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  001e1	85 d2		 test	 edx, edx
  001e3	78 50		 js	 SHORT $LN142@FindNextDi
  001e5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001e7	3b d1		 cmp	 edx, ecx
  001e9	7d 4a		 jge	 SHORT $LN142@FindNextDi
  001eb	85 ff		 test	 edi, edi
  001ed	78 46		 js	 SHORT $LN142@FindNextDi
  001ef	3b f9		 cmp	 edi, ecx
  001f1	7d 42		 jge	 SHORT $LN142@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  001f3	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  001f9	0f af cf	 imul	 ecx, edi
  001fc	03 c1		 add	 eax, ecx
  001fe	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00202	75 31		 jne	 SHORT $LN142@FindNextDi

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  00204	03 ca		 add	 ecx, edx

; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00206	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00209	7d 2a		 jge	 SHORT $LN142@FindNextDi

; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  0020b	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00211	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  00215	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0021b	73 14		 jae	 SHORT $LN66@FindNextDi
  0021d	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00221	75 0e		 jne	 SHORT $LN66@FindNextDi

; 456  : 					{
; 457  : 						if ( this->IsThisSpotOK(endx, endy) != FALSE && this->CanWeMoveForward3(endx, endy) != FALSE)
; 458  : 						{
; 459  : 							MinDist = dist;
; 460  : 							WhichDir = ldir;

  00223	8b 45 f0	 mov	 eax, DWORD PTR _dist$1$[ebp]
  00226	8b 4d f4	 mov	 ecx, DWORD PTR _ldir$3$[ebp]
  00229	89 45 fc	 mov	 DWORD PTR _MinDist$1$[ebp], eax
  0022c	89 4d f8	 mov	 DWORD PTR _WhichDir$1$[ebp], ecx
  0022f	eb 07		 jmp	 SHORT $LN8@FindNextDi
$LN66@FindNextDi:

; 111  : 		{
; 112  : 			this->HitMap[which] = 1;

  00231	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1
$LN142@FindNextDi:
  00235	8b 45 fc	 mov	 eax, DWORD PTR _MinDist$1$[ebp]
$LN8@FindNextDi:

; 447  : 			{
; 448  : 				for ( i = dirstart+2 ; i <= dirstart+6 ; i++ )

  00238	8b 4d 18	 mov	 ecx, DWORD PTR _dirstart$[ebp]
  0023b	43		 inc	 ebx
  0023c	83 c1 06	 add	 ecx, 6
  0023f	3b d9		 cmp	 ebx, ecx
  00241	0f 8e 5b ff ff
	ff		 jle	 $LL10@FindNextDi
$LN9@FindNextDi:

; 461  : 						}
; 462  : 					}
; 463  : 				}
; 464  : 			}
; 465  : 		}
; 466  : 		
; 467  : 		if ( MinDist == 10000000 )

  00247	3d 80 96 98 00	 cmp	 eax, 10000000		; 00989680H
  0024c	0f 84 2f 02 00
	00		 je	 $LN125@FindNextDi
$LN20@FindNextDi:

; 470  : 		}
; 471  : 		
; 472  : 		if ( this->CanWeMoveForward3(sx+this->Dir[WhichDir*2],sy+ this->Dir[WhichDir*2+1]) != FALSE )

  00252	8b 4d f8	 mov	 ecx, DWORD PTR _WhichDir$1$[ebp]

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  00255	8b 16		 mov	 edx, DWORD PTR [esi]

; 470  : 		}
; 471  : 		
; 472  : 		if ( this->CanWeMoveForward3(sx+this->Dir[WhichDir*2],sy+ this->Dir[WhichDir*2+1]) != FALSE )

  00257	8b 5d 0c	 mov	 ebx, DWORD PTR _sy$[ebp]
  0025a	8b 84 ce f8 03
	00 00		 mov	 eax, DWORD PTR [esi+ecx*8+1016]
  00261	8b bc ce f4 03
	00 00		 mov	 edi, DWORD PTR [esi+ecx*8+1012]
  00268	03 c3		 add	 eax, ebx
  0026a	03 7d 08	 add	 edi, DWORD PTR _sx$[ebp]

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  0026d	8b ca		 mov	 ecx, edx
  0026f	0f af c8	 imul	 ecx, eax
  00272	03 cf		 add	 ecx, edi

; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00274	3b fa		 cmp	 edi, edx
  00276	0f 8d 8b 00 00
	00		 jge	 $LN21@FindNextDi
  0027c	85 ff		 test	 edi, edi
  0027e	0f 88 83 00 00
	00		 js	 $LN21@FindNextDi
  00284	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00287	0f 8d 7a 00 00
	00		 jge	 $LN21@FindNextDi
  0028d	85 c0		 test	 eax, eax
  0028f	78 76		 js	 SHORT $LN21@FindNextDi

; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  00291	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00297	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  0029b	73 60		 jae	 SHORT $LN72@FindNextDi
  0029d	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  002a3	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  002a7	75 54		 jne	 SHORT $LN72@FindNextDi

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  002a9	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  002ac	33 c9		 xor	 ecx, ecx
  002ae	85 ff		 test	 edi, edi
  002b0	7e 3f		 jle	 SHORT $LN131@FindNextDi
$LL77@FindNextDi:

; 58   : 		{
; 59   : 			if ( x ==  this->PathX[i] && y == this->PathY[i] )

  002b2	0f b6 44 0e 0c	 movzx	 eax, BYTE PTR [esi+ecx+12]
  002b7	39 45 08	 cmp	 DWORD PTR _sx$[ebp], eax
  002ba	75 0c		 jne	 SHORT $LN75@FindNextDi
  002bc	0f b6 84 31 00
	02 00 00	 movzx	 eax, BYTE PTR [ecx+esi+512]
  002c4	3b d8		 cmp	 ebx, eax
  002c6	74 11		 je	 SHORT $LN74@FindNextDi
$LN75@FindNextDi:

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  002c8	41		 inc	 ecx
  002c9	3b cf		 cmp	 ecx, edi
  002cb	7c e5		 jl	 SHORT $LL77@FindNextDi

; 480  : 			}
; 481  : 
; 482  : 			return WhichDir;

  002cd	8b 45 f8	 mov	 eax, DWORD PTR _WhichDir$1$[ebp]
  002d0	5f		 pop	 edi
  002d1	5e		 pop	 esi
  002d2	5b		 pop	 ebx

; 520  : 		return -1;
; 521  : 	};

  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c2 1c 00	 ret	 28			; 0000001cH
$LN74@FindNextDi:

; 473  : 		{
; 474  : 			int path = this->VerifyThatOnPath(sx, sy);
; 475  : 
; 476  : 			if ( path != -1 )

  002d9	83 f9 ff	 cmp	 ecx, -1
  002dc	74 13		 je	 SHORT $LN131@FindNextDi

; 477  : 			{
; 478  : 				this->HitMap[sx+ sy * this->Width ] = 1;

  002de	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  002e1	0f af d3	 imul	 edx, ebx
  002e4	03 96 40 04 00
	00		 add	 edx, DWORD PTR [esi+1088]
  002ea	c6 04 02 01	 mov	 BYTE PTR [edx+eax], 1

; 479  : 				this->NumPath = path;

  002ee	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN131@FindNextDi:

; 480  : 			}
; 481  : 
; 482  : 			return WhichDir;

  002f1	8b 45 f8	 mov	 eax, DWORD PTR _WhichDir$1$[ebp]
  002f4	5f		 pop	 edi
  002f5	5e		 pop	 esi
  002f6	5b		 pop	 ebx

; 520  : 		return -1;
; 521  : 	};

  002f7	8b e5		 mov	 esp, ebp
  002f9	5d		 pop	 ebp
  002fa	c2 1c 00	 ret	 28			; 0000001cH
$LN72@FindNextDi:

; 111  : 		{
; 112  : 			this->HitMap[which] = 1;

  002fd	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00303	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN21@FindNextDi:

; 483  : 		}
; 484  : 
; 485  : 		if ( ErrorCheck != 0 )

  00307	80 7d 20 00	 cmp	 BYTE PTR _ErrorCheck$[ebp], 0
  0030b	0f 84 5e 01 00
	00		 je	 $LN26@FindNextDi

; 486  : 		{
; 487  : 			int dir = WhichDir+7;

  00311	8b 4d f8	 mov	 ecx, DWORD PTR _WhichDir$1$[ebp]
  00314	83 c1 07	 add	 ecx, 7

; 488  : 
; 489  : 			dir %= 8;

  00317	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  0031d	79 05		 jns	 SHORT $LN161@FindNextDi
  0031f	49		 dec	 ecx
  00320	83 c9 f8	 or	 ecx, -8			; fffffff8H
  00323	41		 inc	 ecx
$LN161@FindNextDi:

; 490  : 
; 491  : 			if (this->CanWeMoveForward3(sx + this->Dir[dir*2], sy + this->Dir[dir*2+1]) != FALSE )

  00324	8b 84 ce f8 03
	00 00		 mov	 eax, DWORD PTR [esi+ecx*8+1016]
  0032b	8b bc ce f4 03
	00 00		 mov	 edi, DWORD PTR [esi+ecx*8+1012]
  00332	03 c3		 add	 eax, ebx

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  00334	8b 16		 mov	 edx, DWORD PTR [esi]

; 490  : 
; 491  : 			if (this->CanWeMoveForward3(sx + this->Dir[dir*2], sy + this->Dir[dir*2+1]) != FALSE )

  00336	03 7d 08	 add	 edi, DWORD PTR _sx$[ebp]
  00339	89 4d 1c	 mov	 DWORD PTR _dir$1$[ebp], ecx

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  0033c	8b ca		 mov	 ecx, edx
  0033e	0f af c8	 imul	 ecx, eax
  00341	03 cf		 add	 ecx, edi

; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00343	3b fa		 cmp	 edi, edx
  00345	0f 8d 8b 00 00
	00		 jge	 $LN24@FindNextDi
  0034b	85 ff		 test	 edi, edi
  0034d	0f 88 83 00 00
	00		 js	 $LN24@FindNextDi
  00353	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00356	0f 8d 7a 00 00
	00		 jge	 $LN24@FindNextDi
  0035c	85 c0		 test	 eax, eax
  0035e	78 76		 js	 SHORT $LN24@FindNextDi

; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  00360	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00366	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  0036a	73 60		 jae	 SHORT $LN84@FindNextDi
  0036c	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00372	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00376	75 54		 jne	 SHORT $LN84@FindNextDi

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00378	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0037b	33 c9		 xor	 ecx, ecx
  0037d	85 ff		 test	 edi, edi
  0037f	7e 3f		 jle	 SHORT $LN132@FindNextDi
$LL89@FindNextDi:

; 58   : 		{
; 59   : 			if ( x ==  this->PathX[i] && y == this->PathY[i] )

  00381	0f b6 44 0e 0c	 movzx	 eax, BYTE PTR [esi+ecx+12]
  00386	39 45 08	 cmp	 DWORD PTR _sx$[ebp], eax
  00389	75 0c		 jne	 SHORT $LN87@FindNextDi
  0038b	0f b6 84 31 00
	02 00 00	 movzx	 eax, BYTE PTR [ecx+esi+512]
  00393	3b d8		 cmp	 ebx, eax
  00395	74 11		 je	 SHORT $LN86@FindNextDi
$LN87@FindNextDi:

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00397	41		 inc	 ecx
  00398	3b cf		 cmp	 ecx, edi
  0039a	7c e5		 jl	 SHORT $LL89@FindNextDi

; 499  : 				}
; 500  : 				return dir;

  0039c	8b 45 1c	 mov	 eax, DWORD PTR _dir$1$[ebp]
  0039f	5f		 pop	 edi
  003a0	5e		 pop	 esi
  003a1	5b		 pop	 ebx

; 520  : 		return -1;
; 521  : 	};

  003a2	8b e5		 mov	 esp, ebp
  003a4	5d		 pop	 ebp
  003a5	c2 1c 00	 ret	 28			; 0000001cH
$LN86@FindNextDi:

; 492  : 			{
; 493  : 				int path = this->VerifyThatOnPath(sx, sy);
; 494  : 
; 495  : 				if ( path != -1 )

  003a8	83 f9 ff	 cmp	 ecx, -1
  003ab	74 13		 je	 SHORT $LN132@FindNextDi

; 496  : 				{
; 497  : 					this->HitMap[sx+ sy * this->Width] = 1;

  003ad	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  003b0	0f af d3	 imul	 edx, ebx
  003b3	03 96 40 04 00
	00		 add	 edx, DWORD PTR [esi+1088]
  003b9	c6 04 02 01	 mov	 BYTE PTR [edx+eax], 1

; 498  : 					this->NumPath = path;

  003bd	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN132@FindNextDi:

; 499  : 				}
; 500  : 				return dir;

  003c0	8b 45 1c	 mov	 eax, DWORD PTR _dir$1$[ebp]
  003c3	5f		 pop	 edi
  003c4	5e		 pop	 esi
  003c5	5b		 pop	 ebx

; 520  : 		return -1;
; 521  : 	};

  003c6	8b e5		 mov	 esp, ebp
  003c8	5d		 pop	 ebp
  003c9	c2 1c 00	 ret	 28			; 0000001cH
$LN84@FindNextDi:

; 111  : 		{
; 112  : 			this->HitMap[which] = 1;

  003cc	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  003d2	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN24@FindNextDi:

; 501  : 			}
; 502  : 
; 503  : 			int dir2 = WhichDir+9;

  003d6	8b 5d f8	 mov	 ebx, DWORD PTR _WhichDir$1$[ebp]
  003d9	83 c3 09	 add	 ebx, 9

; 504  : 			dir2 %= 8;

  003dc	81 e3 07 00 00
	80		 and	 ebx, -2147483641	; 80000007H
  003e2	79 05		 jns	 SHORT $LN162@FindNextDi
  003e4	4b		 dec	 ebx
  003e5	83 cb f8	 or	 ebx, -8			; fffffff8H
  003e8	43		 inc	 ebx
$LN162@FindNextDi:

; 505  : 
; 506  : 			if (CanWeMoveForward3(sx+this->Dir[dir2*2], sy+this->Dir[dir2*2+1]) != FALSE )

  003e9	8b 84 de f8 03
	00 00		 mov	 eax, DWORD PTR [esi+ebx*8+1016]

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  003f0	8b 3e		 mov	 edi, DWORD PTR [esi]
  003f2	8b cf		 mov	 ecx, edi

; 505  : 
; 506  : 			if (CanWeMoveForward3(sx+this->Dir[dir2*2], sy+this->Dir[dir2*2+1]) != FALSE )

  003f4	03 45 0c	 add	 eax, DWORD PTR _sy$[ebp]
  003f7	8b 94 de f4 03
	00 00		 mov	 edx, DWORD PTR [esi+ebx*8+1012]
  003fe	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;

  00401	0f af c8	 imul	 ecx, eax
  00404	03 ca		 add	 ecx, edx

; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00406	3b d7		 cmp	 edx, edi
  00408	7d 62		 jge	 SHORT $LN158@FindNextDi
  0040a	85 d2		 test	 edx, edx
  0040c	78 5e		 js	 SHORT $LN158@FindNextDi
  0040e	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00411	7d 59		 jge	 SHORT $LN158@FindNextDi
  00413	85 c0		 test	 eax, eax
  00415	78 55		 js	 SHORT $LN158@FindNextDi

; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  00417	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  0041d	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  00421	73 3f		 jae	 SHORT $LN96@FindNextDi
  00423	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00429	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  0042d	75 33		 jne	 SHORT $LN96@FindNextDi

; 507  : 			{
; 508  : 				int path = this->VerifyThatOnPath(sx, sy);

  0042f	ff 75 0c	 push	 DWORD PTR _sy$[ebp]
  00432	8b ce		 mov	 ecx, esi
  00434	ff 75 08	 push	 DWORD PTR _sx$[ebp]
  00437	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  0043c	8b c8		 mov	 ecx, eax

; 509  : 
; 510  : 				if ( path != -1 )

  0043e	83 f9 ff	 cmp	 ecx, -1
  00441	74 14		 je	 SHORT $LN27@FindNextDi

; 511  : 				{
; 512  : 					this->HitMap[sx + sy * this->Width] = 1;

  00443	0f af 7d 0c	 imul	 edi, DWORD PTR _sy$[ebp]
  00447	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  0044a	03 be 40 04 00
	00		 add	 edi, DWORD PTR [esi+1088]
  00450	c6 04 07 01	 mov	 BYTE PTR [edi+eax], 1

; 513  : 					this->NumPath = path;

  00454	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN27@FindNextDi:

; 514  : 				}
; 515  : 				return dir2;

  00457	5f		 pop	 edi
  00458	5e		 pop	 esi
  00459	8b c3		 mov	 eax, ebx
  0045b	5b		 pop	 ebx

; 520  : 		return -1;
; 521  : 	};

  0045c	8b e5		 mov	 esp, ebp
  0045e	5d		 pop	 ebp
  0045f	c2 1c 00	 ret	 28			; 0000001cH
$LN96@FindNextDi:

; 111  : 		{
; 112  : 			this->HitMap[which] = 1;

  00462	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00468	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN158@FindNextDi:
  0046c	8b 5d 0c	 mov	 ebx, DWORD PTR _sy$[ebp]
$LN26@FindNextDi:

; 516  : 			}
; 517  : 		}
; 518  : 		
; 519  : 		this->HitMap[sx + sy*this->Width]=1;

  0046f	8b 06		 mov	 eax, DWORD PTR [esi]
  00471	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  00474	0f af c3	 imul	 eax, ebx
  00477	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  0047d	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1
$LN125@FindNextDi:

; 468  : 		{
; 469  : 			return -1;

  00481	5f		 pop	 edi
  00482	5e		 pop	 esi
  00483	83 c8 ff	 or	 eax, -1
  00486	5b		 pop	 ebx

; 520  : 		return -1;
; 521  : 	};

  00487	8b e5		 mov	 esp, ebp
  00489	5d		 pop	 ebp
  0048a	c2 1c 00	 ret	 28			; 0000001cH
?FindNextDir3@PATH@@AAEHHHHHH_N0@Z ENDP			; PATH::FindNextDir3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?FindNextDir2@PATH@@AAEHHHHHH_N0@Z
_TEXT	SEGMENT
_ldir$3$ = -12						; size = 4
_ldir$2$ = -12						; size = 4
_ldir$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
_WhichDir$1$ = -4					; size = 4
_sx$ = 8						; size = 4
_dir$1$ = 12						; size = 4
tv986 = 12						; size = 4
_sy$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_y$1$ = 24						; size = 4
_dir2$1$ = 24						; size = 4
tv996 = 24						; size = 4
_dirstart$ = 24						; size = 4
_x$1$ = 28						; size = 4
_x$1$ = 28						; size = 4
_x$1$ = 28						; size = 4
_dist$1$ = 28						; size = 4
_dist$1$ = 28						; size = 4
_dist$1$ = 28						; size = 4
_First$ = 28						; size = 1
_y$1$ = 32						; size = 4
tv1004 = 32						; size = 4
_ErrorCheck$ = 32					; size = 1
?FindNextDir2@PATH@@AAEHHHHHH_N0@Z PROC			; PATH::FindNextDir2, COMDAT
; _this$ = ecx

; 271  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 272  : 		int MinDist = 10000000;
; 273  : 		long ldir;
; 274  : 		int WhichDir = 0;

  00008	33 c0		 xor	 eax, eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	bf 80 96 98 00	 mov	 edi, 10000000		; 00989680H
  00012	89 75 f8	 mov	 DWORD PTR _this$1$[ebp], esi
  00015	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax

; 275  : 		int i;
; 276  : 
; 277  : 		if ( First != 0 )

  00018	38 45 1c	 cmp	 BYTE PTR _First$[ebp], al
  0001b	74 73		 je	 SHORT $LN11@FindNextDi

; 278  : 		{
; 279  : 			for ( i = 0 ; i<8 ; i++ )

  0001d	33 db		 xor	 ebx, ebx
  0001f	90		 npad	 1
$LL4@FindNextDi:

; 280  : 			{
; 281  : 				ldir = i % 8 ;

  00020	8b c3		 mov	 eax, ebx
  00022	83 e0 07	 and	 eax, 7
  00025	89 45 f4	 mov	 DWORD PTR _ldir$1$[ebp], eax

; 282  : 				int endx = sx + this->Dir[ldir*2];

  00028	8b 8c c6 f4 03
	00 00		 mov	 ecx, DWORD PTR [esi+eax*8+1012]

; 283  : 				int endy = sy + this->Dir[ldir*2+1];

  0002f	8b 94 c6 f8 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1016]
  00036	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  00039	03 55 0c	 add	 edx, DWORD PTR _sy$[ebp]

; 50   : 		int distx = x2 - x1;

  0003c	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]

; 51   : 		int disty = y2 - y1;

  0003f	8b 75 14	 mov	 esi, DWORD PTR _dy$[ebp]
  00042	2b c1		 sub	 eax, ecx
  00044	2b f2		 sub	 esi, edx

; 52   : 		return (distx * distx) + (disty * disty);

  00046	0f af c0	 imul	 eax, eax
  00049	0f af f6	 imul	 esi, esi
  0004c	03 f0		 add	 esi, eax
  0004e	89 75 1c	 mov	 DWORD PTR _dist$1$[ebp], esi

; 284  : 				int dist = this->GetDist(endx, endy, dx, dy);
; 285  : 
; 286  : 				if ( MinDist > dist )

  00051	3b fe		 cmp	 edi, esi
  00053	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00056	7e 2a		 jle	 SHORT $LN2@FindNextDi

; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;
; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 111  : 		{
; 112  : 			this->HitMap[which] = 1;
; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  00058	85 c9		 test	 ecx, ecx
  0005a	78 26		 js	 SHORT $LN2@FindNextDi
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	3b c8		 cmp	 ecx, eax
  00060	7d 20		 jge	 SHORT $LN2@FindNextDi
  00062	85 d2		 test	 edx, edx
  00064	78 1c		 js	 SHORT $LN2@FindNextDi
  00066	3b d0		 cmp	 edx, eax
  00068	7d 18		 jge	 SHORT $LN2@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  0006a	0f af c2	 imul	 eax, edx
  0006d	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00073	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00077	75 09		 jne	 SHORT $LN2@FindNextDi

; 287  : 				{
; 288  : 					if ( this->IsThisSpotOK(endx, endy) != FALSE )
; 289  : 					{
; 290  : 						MinDist = dist;

  00079	8b 45 f4	 mov	 eax, DWORD PTR _ldir$1$[ebp]
  0007c	8b 7d 1c	 mov	 edi, DWORD PTR _dist$1$[ebp]

; 291  : 						WhichDir = ldir;

  0007f	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax
$LN2@FindNextDi:

; 278  : 		{
; 279  : 			for ( i = 0 ; i<8 ; i++ )

  00082	43		 inc	 ebx
  00083	83 fb 08	 cmp	 ebx, 8
  00086	7c 98		 jl	 SHORT $LL4@FindNextDi

; 292  : 					}
; 293  : 				}
; 294  : 			}
; 295  : 		}
; 296  : 		else

  00088	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  0008b	e9 17 01 00 00	 jmp	 $LN9@FindNextDi
$LN11@FindNextDi:

; 297  : 		{
; 298  : 			for ( i = dirstart+7 ; i <= dirstart+9 ; i++ )

  00090	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  00093	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  00096	8d 4b 07	 lea	 ecx, DWORD PTR [ebx+7]
  00099	3b c8		 cmp	 ecx, eax
  0009b	0f 8f 82 00 00
	00		 jg	 $LN106@FindNextDi
$LL7@FindNextDi:

; 299  : 			{
; 300  : 				ldir = i % 8;

  000a1	8b c1		 mov	 eax, ecx
  000a3	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000a8	79 05		 jns	 SHORT $LN116@FindNextDi
  000aa	48		 dec	 eax
  000ab	83 c8 f8	 or	 eax, -8			; fffffff8H
  000ae	40		 inc	 eax
$LN116@FindNextDi:

; 301  : 				int endx = sx + this->Dir[ldir*2];

  000af	8b 94 c6 f4 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1012]

; 302  : 				int endy = sy + this->Dir[ldir*2+1];

  000b6	8b 9c c6 f8 03
	00 00		 mov	 ebx, DWORD PTR [esi+eax*8+1016]
  000bd	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]
  000c0	03 5d 0c	 add	 ebx, DWORD PTR _sy$[ebp]

; 51   : 		int disty = y2 - y1;

  000c3	8b 75 14	 mov	 esi, DWORD PTR _dy$[ebp]

; 299  : 			{
; 300  : 				ldir = i % 8;

  000c6	89 45 f4	 mov	 DWORD PTR _ldir$2$[ebp], eax

; 51   : 		int disty = y2 - y1;

  000c9	2b f3		 sub	 esi, ebx
  000cb	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]
  000ce	2b c2		 sub	 eax, edx

; 52   : 		return (distx * distx) + (disty * disty);

  000d0	0f af f6	 imul	 esi, esi
  000d3	0f af c0	 imul	 eax, eax
  000d6	03 f0		 add	 esi, eax
  000d8	89 75 1c	 mov	 DWORD PTR _dist$1$[ebp], esi

; 303  : 				int dist = this->GetDist(endx, endy, dx, dy);
; 304  : 
; 305  : 				if ( MinDist > dist )

  000db	3b fe		 cmp	 edi, esi
  000dd	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  000e0	7e 2a		 jle	 SHORT $LN5@FindNextDi

; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;
; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 111  : 		{
; 112  : 			this->HitMap[which] = 1;
; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  000e2	85 d2		 test	 edx, edx
  000e4	78 26		 js	 SHORT $LN5@FindNextDi
  000e6	8b 06		 mov	 eax, DWORD PTR [esi]
  000e8	3b d0		 cmp	 edx, eax
  000ea	7d 20		 jge	 SHORT $LN5@FindNextDi
  000ec	85 db		 test	 ebx, ebx
  000ee	78 1c		 js	 SHORT $LN5@FindNextDi
  000f0	3b d8		 cmp	 ebx, eax
  000f2	7d 18		 jge	 SHORT $LN5@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  000f4	0f af c3	 imul	 eax, ebx
  000f7	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  000fd	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00101	75 09		 jne	 SHORT $LN5@FindNextDi

; 306  : 				{
; 307  : 					if ( this->IsThisSpotOK(endx, endy) != FALSE )
; 308  : 					{
; 309  : 						MinDist = dist;

  00103	8b 45 f4	 mov	 eax, DWORD PTR _ldir$2$[ebp]
  00106	8b 7d 1c	 mov	 edi, DWORD PTR _dist$1$[ebp]

; 310  : 						WhichDir = ldir;

  00109	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax
$LN5@FindNextDi:

; 297  : 		{
; 298  : 			for ( i = dirstart+7 ; i <= dirstart+9 ; i++ )

  0010c	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  0010f	41		 inc	 ecx
  00110	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  00113	3b c8		 cmp	 ecx, eax
  00115	7e 8a		 jle	 SHORT $LL7@FindNextDi

; 311  : 					}
; 312  : 				}
; 313  : 			}
; 314  : 
; 315  : 			if ( MinDist == 10000000 )

  00117	81 ff 80 96 98
	00		 cmp	 edi, 10000000		; 00989680H
  0011d	0f 85 84 00 00
	00		 jne	 $LN9@FindNextDi
$LN106@FindNextDi:

; 316  : 			{
; 317  : 				for ( i = dirstart+2 ; i <= dirstart+6 ; i++ )

  00123	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  00126	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  00129	3b c8		 cmp	 ecx, eax
  0012b	0f 8f 76 00 00
	00		 jg	 $LN9@FindNextDi
$LL10@FindNextDi:

; 318  : 				{
; 319  : 					ldir = i % 8;

  00131	8b c1		 mov	 eax, ecx
  00133	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00138	79 05		 jns	 SHORT $LN117@FindNextDi
  0013a	48		 dec	 eax
  0013b	83 c8 f8	 or	 eax, -8			; fffffff8H
  0013e	40		 inc	 eax
$LN117@FindNextDi:

; 320  : 					int endx = sx + this->Dir[ldir*2];

  0013f	8b 94 c6 f4 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1012]

; 321  : 					int endy = sy + this->Dir[ldir*2+1];

  00146	8b 9c c6 f8 03
	00 00		 mov	 ebx, DWORD PTR [esi+eax*8+1016]
  0014d	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]
  00150	03 5d 0c	 add	 ebx, DWORD PTR _sy$[ebp]

; 51   : 		int disty = y2 - y1;

  00153	8b 75 14	 mov	 esi, DWORD PTR _dy$[ebp]

; 318  : 				{
; 319  : 					ldir = i % 8;

  00156	89 45 f4	 mov	 DWORD PTR _ldir$3$[ebp], eax

; 51   : 		int disty = y2 - y1;

  00159	2b f3		 sub	 esi, ebx
  0015b	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]
  0015e	2b c2		 sub	 eax, edx

; 52   : 		return (distx * distx) + (disty * disty);

  00160	0f af f6	 imul	 esi, esi
  00163	0f af c0	 imul	 eax, eax
  00166	03 f0		 add	 esi, eax
  00168	89 75 1c	 mov	 DWORD PTR _dist$1$[ebp], esi

; 322  : 					int dist = this->GetDist(endx, endy, dx, dy);
; 323  : 
; 324  : 					if ( MinDist > dist )

  0016b	3b fe		 cmp	 edi, esi
  0016d	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00170	7e 2a		 jle	 SHORT $LN8@FindNextDi

; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;
; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 111  : 		{
; 112  : 			this->HitMap[which] = 1;
; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  00172	85 d2		 test	 edx, edx
  00174	78 26		 js	 SHORT $LN8@FindNextDi
  00176	8b 06		 mov	 eax, DWORD PTR [esi]
  00178	3b d0		 cmp	 edx, eax
  0017a	7d 20		 jge	 SHORT $LN8@FindNextDi
  0017c	85 db		 test	 ebx, ebx
  0017e	78 1c		 js	 SHORT $LN8@FindNextDi
  00180	3b d8		 cmp	 ebx, eax
  00182	7d 18		 jge	 SHORT $LN8@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  00184	0f af c3	 imul	 eax, ebx
  00187	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  0018d	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00191	75 09		 jne	 SHORT $LN8@FindNextDi

; 325  : 					{
; 326  : 						if ( this->IsThisSpotOK(endx, endy) != FALSE )
; 327  : 						{
; 328  : 							MinDist = dist;

  00193	8b 45 f4	 mov	 eax, DWORD PTR _ldir$3$[ebp]
  00196	8b 7d 1c	 mov	 edi, DWORD PTR _dist$1$[ebp]

; 329  : 							WhichDir = ldir;

  00199	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax
$LN8@FindNextDi:

; 316  : 			{
; 317  : 				for ( i = dirstart+2 ; i <= dirstart+6 ; i++ )

  0019c	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  0019f	41		 inc	 ecx
  001a0	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  001a3	3b c8		 cmp	 ecx, eax
  001a5	7e 8a		 jle	 SHORT $LL10@FindNextDi
$LN9@FindNextDi:

; 330  : 						}
; 331  : 					}
; 332  : 				}
; 333  : 			}
; 334  : 		}
; 335  : 		int LastDist;
; 336  : 
; 337  : 		this->LastDir = dirstart;
; 338  : 		LastDist = this->GetDist(sx, sy, sx + this->Dir[this->LastDir*2], sy + this->Dir[this->LastDir*2+1]);
; 339  : 
; 340  : 		if ( ( LastDist > MinDist - 6 ) && ( LastDist < MinDist + 6 ) && ( MinDist >= 25 ) )

  001a7	8b 55 fc	 mov	 edx, DWORD PTR _WhichDir$1$[ebp]
  001aa	89 9e 34 04 00
	00		 mov	 DWORD PTR [esi+1076], ebx

; 50   : 		int distx = x2 - x1;

  001b0	8b 84 de f4 03
	00 00		 mov	 eax, DWORD PTR [esi+ebx*8+1012]

; 51   : 		int disty = y2 - y1;

  001b7	8b 8c de f8 03
	00 00		 mov	 ecx, DWORD PTR [esi+ebx*8+1016]

; 52   : 		return (distx * distx) + (disty * disty);

  001be	0f af c0	 imul	 eax, eax
  001c1	0f af c9	 imul	 ecx, ecx
  001c4	03 c8		 add	 ecx, eax

; 330  : 						}
; 331  : 					}
; 332  : 				}
; 333  : 			}
; 334  : 		}
; 335  : 		int LastDist;
; 336  : 
; 337  : 		this->LastDir = dirstart;
; 338  : 		LastDist = this->GetDist(sx, sy, sx + this->Dir[this->LastDir*2], sy + this->Dir[this->LastDir*2+1]);
; 339  : 
; 340  : 		if ( ( LastDist > MinDist - 6 ) && ( LastDist < MinDist + 6 ) && ( MinDist >= 25 ) )

  001c6	8d 47 fa	 lea	 eax, DWORD PTR [edi-6]
  001c9	3b c8		 cmp	 ecx, eax
  001cb	7e 0d		 jle	 SHORT $LN20@FindNextDi
  001cd	8d 47 06	 lea	 eax, DWORD PTR [edi+6]
  001d0	3b c8		 cmp	 ecx, eax
  001d2	7d 06		 jge	 SHORT $LN20@FindNextDi
  001d4	83 ff 19	 cmp	 edi, 25			; 00000019H
  001d7	0f 4d d3	 cmovge	 edx, ebx
$LN20@FindNextDi:

; 341  : 		{
; 342  : 			WhichDir = this->LastDir;
; 343  : 		}
; 344  : 
; 345  : 		if ( MinDist == 10000000 )

  001da	81 ff 80 96 98
	00		 cmp	 edi, 10000000		; 00989680H
  001e0	0f 84 41 02 00
	00		 je	 $LN120@FindNextDi

; 346  : 		{
; 347  : 			return -1;
; 348  : 		}
; 349  : 		
; 350  : 		if ( this->CanWeMoveForward2(sx+this->Dir[WhichDir*2],sy+ this->Dir[WhichDir*2+1]) != FALSE )

  001e6	8b 84 d6 f8 03
	00 00		 mov	 eax, DWORD PTR [esi+edx*8+1016]
  001ed	8b 5d 0c	 mov	 ebx, DWORD PTR _sy$[ebp]
  001f0	03 c3		 add	 eax, ebx
  001f2	8b 7d 08	 mov	 edi, DWORD PTR _sx$[ebp]
  001f5	89 45 18	 mov	 DWORD PTR _y$1$[ebp], eax
  001f8	8b 84 d6 f4 03
	00 00		 mov	 eax, DWORD PTR [esi+edx*8+1012]
  001ff	03 c7		 add	 eax, edi
  00201	89 45 1c	 mov	 DWORD PTR _x$1$[ebp], eax

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;

  00204	8b 06		 mov	 eax, DWORD PTR [esi]
  00206	8b c8		 mov	 ecx, eax
  00208	0f af 4d 18	 imul	 ecx, DWORD PTR _y$1$[ebp]
  0020c	03 4d 1c	 add	 ecx, DWORD PTR _x$1$[ebp]

; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  0020f	39 45 1c	 cmp	 DWORD PTR _x$1$[ebp], eax
  00212	0f 8d 8b 00 00
	00		 jge	 $LN22@FindNextDi
  00218	83 7d 1c 00	 cmp	 DWORD PTR _x$1$[ebp], 0
  0021c	0f 8c 81 00 00
	00		 jl	 $LN22@FindNextDi
  00222	8b 45 18	 mov	 eax, DWORD PTR _y$1$[ebp]
  00225	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00228	0f 8d 75 00 00
	00		 jge	 $LN22@FindNextDi
  0022e	85 c0		 test	 eax, eax
  00230	78 71		 js	 SHORT $LN22@FindNextDi

; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  00232	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00238	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  0023c	73 5b		 jae	 SHORT $LN57@FindNextDi
  0023e	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00244	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00248	75 4f		 jne	 SHORT $LN57@FindNextDi

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  0024a	33 c9		 xor	 ecx, ecx
  0024c	39 4e 08	 cmp	 DWORD PTR [esi+8], ecx
  0024f	7e 3d		 jle	 SHORT $LN112@FindNextDi
$LL62@FindNextDi:

; 58   : 		{
; 59   : 			if ( x ==  this->PathX[i] && y == this->PathY[i] )

  00251	0f b6 44 0e 0c	 movzx	 eax, BYTE PTR [esi+ecx+12]
  00256	3b f8		 cmp	 edi, eax
  00258	75 0c		 jne	 SHORT $LN60@FindNextDi
  0025a	0f b6 84 31 00
	02 00 00	 movzx	 eax, BYTE PTR [ecx+esi+512]
  00262	3b d8		 cmp	 ebx, eax
  00264	74 11		 je	 SHORT $LN59@FindNextDi
$LN60@FindNextDi:

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00266	41		 inc	 ecx
  00267	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0026a	7c e5		 jl	 SHORT $LL62@FindNextDi

; 358  : 			}
; 359  : 
; 360  : 			return WhichDir;

  0026c	5f		 pop	 edi
  0026d	5e		 pop	 esi
  0026e	8b c2		 mov	 eax, edx
  00270	5b		 pop	 ebx

; 399  : 	};

  00271	8b e5		 mov	 esp, ebp
  00273	5d		 pop	 ebp
  00274	c2 1c 00	 ret	 28			; 0000001cH
$LN59@FindNextDi:

; 351  : 		{
; 352  : 			int path = this->VerifyThatOnPath(sx, sy);
; 353  : 
; 354  : 			if ( path != -1 )

  00277	83 f9 ff	 cmp	 ecx, -1
  0027a	74 12		 je	 SHORT $LN112@FindNextDi

; 355  : 			{
; 356  : 				this->HitMap[sx+ sy * this->Width ] = 1;

  0027c	8b 06		 mov	 eax, DWORD PTR [esi]
  0027e	0f af c3	 imul	 eax, ebx
  00281	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00287	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1

; 357  : 				this->NumPath = path;

  0028b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN112@FindNextDi:

; 358  : 			}
; 359  : 
; 360  : 			return WhichDir;

  0028e	5f		 pop	 edi
  0028f	5e		 pop	 esi
  00290	8b c2		 mov	 eax, edx
  00292	5b		 pop	 ebx

; 399  : 	};

  00293	8b e5		 mov	 esp, ebp
  00295	5d		 pop	 ebp
  00296	c2 1c 00	 ret	 28			; 0000001cH
$LN57@FindNextDi:

; 94   : 		{
; 95   : 			this->HitMap[which] = 1;

  00299	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0029f	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN22@FindNextDi:

; 361  : 		}
; 362  : 
; 363  : 		if ( ErrorCheck != 0 )

  002a3	80 7d 20 00	 cmp	 BYTE PTR _ErrorCheck$[ebp], 0
  002a7	0f 84 6b 01 00
	00		 je	 $LN27@FindNextDi

; 364  : 		{
; 365  : 			int dir = WhichDir+7;

  002ad	8d 4a 07	 lea	 ecx, DWORD PTR [edx+7]

; 366  : 
; 367  : 			dir %= 8;

  002b0	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  002b6	79 05		 jns	 SHORT $LN118@FindNextDi
  002b8	49		 dec	 ecx
  002b9	83 c9 f8	 or	 ecx, -8			; fffffff8H
  002bc	41		 inc	 ecx
$LN118@FindNextDi:

; 368  : 
; 369  : 			if (this->CanWeMoveForward2(sx + this->Dir[dir*2], sy + this->Dir[dir*2+1]) != FALSE )

  002bd	8b 84 ce f8 03
	00 00		 mov	 eax, DWORD PTR [esi+ecx*8+1016]
  002c4	03 c3		 add	 eax, ebx
  002c6	89 4d 0c	 mov	 DWORD PTR _dir$1$[ebp], ecx
  002c9	89 45 20	 mov	 DWORD PTR _y$1$[ebp], eax
  002cc	8b 84 ce f4 03
	00 00		 mov	 eax, DWORD PTR [esi+ecx*8+1012]
  002d3	03 c7		 add	 eax, edi
  002d5	89 45 1c	 mov	 DWORD PTR _x$1$[ebp], eax

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;

  002d8	8b 06		 mov	 eax, DWORD PTR [esi]
  002da	8b c8		 mov	 ecx, eax
  002dc	0f af 4d 20	 imul	 ecx, DWORD PTR _y$1$[ebp]
  002e0	03 4d 1c	 add	 ecx, DWORD PTR _x$1$[ebp]

; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  002e3	39 45 1c	 cmp	 DWORD PTR _x$1$[ebp], eax
  002e6	0f 8d 97 00 00
	00		 jge	 $LN25@FindNextDi
  002ec	83 7d 1c 00	 cmp	 DWORD PTR _x$1$[ebp], 0
  002f0	0f 8c 8d 00 00
	00		 jl	 $LN25@FindNextDi
  002f6	8b 45 20	 mov	 eax, DWORD PTR _y$1$[ebp]
  002f9	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  002fc	0f 8d 81 00 00
	00		 jge	 $LN25@FindNextDi
  00302	85 c0		 test	 eax, eax
  00304	0f 88 79 00 00
	00		 js	 $LN25@FindNextDi

; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  0030a	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00310	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  00314	73 63		 jae	 SHORT $LN69@FindNextDi
  00316	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0031c	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00320	75 57		 jne	 SHORT $LN69@FindNextDi

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00322	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00325	33 c9		 xor	 ecx, ecx
  00327	85 d2		 test	 edx, edx
  00329	7e 42		 jle	 SHORT $LN113@FindNextDi
  0032b	0f 1f 44 00 00	 npad	 5
$LL74@FindNextDi:

; 58   : 		{
; 59   : 			if ( x ==  this->PathX[i] && y == this->PathY[i] )

  00330	0f b6 44 0e 0c	 movzx	 eax, BYTE PTR [esi+ecx+12]
  00335	3b f8		 cmp	 edi, eax
  00337	75 0c		 jne	 SHORT $LN72@FindNextDi
  00339	0f b6 84 31 00
	02 00 00	 movzx	 eax, BYTE PTR [ecx+esi+512]
  00341	3b d8		 cmp	 ebx, eax
  00343	74 11		 je	 SHORT $LN71@FindNextDi
$LN72@FindNextDi:

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00345	41		 inc	 ecx
  00346	3b ca		 cmp	 ecx, edx
  00348	7c e6		 jl	 SHORT $LL74@FindNextDi

; 377  : 				}
; 378  : 				return dir;

  0034a	8b 45 0c	 mov	 eax, DWORD PTR _dir$1$[ebp]
  0034d	5f		 pop	 edi
  0034e	5e		 pop	 esi
  0034f	5b		 pop	 ebx

; 399  : 	};

  00350	8b e5		 mov	 esp, ebp
  00352	5d		 pop	 ebp
  00353	c2 1c 00	 ret	 28			; 0000001cH
$LN71@FindNextDi:

; 370  : 			{
; 371  : 				int path = this->VerifyThatOnPath(sx, sy);
; 372  : 
; 373  : 				if ( path != -1 )

  00356	83 f9 ff	 cmp	 ecx, -1
  00359	74 12		 je	 SHORT $LN113@FindNextDi

; 374  : 				{
; 375  : 					this->HitMap[sx+ sy * this->Width] = 1;

  0035b	8b 06		 mov	 eax, DWORD PTR [esi]
  0035d	0f af c3	 imul	 eax, ebx
  00360	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00366	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1

; 376  : 					this->NumPath = path;

  0036a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN113@FindNextDi:

; 377  : 				}
; 378  : 				return dir;

  0036d	8b 45 0c	 mov	 eax, DWORD PTR _dir$1$[ebp]
  00370	5f		 pop	 edi
  00371	5e		 pop	 esi
  00372	5b		 pop	 ebx

; 399  : 	};

  00373	8b e5		 mov	 esp, ebp
  00375	5d		 pop	 ebp
  00376	c2 1c 00	 ret	 28			; 0000001cH
$LN69@FindNextDi:

; 94   : 		{
; 95   : 			this->HitMap[which] = 1;

  00379	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0037f	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN25@FindNextDi:

; 379  : 			}
; 380  : 
; 381  : 			int dir2 = WhichDir+9;

  00383	8d 42 09	 lea	 eax, DWORD PTR [edx+9]

; 382  : 			dir2 %= 8;

  00386	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0038b	79 05		 jns	 SHORT $LN119@FindNextDi
  0038d	48		 dec	 eax
  0038e	83 c8 f8	 or	 eax, -8			; fffffff8H
  00391	40		 inc	 eax
$LN119@FindNextDi:

; 383  : 
; 384  : 			if (CanWeMoveForward2(sx+this->Dir[dir2*2], sy+this->Dir[dir2*2+1]) != FALSE )

  00392	8b 94 c6 f8 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1016]
  00399	89 45 18	 mov	 DWORD PTR _dir2$1$[ebp], eax
  0039c	03 d3		 add	 edx, ebx
  0039e	8b 84 c6 f4 03
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+1012]
  003a5	03 c7		 add	 eax, edi
  003a7	89 45 1c	 mov	 DWORD PTR _x$1$[ebp], eax

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;
; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )
; 77   : 		{
; 78   : 			this->HitMap[which] = 1;
; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;

  003aa	8b 06		 mov	 eax, DWORD PTR [esi]
  003ac	8b c8		 mov	 ecx, eax
  003ae	0f af ca	 imul	 ecx, edx
  003b1	03 4d 1c	 add	 ecx, DWORD PTR _x$1$[ebp]

; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  003b4	39 45 1c	 cmp	 DWORD PTR _x$1$[ebp], eax
  003b7	7d 5f		 jge	 SHORT $LN27@FindNextDi
  003b9	83 7d 1c 00	 cmp	 DWORD PTR _x$1$[ebp], 0
  003bd	7c 59		 jl	 SHORT $LN27@FindNextDi
  003bf	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  003c2	7d 54		 jge	 SHORT $LN27@FindNextDi
  003c4	85 d2		 test	 edx, edx
  003c6	78 50		 js	 SHORT $LN27@FindNextDi

; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  003c8	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  003ce	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  003d2	73 3a		 jae	 SHORT $LN81@FindNextDi
  003d4	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  003da	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  003de	75 2e		 jne	 SHORT $LN81@FindNextDi

; 385  : 			{
; 386  : 				int path = this->VerifyThatOnPath(sx, sy);

  003e0	53		 push	 ebx
  003e1	57		 push	 edi
  003e2	8b ce		 mov	 ecx, esi
  003e4	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  003e9	8b c8		 mov	 ecx, eax

; 387  : 
; 388  : 				if ( path != -1 )

  003eb	83 f9 ff	 cmp	 ecx, -1
  003ee	74 12		 je	 SHORT $LN28@FindNextDi

; 389  : 				{
; 390  : 					this->HitMap[sx + sy * this->Width] = 1;

  003f0	8b 06		 mov	 eax, DWORD PTR [esi]
  003f2	0f af c3	 imul	 eax, ebx
  003f5	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  003fb	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1

; 391  : 					this->NumPath = path;

  003ff	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN28@FindNextDi:

; 392  : 				}
; 393  : 				return dir2;

  00402	8b 45 18	 mov	 eax, DWORD PTR _dir2$1$[ebp]
  00405	5f		 pop	 edi
  00406	5e		 pop	 esi
  00407	5b		 pop	 ebx

; 399  : 	};

  00408	8b e5		 mov	 esp, ebp
  0040a	5d		 pop	 ebp
  0040b	c2 1c 00	 ret	 28			; 0000001cH
$LN81@FindNextDi:

; 94   : 		{
; 95   : 			this->HitMap[which] = 1;

  0040e	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00414	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN27@FindNextDi:

; 394  : 			}
; 395  : 		}
; 396  : 		
; 397  : 		this->HitMap[sx + sy*this->Width]=1;

  00418	8b 06		 mov	 eax, DWORD PTR [esi]
  0041a	0f af c3	 imul	 eax, ebx
  0041d	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00423	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1
$LN120@FindNextDi:

; 398  : 		return -1;

  00427	5f		 pop	 edi
  00428	5e		 pop	 esi
  00429	83 c8 ff	 or	 eax, -1
  0042c	5b		 pop	 ebx

; 399  : 	};

  0042d	8b e5		 mov	 esp, ebp
  0042f	5d		 pop	 ebp
  00430	c2 1c 00	 ret	 28			; 0000001cH
?FindNextDir2@PATH@@AAEHHHHHH_N0@Z ENDP			; PATH::FindNextDir2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?FindNextDir@PATH@@AAEHHHHHH_N0@Z
_TEXT	SEGMENT
_ldir$3$ = -12						; size = 4
_ldir$2$ = -12						; size = 4
_ldir$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
_WhichDir$1$ = -4					; size = 4
_sx$ = 8						; size = 4
_dir$1$ = 12						; size = 4
tv986 = 12						; size = 4
_sy$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_y$1$ = 24						; size = 4
_dir2$1$ = 24						; size = 4
tv996 = 24						; size = 4
_dirstart$ = 24						; size = 4
_x$1$ = 28						; size = 4
_x$1$ = 28						; size = 4
_x$1$ = 28						; size = 4
_dist$1$ = 28						; size = 4
_dist$1$ = 28						; size = 4
_dist$1$ = 28						; size = 4
_First$ = 28						; size = 1
_y$1$ = 32						; size = 4
tv1004 = 32						; size = 4
_ErrorCheck$ = 32					; size = 1
?FindNextDir@PATH@@AAEHHHHHH_N0@Z PROC			; PATH::FindNextDir, COMDAT
; _this$ = ecx

; 141  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 142  : 		int MinDist = 10000000;
; 143  : 		long ldir;
; 144  : 		int WhichDir = 0;

  00008	33 c0		 xor	 eax, eax
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	bf 80 96 98 00	 mov	 edi, 10000000		; 00989680H
  00012	89 75 f8	 mov	 DWORD PTR _this$1$[ebp], esi
  00015	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax

; 145  : 		int i;
; 146  : 
; 147  : 		if ( First != 0 )

  00018	38 45 1c	 cmp	 BYTE PTR _First$[ebp], al
  0001b	74 73		 je	 SHORT $LN11@FindNextDi

; 148  : 		{
; 149  : 			for ( i = 0 ; i<8 ; i++ )

  0001d	33 db		 xor	 ebx, ebx
  0001f	90		 npad	 1
$LL4@FindNextDi:

; 150  : 			{
; 151  : 				ldir = i % 8;

  00020	8b c3		 mov	 eax, ebx
  00022	83 e0 07	 and	 eax, 7
  00025	89 45 f4	 mov	 DWORD PTR _ldir$1$[ebp], eax

; 152  : 				int endx = sx + this->Dir[ldir*2];

  00028	8b 8c c6 f4 03
	00 00		 mov	 ecx, DWORD PTR [esi+eax*8+1012]

; 153  : 				int endy = sy + this->Dir[ldir*2+1];

  0002f	8b 94 c6 f8 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1016]
  00036	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  00039	03 55 0c	 add	 edx, DWORD PTR _sy$[ebp]

; 50   : 		int distx = x2 - x1;

  0003c	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]

; 51   : 		int disty = y2 - y1;

  0003f	8b 75 14	 mov	 esi, DWORD PTR _dy$[ebp]
  00042	2b c1		 sub	 eax, ecx
  00044	2b f2		 sub	 esi, edx

; 52   : 		return (distx * distx) + (disty * disty);

  00046	0f af c0	 imul	 eax, eax
  00049	0f af f6	 imul	 esi, esi
  0004c	03 f0		 add	 esi, eax
  0004e	89 75 1c	 mov	 DWORD PTR _dist$1$[ebp], esi

; 154  : 				int dist = this->GetDist(endx, endy, dx, dy);
; 155  : 
; 156  : 				if ( MinDist > dist )

  00051	3b fe		 cmp	 edi, esi
  00053	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00056	7e 2a		 jle	 SHORT $LN2@FindNextDi

; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;
; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 111  : 		{
; 112  : 			this->HitMap[which] = 1;
; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  00058	85 c9		 test	 ecx, ecx
  0005a	78 26		 js	 SHORT $LN2@FindNextDi
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	3b c8		 cmp	 ecx, eax
  00060	7d 20		 jge	 SHORT $LN2@FindNextDi
  00062	85 d2		 test	 edx, edx
  00064	78 1c		 js	 SHORT $LN2@FindNextDi
  00066	3b d0		 cmp	 edx, eax
  00068	7d 18		 jge	 SHORT $LN2@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  0006a	0f af c2	 imul	 eax, edx
  0006d	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00073	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00077	75 09		 jne	 SHORT $LN2@FindNextDi

; 157  : 				{
; 158  : 					if ( this->IsThisSpotOK(endx, endy) != FALSE )
; 159  : 					{
; 160  : 						MinDist = dist;

  00079	8b 45 f4	 mov	 eax, DWORD PTR _ldir$1$[ebp]
  0007c	8b 7d 1c	 mov	 edi, DWORD PTR _dist$1$[ebp]

; 161  : 						WhichDir = ldir;

  0007f	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax
$LN2@FindNextDi:

; 148  : 		{
; 149  : 			for ( i = 0 ; i<8 ; i++ )

  00082	43		 inc	 ebx
  00083	83 fb 08	 cmp	 ebx, 8
  00086	7c 98		 jl	 SHORT $LL4@FindNextDi

; 162  : 					}
; 163  : 				}
; 164  : 			}
; 165  : 		}
; 166  : 		else

  00088	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  0008b	e9 17 01 00 00	 jmp	 $LN9@FindNextDi
$LN11@FindNextDi:

; 167  : 		{
; 168  : 			for ( i = dirstart+7 ; i <= dirstart+9 ; i++ )

  00090	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  00093	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  00096	8d 4b 07	 lea	 ecx, DWORD PTR [ebx+7]
  00099	3b c8		 cmp	 ecx, eax
  0009b	0f 8f 82 00 00
	00		 jg	 $LN106@FindNextDi
$LL7@FindNextDi:

; 169  : 			{
; 170  : 				ldir = i % 8;

  000a1	8b c1		 mov	 eax, ecx
  000a3	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000a8	79 05		 jns	 SHORT $LN116@FindNextDi
  000aa	48		 dec	 eax
  000ab	83 c8 f8	 or	 eax, -8			; fffffff8H
  000ae	40		 inc	 eax
$LN116@FindNextDi:

; 171  : 				int endx = sx + this->Dir[ldir*2];

  000af	8b 94 c6 f4 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1012]

; 172  : 				int endy = sy + this->Dir[ldir*2+1];

  000b6	8b 9c c6 f8 03
	00 00		 mov	 ebx, DWORD PTR [esi+eax*8+1016]
  000bd	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]
  000c0	03 5d 0c	 add	 ebx, DWORD PTR _sy$[ebp]

; 51   : 		int disty = y2 - y1;

  000c3	8b 75 14	 mov	 esi, DWORD PTR _dy$[ebp]

; 169  : 			{
; 170  : 				ldir = i % 8;

  000c6	89 45 f4	 mov	 DWORD PTR _ldir$2$[ebp], eax

; 51   : 		int disty = y2 - y1;

  000c9	2b f3		 sub	 esi, ebx
  000cb	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]
  000ce	2b c2		 sub	 eax, edx

; 52   : 		return (distx * distx) + (disty * disty);

  000d0	0f af f6	 imul	 esi, esi
  000d3	0f af c0	 imul	 eax, eax
  000d6	03 f0		 add	 esi, eax
  000d8	89 75 1c	 mov	 DWORD PTR _dist$1$[ebp], esi

; 173  : 				int dist = this->GetDist(endx, endy, dx, dy);
; 174  : 
; 175  : 				if ( MinDist > dist )

  000db	3b fe		 cmp	 edi, esi
  000dd	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  000e0	7e 2a		 jle	 SHORT $LN5@FindNextDi

; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;
; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 111  : 		{
; 112  : 			this->HitMap[which] = 1;
; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  000e2	85 d2		 test	 edx, edx
  000e4	78 26		 js	 SHORT $LN5@FindNextDi
  000e6	8b 06		 mov	 eax, DWORD PTR [esi]
  000e8	3b d0		 cmp	 edx, eax
  000ea	7d 20		 jge	 SHORT $LN5@FindNextDi
  000ec	85 db		 test	 ebx, ebx
  000ee	78 1c		 js	 SHORT $LN5@FindNextDi
  000f0	3b d8		 cmp	 ebx, eax
  000f2	7d 18		 jge	 SHORT $LN5@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  000f4	0f af c3	 imul	 eax, ebx
  000f7	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  000fd	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00101	75 09		 jne	 SHORT $LN5@FindNextDi

; 176  : 				{
; 177  : 					if ( this->IsThisSpotOK(endx, endy) != FALSE )
; 178  : 					{
; 179  : 						MinDist = dist;

  00103	8b 45 f4	 mov	 eax, DWORD PTR _ldir$2$[ebp]
  00106	8b 7d 1c	 mov	 edi, DWORD PTR _dist$1$[ebp]

; 180  : 						WhichDir = ldir;

  00109	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax
$LN5@FindNextDi:

; 167  : 		{
; 168  : 			for ( i = dirstart+7 ; i <= dirstart+9 ; i++ )

  0010c	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  0010f	41		 inc	 ecx
  00110	8d 43 09	 lea	 eax, DWORD PTR [ebx+9]
  00113	3b c8		 cmp	 ecx, eax
  00115	7e 8a		 jle	 SHORT $LL7@FindNextDi

; 181  : 					}
; 182  : 				}
; 183  : 			}
; 184  : 
; 185  : 			if ( MinDist == 10000000 )

  00117	81 ff 80 96 98
	00		 cmp	 edi, 10000000		; 00989680H
  0011d	0f 85 84 00 00
	00		 jne	 $LN9@FindNextDi
$LN106@FindNextDi:

; 186  : 			{
; 187  : 				for ( i = dirstart+2 ; i <= dirstart+6 ; i++ )

  00123	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  00126	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  00129	3b c8		 cmp	 ecx, eax
  0012b	0f 8f 76 00 00
	00		 jg	 $LN9@FindNextDi
$LL10@FindNextDi:

; 188  : 				{
; 189  : 					ldir = i % 8;

  00131	8b c1		 mov	 eax, ecx
  00133	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00138	79 05		 jns	 SHORT $LN117@FindNextDi
  0013a	48		 dec	 eax
  0013b	83 c8 f8	 or	 eax, -8			; fffffff8H
  0013e	40		 inc	 eax
$LN117@FindNextDi:

; 190  : 					int endx = sx + this->Dir[ldir*2];

  0013f	8b 94 c6 f4 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1012]

; 191  : 					int endy = sy + this->Dir[ldir*2+1];

  00146	8b 9c c6 f8 03
	00 00		 mov	 ebx, DWORD PTR [esi+eax*8+1016]
  0014d	03 55 08	 add	 edx, DWORD PTR _sx$[ebp]
  00150	03 5d 0c	 add	 ebx, DWORD PTR _sy$[ebp]

; 51   : 		int disty = y2 - y1;

  00153	8b 75 14	 mov	 esi, DWORD PTR _dy$[ebp]

; 188  : 				{
; 189  : 					ldir = i % 8;

  00156	89 45 f4	 mov	 DWORD PTR _ldir$3$[ebp], eax

; 51   : 		int disty = y2 - y1;

  00159	2b f3		 sub	 esi, ebx
  0015b	8b 45 10	 mov	 eax, DWORD PTR _dx$[ebp]
  0015e	2b c2		 sub	 eax, edx

; 52   : 		return (distx * distx) + (disty * disty);

  00160	0f af f6	 imul	 esi, esi
  00163	0f af c0	 imul	 eax, eax
  00166	03 f0		 add	 esi, eax
  00168	89 75 1c	 mov	 DWORD PTR _dist$1$[ebp], esi

; 192  : 					int dist = this->GetDist(endx, endy, dx, dy);
; 193  : 
; 194  : 					if ( MinDist > dist )

  0016b	3b fe		 cmp	 edi, esi
  0016d	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00170	7e 2a		 jle	 SHORT $LN8@FindNextDi

; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;
; 82   : 	};	// line : 43
; 83   : 
; 84   : 	BOOL CanWeMoveForward2(int x, int y) // line : 46
; 85   : 	{
; 86   : 		int which = x +  y* this->Width ;
; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 89   : 		{
; 90   : 			return false;
; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 94   : 		{
; 95   : 			this->HitMap[which] = 1;
; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;
; 99   : 	};
; 100  : 	
; 101  : 	BOOL CanWeMoveForward3(int x, int y) // line : 46
; 102  : 	{
; 103  : 		int which = x +  y* this->Width ;
; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )
; 106  : 		{
; 107  : 			return false;
; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )
; 111  : 		{
; 112  : 			this->HitMap[which] = 1;
; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;
; 116  : 	};
; 117  : 
; 118  : 	// line : 56
; 119  : 
; 120  : 
; 121  : 	BOOL IsThisSpotOK(int x, int y) // line : 59
; 122  : 	{
; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  00172	85 d2		 test	 edx, edx
  00174	78 26		 js	 SHORT $LN8@FindNextDi
  00176	8b 06		 mov	 eax, DWORD PTR [esi]
  00178	3b d0		 cmp	 edx, eax
  0017a	7d 20		 jge	 SHORT $LN8@FindNextDi
  0017c	85 db		 test	 ebx, ebx
  0017e	78 1c		 js	 SHORT $LN8@FindNextDi
  00180	3b d8		 cmp	 ebx, eax
  00182	7d 18		 jge	 SHORT $LN8@FindNextDi

; 128  : 		{
; 129  : 			return false;
; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  00184	0f af c3	 imul	 eax, ebx
  00187	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  0018d	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00191	75 09		 jne	 SHORT $LN8@FindNextDi

; 195  : 					{
; 196  : 						if ( this->IsThisSpotOK(endx, endy) != FALSE )
; 197  : 						{
; 198  : 							MinDist = dist;

  00193	8b 45 f4	 mov	 eax, DWORD PTR _ldir$3$[ebp]
  00196	8b 7d 1c	 mov	 edi, DWORD PTR _dist$1$[ebp]

; 199  : 							WhichDir = ldir;

  00199	89 45 fc	 mov	 DWORD PTR _WhichDir$1$[ebp], eax
$LN8@FindNextDi:

; 186  : 			{
; 187  : 				for ( i = dirstart+2 ; i <= dirstart+6 ; i++ )

  0019c	8b 5d 18	 mov	 ebx, DWORD PTR _dirstart$[ebp]
  0019f	41		 inc	 ecx
  001a0	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  001a3	3b c8		 cmp	 ecx, eax
  001a5	7e 8a		 jle	 SHORT $LL10@FindNextDi
$LN9@FindNextDi:

; 200  : 						}
; 201  : 					}
; 202  : 				}
; 203  : 			}
; 204  : 		}
; 205  : 		int LastDist;
; 206  : 
; 207  : 		this->LastDir = dirstart;
; 208  : 		LastDist = this->GetDist(sx, sy, sx + this->Dir[this->LastDir*2], sy + this->Dir[this->LastDir*2+1]);
; 209  : 
; 210  : 		if ( ( LastDist > MinDist - 6 ) && ( LastDist < MinDist + 6 ) && ( MinDist >= 25 ) )

  001a7	8b 55 fc	 mov	 edx, DWORD PTR _WhichDir$1$[ebp]
  001aa	89 9e 34 04 00
	00		 mov	 DWORD PTR [esi+1076], ebx

; 50   : 		int distx = x2 - x1;

  001b0	8b 84 de f4 03
	00 00		 mov	 eax, DWORD PTR [esi+ebx*8+1012]

; 51   : 		int disty = y2 - y1;

  001b7	8b 8c de f8 03
	00 00		 mov	 ecx, DWORD PTR [esi+ebx*8+1016]

; 52   : 		return (distx * distx) + (disty * disty);

  001be	0f af c0	 imul	 eax, eax
  001c1	0f af c9	 imul	 ecx, ecx
  001c4	03 c8		 add	 ecx, eax

; 200  : 						}
; 201  : 					}
; 202  : 				}
; 203  : 			}
; 204  : 		}
; 205  : 		int LastDist;
; 206  : 
; 207  : 		this->LastDir = dirstart;
; 208  : 		LastDist = this->GetDist(sx, sy, sx + this->Dir[this->LastDir*2], sy + this->Dir[this->LastDir*2+1]);
; 209  : 
; 210  : 		if ( ( LastDist > MinDist - 6 ) && ( LastDist < MinDist + 6 ) && ( MinDist >= 25 ) )

  001c6	8d 47 fa	 lea	 eax, DWORD PTR [edi-6]
  001c9	3b c8		 cmp	 ecx, eax
  001cb	7e 0d		 jle	 SHORT $LN20@FindNextDi
  001cd	8d 47 06	 lea	 eax, DWORD PTR [edi+6]
  001d0	3b c8		 cmp	 ecx, eax
  001d2	7d 06		 jge	 SHORT $LN20@FindNextDi
  001d4	83 ff 19	 cmp	 edi, 25			; 00000019H
  001d7	0f 4d d3	 cmovge	 edx, ebx
$LN20@FindNextDi:

; 211  : 		{
; 212  : 			WhichDir = this->LastDir;
; 213  : 		}
; 214  : 
; 215  : 		if ( MinDist == 10000000 )

  001da	81 ff 80 96 98
	00		 cmp	 edi, 10000000		; 00989680H
  001e0	0f 84 41 02 00
	00		 je	 $LN120@FindNextDi

; 216  : 		{
; 217  : 			return -1;
; 218  : 		}
; 219  : 		
; 220  : 		if ( this->CanWeMoveForward(sx+this->Dir[((WhichDir*2))], sy+this->Dir[((WhichDir*2))+1]) != FALSE )

  001e6	8b 84 d6 f8 03
	00 00		 mov	 eax, DWORD PTR [esi+edx*8+1016]
  001ed	8b 5d 0c	 mov	 ebx, DWORD PTR _sy$[ebp]
  001f0	03 c3		 add	 eax, ebx
  001f2	8b 7d 08	 mov	 edi, DWORD PTR _sx$[ebp]
  001f5	89 45 18	 mov	 DWORD PTR _y$1$[ebp], eax
  001f8	8b 84 d6 f4 03
	00 00		 mov	 eax, DWORD PTR [esi+edx*8+1012]
  001ff	03 c7		 add	 eax, edi
  00201	89 45 1c	 mov	 DWORD PTR _x$1$[ebp], eax

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;

  00204	8b 06		 mov	 eax, DWORD PTR [esi]
  00206	8b c8		 mov	 ecx, eax
  00208	0f af 4d 18	 imul	 ecx, DWORD PTR _y$1$[ebp]
  0020c	03 4d 1c	 add	 ecx, DWORD PTR _x$1$[ebp]

; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  0020f	39 45 1c	 cmp	 DWORD PTR _x$1$[ebp], eax
  00212	0f 8d 8b 00 00
	00		 jge	 $LN22@FindNextDi
  00218	83 7d 1c 00	 cmp	 DWORD PTR _x$1$[ebp], 0
  0021c	0f 8c 81 00 00
	00		 jl	 $LN22@FindNextDi
  00222	8b 45 18	 mov	 eax, DWORD PTR _y$1$[ebp]
  00225	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00228	0f 8d 75 00 00
	00		 jge	 $LN22@FindNextDi
  0022e	85 c0		 test	 eax, eax
  00230	78 71		 js	 SHORT $LN22@FindNextDi

; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )

  00232	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00238	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  0023c	77 5b		 ja	 SHORT $LN57@FindNextDi
  0023e	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00244	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00248	75 4f		 jne	 SHORT $LN57@FindNextDi

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  0024a	33 c9		 xor	 ecx, ecx
  0024c	39 4e 08	 cmp	 DWORD PTR [esi+8], ecx
  0024f	7e 3d		 jle	 SHORT $LN112@FindNextDi
$LL62@FindNextDi:

; 58   : 		{
; 59   : 			if ( x ==  this->PathX[i] && y == this->PathY[i] )

  00251	0f b6 44 0e 0c	 movzx	 eax, BYTE PTR [esi+ecx+12]
  00256	3b f8		 cmp	 edi, eax
  00258	75 0c		 jne	 SHORT $LN60@FindNextDi
  0025a	0f b6 84 31 00
	02 00 00	 movzx	 eax, BYTE PTR [ecx+esi+512]
  00262	3b d8		 cmp	 ebx, eax
  00264	74 11		 je	 SHORT $LN59@FindNextDi
$LN60@FindNextDi:

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00266	41		 inc	 ecx
  00267	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0026a	7c e5		 jl	 SHORT $LL62@FindNextDi

; 228  : 			}
; 229  : 
; 230  : 			return WhichDir;

  0026c	5f		 pop	 edi
  0026d	5e		 pop	 esi
  0026e	8b c2		 mov	 eax, edx
  00270	5b		 pop	 ebx

; 268  : 	};	// line : 155

  00271	8b e5		 mov	 esp, ebp
  00273	5d		 pop	 ebp
  00274	c2 1c 00	 ret	 28			; 0000001cH
$LN59@FindNextDi:

; 221  : 		{
; 222  : 			int path = this->VerifyThatOnPath(sx, sy);
; 223  : 
; 224  : 			if ( path != -1 )

  00277	83 f9 ff	 cmp	 ecx, -1
  0027a	74 12		 je	 SHORT $LN112@FindNextDi

; 225  : 			{
; 226  : 				this->HitMap[sx + sy * this->Width ] = 1;

  0027c	8b 06		 mov	 eax, DWORD PTR [esi]
  0027e	0f af c3	 imul	 eax, ebx
  00281	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00287	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1

; 227  : 				this->NumPath = path;

  0028b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN112@FindNextDi:

; 228  : 			}
; 229  : 
; 230  : 			return WhichDir;

  0028e	5f		 pop	 edi
  0028f	5e		 pop	 esi
  00290	8b c2		 mov	 eax, edx
  00292	5b		 pop	 ebx

; 268  : 	};	// line : 155

  00293	8b e5		 mov	 esp, ebp
  00295	5d		 pop	 ebp
  00296	c2 1c 00	 ret	 28			; 0000001cH
$LN57@FindNextDi:

; 77   : 		{
; 78   : 			this->HitMap[which] = 1;

  00299	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0029f	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN22@FindNextDi:

; 231  : 		}
; 232  : 
; 233  : 		if ( ErrorCheck != 0 )

  002a3	80 7d 20 00	 cmp	 BYTE PTR _ErrorCheck$[ebp], 0
  002a7	0f 84 6b 01 00
	00		 je	 $LN27@FindNextDi

; 234  : 		{
; 235  : 			int dir = WhichDir+7;

  002ad	8d 4a 07	 lea	 ecx, DWORD PTR [edx+7]

; 236  : 
; 237  : 			dir %= 8;

  002b0	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  002b6	79 05		 jns	 SHORT $LN118@FindNextDi
  002b8	49		 dec	 ecx
  002b9	83 c9 f8	 or	 ecx, -8			; fffffff8H
  002bc	41		 inc	 ecx
$LN118@FindNextDi:

; 238  : 
; 239  : 			if (this->CanWeMoveForward(sx + this->Dir[dir*2], sy + this->Dir[dir*2+1]) != FALSE )

  002bd	8b 84 ce f8 03
	00 00		 mov	 eax, DWORD PTR [esi+ecx*8+1016]
  002c4	03 c3		 add	 eax, ebx
  002c6	89 4d 0c	 mov	 DWORD PTR _dir$1$[ebp], ecx
  002c9	89 45 20	 mov	 DWORD PTR _y$1$[ebp], eax
  002cc	8b 84 ce f4 03
	00 00		 mov	 eax, DWORD PTR [esi+ecx*8+1012]
  002d3	03 c7		 add	 eax, edi
  002d5	89 45 1c	 mov	 DWORD PTR _x$1$[ebp], eax

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;

  002d8	8b 06		 mov	 eax, DWORD PTR [esi]
  002da	8b c8		 mov	 ecx, eax
  002dc	0f af 4d 20	 imul	 ecx, DWORD PTR _y$1$[ebp]
  002e0	03 4d 1c	 add	 ecx, DWORD PTR _x$1$[ebp]

; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  002e3	39 45 1c	 cmp	 DWORD PTR _x$1$[ebp], eax
  002e6	0f 8d 97 00 00
	00		 jge	 $LN25@FindNextDi
  002ec	83 7d 1c 00	 cmp	 DWORD PTR _x$1$[ebp], 0
  002f0	0f 8c 8d 00 00
	00		 jl	 $LN25@FindNextDi
  002f6	8b 45 20	 mov	 eax, DWORD PTR _y$1$[ebp]
  002f9	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  002fc	0f 8d 81 00 00
	00		 jge	 $LN25@FindNextDi
  00302	85 c0		 test	 eax, eax
  00304	0f 88 79 00 00
	00		 js	 $LN25@FindNextDi

; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )

  0030a	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  00310	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  00314	77 63		 ja	 SHORT $LN69@FindNextDi
  00316	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0031c	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00320	75 57		 jne	 SHORT $LN69@FindNextDi

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00322	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00325	33 c9		 xor	 ecx, ecx
  00327	85 d2		 test	 edx, edx
  00329	7e 42		 jle	 SHORT $LN113@FindNextDi
  0032b	0f 1f 44 00 00	 npad	 5
$LL74@FindNextDi:

; 58   : 		{
; 59   : 			if ( x ==  this->PathX[i] && y == this->PathY[i] )

  00330	0f b6 44 0e 0c	 movzx	 eax, BYTE PTR [esi+ecx+12]
  00335	3b f8		 cmp	 edi, eax
  00337	75 0c		 jne	 SHORT $LN72@FindNextDi
  00339	0f b6 84 31 00
	02 00 00	 movzx	 eax, BYTE PTR [ecx+esi+512]
  00341	3b d8		 cmp	 ebx, eax
  00343	74 11		 je	 SHORT $LN71@FindNextDi
$LN72@FindNextDi:

; 53   : 	}	// line : 23
; 54   : 
; 55   : 	int VerifyThatOnPath(int x, int y)
; 56   : 	{
; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00345	41		 inc	 ecx
  00346	3b ca		 cmp	 ecx, edx
  00348	7c e6		 jl	 SHORT $LL74@FindNextDi

; 247  : 				}
; 248  : 				return dir;

  0034a	8b 45 0c	 mov	 eax, DWORD PTR _dir$1$[ebp]
  0034d	5f		 pop	 edi
  0034e	5e		 pop	 esi
  0034f	5b		 pop	 ebx

; 268  : 	};	// line : 155

  00350	8b e5		 mov	 esp, ebp
  00352	5d		 pop	 ebp
  00353	c2 1c 00	 ret	 28			; 0000001cH
$LN71@FindNextDi:

; 240  : 			{
; 241  : 				int path = this->VerifyThatOnPath(sx, sy);
; 242  : 
; 243  : 				if ( path != -1 )

  00356	83 f9 ff	 cmp	 ecx, -1
  00359	74 12		 je	 SHORT $LN113@FindNextDi

; 244  : 				{
; 245  : 					this->HitMap[sx  + sy * this->Width] = 1;

  0035b	8b 06		 mov	 eax, DWORD PTR [esi]
  0035d	0f af c3	 imul	 eax, ebx
  00360	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00366	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1

; 246  : 					this->NumPath = path;

  0036a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN113@FindNextDi:

; 247  : 				}
; 248  : 				return dir;

  0036d	8b 45 0c	 mov	 eax, DWORD PTR _dir$1$[ebp]
  00370	5f		 pop	 edi
  00371	5e		 pop	 esi
  00372	5b		 pop	 ebx

; 268  : 	};	// line : 155

  00373	8b e5		 mov	 esp, ebp
  00375	5d		 pop	 ebp
  00376	c2 1c 00	 ret	 28			; 0000001cH
$LN69@FindNextDi:

; 77   : 		{
; 78   : 			this->HitMap[which] = 1;

  00379	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  0037f	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN25@FindNextDi:

; 249  : 			}
; 250  : 
; 251  : 			int dir2 = WhichDir+9;

  00383	8d 42 09	 lea	 eax, DWORD PTR [edx+9]

; 252  : 			dir2 %= 8;

  00386	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0038b	79 05		 jns	 SHORT $LN119@FindNextDi
  0038d	48		 dec	 eax
  0038e	83 c8 f8	 or	 eax, -8			; fffffff8H
  00391	40		 inc	 eax
$LN119@FindNextDi:

; 253  : 			if (CanWeMoveForward(sx+this->Dir[dir2*2], sy+this->Dir[dir2*2+1]) != FALSE )

  00392	8b 94 c6 f8 03
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+1016]
  00399	89 45 18	 mov	 DWORD PTR _dir2$1$[ebp], eax
  0039c	03 d3		 add	 edx, ebx
  0039e	8b 84 c6 f4 03
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+1012]
  003a5	03 c7		 add	 eax, edi
  003a7	89 45 1c	 mov	 DWORD PTR _x$1$[ebp], eax

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;
; 65   : 	}
; 66   : 
; 67   : 	BOOL CanWeMoveForward(int x, int y) // line : 33
; 68   : 	{
; 69   : 		int which = x+ y * this->Width  ;

  003aa	8b 06		 mov	 eax, DWORD PTR [esi]
  003ac	8b c8		 mov	 ecx, eax
  003ae	0f af ca	 imul	 ecx, edx
  003b1	03 4d 1c	 add	 ecx, DWORD PTR _x$1$[ebp]

; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  003b4	39 45 1c	 cmp	 DWORD PTR _x$1$[ebp], eax
  003b7	7d 5f		 jge	 SHORT $LN27@FindNextDi
  003b9	83 7d 1c 00	 cmp	 DWORD PTR _x$1$[ebp], 0
  003bd	7c 59		 jl	 SHORT $LN27@FindNextDi
  003bf	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  003c2	7d 54		 jge	 SHORT $LN27@FindNextDi
  003c4	85 d2		 test	 edx, edx
  003c6	78 50		 js	 SHORT $LN27@FindNextDi

; 72   : 		{
; 73   : 			return false;
; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )

  003c8	8b 86 3c 04 00
	00		 mov	 eax, DWORD PTR [esi+1084]
  003ce	80 3c 01 01	 cmp	 BYTE PTR [ecx+eax], 1
  003d2	77 3a		 ja	 SHORT $LN81@FindNextDi
  003d4	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  003da	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  003de	75 2e		 jne	 SHORT $LN81@FindNextDi

; 254  : 			{
; 255  : 				int path = this->VerifyThatOnPath(sx, sy);

  003e0	53		 push	 ebx
  003e1	57		 push	 edi
  003e2	8b ce		 mov	 ecx, esi
  003e4	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  003e9	8b c8		 mov	 ecx, eax

; 256  : 
; 257  : 				if ( path != -1 )

  003eb	83 f9 ff	 cmp	 ecx, -1
  003ee	74 12		 je	 SHORT $LN28@FindNextDi

; 258  : 				{
; 259  : 					this->HitMap[sx + sy * this->Width] = 1;

  003f0	8b 06		 mov	 eax, DWORD PTR [esi]
  003f2	0f af c3	 imul	 eax, ebx
  003f5	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  003fb	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1

; 260  : 					this->NumPath = path;

  003ff	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN28@FindNextDi:

; 261  : 				}
; 262  : 				return dir2;

  00402	8b 45 18	 mov	 eax, DWORD PTR _dir2$1$[ebp]
  00405	5f		 pop	 edi
  00406	5e		 pop	 esi
  00407	5b		 pop	 ebx

; 268  : 	};	// line : 155

  00408	8b e5		 mov	 esp, ebp
  0040a	5d		 pop	 ebp
  0040b	c2 1c 00	 ret	 28			; 0000001cH
$LN81@FindNextDi:

; 77   : 		{
; 78   : 			this->HitMap[which] = 1;

  0040e	8b 86 40 04 00
	00		 mov	 eax, DWORD PTR [esi+1088]
  00414	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN27@FindNextDi:

; 263  : 			}
; 264  : 		}
; 265  : 		
; 266  : 		this->HitMap[sx + sy*this->Width]=1;

  00418	8b 06		 mov	 eax, DWORD PTR [esi]
  0041a	0f af c3	 imul	 eax, ebx
  0041d	03 86 40 04 00
	00		 add	 eax, DWORD PTR [esi+1088]
  00423	c6 04 38 01	 mov	 BYTE PTR [eax+edi], 1
$LN120@FindNextDi:

; 267  : 		return -1;

  00427	5f		 pop	 edi
  00428	5e		 pop	 esi
  00429	83 c8 ff	 or	 eax, -1
  0042c	5b		 pop	 ebx

; 268  : 	};	// line : 155

  0042d	8b e5		 mov	 esp, ebp
  0042f	5d		 pop	 ebp
  00430	c2 1c 00	 ret	 28			; 0000001cH
?FindNextDir@PATH@@AAEHHHHHH_N0@Z ENDP			; PATH::FindNextDir
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?IsThisSpotOK@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?IsThisSpotOK@PATH@@AAEHHH@Z PROC			; PATH::IsThisSpotOK, COMDAT
; _this$ = ecx

; 122  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 123  : 		int pos;
; 124  : 
; 125  : 		pos = x+ y * this->Width ;
; 126  : 
; 127  : 		if ( x < 0 || x >= this->Width || y < 0 || y >= this->Width )	// Make Deathway fix here maybe

  00004	8b 75 08	 mov	 esi, DWORD PTR _x$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 27		 js	 SHORT $LN3@IsThisSpot
  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7d 21		 jge	 SHORT $LN3@IsThisSpot
  00011	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	78 1a		 js	 SHORT $LN3@IsThisSpot
  00018	3b c2		 cmp	 eax, edx
  0001a	7d 16		 jge	 SHORT $LN3@IsThisSpot

; 130  : 		}
; 131  : 		if ( this->HitMap[pos] != 0 )

  0001c	0f af d0	 imul	 edx, eax
  0001f	33 c0		 xor	 eax, eax
  00021	03 91 40 04 00
	00		 add	 edx, DWORD PTR [ecx+1088]
  00027	38 04 32	 cmp	 BYTE PTR [edx+esi], al
  0002a	5e		 pop	 esi
  0002b	0f 94 c0	 sete	 al

; 132  : 		{
; 133  : 			return false;
; 134  : 		}
; 135  : 		return true;
; 136  : 	};	// line : 68

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
$LN3@IsThisSpot:

; 128  : 		{
; 129  : 			return false;

  00032	33 c0		 xor	 eax, eax
  00034	5e		 pop	 esi

; 132  : 		{
; 133  : 			return false;
; 134  : 		}
; 135  : 		return true;
; 136  : 	};	// line : 68

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?IsThisSpotOK@PATH@@AAEHHH@Z ENDP			; PATH::IsThisSpotOK
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?CanWeMoveForward3@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?CanWeMoveForward3@PATH@@AAEHHH@Z PROC			; PATH::CanWeMoveForward3, COMDAT
; _this$ = ecx

; 102  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  : 		int which = x +  y* this->Width ;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 0c	 mov	 esi, DWORD PTR _y$[ebp]
  00009	0f af d6	 imul	 edx, esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _x$[ebp]
  00010	03 d7		 add	 edx, edi

; 104  : 		
; 105  : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00012	3b 39		 cmp	 edi, DWORD PTR [ecx]
  00014	7d 3a		 jge	 SHORT $LN3@CanWeMoveF
  00016	85 ff		 test	 edi, edi
  00018	78 36		 js	 SHORT $LN3@CanWeMoveF
  0001a	3b 71 04	 cmp	 esi, DWORD PTR [ecx+4]
  0001d	7d 31		 jge	 SHORT $LN3@CanWeMoveF
  0001f	85 f6		 test	 esi, esi
  00021	78 2d		 js	 SHORT $LN3@CanWeMoveF

; 108  : 		}
; 109  : 
; 110  : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  00023	8b 81 3c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1084]
  00029	80 3c 02 01	 cmp	 BYTE PTR [edx+eax], 1
  0002d	73 17		 jae	 SHORT $LN5@CanWeMoveF
  0002f	8b 81 40 04 00
	00		 mov	 eax, DWORD PTR [ecx+1088]
  00035	80 3c 02 00	 cmp	 BYTE PTR [edx+eax], 0
  00039	75 0b		 jne	 SHORT $LN5@CanWeMoveF

; 113  : 			return false;
; 114  : 		}
; 115  : 		return TRUE;

  0003b	5f		 pop	 edi
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	5e		 pop	 esi

; 116  : 	};

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN5@CanWeMoveF:

; 111  : 		{
; 112  : 			this->HitMap[which] = 1;

  00046	8b 81 40 04 00
	00		 mov	 eax, DWORD PTR [ecx+1088]
  0004c	c6 04 02 01	 mov	 BYTE PTR [edx+eax], 1
$LN3@CanWeMoveF:

; 106  : 		{
; 107  : 			return false;

  00050	5f		 pop	 edi
  00051	33 c0		 xor	 eax, eax
  00053	5e		 pop	 esi

; 116  : 	};

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
?CanWeMoveForward3@PATH@@AAEHHH@Z ENDP			; PATH::CanWeMoveForward3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?CanWeMoveForward2@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?CanWeMoveForward2@PATH@@AAEHHH@Z PROC			; PATH::CanWeMoveForward2, COMDAT
; _this$ = ecx

; 85   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 		int which = x +  y* this->Width ;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 0c	 mov	 esi, DWORD PTR _y$[ebp]
  00009	0f af d6	 imul	 edx, esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _x$[ebp]
  00010	03 d7		 add	 edx, edi

; 87   : 		
; 88   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00012	3b 39		 cmp	 edi, DWORD PTR [ecx]
  00014	7d 3a		 jge	 SHORT $LN3@CanWeMoveF
  00016	85 ff		 test	 edi, edi
  00018	78 36		 js	 SHORT $LN3@CanWeMoveF
  0001a	3b 71 04	 cmp	 esi, DWORD PTR [ecx+4]
  0001d	7d 31		 jge	 SHORT $LN3@CanWeMoveF
  0001f	85 f6		 test	 esi, esi
  00021	78 2d		 js	 SHORT $LN3@CanWeMoveF

; 91   : 		}
; 92   : 
; 93   : 		if ( this->Map[which] >= 1 || this->HitMap[which] != 0 )

  00023	8b 81 3c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1084]
  00029	80 3c 02 01	 cmp	 BYTE PTR [edx+eax], 1
  0002d	73 17		 jae	 SHORT $LN5@CanWeMoveF
  0002f	8b 81 40 04 00
	00		 mov	 eax, DWORD PTR [ecx+1088]
  00035	80 3c 02 00	 cmp	 BYTE PTR [edx+eax], 0
  00039	75 0b		 jne	 SHORT $LN5@CanWeMoveF

; 96   : 			return false;
; 97   : 		}
; 98   : 		return TRUE;

  0003b	5f		 pop	 edi
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	5e		 pop	 esi

; 99   : 	};

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN5@CanWeMoveF:

; 94   : 		{
; 95   : 			this->HitMap[which] = 1;

  00046	8b 81 40 04 00
	00		 mov	 eax, DWORD PTR [ecx+1088]
  0004c	c6 04 02 01	 mov	 BYTE PTR [edx+eax], 1
$LN3@CanWeMoveF:

; 89   : 		{
; 90   : 			return false;

  00050	5f		 pop	 edi
  00051	33 c0		 xor	 eax, eax
  00053	5e		 pop	 esi

; 99   : 	};

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
?CanWeMoveForward2@PATH@@AAEHHH@Z ENDP			; PATH::CanWeMoveForward2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?CanWeMoveForward@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?CanWeMoveForward@PATH@@AAEHHH@Z PROC			; PATH::CanWeMoveForward, COMDAT
; _this$ = ecx

; 68   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 		int which = x+ y * this->Width  ;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 0c	 mov	 esi, DWORD PTR _y$[ebp]
  00009	0f af d6	 imul	 edx, esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _x$[ebp]
  00010	03 d7		 add	 edx, edi

; 70   : 		
; 71   : 		if ( x >= this->Width || x < 0 || y >= this->Height || y < 0 )

  00012	3b 39		 cmp	 edi, DWORD PTR [ecx]
  00014	7d 3a		 jge	 SHORT $LN3@CanWeMoveF
  00016	85 ff		 test	 edi, edi
  00018	78 36		 js	 SHORT $LN3@CanWeMoveF
  0001a	3b 71 04	 cmp	 esi, DWORD PTR [ecx+4]
  0001d	7d 31		 jge	 SHORT $LN3@CanWeMoveF
  0001f	85 f6		 test	 esi, esi
  00021	78 2d		 js	 SHORT $LN3@CanWeMoveF

; 74   : 		}
; 75   : 
; 76   : 		if ( this->Map[which] > 1 || this->HitMap[which] != 0 )

  00023	8b 81 3c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1084]
  00029	80 3c 02 01	 cmp	 BYTE PTR [edx+eax], 1
  0002d	77 17		 ja	 SHORT $LN5@CanWeMoveF
  0002f	8b 81 40 04 00
	00		 mov	 eax, DWORD PTR [ecx+1088]
  00035	80 3c 02 00	 cmp	 BYTE PTR [edx+eax], 0
  00039	75 0b		 jne	 SHORT $LN5@CanWeMoveF

; 79   : 			return false;
; 80   : 		}
; 81   : 		return TRUE;

  0003b	5f		 pop	 edi
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	5e		 pop	 esi

; 82   : 	};	// line : 43

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN5@CanWeMoveF:

; 77   : 		{
; 78   : 			this->HitMap[which] = 1;

  00046	8b 81 40 04 00
	00		 mov	 eax, DWORD PTR [ecx+1088]
  0004c	c6 04 02 01	 mov	 BYTE PTR [edx+eax], 1
$LN3@CanWeMoveF:

; 72   : 		{
; 73   : 			return false;

  00050	5f		 pop	 edi
  00051	33 c0		 xor	 eax, eax
  00053	5e		 pop	 esi

; 82   : 	};	// line : 43

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
?CanWeMoveForward@PATH@@AAEHHH@Z ENDP			; PATH::CanWeMoveForward
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?VerifyThatOnPath@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?VerifyThatOnPath@PATH@@AAEHHH@Z PROC			; PATH::VerifyThatOnPath, COMDAT
; _this$ = ecx

; 56   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  00005	33 c0		 xor	 eax, eax
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0000d	85 f6		 test	 esi, esi
  0000f	7e 20		 jle	 SHORT $LN12@VerifyThat
  00011	8b 7d 0c	 mov	 edi, DWORD PTR _y$[ebp]
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _x$[ebp]
$LL4@VerifyThat:

; 58   : 		{
; 59   : 			if ( x ==  this->PathX[i] && y == this->PathY[i] )

  00017	0f b6 4c 02 0c	 movzx	 ecx, BYTE PTR [edx+eax+12]
  0001c	3b d9		 cmp	 ebx, ecx
  0001e	75 0c		 jne	 SHORT $LN2@VerifyThat
  00020	0f b6 8c 10 00
	02 00 00	 movzx	 ecx, BYTE PTR [eax+edx+512]
  00028	3b f9		 cmp	 edi, ecx
  0002a	74 08		 je	 SHORT $LN1@VerifyThat
$LN2@VerifyThat:

; 57   : 		for ( int i = 0 ; i < this->NumPath ; i++ )

  0002c	40		 inc	 eax
  0002d	3b c6		 cmp	 eax, esi
  0002f	7c e6		 jl	 SHORT $LL4@VerifyThat
$LN12@VerifyThat:

; 60   : 			{
; 61   : 				return i;
; 62   : 			}
; 63   : 		}
; 64   : 		return -1;

  00031	83 c8 ff	 or	 eax, -1
$LN1@VerifyThat:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 65   : 	}

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?VerifyThatOnPath@PATH@@AAEHHH@Z ENDP			; PATH::VerifyThatOnPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\zzzpath.h
;	COMDAT ?GetDist@PATH@@AAEHHHHH@Z
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?GetDist@PATH@@AAEHHHHH@Z PROC				; PATH::GetDist, COMDAT
; _this$ = ecx

; 49   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 50   : 		int distx = x2 - x1;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _x2$[ebp]

; 51   : 		int disty = y2 - y1;

  00006	8b 45 14	 mov	 eax, DWORD PTR _y2$[ebp]
  00009	2b 4d 08	 sub	 ecx, DWORD PTR _x1$[ebp]
  0000c	2b 45 0c	 sub	 eax, DWORD PTR _y1$[ebp]

; 52   : 		return (distx * distx) + (disty * disty);

  0000f	0f af c0	 imul	 eax, eax
  00012	0f af c9	 imul	 ecx, ecx
  00015	03 c1		 add	 eax, ecx

; 53   : 	}	// line : 23

  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
?GetDist@PATH@@AAEHHHHH@Z ENDP				; PATH::GetDist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Xx$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 316  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 317  : 	return (_CSTD sqrtf(_Xx));

  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv65[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv65[esp+8]

; 318  : 	}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 745  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 746  :         return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 747  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 1288 : // -------------------------------------------------------------------------------

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapclass.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 1288 : // -------------------------------------------------------------------------------

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
