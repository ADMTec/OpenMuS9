; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\PartyClass.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?allocate@?$allocator@UPartyBonusByNearby@@@std@@QAEPAUPartyBonusByNearby@@I@Z ; std::allocator<PartyBonusByNearby>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate
PUBLIC	?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reserve
PUBLIC	?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::deallocate
PUBLIC	?allocate@?$allocator@UPartyBonusByClass@@@std@@QAEPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::allocate
PUBLIC	?push_back@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXABUPartyBonusByClass@@@Z ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::push_back
PUBLIC	?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reserve
PUBLIC	??1PartyBonusInfo@@QAE@XZ			; PartyBonusInfo::~PartyBonusInfo
PUBLIC	??0PartyClass@@QAE@XZ				; PartyClass::PartyClass
PUBLIC	??1PartyClass@@UAE@XZ				; PartyClass::~PartyClass
PUBLIC	?IsParty@PartyClass@@QAEHH@Z			; PartyClass::IsParty
PUBLIC	?Create@PartyClass@@QAEHHHH@Z			; PartyClass::Create
PUBLIC	?Destroy@PartyClass@@QAEHH@Z			; PartyClass::Destroy
PUBLIC	?Add@PartyClass@@QAEHHHHH@Z			; PartyClass::Add
PUBLIC	?Delete@PartyClass@@QAEXHH@Z			; PartyClass::Delete
PUBLIC	?Delete@PartyClass@@QAEHHHH@Z			; PartyClass::Delete
PUBLIC	?GetCount@PartyClass@@QAEHH@Z			; PartyClass::GetCount
PUBLIC	?GetIndexUser@PartyClass@@QAEHHHAAH0@Z		; PartyClass::GetIndexUser
PUBLIC	?GetPartyCount@PartyClass@@QAEHH@Z		; PartyClass::GetPartyCount
PUBLIC	?GetIndex@PartyClass@@QAEHHHH@Z			; PartyClass::GetIndex
PUBLIC	?SetLevel@PartyClass@@QAEHHH@Z			; PartyClass::SetLevel
PUBLIC	?GetLevel@PartyClass@@QAEHHAAH0@Z		; PartyClass::GetLevel
PUBLIC	?Isleader@PartyClass@@QAEHHHH@Z			; PartyClass::Isleader
PUBLIC	?Paint@PartyClass@@QAEXH@Z			; PartyClass::Paint
PUBLIC	?PartyMemberLifeSend@PartyClass@@QAEXH@Z	; PartyClass::PartyMemberLifeSend
PUBLIC	?PartyLog@PartyClass@@QAEXHHH@Z			; PartyClass::PartyLog
PUBLIC	?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z	; PartyClass::UpdatePKPartyPanalty
PUBLIC	?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z ; PartyClass::GetReallyConnectPartyMemberCount
PUBLIC	?SwitchLeader@PartyClass@@QAEXH@Z		; PartyClass::SwitchLeader
PUBLIC	?ChangeLeader@PartyClass@@QAEXH@Z		; PartyClass::ChangeLeader
PUBLIC	?GetPartyPkLevel@PartyClass@@QAEDH@Z		; PartyClass::GetPartyPkLevel
PUBLIC	?SetPkLevel@PartyClass@@QAEXHHHE@Z		; PartyClass::SetPkLevel
PUBLIC	?SetPkCount@PartyClass@@QAEXH@Z			; PartyClass::SetPkCount
PUBLIC	?ResetLeader@PartyClass@@QAEXH@Z		; PartyClass::ResetLeader
PUBLIC	?ReadBonusInfo@PartyClass@@QAEXPAD@Z		; PartyClass::ReadBonusInfo
PUBLIC	?GetExpBonus@PartyClass@@QAEHPAUOBJECTSTRUCT@@0H@Z ; PartyClass::GetExpBonus
PUBLIC	?SetLeader@PartyClass@@QAE_NHH@Z		; PartyClass::SetLeader
PUBLIC	??_GPartyClass@@UAEPAXI@Z			; PartyClass::`scalar deleting destructor'
PUBLIC	?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z ; CGReqPartyMatchWindow
PUBLIC	?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z ; CGReqPartyMatchReg
PUBLIC	?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z ; CGReqPartyMatchJoin
PUBLIC	?CGReqPartyMatchWaitingList@@YAXH@Z		; CGReqPartyMatchWaitingList
PUBLIC	?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z ; CGReqPartyMatchCancel
PUBLIC	?CGReqPartyMatchAcceptList@@YAXH@Z		; CGReqPartyMatchAcceptList
PUBLIC	?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z ; CGReqPartyMatchRequestAnswer
PUBLIC	?DGAnsPartyMatchReg@@YAXPAUPMSG_PARTYMATCHING_REG_ANS@@@Z ; DGAnsPartyMatchReg
PUBLIC	?DGAnsPartyMatchInfo@@YAXPAE@Z			; DGAnsPartyMatchInfo
PUBLIC	?DGAnsPartyMatchJoin@@YAXPAUPMSG_PARTYMATCHING_JOIN_ANS@@@Z ; DGAnsPartyMatchJoin
PUBLIC	?DGAnsPartyMatchWaitlist@@YAXPAUPMSG_PARTYMATCHING_WAIT_ANS@@@Z ; DGAnsPartyMatchWaitlist
PUBLIC	?DGAnsPartyMatchCancel@@YAXPAUPMSG_PARTYMATCHING_CANCEL_ANS@@@Z ; DGAnsPartyMatchCancel
PUBLIC	?DGAnsPartyMatchAcceptList@@YAXPAE@Z		; DGAnsPartyMatchAcceptList
PUBLIC	?DGAnsPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_DGANS_REQUESTANSWER@@@Z ; DGAnsPartyMatchRequestAnswer
PUBLIC	?GDPartyMatchUpdateStatus@@YAXPADE@Z		; GDPartyMatchUpdateStatus
PUBLIC	??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::allocator<PartyBonusByClass>,PartyBonusByClass>
PUBLIC	??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::allocator<PartyBonusByNearby>,PartyBonusByNearby>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7PartyClass@@6B@				; PartyClass::`vftable'
PUBLIC	??_C@_0BC@JDIKBIFA@PartyMember?$CI?$CFd?$CJ?5?3?$AA@ ; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_02DNJFBPJB@?$FN?$FL?$AA@			; `string'
PUBLIC	??_C@_03EDAPGMLK@?$FN?0?5?$AA@			; `string'
PUBLIC	??_C@_0BM@LALPKKLG@?$FLNotice?$FN?5File?5?$CFs?5not?5found?$CB?$AA@ ; `string'
PUBLIC	??_C@_0L@IEPNMBM@partybonus?$AA@		; `string'
PUBLIC	??_C@_0BC@CJJHODAB@partymembernearby?$AA@	; `string'
PUBLIC	??_C@_0BB@IEGGGIGJ@partymemberclass?$AA@	; `string'
PUBLIC	??_C@_05JNLCBACP@bonus?$AA@			; `string'
PUBLIC	??_C@_0M@KPHNJNMB@nearbycount?$AA@		; `string'
PUBLIC	??_C@_02CPBOKKCA@dw?$AA@			; `string'
PUBLIC	??_C@_02MJGJPHHN@dk?$AA@			; `string'
PUBLIC	??_C@_03KACJNJLH@elf?$AA@			; `string'
PUBLIC	??_C@_02GKANIDPO@mg?$AA@			; `string'
PUBLIC	??_C@_02IGCIGBLK@dl?$AA@			; `string'
PUBLIC	??_C@_03CFFIJAMA@sum?$AA@			; `string'
PUBLIC	??_C@_02GEGMFGPC@rf?$AA@			; `string'
PUBLIC	??_C@_0CK@FNDAOIBL@?$FLParty?5System?$FN?5PartyIndex?$CI?$CFd?$CJ?3?5P@ ; `string'
PUBLIC	??_C@_0DA@MHAFDPJC@?$FLParty?5System?$FN?5PartyMember?$CI?$CFd?$CJ?0?5@ ; `string'
PUBLIC	??_C@_09BCDIPNKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@ ; `string'
PUBLIC	??_C@_0BF@CDBILJMP@PartyOut?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@DIPPFHJE@PartyRejoin?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@ ; `string'
PUBLIC	??_C@_0BP@GIPBDNCJ@Your?5character?5is?5not?5in?5party?$AA@ ; `string'
PUBLIC	??_C@_0BL@DDDPOLAI@Target?5is?5not?5party?5member?$AA@ ; `string'
PUBLIC	??_C@_0CD@LEEFHALA@Your?5character?5is?5not?5party?5lead@ ; `string'
PUBLIC	??_C@_0BF@OFNDHPCK@New?5party?5leader?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@		; `string'
PUBLIC	??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BI@MEOHNEFK@Target?5user?5not?5in?5game?$AA@ ; `string'
PUBLIC	??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@ ; `string'
PUBLIC	??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@ ; `string'
PUBLIC	??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@ ; `string'
PUBLIC	??_C@_0BN@PPICOFML@Target?5user?5already?5in?5party?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4PartyClass@@6B@				; PartyClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVPartyClass@@@8				; PartyClass `RTTI Type Descriptor'
PUBLIC	??_R3PartyClass@@8				; PartyClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2PartyClass@@8				; PartyClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@PartyClass@@8			; PartyClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@42c80000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?GCResultSend@@YAXHEE@Z:PROC			; GCResultSend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?CGPartyList@@YAXH@Z:PROC			; CGPartyList
EXTRN	?CGPartyListAll@@YAXH@Z:PROC			; CGPartyListAll
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjGetIndex@@YAHPAD@Z:PROC			; gObjGetIndex
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	??_EPartyClass@@UAEPAXI@Z:PROC			; PartyClass::`vector deleting destructor'
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?PHeadSubSetW@@YAXPAEEEH@Z:PROC			; PHeadSubSetW
EXTRN	?as_int@xml_attribute@pugi@@QBEHH@Z:PROC	; pugi::xml_attribute::as_int
EXTRN	??0xml_node@pugi@@QAE@XZ:PROC			; pugi::xml_node::xml_node
EXTRN	??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ:PROC	; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
EXTRN	?next_sibling@xml_node@pugi@@QBE?AV12@XZ:PROC	; pugi::xml_node::next_sibling
EXTRN	?text@xml_node@pugi@@QBE?AVxml_text@2@XZ:PROC	; pugi::xml_node::text
EXTRN	?child@xml_node@pugi@@QBE?AV12@PBD@Z:PROC	; pugi::xml_node::child
EXTRN	?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z:PROC ; pugi::xml_node::attribute
EXTRN	?as_int@xml_text@pugi@@QBEHH@Z:PROC		; pugi::xml_text::as_int
EXTRN	??0xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::xml_document
EXTRN	??1xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::~xml_document
EXTRN	?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z:PROC ; pugi::xml_document::load_file
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gGensSystem@@3VCGensSystem@@A:BYTE		; gGensSystem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@PartyClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@PartyClass@@8 DD FLAT:??_R0?AVPartyClass@@@8 ; PartyClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3PartyClass@@8
rdata$r	ENDS
;	COMDAT ??_R2PartyClass@@8
rdata$r	SEGMENT
??_R2PartyClass@@8 DD FLAT:??_R1A@?0A@EA@PartyClass@@8	; PartyClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3PartyClass@@8
rdata$r	SEGMENT
??_R3PartyClass@@8 DD 00H				; PartyClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2PartyClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPartyClass@@@8
data$r	SEGMENT
??_R0?AVPartyClass@@@8 DD FLAT:??_7type_info@@6B@	; PartyClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPartyClass@@', 00H
data$r	ENDS
;	COMDAT ??_R4PartyClass@@6B@
rdata$r	SEGMENT
??_R4PartyClass@@6B@ DD 00H				; PartyClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPartyClass@@@8
	DD	FLAT:??_R3PartyClass@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PPICOFML@Target?5user?5already?5in?5party?$AA@
CONST	SEGMENT
??_C@_0BN@PPICOFML@Target?5user?5already?5in?5party?$AA@ DB 'Target user '
	DB	'already in party', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
CONST	SEGMENT
??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@ DB 'Party not a'
	DB	'llowed in Imperial Fort.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
CONST	SEGMENT
??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@ DB 'Party not al'
	DB	'lowed in Doppelganger.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
CONST	SEGMENT
??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@ DB 'Party not a'
	DB	'llowed in Illusion Temple.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEOHNEFK@Target?5user?5not?5in?5game?$AA@
CONST	SEGMENT
??_C@_0BI@MEOHNEFK@Target?5user?5not?5in?5game?$AA@ DB 'Target user not i'
	DB	'n game', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@ DB 'error: %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
CONST	SEGMENT
??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@ DB 'PartyClass.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OFNDHPCK@New?5party?5leader?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@OFNDHPCK@New?5party?5leader?3?5?$CFs?$AA@ DB 'New party leader:'
	DB	' %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LEEFHALA@Your?5character?5is?5not?5party?5lead@
CONST	SEGMENT
??_C@_0CD@LEEFHALA@Your?5character?5is?5not?5party?5lead@ DB 'Your charac'
	DB	'ter is not party leader', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DDDPOLAI@Target?5is?5not?5party?5member?$AA@
CONST	SEGMENT
??_C@_0BL@DDDPOLAI@Target?5is?5not?5party?5member?$AA@ DB 'Target is not '
	DB	'party member', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GIPBDNCJ@Your?5character?5is?5not?5in?5party?$AA@
CONST	SEGMENT
??_C@_0BP@GIPBDNCJ@Your?5character?5is?5not?5in?5party?$AA@ DB 'Your char'
	DB	'acter is not in party', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DIPPFHJE@PartyRejoin?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@
CONST	SEGMENT
??_C@_0BI@DIPPFHJE@PartyRejoin?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@ DB 'P'
	DB	'artyRejoin : [%s][%s] ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CDBILJMP@PartyOut?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@
CONST	SEGMENT
??_C@_0BF@CDBILJMP@PartyOut?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@ DB 'Pa'
	DB	'rtyOut : [%s][%s] ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCDIPNKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@
CONST	SEGMENT
??_C@_09BCDIPNKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@ DB '[%s][%s] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MHAFDPJC@?$FLParty?5System?$FN?5PartyMember?$CI?$CFd?$CJ?0?5@
CONST	SEGMENT
??_C@_0DA@MHAFDPJC@?$FLParty?5System?$FN?5PartyMember?$CI?$CFd?$CJ?0?5@ DB '['
	DB	'Party System] PartyMember(%d), PartyIndex(%d) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FNDAOIBL@?$FLParty?5System?$FN?5PartyIndex?$CI?$CFd?$CJ?3?5P@
CONST	SEGMENT
??_C@_0CK@FNDAOIBL@?$FLParty?5System?$FN?5PartyIndex?$CI?$CFd?$CJ?3?5P@ DB '['
	DB	'Party System] PartyIndex(%d): PartyBreak', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GEGMFGPC@rf?$AA@
CONST	SEGMENT
??_C@_02GEGMFGPC@rf?$AA@ DB 'rf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFFIJAMA@sum?$AA@
CONST	SEGMENT
??_C@_03CFFIJAMA@sum?$AA@ DB 'sum', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IGCIGBLK@dl?$AA@
CONST	SEGMENT
??_C@_02IGCIGBLK@dl?$AA@ DB 'dl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GKANIDPO@mg?$AA@
CONST	SEGMENT
??_C@_02GKANIDPO@mg?$AA@ DB 'mg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KACJNJLH@elf?$AA@
CONST	SEGMENT
??_C@_03KACJNJLH@elf?$AA@ DB 'elf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJGJPHHN@dk?$AA@
CONST	SEGMENT
??_C@_02MJGJPHHN@dk?$AA@ DB 'dk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CPBOKKCA@dw?$AA@
CONST	SEGMENT
??_C@_02CPBOKKCA@dw?$AA@ DB 'dw', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KPHNJNMB@nearbycount?$AA@
CONST	SEGMENT
??_C@_0M@KPHNJNMB@nearbycount?$AA@ DB 'nearbycount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JNLCBACP@bonus?$AA@
CONST	SEGMENT
??_C@_05JNLCBACP@bonus?$AA@ DB 'bonus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEGGGIGJ@partymemberclass?$AA@
CONST	SEGMENT
??_C@_0BB@IEGGGIGJ@partymemberclass?$AA@ DB 'partymemberclass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CJJHODAB@partymembernearby?$AA@
CONST	SEGMENT
??_C@_0BC@CJJHODAB@partymembernearby?$AA@ DB 'partymembernearby', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEPNMBM@partybonus?$AA@
CONST	SEGMENT
??_C@_0L@IEPNMBM@partybonus?$AA@ DB 'partybonus', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LALPKKLG@?$FLNotice?$FN?5File?5?$CFs?5not?5found?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@LALPKKLG@?$FLNotice?$FN?5File?5?$CFs?5not?5found?$CB?$AA@ DB '['
	DB	'Notice] File %s not found!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EDAPGMLK@?$FN?0?5?$AA@
CONST	SEGMENT
??_C@_03EDAPGMLK@?$FN?0?5?$AA@ DB '], ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DNJFBPJB@?$FN?$FL?$AA@
CONST	SEGMENT
??_C@_02DNJFBPJB@?$FN?$FL?$AA@ DB '][', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JDIKBIFA@PartyMember?$CI?$CFd?$CJ?5?3?$AA@
CONST	SEGMENT
??_C@_0BC@JDIKBIFA@PartyMember?$CI?$CFd?$CJ?5?3?$AA@ DB 'PartyMember(%d) '
	DB	':', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7PartyClass@@6B@
CONST	SEGMENT
??_7PartyClass@@6B@ DD FLAT:??_R4PartyClass@@6B@	; PartyClass::`vftable'
	DD	FLAT:??_EPartyClass@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ReadBonusInfo@PartyClass@@QAEXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadBonusInfo@PartyClass@@QAEXPAD@Z$0
__ehfuncinfo$?ReadBonusInfo@PartyClass@@QAEXPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadBonusInfo@PartyClass@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z$50 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z$50
__ehfuncinfo$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z$50 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z$50
__ehfuncinfo$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@U1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByNearby@@U1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@$$QAU2@@Z PROC ; std::allocator<PartyBonusByNearby>::construct<PartyBonusByNearby,PartyBonusByNearby>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 656  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@UPartyBonusByNearby@@U1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@$$QAU2@@Z ENDP ; std::allocator<PartyBonusByNearby>::construct<PartyBonusByNearby,PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@U1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByClass@@U1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@$$QAU2@@Z PROC ; std::allocator<PartyBonusByClass>::construct<PartyBonusByClass,PartyBonusByClass>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 656  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UPartyBonusByClass@@U1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@$$QAU2@@Z ENDP ; std::allocator<PartyBonusByClass>::construct<PartyBonusByClass,PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@U1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPartyBonusByNearby@@U1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN8@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@UPartyBonusByNearby@@U1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UPartyBonusByNearby@@@std@@YA$$QAUPartyBonusByNearby@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UPartyBonusByNearby@@@std@@YA$$QAUPartyBonusByNearby@@AAU1@@Z PROC ; std::forward<PartyBonusByNearby>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UPartyBonusByNearby@@@std@@YA$$QAUPartyBonusByNearby@@AAU1@@Z ENDP ; std::forward<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@U1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPartyBonusByClass@@U1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UPartyBonusByClass@@U1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UPartyBonusByClass@@@std@@YA$$QAUPartyBonusByClass@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UPartyBonusByClass@@@std@@YA$$QAUPartyBonusByClass@@AAU1@@Z PROC ; std::forward<PartyBonusByClass>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UPartyBonusByClass@@@std@@YA$$QAUPartyBonusByClass@@AAU1@@Z ENDP ; std::forward<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@U1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByNearby@@U1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN13@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@UPartyBonusByNearby@@U1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@U1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByClass@@U1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UPartyBonusByClass@@U1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartyBonusByNearby@@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartyBonusByNearby@@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@@Z PROC ; std::allocator<PartyBonusByNearby>::destroy<PartyBonusByNearby>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UPartyBonusByNearby@@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@@Z ENDP ; std::allocator<PartyBonusByNearby>::destroy<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartyBonusByClass@@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartyBonusByClass@@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@@Z PROC ; std::allocator<PartyBonusByClass>::destroy<PartyBonusByClass>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UPartyBonusByClass@@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@@Z ENDP ; std::allocator<PartyBonusByClass>::destroy<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::allocator<PartyBonusByNearby>,PartyBonusByNearby>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	3b cf		 cmp	 ecx, edi
  0000c	74 22		 je	 SHORT $LN37@Uninit_mov
  0000e	56		 push	 esi
  0000f	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
$LL4@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00012	85 f6		 test	 esi, esi
  00014	74 0a		 je	 SHORT $LN2@Uninit_mov
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	89 06		 mov	 DWORD PTR [esi], eax
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN2@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00020	83 c1 08	 add	 ecx, 8
  00023	83 c6 08	 add	 esi, 8
  00026	3b cf		 cmp	 ecx, edi
  00028	75 e8		 jne	 SHORT $LL4@Uninit_mov

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5f		 pop	 edi

; 450  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN37@Uninit_mov:

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);

  00030	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	5f		 pop	 edi

; 450  : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::allocator<PartyBonusByNearby>,PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@PAU1@@Z PROC ; std::_Val_type<PartyBonusByNearby *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@PAU1@@Z ENDP ; std::_Val_type<PartyBonusByNearby *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::allocator<PartyBonusByClass>,PartyBonusByClass>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 1c		 je	 SHORT $LN3@Uninit_mov
$LL4@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN2@Uninit_mov
  00015	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00019	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN2@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00023	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00026	83 c0 0c	 add	 eax, 12			; 0000000cH
  00029	3b ce		 cmp	 ecx, esi
  0002b	75 e4		 jne	 SHORT $LL4@Uninit_mov
$LN3@Uninit_mov:
  0002d	5e		 pop	 esi

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);
; 450  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::allocator<PartyBonusByClass>,PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@PAU1@@Z PROC ; std::_Val_type<PartyBonusByClass *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@PAU1@@Z ENDP ; std::_Val_type<PartyBonusByClass *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartyBonusByNearby@@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UPartyBonusByNearby@@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::destroy<PartyBonusByNearby>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@UPartyBonusByNearby@@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::destroy<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<PartyBonusByNearby>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartyBonusByClass@@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UPartyBonusByClass@@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByClass> >::destroy<PartyBonusByClass>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@UPartyBonusByClass@@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByClass> >::destroy<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<PartyBonusByClass>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUPartyBonusByNearby@@PAU1@@std@@YAAAPAUPartyBonusByNearby@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUPartyBonusByNearby@@PAU1@@std@@YAAAPAUPartyBonusByNearby@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<PartyBonusByNearby *,PartyBonusByNearby *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUPartyBonusByNearby@@PAU1@@std@@YAAAPAUPartyBonusByNearby@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<PartyBonusByNearby *,PartyBonusByNearby *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z PROC ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::allocator<PartyBonusByNearby>,PartyBonusByNearby>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z ENDP ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@PAU1@@Z PROC ; std::_Unchecked<PartyBonusByNearby *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@PAU1@@Z ENDP ; std::_Unchecked<PartyBonusByNearby *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUPartyBonusByClass@@PAU1@@std@@YAAAPAUPartyBonusByClass@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUPartyBonusByClass@@PAU1@@std@@YAAAPAUPartyBonusByClass@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<PartyBonusByClass *,PartyBonusByClass *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUPartyBonusByClass@@PAU1@@std@@YAAAPAUPartyBonusByClass@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<PartyBonusByClass *,PartyBonusByClass *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUPartyBonusByClass@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUPartyBonusByClass@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z PROC ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::allocator<PartyBonusByClass>,PartyBonusByClass>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUPartyBonusByClass@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z ENDP ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@PAU1@@Z PROC ; std::_Unchecked<PartyBonusByClass *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@PAU1@@Z ENDP ; std::_Unchecked<PartyBonusByClass *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartyBonusByNearby@@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartyBonusByNearby@@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::destroy<PartyBonusByNearby>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UPartyBonusByNearby@@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::destroy<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@AAU1@@Z PROC ; std::addressof<PartyBonusByNearby>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UPartyBonusByNearby@@@std@@YAPAUPartyBonusByNearby@@AAU1@@Z ENDP ; std::addressof<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartyBonusByClass@@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartyBonusByClass@@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::destroy<PartyBonusByClass>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UPartyBonusByClass@@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::destroy<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@AAU1@@Z PROC ; std::addressof<PartyBonusByClass>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UPartyBonusByClass@@@std@@YAPAUPartyBonusByClass@@AAU1@@Z ENDP ; std::addressof<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@ABU1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByNearby@@ABU1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@ABU2@@Z PROC ; std::allocator<PartyBonusByNearby>::construct<PartyBonusByNearby,PartyBonusByNearby const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 656  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@UPartyBonusByNearby@@ABU1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@ABU2@@Z ENDP ; std::allocator<PartyBonusByNearby>::construct<PartyBonusByNearby,PartyBonusByNearby const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@AAU1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByNearby@@AAU1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@AAU2@@Z PROC ; std::allocator<PartyBonusByNearby>::construct<PartyBonusByNearby,PartyBonusByNearby &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 656  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@UPartyBonusByNearby@@AAU1@@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@AAU2@@Z ENDP ; std::allocator<PartyBonusByNearby>::construct<PartyBonusByNearby,PartyBonusByNearby &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@ABU1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByClass@@ABU1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@ABU2@@Z PROC ; std::allocator<PartyBonusByClass>::construct<PartyBonusByClass,PartyBonusByClass const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 656  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UPartyBonusByClass@@ABU1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@ABU2@@Z ENDP ; std::allocator<PartyBonusByClass>::construct<PartyBonusByClass,PartyBonusByClass const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@AAU1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByClass@@AAU1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@AAU2@@Z PROC ; std::allocator<PartyBonusByClass>::construct<PartyBonusByClass,PartyBonusByClass &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 656  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UPartyBonusByClass@@AAU1@@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@AAU2@@Z ENDP ; std::allocator<PartyBonusByClass>::construct<PartyBonusByClass,PartyBonusByClass &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUPartyBonusByNearby@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUPartyBonusByNearby@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z PROC ; std::_Uninitialized_move<PartyBonusByNearby *,PartyBonusByNearby *,std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::allocator<PartyBonusByNearby>,PartyBonusByNearby>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUPartyBonusByNearby@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<PartyBonusByNearby *,PartyBonusByNearby *,std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUPartyBonusByClass@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUPartyBonusByClass@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z PROC ; std::_Uninitialized_move<PartyBonusByClass *,PartyBonusByClass *,std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::allocator<PartyBonusByClass>,PartyBonusByClass>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUPartyBonusByClass@@PAU1@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<PartyBonusByClass *,PartyBonusByClass *,std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAXPAUPartyBonusByNearby@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAXPAUPartyBonusByNearby@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAXPAUPartyBonusByNearby@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UPartyBonusByNearby@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPartyBonusByNearby@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UPartyBonusByNearby@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPartyBonusByNearby@@0@Z PROC ; std::_Ptr_cat<PartyBonusByNearby,PartyBonusByNearby>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UPartyBonusByNearby@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPartyBonusByNearby@@0@Z ENDP ; std::_Ptr_cat<PartyBonusByNearby,PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UPartyBonusByNearby@@@std@@@std@@YAABV?$allocator@UPartyBonusByNearby@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UPartyBonusByNearby@@@std@@@std@@YAABV?$allocator@UPartyBonusByNearby@@@0@ABV10@@Z PROC ; std::forward<std::allocator<PartyBonusByNearby> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UPartyBonusByNearby@@@std@@@std@@YAABV?$allocator@UPartyBonusByNearby@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<PartyBonusByNearby> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAXPAUPartyBonusByClass@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAXPAUPartyBonusByClass@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAXPAUPartyBonusByClass@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UPartyBonusByClass@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPartyBonusByClass@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UPartyBonusByClass@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPartyBonusByClass@@0@Z PROC ; std::_Ptr_cat<PartyBonusByClass,PartyBonusByClass>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UPartyBonusByClass@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPartyBonusByClass@@0@Z ENDP ; std::_Ptr_cat<PartyBonusByClass,PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UPartyBonusByClass@@@std@@@std@@YAABV?$allocator@UPartyBonusByClass@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UPartyBonusByClass@@@std@@@std@@YAABV?$allocator@UPartyBonusByClass@@@0@ABV10@@Z PROC ; std::forward<std::allocator<PartyBonusByClass> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UPartyBonusByClass@@@std@@@std@@YAABV?$allocator@UPartyBonusByClass@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<PartyBonusByClass> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@ABU1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPartyBonusByNearby@@ABU1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN8@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@UPartyBonusByNearby@@ABU1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUPartyBonusByNearby@@@std@@YAABUPartyBonusByNearby@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUPartyBonusByNearby@@@std@@YAABUPartyBonusByNearby@@ABU1@@Z PROC ; std::forward<PartyBonusByNearby const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUPartyBonusByNearby@@@std@@YAABUPartyBonusByNearby@@ABU1@@Z ENDP ; std::forward<PartyBonusByNearby const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@AAU1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPartyBonusByNearby@@AAU1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN8@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@UPartyBonusByNearby@@AAU1@@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByNearby@@@1@PAUPartyBonusByNearby@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUPartyBonusByNearby@@@std@@YAAAUPartyBonusByNearby@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUPartyBonusByNearby@@@std@@YAAAUPartyBonusByNearby@@AAU1@@Z PROC ; std::forward<PartyBonusByNearby &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUPartyBonusByNearby@@@std@@YAAAUPartyBonusByNearby@@AAU1@@Z ENDP ; std::forward<PartyBonusByNearby &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBUPartyBonusByNearby@@@std@@YAPBUPartyBonusByNearby@@ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBUPartyBonusByNearby@@@std@@YAPBUPartyBonusByNearby@@ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<PartyBonusByNearby const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBUPartyBonusByNearby@@@std@@YAPBUPartyBonusByNearby@@ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<PartyBonusByNearby const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@ABU1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPartyBonusByClass@@ABU1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UPartyBonusByClass@@ABU1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUPartyBonusByClass@@@std@@YAABUPartyBonusByClass@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUPartyBonusByClass@@@std@@YAABUPartyBonusByClass@@ABU1@@Z PROC ; std::forward<PartyBonusByClass const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUPartyBonusByClass@@@std@@YAABUPartyBonusByClass@@ABU1@@Z ENDP ; std::forward<PartyBonusByClass const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@AAU1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPartyBonusByClass@@AAU1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UPartyBonusByClass@@AAU1@@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAXAAV?$allocator@UPartyBonusByClass@@@1@PAUPartyBonusByClass@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUPartyBonusByClass@@@std@@YAAAUPartyBonusByClass@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUPartyBonusByClass@@@std@@YAAAUPartyBonusByClass@@AAU1@@Z PROC ; std::forward<PartyBonusByClass &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUPartyBonusByClass@@@std@@YAAAUPartyBonusByClass@@AAU1@@Z ENDP ; std::forward<PartyBonusByClass &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBUPartyBonusByClass@@@std@@YAPBUPartyBonusByClass@@ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBUPartyBonusByClass@@@std@@YAPBUPartyBonusByClass@@ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<PartyBonusByClass const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBUPartyBonusByClass@@@std@@YAPBUPartyBonusByClass@@ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<PartyBonusByClass const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUPartyBonusByNearby@@@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEPAUPartyBonusByNearby@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUPartyBonusByNearby@@@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEPAUPartyBonusByNearby@@PAU2@00@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Umove<PartyBonusByNearby *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::allocator<PartyBonusByNearby>,PartyBonusByNearby>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUPartyBonusByNearby@@@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEPAUPartyBonusByNearby@@PAU2@00@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Umove<PartyBonusByNearby *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUPartyBonusByClass@@@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEPAUPartyBonusByClass@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUPartyBonusByClass@@@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEPAUPartyBonusByClass@@PAU2@00@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Umove<PartyBonusByClass *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::allocator<PartyBonusByClass>,PartyBonusByClass>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUPartyBonusByClass@@@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEPAUPartyBonusByClass@@PAU2@00@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Umove<PartyBonusByClass *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAXPAUPartyBonusByNearby@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAXPAUPartyBonusByNearby@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@YAXPAUPartyBonusByNearby@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UPartyBonusByNearby@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UPartyBonusByNearby@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UPartyBonusByNearby@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UPartyBonusByNearby@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1><std::allocator<PartyBonusByNearby> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UPartyBonusByNearby@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UPartyBonusByNearby@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1><std::allocator<PartyBonusByNearby> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAXPAUPartyBonusByClass@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAXPAUPartyBonusByClass@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@YAXPAUPartyBonusByClass@@0AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PartyBonusByClass> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UPartyBonusByClass@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UPartyBonusByClass@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UPartyBonusByClass@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UPartyBonusByClass@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1><std::allocator<PartyBonusByClass> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UPartyBonusByClass@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UPartyBonusByClass@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1><std::allocator<PartyBonusByClass> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@ABU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByNearby@@ABU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN13@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@UPartyBonusByNearby@@ABU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByNearby@@AAU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByNearby@@AAU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN13@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@UPartyBonusByNearby@@AAU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::construct<PartyBonusByNearby,PartyBonusByNearby &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUPartyBonusByNearby@@@std@@YAPBUPartyBonusByNearby@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUPartyBonusByNearby@@@std@@YAPBUPartyBonusByNearby@@ABU1@@Z PROC ; std::addressof<PartyBonusByNearby const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUPartyBonusByNearby@@@std@@YAPBUPartyBonusByNearby@@ABU1@@Z ENDP ; std::addressof<PartyBonusByNearby const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@ABU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByClass@@ABU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UPartyBonusByClass@@ABU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartyBonusByClass@@AAU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartyBonusByClass@@AAU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UPartyBonusByClass@@AAU1@@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::construct<PartyBonusByClass,PartyBonusByClass &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUPartyBonusByClass@@@std@@YAPBUPartyBonusByClass@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUPartyBonusByClass@@@std@@YAPBUPartyBonusByClass@@ABU1@@Z PROC ; std::addressof<PartyBonusByClass const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUPartyBonusByClass@@@std@@YAPBUPartyBonusByClass@@ABU1@@Z ENDP ; std::addressof<PartyBonusByClass const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GDPartyMatchUpdateStatus@@YAXPADE@Z
_TEXT	SEGMENT
_lpRequest$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_Character$ = 8						; size = 4
_Status$ = 12						; size = 1
?GDPartyMatchUpdateStatus@@YAXPADE@Z PROC		; GDPartyMatchUpdateStatus, COMDAT

; 1500 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _Character$[ebp]
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	PARTYMATCH_GDREQ_UPDATESTATUS lpRequest = { 0 };
; 1502 : 	lpRequest.h.c			= 0xC1;
; 1503 : 	lpRequest.h.headcode	= 0xEF;
; 1504 : 	lpRequest.h.subcode		= 0x07;
; 1505 : 	lpRequest.h.size		= sizeof(PARTYMATCH_GDREQ_UPDATESTATUS);
; 1506 : 	lpRequest.Status		= Status;

  00016	8a 45 0c	 mov	 al, BYTE PTR _Status$[ebp]
  00019	c6 45 fb 00	 mov	 BYTE PTR _lpRequest$[ebp+15], 0
  0001d	88 45 fb	 mov	 BYTE PTR _lpRequest$[ebp+15], al

; 1507 : 	memcpy(lpRequest.Character, Character, 10);

  00020	66 8b 41 08	 mov	 ax, WORD PTR [ecx+8]
  00024	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _lpRequest$[ebp+9], 0
  0002b	66 0f d6 45 ed	 movq	 QWORD PTR _lpRequest$[ebp+1], xmm0
  00030	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]

; 1508 : 	cDBSMng.Send((PCHAR)&lpRequest, sizeof(PARTYMATCH_GDREQ_UPDATESTATUS));

  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00039	66 c7 45 f9 00
	00		 mov	 WORD PTR _lpRequest$[ebp+13], 0
  0003f	66 89 45 f8	 mov	 WORD PTR _lpRequest$[ebp+12], ax
  00043	8d 45 ec	 lea	 eax, DWORD PTR _lpRequest$[ebp]
  00046	6a 10		 push	 16			; 00000010H
  00048	50		 push	 eax
  00049	c7 45 ec c1 10
	ef 07		 mov	 DWORD PTR _lpRequest$[ebp], 133107905 ; 07ef10c1H
  00050	66 0f d6 45 f0	 movq	 QWORD PTR _lpRequest$[ebp+4], xmm0
  00055	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 1509 : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?GDPartyMatchUpdateStatus@@YAXPADE@Z ENDP		; GDPartyMatchUpdateStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?DGAnsPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_DGANS_REQUESTANSWER@@@Z
_TEXT	SEGMENT
tv437 = -308						; size = 4
_PartyNumber$ = -308					; size = 4
tv431 = -304						; size = 4
tv429 = -304						; size = 4
tv434 = -300						; size = 4
tv436 = -296						; size = 4
tv435 = -292						; size = 4
tv433 = -292						; size = 4
_PartyNumber$1$ = -288					; size = 4
_lpRequest$ = -284					; size = 23
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?DGAnsPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_DGANS_REQUESTANSWER@@@Z PROC ; DGAnsPartyMatchRequestAnswer, COMDAT

; 1410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 08	 mov	 edx, DWORD PTR _lpData$[ebp]
  00016	57		 push	 edi

; 1411 : 	if(		!OBJMAX_RANGE(lpData->UserIndex) 
; 1412 : 		||	gObj[lpData->UserIndex].Connected != PLAYER_PLAYING )

  00017	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0001a	85 ff		 test	 edi, edi
  0001c	0f 88 8c 03 00
	00		 js	 $LN3@DGAnsParty
  00022	33 c0		 xor	 eax, eax
  00024	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 79 03 00
	00		 je	 $LN3@DGAnsParty
  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003a	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00040	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00045	0f 85 63 03 00
	00		 jne	 $LN3@DGAnsParty

; 1413 : 	{
; 1414 : 		return;
; 1415 : 	}
; 1416 : 	// ----
; 1417 : 	if( lpData->Type == 0 )

  0004b	83 7a 13 00	 cmp	 DWORD PTR [edx+19], 0
  0004f	75 18		 jne	 SHORT $LN4@DGAnsParty

; 1418 : 	{
; 1419 : 		CGReqPartyMatchAcceptList(lpData->UserIndex);

  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ?CGReqPartyMatchAcceptList@@YAXH@Z ; CGReqPartyMatchAcceptList
  00057	83 c4 04	 add	 esp, 4
  0005a	5f		 pop	 edi

; 1497 : }

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN4@DGAnsParty:
  00069	53		 push	 ebx

; 1420 : 		return;
; 1421 : 	}
; 1422 : 	// ----
; 1423 : 	int UserIndex	= lpData->UserIndex;
; 1424 : 	int TargetIndex = gObjGetIndex(lpData->Character);

  0006a	8d 42 08	 lea	 eax, DWORD PTR [edx+8]
  0006d	56		 push	 esi
  0006e	50		 push	 eax
  0006f	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv437[ebp], eax
  00075	e8 00 00 00 00	 call	 ?gObjGetIndex@@YAHPAD@Z	; gObjGetIndex
  0007a	8b d8		 mov	 ebx, eax
  0007c	83 c4 04	 add	 esp, 4

; 1425 : 	// ----
; 1426 : 	if(	!OBJMAX_RANGE(TargetIndex) ||

  0007f	85 db		 test	 ebx, ebx
  00081	0f 88 15 03 00
	00		 js	 $LN6@DGAnsParty
  00087	33 c9		 xor	 ecx, ecx
  00089	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0008f	0f 9e c1	 setle	 cl
  00092	85 c9		 test	 ecx, ecx
  00094	0f 84 02 03 00
	00		 je	 $LN6@DGAnsParty
  0009a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048
  000a6	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv436[ebp], eax
  000ac	83 7c 30 04 03	 cmp	 DWORD PTR [eax+esi+4], 3
  000b1	0f 85 e5 02 00
	00		 jne	 $LN6@DGAnsParty

; 1430 : 		return;
; 1431 : 	}
; 1432 : 	// ----
; 1433 : 	LPOBJ lpTargetUser = &gObj[TargetIndex];
; 1434 : 	// ----
; 1435 : 	int PartyNumber;
; 1436 : 	char szTemp[256] = { 0 };
; 1437 : 	// ----
; 1438 : 	if( gObj[UserIndex].PartyNumber < 0 )

  000b7	68 00 01 00 00	 push	 256			; 00000100H
  000bc	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  000c2	6a 00		 push	 0
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _memset
  000ca	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	83 bc 30 0c 06
	00 00 00	 cmp	 DWORD PTR [eax+esi+1548], 0
  000db	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv434[ebp], eax
  000e1	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000e4	89 8d dc fe ff
	ff		 mov	 DWORD PTR tv433[ebp], ecx
  000ea	7d 2e		 jge	 SHORT $LN7@DGAnsParty

; 1439 : 	{
; 1440 : 		gObj[UserIndex].PartyNumber = gParty.Create(UserIndex, gObj[UserIndex].DBNumber, gObj[UserIndex].Level);

  000ec	0f bf 81 96 00
	00 00		 movsx	 eax, WORD PTR [ecx+150]
  000f3	50		 push	 eax
  000f4	ff 71 30	 push	 DWORD PTR [ecx+48]
  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000fc	57		 push	 edi
  000fd	e8 00 00 00 00	 call	 ?Create@PartyClass@@QAEHHHH@Z ; PartyClass::Create
  00102	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv433[ebp]
  00108	89 81 0c 06 00
	00		 mov	 DWORD PTR [ecx+1548], eax
  0010e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00114	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv434[ebp]
$LN7@DGAnsParty:

; 1441 : 	}
; 1442 : 	// ----
; 1443 : 	if( gObj[UserIndex].PartyNumber >= 0  )

  0011a	05 0c 06 00 00	 add	 eax, 1548		; 0000060cH
  0011f	03 c6		 add	 eax, esi
  00121	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv431[ebp], eax
  00127	8b 08		 mov	 ecx, DWORD PTR [eax]
  00129	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _PartyNumber$1$[ebp], ecx
  0012f	85 c9		 test	 ecx, ecx
  00131	0f 88 5a 02 00
	00		 js	 $LN22@DGAnsParty

; 1444 : 	{
; 1445 : 		PartyNumber = gObj[UserIndex].PartyNumber;
; 1446 : 		int iPartyPos = gParty.Add(gObj[UserIndex].PartyNumber, TargetIndex, gObj[TargetIndex].DBNumber, gObj[TargetIndex].Level);

  00137	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv436[ebp]
  0013d	03 d6		 add	 edx, esi
  0013f	89 95 dc fe ff
	ff		 mov	 DWORD PTR tv435[ebp], edx
  00145	0f bf 82 96 00
	00 00		 movsx	 eax, WORD PTR [edx+150]
  0014c	50		 push	 eax
  0014d	ff 72 30	 push	 DWORD PTR [edx+48]
  00150	53		 push	 ebx
  00151	51		 push	 ecx
  00152	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00157	e8 00 00 00 00	 call	 ?Add@PartyClass@@QAEHHHHH@Z ; PartyClass::Add

; 1447 : 		// ----
; 1448 : 		if( iPartyPos >= 0 )

  0015c	85 c0		 test	 eax, eax
  0015e	0f 88 ab 00 00
	00		 js	 $LN9@DGAnsParty

; 1449 : 		{
; 1450 : 			gObj[TargetIndex].PartyNumber = gObj[UserIndex].PartyNumber;

  00164	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv431[ebp]
  0016a	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv435[ebp]
  00170	8b 00		 mov	 eax, DWORD PTR [eax]
  00172	89 81 0c 06 00
	00		 mov	 DWORD PTR [ecx+1548], eax

; 1451 : 			wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[TargetIndex].Name);

  00178	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv436[ebp]
  0017e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00183	83 c1 5d	 add	 ecx, 93			; 0000005dH
  00186	03 c1		 add	 eax, ecx
  00188	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0018d	50		 push	 eax
  0018e	68 53 04 00 00	 push	 1107			; 00000453H
  00193	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00198	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  0019e	50		 push	 eax
  0019f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  001a5	50		 push	 eax
  001a6	ff d6		 call	 esi

; 1452 : 			::GCServerMsgStringSend(szTemp, UserIndex, 1);

  001a8	6a 01		 push	 1
  001aa	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  001b0	57		 push	 edi
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1453 : 			wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[UserIndex].Name);

  001b7	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv434[ebp]
  001bd	83 c4 18	 add	 esp, 24			; 00000018H
  001c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c5	83 c1 5d	 add	 ecx, 93			; 0000005dH
  001c8	03 c1		 add	 eax, ecx
  001ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001cf	50		 push	 eax
  001d0	68 53 04 00 00	 push	 1107			; 00000453H
  001d5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001da	50		 push	 eax
  001db	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  001e1	50		 push	 eax
  001e2	ff d6		 call	 esi

; 1454 : 			::GCServerMsgStringSend(szTemp, TargetIndex, 1);

  001e4	6a 01		 push	 1
  001e6	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  001ec	53		 push	 ebx
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1455 : 			gParty.Paint(PartyNumber);

  001f3	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _PartyNumber$1$[ebp]
  001f9	83 c4 18	 add	 esp, 24			; 00000018H
  001fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00201	53		 push	 ebx
  00202	e8 00 00 00 00	 call	 ?Paint@PartyClass@@QAEXH@Z ; PartyClass::Paint
  00207	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020d	eb 2c		 jmp	 SHORT $LN13@DGAnsParty
$LN9@DGAnsParty:

; 1456 : 		}
; 1457 : 		else if( iPartyPos == -1 )

  0020f	83 f8 ff	 cmp	 eax, -1
  00212	0f 85 35 01 00
	00		 jne	 $LN11@DGAnsParty

; 1458 : 		{
; 1459 : 			GCResultSend(UserIndex, 0x41, 2);

  00218	6a 02		 push	 2
  0021a	6a 41		 push	 65			; 00000041H
  0021c	57		 push	 edi
  0021d	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 1460 : 			GCResultSend(TargetIndex, 0x41, 2);

  00222	6a 02		 push	 2
  00224	6a 41		 push	 65			; 00000041H
  00226	53		 push	 ebx
  00227	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
$LN26@DGAnsParty:

; 1465 : 			GCServerMsgStringSend(szTemp, TargetIndex, 1);

  0022c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00232	83 c4 18	 add	 esp, 24			; 00000018H
$LN23@DGAnsParty:
  00235	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _PartyNumber$1$[ebp]
$LN13@DGAnsParty:

; 1466 : 		}
; 1467 : 	}
; 1468 : 	// ----
; 1469 : 	if( gObj[TargetIndex].m_IfState.use !=  0 && gObj[TargetIndex].m_IfState.type == 2)

  0023b	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv436[ebp]
  00241	8d 82 b8 11 00
	00		 lea	 eax, DWORD PTR [edx+4536]
  00247	03 c6		 add	 eax, esi
  00249	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv429[ebp], eax
  0024f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00251	f6 c1 03	 test	 cl, 3
  00254	74 2f		 je	 SHORT $LN14@DGAnsParty
  00256	8b c1		 mov	 eax, ecx
  00258	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0025d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00262	75 21		 jne	 SHORT $LN14@DGAnsParty

; 1470 : 	{
; 1471 : 		gObj[TargetIndex].m_IfState.use = 0;

  00264	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv429[ebp]
  0026a	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0026d	89 08		 mov	 DWORD PTR [eax], ecx

; 1472 : 		gObj[TargetIndex].PartyTargetUser = -1;

  0026f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00274	c7 84 02 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax+1552], -1
  0027f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN14@DGAnsParty:

; 1473 : 	}
; 1474 : 	// ----
; 1475 : 	if( gObj[UserIndex].m_IfState.use !=  0 && gObj[UserIndex].m_IfState.type == 2)

  00285	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR tv434[ebp]
  0028b	8b 8c 32 b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+esi+4536]
  00292	f6 c1 03	 test	 cl, 3
  00295	74 28		 je	 SHORT $LN15@DGAnsParty
  00297	8b c1		 mov	 eax, ecx
  00299	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0029e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002a3	75 1a		 jne	 SHORT $LN15@DGAnsParty

; 1476 : 	{
; 1477 : 		gObj[UserIndex].m_IfState.use = 0;

  002a5	83 e1 fc	 and	 ecx, -4			; fffffffcH
  002a8	89 8c 32 b8 11
	00 00		 mov	 DWORD PTR [edx+esi+4536], ecx

; 1478 : 		gObj[UserIndex].PartyTargetUser = -1;

  002af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b4	c7 84 02 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax+1552], -1
$LN15@DGAnsParty:

; 1479 : 	}
; 1480 : 	// ----
; 1481 : 	if( PartyNumber >= 0 )

  002bf	85 db		 test	 ebx, ebx
  002c1	78 09		 js	 SHORT $LN16@DGAnsParty

; 1482 : 	{
; 1483 : 		CGPartyListAll(PartyNumber);

  002c3	53		 push	 ebx
  002c4	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  002c9	83 c4 04	 add	 esp, 4
$LN16@DGAnsParty:

; 1484 : 	}
; 1485 : 	// ----
; 1486 : 	PARTYMATCH_GDREQ_REQUESTANSWER lpRequest = { 0 };
; 1487 : 	lpRequest.h.c			= 0xC1;
; 1488 : 	lpRequest.h.headcode	= 0xEF;
; 1489 : 	lpRequest.h.subcode		= 0x05;
; 1490 : 	lpRequest.h.size		= sizeof(PARTYMATCH_GDREQ_REQUESTANSWER);
; 1491 : 	lpRequest.UserIndex		= UserIndex;
; 1492 : 	lpRequest.Type			= 0; //Delete
; 1493 : 	memcpy(lpRequest.Character, lpData->Character, 10);

  002cc	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv437[ebp]
  002d2	0f 57 c0	 xorps	 xmm0, xmm0
  002d5	0f 11 85 e5 fe
	ff ff		 movups	 XMMWORD PTR _lpRequest$[ebp+1], xmm0
  002dc	c7 85 f5 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _lpRequest$[ebp+17], 0

; 1494 : 	cDBSMng.Send((PCHAR)&lpRequest, sizeof(PARTYMATCH_GDREQ_REQUESTANSWER));

  002e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002eb	6a 17		 push	 23			; 00000017H
  002ed	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  002f1	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  002f5	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _lpRequest$[ebp+16], ax
  002fc	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _lpRequest$[ebp]
  00302	66 c7 85 f9 fe
	ff ff 00 00	 mov	 WORD PTR _lpRequest$[ebp+21], 0
  0030b	50		 push	 eax
  0030c	c7 85 e4 fe ff
	ff c1 17 ef 05	 mov	 DWORD PTR _lpRequest$[ebp], 99555265 ; 05ef17c1H
  00316	89 bd e8 fe ff
	ff		 mov	 DWORD PTR _lpRequest$[ebp+4], edi
  0031c	c7 85 f7 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _lpRequest$[ebp+19], 0
  00326	66 0f d6 85 ec
	fe ff ff	 movq	 QWORD PTR _lpRequest$[ebp+8], xmm0
  0032e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 1495 : 	// ----	
; 1496 : 	CGReqPartyMatchAcceptList(UserIndex);

  00333	57		 push	 edi
  00334	e8 00 00 00 00	 call	 ?CGReqPartyMatchAcceptList@@YAXH@Z ; CGReqPartyMatchAcceptList
  00339	83 c4 04	 add	 esp, 4
  0033c	5e		 pop	 esi
  0033d	5b		 pop	 ebx
  0033e	5f		 pop	 edi

; 1497 : }

  0033f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00342	33 cd		 xor	 ecx, ebp
  00344	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c3		 ret	 0
$LN11@DGAnsParty:

; 1461 : 		}
; 1462 : 		else if( iPartyPos == -2 )

  0034d	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  00350	0f 85 df fe ff
	ff		 jne	 $LN23@DGAnsParty

; 1463 : 		{
; 1464 : 			wsprintf(szTemp, lMsg.Get(MSGGET(4, 84)), gObj[TargetIndex].Name);

  00356	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv435[ebp]
  0035c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00361	83 c0 5d	 add	 eax, 93			; 0000005dH
  00364	50		 push	 eax
  00365	68 54 04 00 00	 push	 1108			; 00000454H
  0036a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0036f	50		 push	 eax
  00370	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00376	50		 push	 eax
  00377	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1465 : 			GCServerMsgStringSend(szTemp, TargetIndex, 1);

  0037d	6a 01		 push	 1
  0037f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00385	53		 push	 ebx
  00386	50		 push	 eax
  00387	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0038c	e9 9b fe ff ff	 jmp	 $LN26@DGAnsParty
$LN22@DGAnsParty:
  00391	8b 9d cc fe ff
	ff		 mov	 ebx, DWORD PTR _PartyNumber$[ebp]
  00397	e9 9f fe ff ff	 jmp	 $LN13@DGAnsParty
$LN6@DGAnsParty:

; 1427 : 		gObj[TargetIndex].Connected != PLAYER_PLAYING )
; 1428 : 	{
; 1429 : 		::GCServerMsgStringSend("Target user not in game", UserIndex, 1);

  0039c	6a 01		 push	 1
  0039e	57		 push	 edi
  0039f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MEOHNEFK@Target?5user?5not?5in?5game?$AA@
  003a4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ac	5e		 pop	 esi
  003ad	5b		 pop	 ebx
$LN3@DGAnsParty:

; 1497 : }

  003ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b1	33 cd		 xor	 ecx, ebp
  003b3	5f		 pop	 edi
  003b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b9	8b e5		 mov	 esp, ebp
  003bb	5d		 pop	 ebp
  003bc	c3		 ret	 0
?DGAnsPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_DGANS_REQUESTANSWER@@@Z ENDP ; DGAnsPartyMatchRequestAnswer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?DGAnsPartyMatchAcceptList@@YAXPAE@Z
_TEXT	SEGMENT
_lpData$GSCopy$1$ = -1316				; size = 4
tv375 = -1312						; size = 4
tv377 = -1308						; size = 4
tv378 = -1304						; size = 4
_lpAnswer$ = -1300					; size = 1296
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?DGAnsPartyMatchAcceptList@@YAXPAE@Z PROC		; DGAnsPartyMatchAcceptList, COMDAT

; 1282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 05 00
	00		 sub	 esp, 1316		; 00000524H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpData$[ebp]
  00017	89 9d dc fa ff
	ff		 mov	 DWORD PTR _lpData$GSCopy$1$[ebp], ebx

; 1283 : 	GUILDMATCH_DGANS_REQUESTLIST_COUNT* lpRecvCount = (GUILDMATCH_DGANS_REQUESTLIST_COUNT*)lpData;
; 1284 : 	// ----
; 1285 : 	if(		!OBJMAX_RANGE(lpRecvCount->UserIndex) 
; 1286 : 		||	gObj[lpRecvCount->UserIndex].Connected != PLAYER_PLAYING )

  0001d	8b 4b 05	 mov	 ecx, DWORD PTR [ebx+5]
  00020	85 c9		 test	 ecx, ecx
  00022	0f 88 3b 01 00
	00		 js	 $LN6@DGAnsParty
  00028	33 c0		 xor	 eax, eax
  0002a	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	0f 84 28 01 00
	00		 je	 $LN6@DGAnsParty
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  00046	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0004b	0f 85 12 01 00
	00		 jne	 $LN6@DGAnsParty

; 1287 : 	{
; 1288 : 		return;
; 1289 : 	}
; 1290 : 	// ----
; 1291 : 	GUILDMATCH_GCANS_REQUESTLIST_COUNT lpAnswer = { 0 };

  00051	57		 push	 edi
  00052	68 0f 05 00 00	 push	 1295			; 0000050fH
  00057	8d 85 ed fa ff
	ff		 lea	 eax, DWORD PTR _lpAnswer$[ebp+1]
  0005d	6a 00		 push	 0
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _memset

; 1292 : 	lpAnswer.h.c			= 0xC2;
; 1293 : 	lpAnswer.h.headcode		= 0xEF;
; 1294 : 	lpAnswer.h.subcode		= 0x04;
; 1295 : 	lpAnswer.h.sizeH		= SET_NUMBERH(sizeof(lpAnswer));
; 1296 : 	lpAnswer.h.sizeL		= SET_NUMBERL(sizeof(lpAnswer));
; 1297 : 	lpAnswer.RequestCount	= lpRecvCount->Count;

  00065	8b 43 09	 mov	 eax, DWORD PTR [ebx+9]

; 1298 : 	// ----
; 1299 : 	GUILDMATCH_DGANS_REQUESTLIST_INFO* lpRecvInfo = (GUILDMATCH_DGANS_REQUESTLIST_INFO*)&lpData[sizeof(GUILDMATCH_DGANS_REQUESTLIST_COUNT)];

  00068	8d 4b 0d	 lea	 ecx, DWORD PTR [ebx+13]
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	66 c7 85 ec fa
	ff ff c2 05	 mov	 WORD PTR _lpAnswer$[ebp], 1474 ; 000005c2H

; 1300 : 	// ----
; 1301 : 	for( int i = 0; i < lpAnswer.RequestCount; i++ )

  00077	33 ff		 xor	 edi, edi
  00079	66 c7 85 ef fa
	ff ff ef 04	 mov	 WORD PTR _lpAnswer$[ebp+3], 1263 ; 000004efH
  00082	c6 85 ee fa ff
	ff 10		 mov	 BYTE PTR _lpAnswer$[ebp+2], 16 ; 00000010H
  00089	89 85 f4 fa ff
	ff		 mov	 DWORD PTR _lpAnswer$[ebp+8], eax
  0008f	85 c0		 test	 eax, eax
  00091	0f 8e b4 00 00
	00		 jle	 $LN3@DGAnsParty
  00097	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _lpAnswer$[ebp+4]
  0009d	2b c1		 sub	 eax, ecx
  0009f	89 85 e8 fa ff
	ff		 mov	 DWORD PTR tv378[ebp], eax
  000a5	8d 85 fb fa ff
	ff		 lea	 eax, DWORD PTR _lpAnswer$[ebp+15]
  000ab	2b c1		 sub	 eax, ecx
  000ad	89 85 e4 fa ff
	ff		 mov	 DWORD PTR tv377[ebp], eax
  000b3	8d 85 fc fa ff
	ff		 lea	 eax, DWORD PTR _lpAnswer$[ebp+16]
  000b9	2b c1		 sub	 eax, ecx
  000bb	56		 push	 esi
  000bc	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
  000bf	89 85 e0 fa ff
	ff		 mov	 DWORD PTR tv375[ebp], eax
$LL4@DGAnsParty:

; 1302 : 	{
; 1303 : 		int UserIndex = gObjGetIndex(lpRecvInfo[i].Character);

  000c5	8d 5e f4	 lea	 ebx, DWORD PTR [esi-12]
  000c8	53		 push	 ebx
  000c9	e8 00 00 00 00	 call	 ?gObjGetIndex@@YAHPAD@Z	; gObjGetIndex
  000ce	83 c4 04	 add	 esp, 4

; 1304 : 		// ----
; 1305 : 		if(		!OBJMAX_RANGE(UserIndex) 
; 1306 : 			||	gObj[UserIndex].Connected != PLAYER_PLAYING )

  000d1	85 c0		 test	 eax, eax
  000d3	78 5a		 js	 SHORT $LN8@DGAnsParty
  000d5	33 c9		 xor	 ecx, ecx
  000d7	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  000dc	0f 9e c1	 setle	 cl
  000df	85 c9		 test	 ecx, ecx
  000e1	74 4c		 je	 SHORT $LN8@DGAnsParty
  000e3	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000f3	75 3a		 jne	 SHORT $LN8@DGAnsParty

; 1309 : 			continue;
; 1310 : 		}
; 1311 : 		// ----
; 1312 : 		memcpy(lpAnswer.m_RequestList[i].Character, lpRecvInfo[i].Character, 10);

  000f5	8b 8d e8 fa ff
	ff		 mov	 ecx, DWORD PTR tv378[ebp]
  000fb	66 8b 43 08	 mov	 ax, WORD PTR [ebx+8]
  000ff	f3 0f 7e 03	 movq	 xmm0, QWORD PTR [ebx]
  00103	66 0f d6 04 31	 movq	 QWORD PTR [ecx+esi], xmm0
  00108	66 89 44 31 08	 mov	 WORD PTR [ecx+esi+8], ax

; 1313 : 		lpAnswer.m_RequestList[i].Class = lpRecvInfo[i].Class / 16; //wrong...

  0010d	8b 8d e4 fa ff
	ff		 mov	 ecx, DWORD PTR tv377[ebp]
  00113	8a 46 ff	 mov	 al, BYTE PTR [esi-1]
  00116	c0 e8 04	 shr	 al, 4
  00119	88 04 31	 mov	 BYTE PTR [ecx+esi], al

; 1314 : 		lpAnswer.m_RequestList[i].Level = lpRecvInfo[i].Level;

  0011c	8b 8d e0 fa ff
	ff		 mov	 ecx, DWORD PTR tv375[ebp]
  00122	8b 06		 mov	 eax, DWORD PTR [esi]
  00124	89 04 31	 mov	 DWORD PTR [ecx+esi], eax

; 1315 : 	}

  00127	8b 85 f4 fa ff
	ff		 mov	 eax, DWORD PTR _lpAnswer$[ebp+8]
  0012d	eb 0d		 jmp	 SHORT $LN2@DGAnsParty
$LN8@DGAnsParty:

; 1307 : 		{
; 1308 : 			lpAnswer.RequestCount--;

  0012f	8b 85 f4 fa ff
	ff		 mov	 eax, DWORD PTR _lpAnswer$[ebp+8]
  00135	48		 dec	 eax
  00136	89 85 f4 fa ff
	ff		 mov	 DWORD PTR _lpAnswer$[ebp+8], eax
$LN2@DGAnsParty:

; 1300 : 	// ----
; 1301 : 	for( int i = 0; i < lpAnswer.RequestCount; i++ )

  0013c	47		 inc	 edi
  0013d	83 c6 10	 add	 esi, 16			; 00000010H
  00140	3b f8		 cmp	 edi, eax
  00142	7c 81		 jl	 SHORT $LL4@DGAnsParty
  00144	8b 9d dc fa ff
	ff		 mov	 ebx, DWORD PTR _lpData$GSCopy$1$[ebp]
  0014a	5e		 pop	 esi
$LN3@DGAnsParty:

; 1316 : 	// ----
; 1317 : 	DataSend(lpRecvCount->UserIndex, (LPBYTE)&lpAnswer, sizeof(lpAnswer));

  0014b	68 10 05 00 00	 push	 1296			; 00000510H
  00150	8d 85 ec fa ff
	ff		 lea	 eax, DWORD PTR _lpAnswer$[ebp]
  00156	50		 push	 eax
  00157	ff 73 05	 push	 DWORD PTR [ebx+5]
  0015a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00162	5f		 pop	 edi
$LN6@DGAnsParty:

; 1318 : }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	5b		 pop	 ebx
  00169	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
?DGAnsPartyMatchAcceptList@@YAXPAE@Z ENDP		; DGAnsPartyMatchAcceptList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?DGAnsPartyMatchCancel@@YAXPAUPMSG_PARTYMATCHING_CANCEL_ANS@@@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsPartyMatchCancel@@YAXPAUPMSG_PARTYMATCHING_CANCEL_ANS@@@Z PROC ; DGAnsPartyMatchCancel, COMDAT

; 1225 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi

; 1226 : 	int aIndex = lpMsg->aIndex;

  00015	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 1227 : 
; 1228 : 	if( !gObjIsConnected(aIndex) )

  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 28		 jne	 SHORT $LN4@DGAnsParty

; 1229 : 	{
; 1230 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00025	68 ce 04 00 00	 push	 1230			; 000004ceH
$LN15@DGAnsParty:
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 1261 : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN4@DGAnsParty:

; 1231 : 		return;
; 1232 : 	}
; 1233 : 
; 1234 : 	if( strcmp(gObj[aIndex].Name,lpMsg->szName) )

  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  00055	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  0005b	83 c0 5d	 add	 eax, 93			; 0000005dH
  0005e	03 c1		 add	 eax, ecx
$LL11@DGAnsParty:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	3a 0a		 cmp	 cl, BYTE PTR [edx]
  00064	75 1a		 jne	 SHORT $LN12@DGAnsParty
  00066	84 c9		 test	 cl, cl
  00068	74 12		 je	 SHORT $LN13@DGAnsParty
  0006a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0006d	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00070	75 0e		 jne	 SHORT $LN12@DGAnsParty
  00072	83 c0 02	 add	 eax, 2
  00075	83 c2 02	 add	 edx, 2
  00078	84 c9		 test	 cl, cl
  0007a	75 e4		 jne	 SHORT $LL11@DGAnsParty
$LN13@DGAnsParty:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN14@DGAnsParty
$LN12@DGAnsParty:
  00080	1b c0		 sbb	 eax, eax
  00082	83 c8 01	 or	 eax, 1
$LN14@DGAnsParty:
  00085	85 c0		 test	 eax, eax
  00087	74 07		 je	 SHORT $LN5@DGAnsParty

; 1235 : 	{
; 1236 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00089	68 d4 04 00 00	 push	 1236			; 000004d4H

; 1237 : 		return;

  0008e	eb 9a		 jmp	 SHORT $LN15@DGAnsParty
$LN5@DGAnsParty:

; 1238 : 	}
; 1239 : 
; 1240 : 	switch( lpMsg->iResult )
; 1241 : 	{
; 1242 : 	case 0:
; 1243 : 	case 1:
; 1244 : 		if( lpMsg->btType == 0 )
; 1245 : 		{
; 1246 : 		}
; 1247 : 		else if( lpMsg->btType == 1 )
; 1248 : 		{
; 1249 : //			gObj[aIndex].m_bIsPartyWaiting = FALSE;
; 1250 : 		}
; 1251 : 		break;
; 1252 : 	}
; 1253 : 
; 1254 : 	PMSG_PARTYMATCH_CANCEL_ANS pMsg;
; 1255 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x06,sizeof(pMsg));

  00090	6a 0c		 push	 12			; 0000000cH
  00092	6a 06		 push	 6
  00094	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00097	68 ef 00 00 00	 push	 239			; 000000efH
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1256 : 
; 1257 : 	pMsg.Type = lpMsg->btType;

  000a2	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  000a6	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 1258 : 	pMsg.Result = lpMsg->iResult;

  000a9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000ac	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 1259 : 
; 1260 : 	DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  000af	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000b2	6a 0c		 push	 12			; 0000000cH
  000b4	50		 push	 eax
  000b5	57		 push	 edi
  000b6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1261 : }

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c1	33 cd		 xor	 ecx, ebp
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?DGAnsPartyMatchCancel@@YAXPAUPMSG_PARTYMATCHING_CANCEL_ANS@@@Z ENDP ; DGAnsPartyMatchCancel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?DGAnsPartyMatchWaitlist@@YAXPAUPMSG_PARTYMATCHING_WAIT_ANS@@@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsPartyMatchWaitlist@@YAXPAUPMSG_PARTYMATCHING_WAIT_ANS@@@Z PROC ; DGAnsPartyMatchWaitlist, COMDAT

; 1193 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi

; 1194 : 	int aIndex = lpMsg->aIndex;

  00015	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 1195 : 
; 1196 : 	if( !gObjIsConnected(aIndex) )

  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 28		 jne	 SHORT $LN2@DGAnsParty

; 1197 : 	{
; 1198 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00025	68 ae 04 00 00	 push	 1198			; 000004aeH
$LN10@DGAnsParty:
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 1222 : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN2@DGAnsParty:

; 1199 : 		return;
; 1200 : 	}
; 1201 : 
; 1202 : 	if( strcmp(gObj[aIndex].Name,lpMsg->szName) )

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00056	69 d7 40 27 00
	00		 imul	 edx, edi, 10048
  0005c	83 c1 5d	 add	 ecx, 93			; 0000005dH
  0005f	03 ca		 add	 ecx, edx
$LL6@DGAnsParty:
  00061	8a 11		 mov	 dl, BYTE PTR [ecx]
  00063	3a 10		 cmp	 dl, BYTE PTR [eax]
  00065	75 1a		 jne	 SHORT $LN7@DGAnsParty
  00067	84 d2		 test	 dl, dl
  00069	74 12		 je	 SHORT $LN8@DGAnsParty
  0006b	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0006e	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00071	75 0e		 jne	 SHORT $LN7@DGAnsParty
  00073	83 c1 02	 add	 ecx, 2
  00076	83 c0 02	 add	 eax, 2
  00079	84 d2		 test	 dl, dl
  0007b	75 e4		 jne	 SHORT $LL6@DGAnsParty
$LN8@DGAnsParty:
  0007d	33 c0		 xor	 eax, eax
  0007f	eb 05		 jmp	 SHORT $LN9@DGAnsParty
$LN7@DGAnsParty:
  00081	1b c0		 sbb	 eax, eax
  00083	83 c8 01	 or	 eax, 1
$LN9@DGAnsParty:
  00086	85 c0		 test	 eax, eax
  00088	74 07		 je	 SHORT $LN3@DGAnsParty

; 1203 : 	{
; 1204 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  0008a	68 b4 04 00 00	 push	 1204			; 000004b4H

; 1205 : 		return;

  0008f	eb 99		 jmp	 SHORT $LN10@DGAnsParty
$LN3@DGAnsParty:

; 1206 : 	}
; 1207 : 
; 1208 : 	if( lpMsg->iResult == (int)-1 )

  00091	83 7e 14 ff	 cmp	 DWORD PTR [esi+20], -1
  00095	74 4f		 je	 SHORT $LN1@DGAnsParty

; 1209 : 	{
; 1210 : 		return;
; 1211 : 	}
; 1212 : 
; 1213 : 	PMSG_PARTYMATCH_WAIT_ANS pMsg;
; 1214 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x03,sizeof(pMsg));

  00097	6a 18		 push	 24			; 00000018H
  00099	6a 03		 push	 3
  0009b	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009e	68 ef 00 00 00	 push	 239			; 000000efH
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1215 : 
; 1216 : 	pMsg.iResult = lpMsg->iResult;

  000a9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 1217 : 	pMsg.iServerCode = lpMsg->ServerCode % 20 + 1;

  000ac	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  000b1	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  000b4	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000b7	99		 cdq
  000b8	f7 f9		 idiv	 ecx

; 1218 : 	memcpy(pMsg.szPartyLeader,lpMsg->szPartyLeader,sizeof(pMsg.szPartyLeader)-1);

  000ba	66 8b 46 20	 mov	 ax, WORD PTR [esi+32]
  000be	f3 0f 7e 46 18	 movq	 xmm0, QWORD PTR [esi+24]
  000c3	42		 inc	 edx
  000c4	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 1219 : 	pMsg.szPartyLeader[sizeof(pMsg.szPartyLeader)-1] = '\0';
; 1220 : 
; 1221 : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000c8	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000cc	50		 push	 eax
  000cd	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000d0	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  000d3	50		 push	 eax
  000d4	57		 push	 edi
  000d5	66 0f d6 45 f0	 movq	 QWORD PTR _pMsg$[ebp+12], xmm0
  000da	c6 45 fa 00	 mov	 BYTE PTR _pMsg$[ebp+22], 0
  000de	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e3	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@DGAnsParty:

; 1222 : }

  000e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e9	5f		 pop	 edi
  000ea	33 cd		 xor	 ecx, ebp
  000ec	5e		 pop	 esi
  000ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
?DGAnsPartyMatchWaitlist@@YAXPAUPMSG_PARTYMATCHING_WAIT_ANS@@@Z ENDP ; DGAnsPartyMatchWaitlist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?DGAnsPartyMatchJoin@@YAXPAUPMSG_PARTYMATCHING_JOIN_ANS@@@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 8
_lpNotification$1 = -8					; size = 8
_aIndex$1$ = 8						; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsPartyMatchJoin@@YAXPAUPMSG_PARTYMATCHING_JOIN_ANS@@@Z PROC ; DGAnsPartyMatchJoin, COMDAT

; 1148 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 1149 : 	int aIndex = lpMsg->aIndex;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0000a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1150 : 
; 1151 : 	if( !gObjIsConnected(aIndex) )

  0000d	50		 push	 eax
  0000e	89 45 08	 mov	 DWORD PTR _aIndex$1$[ebp], eax
  00011	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	75 1d		 jne	 SHORT $LN7@DGAnsParty

; 1152 : 	{
; 1153 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  0001d	68 81 04 00 00	 push	 1153			; 00000481H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1178 : 						break;
; 1179 : 					}
; 1180 : 				}
; 1181 : 			}
; 1182 : 		}
; 1183 : 		break;
; 1184 : //default:
; 1185 : //		gObj[aIndex].m_bIsPartyWaiting = FALSE;
; 1186 : //		break;
; 1187 : 	}
; 1188 : 
; 1189 : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	5b		 pop	 ebx

; 1190 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN7@DGAnsParty:

; 1154 : 		return;
; 1155 : 	}
; 1156 : 
; 1157 : 	PMSG_PARTYMATCH_JOIN_ANS pMsg;
; 1158 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x02,sizeof(pMsg));

  0003a	6a 08		 push	 8
  0003c	6a 02		 push	 2
  0003e	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00041	68 ef 00 00 00	 push	 239			; 000000efH
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1159 : 
; 1160 : 	pMsg.iResult = lpMsg->iResult;

  0004c	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 1161 : 
; 1162 : 	switch(pMsg.iResult)

  00055	85 c0		 test	 eax, eax
  00057	0f 85 87 00 00
	00		 jne	 $LN17@DGAnsParty

; 1163 : 	{
; 1164 : 	case 0:
; 1165 : 		{
; 1166 : 			for( int i = OBJ_STARTUSERINDEX; i < OBJMAX; i++ )

  0005d	56		 push	 esi
  0005e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	57		 push	 edi
  00065	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0006a	81 c6 5d dd 49
	06		 add	 esi, 105504093		; 0649dd5dH
$LL6@DGAnsParty:

; 1167 : 			{
; 1168 : 				if( gObj[i].Name != NULL && !strcmp(lpMsg->szName, gObj[i].Name) )

  00070	85 f6		 test	 esi, esi
  00072	74 3b		 je	 SHORT $LN4@DGAnsParty
  00074	8b c6		 mov	 eax, esi
  00076	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@DGAnsParty:
  00080	8a 11		 mov	 dl, BYTE PTR [ecx]
  00082	3a 10		 cmp	 dl, BYTE PTR [eax]
  00084	75 1a		 jne	 SHORT $LN19@DGAnsParty
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN20@DGAnsParty
  0008a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0008d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00090	75 0e		 jne	 SHORT $LN19@DGAnsParty
  00092	83 c1 02	 add	 ecx, 2
  00095	83 c0 02	 add	 eax, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL18@DGAnsParty
$LN20@DGAnsParty:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN21@DGAnsParty
$LN19@DGAnsParty:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 c8 01	 or	 eax, 1
$LN21@DGAnsParty:
  000a5	85 c0		 test	 eax, eax
  000a7	75 06		 jne	 SHORT $LN4@DGAnsParty

; 1169 : 				{
; 1170 : 					if( gObj[i].Connected == PLAYER_PLAYING )

  000a9	83 7e a7 03	 cmp	 DWORD PTR [esi-89], 3
  000ad	74 11		 je	 SHORT $LN13@DGAnsParty
$LN4@DGAnsParty:

; 1163 : 	{
; 1164 : 	case 0:
; 1165 : 		{
; 1166 : 			for( int i = OBJ_STARTUSERINDEX; i < OBJMAX; i++ )

  000af	47		 inc	 edi
  000b0	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  000b6	81 ff ec 2c 00
	00		 cmp	 edi, 11500		; 00002cecH
  000bc	7c b2		 jl	 SHORT $LL6@DGAnsParty
  000be	eb 22		 jmp	 SHORT $LN22@DGAnsParty
$LN13@DGAnsParty:

; 1171 : 					{
; 1172 : 						PARTYMATCH_GCSET_JOINNOTIFICATION lpNotification = { 0 };

  000c0	33 c0		 xor	 eax, eax
  000c2	89 45 f9	 mov	 DWORD PTR _lpNotification$1[ebp+1], eax
  000c5	66 89 45 fd	 mov	 WORD PTR _lpNotification$1[ebp+5], ax
  000c9	88 45 ff	 mov	 BYTE PTR _lpNotification$1[ebp+7], al

; 1173 : 						lpNotification.h.c			= 0xC1;
; 1174 : 						lpNotification.h.headcode	= 0xEF;
; 1175 : 						lpNotification.h.subcode	= 0x8;
; 1176 : 						lpNotification.h.size		= sizeof(PARTYMATCH_GCSET_JOINNOTIFICATION);
; 1177 : 						DataSend(i, (LPBYTE)&lpNotification, sizeof(PARTYMATCH_GCSET_JOINNOTIFICATION));

  000cc	8d 45 f8	 lea	 eax, DWORD PTR _lpNotification$1[ebp]
  000cf	6a 08		 push	 8
  000d1	50		 push	 eax
  000d2	57		 push	 edi
  000d3	c7 45 f8 c1 08
	ef 08		 mov	 DWORD PTR _lpNotification$1[ebp], 149883073 ; 08ef08c1H
  000da	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@DGAnsParty:
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
$LN17@DGAnsParty:

; 1178 : 						break;
; 1179 : 					}
; 1180 : 				}
; 1181 : 			}
; 1182 : 		}
; 1183 : 		break;
; 1184 : //default:
; 1185 : //		gObj[aIndex].m_bIsPartyWaiting = FALSE;
; 1186 : //		break;
; 1187 : 	}
; 1188 : 
; 1189 : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000e4	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000e8	50		 push	 eax
  000e9	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ec	50		 push	 eax
  000ed	ff 75 08	 push	 DWORD PTR _aIndex$1$[ebp]
  000f0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	5b		 pop	 ebx

; 1190 : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
?DGAnsPartyMatchJoin@@YAXPAUPMSG_PARTYMATCHING_JOIN_ANS@@@Z ENDP ; DGAnsPartyMatchJoin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?DGAnsPartyMatchInfo@@YAXPAE@Z
_TEXT	SEGMENT
_aIndex$1$ = -1036					; size = 4
tv1216 = -1032						; size = 4
_cBUFFER$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsPartyMatchInfo@@YAXPAE@Z PROC			; DGAnsPartyMatchInfo, COMDAT

; 1076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 1077 : 
; 1078 : 	if( lpMsg == NULL )

  00017	85 f6		 test	 esi, esi
  00019	75 27		 jne	 SHORT $LN5@DGAnsParty

; 1079 : 	{
; 1080 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  0001b	68 38 04 00 00	 push	 1080			; 00000438H
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	5e		 pop	 esi

; 1145 : }

  00034	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00037	33 cd		 xor	 ecx, ebp
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN5@DGAnsParty:
  00042	57		 push	 edi

; 1081 : 		return;
; 1082 : 	}
; 1083 : 
; 1084 : 	LPMSG_PARTYMATCHING_INFO_ANS lpMsgCount = (LPMSG_PARTYMATCHING_INFO_ANS)&lpMsg[0];
; 1085 : 	PARTYMATCH_INFO* lpMsgBody = (PARTYMATCH_INFO*)&lpMsg[sizeof(PMSG_PARTYMATCHING_INFO_ANS)];
; 1086 : 
; 1087 : 	int aIndex = lpMsgCount->aIndex;

  00043	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1088 : 
; 1089 : 	if( !gObjIsConnected(aIndex) )

  00046	57		 push	 edi
  00047	89 bd f4 fb ff
	ff		 mov	 DWORD PTR _aIndex$1$[ebp], edi
  0004d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00052	83 c4 04	 add	 esp, 4
  00055	85 c0		 test	 eax, eax
  00057	75 07		 jne	 SHORT $LN6@DGAnsParty

; 1090 : 	{
; 1091 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00059	68 43 04 00 00	 push	 1091			; 00000443H

; 1092 : 		return;

  0005e	eb 42		 jmp	 SHORT $LN19@DGAnsParty
$LN6@DGAnsParty:

; 1093 : 	}
; 1094 : 
; 1095 : 	if( strcmp(gObj[aIndex].Name,lpMsgCount->szName) )

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00069	69 d7 40 27 00
	00		 imul	 edx, edi, 10048
  0006f	83 c1 5d	 add	 ecx, 93			; 0000005dH
  00072	03 ca		 add	 ecx, edx
$LL14@DGAnsParty:
  00074	8a 11		 mov	 dl, BYTE PTR [ecx]
  00076	3a 10		 cmp	 dl, BYTE PTR [eax]
  00078	75 1a		 jne	 SHORT $LN15@DGAnsParty
  0007a	84 d2		 test	 dl, dl
  0007c	74 12		 je	 SHORT $LN16@DGAnsParty
  0007e	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00081	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00084	75 0e		 jne	 SHORT $LN15@DGAnsParty
  00086	83 c1 02	 add	 ecx, 2
  00089	83 c0 02	 add	 eax, 2
  0008c	84 d2		 test	 dl, dl
  0008e	75 e4		 jne	 SHORT $LL14@DGAnsParty
$LN16@DGAnsParty:
  00090	33 c0		 xor	 eax, eax
  00092	eb 05		 jmp	 SHORT $LN17@DGAnsParty
$LN15@DGAnsParty:
  00094	1b c0		 sbb	 eax, eax
  00096	83 c8 01	 or	 eax, 1
$LN17@DGAnsParty:
  00099	85 c0		 test	 eax, eax
  0009b	74 28		 je	 SHORT $LN7@DGAnsParty

; 1096 : 	{
; 1097 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  0009d	68 49 04 00 00	 push	 1097			; 00000449H
$LN19@DGAnsParty:
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi

; 1145 : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN7@DGAnsParty:
  000c5	53		 push	 ebx

; 1098 : 		return;
; 1099 : 	}
; 1100 : 
; 1101 : 	BYTE cBUFFER[1024];
; 1102 : 	int lOfs = sizeof(PMSG_PARTYMATCH_COUNT);

  000c6	bb 18 00 00 00	 mov	 ebx, 24			; 00000018H

; 1103 : 
; 1104 : 	PMSG_PARTYMATCH_COUNT* pMsgCount = (PMSG_PARTYMATCH_COUNT*)&cBUFFER[0];
; 1105 : 	PMSG_PARTYMATCH_INFO* pMsgBody = (PMSG_PARTYMATCH_INFO*)&cBUFFER[lOfs];
; 1106 : 
; 1107 : 	PHeadSubSetW((LPBYTE)pMsgCount,0xEF,0x01,lOfs);

  000cb	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  000d1	53		 push	 ebx
  000d2	6a 01		 push	 1
  000d4	68 ef 00 00 00	 push	 239			; 000000efH
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?PHeadSubSetW@@YAXPAEEEH@Z ; PHeadSubSetW

; 1108 : 
; 1109 : 	pMsgCount->count = lpMsgCount->count;
; 1110 : 	pMsgCount->curpage = lpMsgCount->page;

  000df	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
  000e5	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000e8	89 85 08 fc ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+12], eax

; 1111 : 	pMsgCount->totalpage = lpMsgCount->totalpage;

  000ee	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000f1	89 85 0c fc ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+16], eax

; 1112 : 	pMsgCount->result = lpMsgCount->iResult;

  000f7	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000fa	89 8d 04 fc ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], ecx
  00100	89 85 10 fc ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+20], eax

; 1113 : 
; 1114 : 	if( pMsgCount->result == 0 )

  00106	85 c0		 test	 eax, eax
  00108	0f 85 d6 00 00
	00		 jne	 $LN8@DGAnsParty

; 1115 : 	{
; 1116 : 		for(int i = 0; i < pMsgCount->count; i++)

  0010e	85 c9		 test	 ecx, ecx
  00110	0f 8e bd 00 00
	00		 jle	 $LN3@DGAnsParty
  00116	83 c6 64	 add	 esi, 100		; 00000064H
  00119	c7 85 f8 fb ff
	ff 14 00 00 00	 mov	 DWORD PTR tv1216[ebp], 20 ; 00000014H
  00123	8d 8d 1f fc ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER$[ebp+35]
  00129	33 ff		 xor	 edi, edi
  0012b	0f 1f 44 00 00	 npad	 5
$LL4@DGAnsParty:

; 1117 : 		{
; 1118 : 			memcpy(pMsgBody[i].szName,lpMsgBody[i].szLeader,sizeof(pMsgBody[i].szName)-1);

  00130	f3 0f 7e 46 c4	 movq	 xmm0, QWORD PTR [esi-60]
  00135	8d 76 44	 lea	 esi, DWORD PTR [esi+68]
  00138	0f b7 46 88	 movzx	 eax, WORD PTR [esi-120]
  0013c	8d 49 54	 lea	 ecx, DWORD PTR [ecx+84]
  0013f	66 0f d6 41 a1	 movq	 QWORD PTR [ecx-95], xmm0
  00144	47		 inc	 edi

; 1119 : 			pMsgBody[i].szName[sizeof(pMsgBody[i].szName)-1] = '\0';
; 1120 : 
; 1121 : 			memcpy(pMsgBody[i].szDescription,lpMsgBody[i].szDescription,sizeof(pMsgBody[i].szDescription)-1);

  00145	0f 10 46 8b	 movups	 xmm0, XMMWORD PTR [esi-117]
  00149	66 89 41 a9	 mov	 WORD PTR [ecx-87], ax

; 1122 : 			pMsgBody[i].szDescription[sizeof(pMsgBody[i].szDescription)-1] = '\0';
; 1123 : 
; 1124 : 			pMsgBody[i].MinLevel = lpMsgBody[i].MinLevel;
; 1125 : 			pMsgBody[i].MaxLevel = lpMsgBody[i].MaxLevel;
; 1126 : 
; 1127 : 			pMsgBody[i].MoveReqId = lpMsgBody[i].MoveReqId; // movereqid
; 1128 : 			pMsgBody[i].LeaderLevel = lpMsgBody[i].LeaderLevel; // leaderlevel
; 1129 : 			pMsgBody[i].Channel = lpMsgBody[i].LeaderChannel % 20 + 1;	// channel
; 1130 : 			pMsgBody[i].Gens = lpMsgBody[i].Gens;
; 1131 : 			pMsgBody[i].PartyCount = lpMsgBody[i].btPartyCount; // party members
; 1132 : 
; 1133 : 			pMsgBody[i].LeaderClass = lpMsgBody[i].LeaderClass/16;
; 1134 : 			pMsgBody[i].Class = lpMsgBody[i].btClass;
; 1135 : 			pMsgBody[i].IsProtected = lpMsgBody[i].btIsPassword;
; 1136 : 
; 1137 : 			lOfs += sizeof(PMSG_PARTYMATCH_INFO);

  0014d	83 c3 54	 add	 ebx, 84			; 00000054H
  00150	0f b7 46 bc	 movzx	 eax, WORD PTR [esi-68]
  00154	c6 41 ab 00	 mov	 BYTE PTR [ecx-85], 0
  00158	0f 11 41 ac	 movups	 XMMWORD PTR [ecx-84], xmm0
  0015c	0f 10 46 9b	 movups	 xmm0, XMMWORD PTR [esi-101]
  00160	0f 11 41 bc	 movups	 XMMWORD PTR [ecx-68], xmm0
  00164	f3 0f 7e 46 ab	 movq	 xmm0, QWORD PTR [esi-85]
  00169	66 0f d6 41 cc	 movq	 QWORD PTR [ecx-52], xmm0
  0016e	c6 41 d4 00	 mov	 BYTE PTR [ecx-44], 0
  00172	66 89 41 d5	 mov	 WORD PTR [ecx-43], ax
  00176	0f b7 46 be	 movzx	 eax, WORD PTR [esi-66]
  0017a	66 89 41 d7	 mov	 WORD PTR [ecx-41], ax
  0017e	0f bf 46 c0	 movsx	 eax, WORD PTR [esi-64]
  00182	89 41 d9	 mov	 DWORD PTR [ecx-39], eax
  00185	0f bf 46 b4	 movsx	 eax, WORD PTR [esi-76]
  00189	89 41 dd	 mov	 DWORD PTR [ecx-35], eax
  0018c	0f b6 46 b7	 movzx	 eax, BYTE PTR [esi-73]
  00190	99		 cdq
  00191	f7 bd f8 fb ff
	ff		 idiv	 DWORD PTR tv1216[ebp]
  00197	0f b6 46 c2	 movzx	 eax, BYTE PTR [esi-62]
  0019b	88 41 f1	 mov	 BYTE PTR [ecx-15], al
  0019e	42		 inc	 edx
  0019f	0f b6 46 b8	 movzx	 eax, BYTE PTR [esi-72]
  001a3	88 41 e3	 mov	 BYTE PTR [ecx-29], al
  001a6	0f b6 46 b6	 movzx	 eax, BYTE PTR [esi-74]
  001aa	c0 e8 04	 shr	 al, 4
  001ad	88 41 e1	 mov	 BYTE PTR [ecx-31], al
  001b0	0f b6 46 ba	 movzx	 eax, BYTE PTR [esi-70]
  001b4	88 41 e2	 mov	 BYTE PTR [ecx-30], al
  001b7	0f b6 46 b9	 movzx	 eax, BYTE PTR [esi-71]
  001bb	89 51 ed	 mov	 DWORD PTR [ecx-19], edx
  001be	88 41 e4	 mov	 BYTE PTR [ecx-28], al
  001c1	3b bd 04 fc ff
	ff		 cmp	 edi, DWORD PTR _cBUFFER$[ebp+8]
  001c7	0f 8c 63 ff ff
	ff		 jl	 $LL4@DGAnsParty
  001cd	8b bd f4 fb ff
	ff		 mov	 edi, DWORD PTR _aIndex$1$[ebp]
$LN3@DGAnsParty:

; 1138 : 		}
; 1139 : 
; 1140 : 		pMsgCount->h.sizeH = SET_NUMBERH(lOfs);

  001d3	8b c3		 mov	 eax, ebx

; 1141 : 		pMsgCount->h.sizeL = SET_NUMBERL(lOfs);

  001d5	88 9d fe fb ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], bl
  001db	c1 e8 08	 shr	 eax, 8
  001de	88 85 fd fb ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], al
$LN8@DGAnsParty:

; 1142 : 	}
; 1143 : 
; 1144 : 	DataSend(aIndex,(LPBYTE)&cBUFFER[0],lOfs);

  001e4	53		 push	 ebx
  001e5	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  001eb	50		 push	 eax
  001ec	57		 push	 edi
  001ed	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1145 : }

  001f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f8	33 cd		 xor	 ecx, ebp
  001fa	5b		 pop	 ebx
  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c3		 ret	 0
?DGAnsPartyMatchInfo@@YAXPAE@Z ENDP			; DGAnsPartyMatchInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?DGAnsPartyMatchReg@@YAXPAUPMSG_PARTYMATCHING_REG_ANS@@@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_lpMsg$ = 8						; size = 4
?DGAnsPartyMatchReg@@YAXPAUPMSG_PARTYMATCHING_REG_ANS@@@Z PROC ; DGAnsPartyMatchReg, COMDAT

; 1043 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1044 : 	int aIndex = lpMsg->aIndex;

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1045 : 
; 1046 : 	if( !gObjIsConnected(aIndex) )

  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	75 1e		 jne	 SHORT $LN4@DGAnsParty

; 1047 : 	{
; 1048 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  0001b	68 18 04 00 00	 push	 1048			; 00000418H
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 1072 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN4@DGAnsParty:
  00039	53		 push	 ebx

; 1049 : 		return;
; 1050 : 	}
; 1051 : 
; 1052 : 	if( strcmp(gObj[aIndex].Name,lpMsg->szName) )

  0003a	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  00040	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00043	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  0004c	0f 1f 40 00	 npad	 4
$LL9@DGAnsParty:
  00050	8a 10		 mov	 dl, BYTE PTR [eax]
  00052	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00054	75 1a		 jne	 SHORT $LN10@DGAnsParty
  00056	84 d2		 test	 dl, dl
  00058	74 12		 je	 SHORT $LN11@DGAnsParty
  0005a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0005d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00060	75 0e		 jne	 SHORT $LN10@DGAnsParty
  00062	83 c0 02	 add	 eax, 2
  00065	83 c1 02	 add	 ecx, 2
  00068	84 d2		 test	 dl, dl
  0006a	75 e4		 jne	 SHORT $LL9@DGAnsParty
$LN11@DGAnsParty:
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 05		 jmp	 SHORT $LN12@DGAnsParty
$LN10@DGAnsParty:
  00070	1b c0		 sbb	 eax, eax
  00072	83 c8 01	 or	 eax, 1
$LN12@DGAnsParty:
  00075	85 c0		 test	 eax, eax
  00077	74 1f		 je	 SHORT $LN5@DGAnsParty

; 1053 : 	{
; 1054 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00079	68 1e 04 00 00	 push	 1054			; 0000041eH
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	5b		 pop	 ebx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi

; 1072 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
$LN5@DGAnsParty:

; 1055 : 		return;
; 1056 : 	}
; 1057 : 
; 1058 : 	switch(lpMsg->iResult)

  00098	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0009c	74 07		 je	 SHORT $LN6@DGAnsParty

; 1059 : 	{
; 1060 : 	case 0:
; 1061 : 		break;
; 1062 : 	default:
; 1063 : 		gObj[aIndex].m_bIsPartyMatch = FALSE;

  0009e	c6 83 cd 26 00
	00 00		 mov	 BYTE PTR [ebx+9933], 0
$LN6@DGAnsParty:

; 1064 : 		break;
; 1065 : 	}
; 1066 : 
; 1067 : 	PMSG_PARTYMATCH_REG_ANS pMsg;
; 1068 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x00,sizeof(pMsg));

  000a5	6a 08		 push	 8
  000a7	6a 00		 push	 0
  000a9	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ac	68 ef 00 00 00	 push	 239			; 000000efH
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1069 : 	pMsg.iResult = lpMsg->iResult;

  000b7	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ba	89 45 fc	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 1070 : 
; 1071 : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000bd	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000c1	50		 push	 eax
  000c2	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c5	50		 push	 eax
  000c6	57		 push	 edi
  000c7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000cc	83 c4 1c	 add	 esp, 28			; 0000001cH
  000cf	5b		 pop	 ebx
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi

; 1072 : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?DGAnsPartyMatchReg@@YAXPAUPMSG_PARTYMATCHING_REG_ANS@@@Z ENDP ; DGAnsPartyMatchReg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z
_TEXT	SEGMENT
_lpRequest$ = -28					; size = 23
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
_UserIndex$ = 12					; size = 4
?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z PROC ; CGReqPartyMatchRequestAnswer, COMDAT

; 1321 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _lpData$[ebp]
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _UserIndex$[ebp]

; 1322 : 	if(		!OBJMAX_RANGE(UserIndex) 
; 1323 : 		||	gObj[UserIndex].Connected != PLAYER_PLAYING )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 a5 02 00
	00		 js	 $LN3@CGReqParty
  0001f	33 c0		 xor	 eax, eax
  00021	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 92 02 00
	00		 je	 $LN3@CGReqParty
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	57		 push	 edi
  00038	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0003e	83 7c 07 04 03	 cmp	 DWORD PTR [edi+eax+4], 3
  00043	0f 85 7a 02 00
	00		 jne	 $LN54@CGReqParty

; 1324 : 	{
; 1325 : 		return;
; 1326 : 	}
; 1327 : 	// ----
; 1328 : 	PARTYMATCH_GDREQ_REQUESTANSWER lpRequest = { 0 };
; 1329 : 	lpRequest.h.c			= 0xC1;
; 1330 : 	lpRequest.h.headcode	= 0xEF;
; 1331 : 	lpRequest.h.subcode		= 0x05;
; 1332 : 	lpRequest.h.size		= sizeof(PARTYMATCH_GDREQ_REQUESTANSWER);
; 1333 : 	lpRequest.UserIndex		= UserIndex;
; 1334 : 	lpRequest.Type			= lpData->Result;

  00049	8b 4a 0f	 mov	 ecx, DWORD PTR [edx+15]
  0004c	0f 57 c0	 xorps	 xmm0, xmm0

; 1335 : 	memcpy(lpRequest.Character, lpData->Character, 10);

  0004f	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  00053	83 c2 04	 add	 edx, 4
  00056	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _lpRequest$[ebp+17], 0
  0005d	66 c7 45 f9 00
	00		 mov	 WORD PTR _lpRequest$[ebp+21], 0
  00063	89 4d f7	 mov	 DWORD PTR _lpRequest$[ebp+19], ecx
  00066	0f 11 45 e5	 movups	 XMMWORD PTR _lpRequest$[ebp+1], xmm0
  0006a	53		 push	 ebx
  0006b	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  0006f	c7 45 e4 c1 17
	ef 05		 mov	 DWORD PTR _lpRequest$[ebp], 99555265 ; 05ef17c1H
  00076	89 75 e8	 mov	 DWORD PTR _lpRequest$[ebp+4], esi
  00079	66 0f d6 45 ec	 movq	 QWORD PTR _lpRequest$[ebp+8], xmm0
  0007e	66 89 45 f4	 mov	 WORD PTR _lpRequest$[ebp+16], ax

; 1336 : 	// ----
; 1337 : 	if( lpData->Result == 1 ) //Accepted

  00082	83 f9 01	 cmp	 ecx, 1
  00085	0f 85 27 02 00
	00		 jne	 $LN20@CGReqParty

; 1338 : 	{
; 1339 : 		int TargetIndex = gObjGetIndex(lpData->Character);

  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 ?gObjGetIndex@@YAHPAD@Z	; gObjGetIndex
  00091	83 c4 04	 add	 esp, 4

; 1340 : 		// ----
; 1341 : 		if( !OBJMAX_RANGE(TargetIndex) ||

  00094	85 c0		 test	 eax, eax
  00096	0f 88 f5 01 00
	00		 js	 $LN6@CGReqParty
  0009c	33 c9		 xor	 ecx, ecx
  0009e	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  000a3	0f 9e c1	 setle	 cl
  000a6	85 c9		 test	 ecx, ecx
  000a8	0f 84 e3 01 00
	00		 je	 $LN6@CGReqParty
  000ae	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b4	69 d0 40 27 00
	00		 imul	 edx, eax, 10048
  000ba	03 d3		 add	 edx, ebx
  000bc	83 7a 04 03	 cmp	 DWORD PTR [edx+4], 3
  000c0	0f 85 cb 01 00
	00		 jne	 $LN6@CGReqParty

; 1345 : 			return;
; 1346 : 		}
; 1347 : 		// ----
; 1348 : 		LPOBJ lpTargetUser = &gObj[TargetIndex];
; 1349 : 		// ----
; 1350 : 		if( CC_MAP_RANGE(gObj[TargetIndex].MapNumber) 
; 1351 : 			|| CC_MAP_RANGE(gObj[TargetIndex].MapNumber)  )

  000c6	8a 8a 23 01 00
	00		 mov	 cl, BYTE PTR [edx+291]
  000cc	80 f9 35	 cmp	 cl, 53			; 00000035H
  000cf	0f 84 90 01 00
	00		 je	 $LN8@CGReqParty
  000d5	80 f9 12	 cmp	 cl, 18			; 00000012H
  000d8	72 23		 jb	 SHORT $LN47@CGReqParty
  000da	b0 17		 mov	 al, 23			; 00000017H
  000dc	3a c1		 cmp	 al, cl
  000de	1b c0		 sbb	 eax, eax
  000e0	83 c0 01	 add	 eax, 1
  000e3	0f 85 7c 01 00
	00		 jne	 $LN8@CGReqParty
  000e9	80 f9 12	 cmp	 cl, 18			; 00000012H
  000ec	72 0f		 jb	 SHORT $LN47@CGReqParty
  000ee	b0 17		 mov	 al, 23			; 00000017H
  000f0	3a c1		 cmp	 al, cl
  000f2	1b c0		 sbb	 eax, eax
  000f4	83 c0 01	 add	 eax, 1
  000f7	0f 85 68 01 00
	00		 jne	 $LN8@CGReqParty
$LN47@CGReqParty:

; 1354 : 			return;
; 1355 : 		}
; 1356 : 		// ----
; 1357 : 		if( IT_MAP_RANGE(gObj[UserIndex].MapNumber) 
; 1358 : 			|| IT_MAP_RANGE(gObj[TargetIndex].MapNumber) )

  000fd	8a 9c 1f 23 01
	00 00		 mov	 bl, BYTE PTR [edi+ebx+291]
  00104	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00107	72 0b		 jb	 SHORT $LN48@CGReqParty
  00109	b0 32		 mov	 al, 50			; 00000032H
  0010b	3a c3		 cmp	 al, bl
  0010d	1b c0		 sbb	 eax, eax
  0010f	83 c0 01	 add	 eax, 1
  00112	75 10		 jne	 SHORT $LN10@CGReqParty
$LN48@CGReqParty:
  00114	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00117	72 2c		 jb	 SHORT $LN49@CGReqParty
  00119	b0 32		 mov	 al, 50			; 00000032H
  0011b	3a c1		 cmp	 al, cl
  0011d	1b c0		 sbb	 eax, eax
  0011f	83 c0 01	 add	 eax, 1
  00122	74 21		 je	 SHORT $LN49@CGReqParty
$LN10@CGReqParty:

; 1359 : 		{
; 1360 : 			::GCServerMsgStringSend("Party not allowed in Illusion Temple.", UserIndex, 1);

  00124	6a 01		 push	 1
  00126	56		 push	 esi
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
  0012c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH
  00134	5b		 pop	 ebx
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi

; 1407 : }

  00137	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
$LN49@CGReqParty:

; 1361 : 			return;
; 1362 : 		}
; 1363 : 		// ----
; 1364 : 		if( DG_MAP_RANGE(gObj[UserIndex].MapNumber) 
; 1365 : 			|| DG_MAP_RANGE(gObj[TargetIndex].MapNumber)  )

  00145	80 fb 41	 cmp	 bl, 65			; 00000041H
  00148	72 0e		 jb	 SHORT $LN50@CGReqParty
  0014a	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  0014f	3a c3		 cmp	 al, bl
  00151	1b c0		 sbb	 eax, eax
  00153	83 c0 01	 add	 eax, 1
  00156	75 10		 jne	 SHORT $LN12@CGReqParty
$LN50@CGReqParty:
  00158	80 f9 41	 cmp	 cl, 65			; 00000041H
  0015b	72 2c		 jb	 SHORT $LN51@CGReqParty
  0015d	b0 44		 mov	 al, 68			; 00000044H
  0015f	3a c1		 cmp	 al, cl
  00161	1b c0		 sbb	 eax, eax
  00163	83 c0 01	 add	 eax, 1
  00166	74 21		 je	 SHORT $LN51@CGReqParty
$LN12@CGReqParty:

; 1366 : 		{
; 1367 : 			::GCServerMsgStringSend("Party not allowed in Doppelganger.", UserIndex, 1);

  00168	6a 01		 push	 1
  0016a	56		 push	 esi
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
  00170	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
  00178	5b		 pop	 ebx
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi

; 1407 : }

  0017b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017e	33 cd		 xor	 ecx, ebp
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
$LN51@CGReqParty:

; 1368 : 			return;
; 1369 : 		}
; 1370 : 		// ----
; 1371 : 		if( IF_MAP_RANGE(gObj[UserIndex].MapNumber) 
; 1372 : 			|| IF_MAP_RANGE(gObj[TargetIndex].MapNumber) )

  00189	80 fb 45	 cmp	 bl, 69			; 00000045H
  0018c	72 0e		 jb	 SHORT $LN52@CGReqParty
  0018e	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  00193	3a c3		 cmp	 al, bl
  00195	1b c0		 sbb	 eax, eax
  00197	83 c0 01	 add	 eax, 1
  0019a	75 10		 jne	 SHORT $LN14@CGReqParty
$LN52@CGReqParty:
  0019c	80 f9 45	 cmp	 cl, 69			; 00000045H
  0019f	72 2c		 jb	 SHORT $LN53@CGReqParty
  001a1	b0 48		 mov	 al, 72			; 00000048H
  001a3	3a c1		 cmp	 al, cl
  001a5	1b c0		 sbb	 eax, eax
  001a7	83 c0 01	 add	 eax, 1
  001aa	74 21		 je	 SHORT $LN53@CGReqParty
$LN14@CGReqParty:

; 1373 : 		{
; 1374 : 			::GCServerMsgStringSend("Party not allowed in Imperial Fort.", UserIndex, 1);

  001ac	6a 01		 push	 1
  001ae	56		 push	 esi
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
  001b4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bc	5b		 pop	 ebx
  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi

; 1407 : }

  001bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c2	33 cd		 xor	 ecx, ebp
  001c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
$LN53@CGReqParty:

; 1375 : 			return;
; 1376 : 		}
; 1377 : 		// ----
; 1378 : 		if( gObj[UserIndex].CloseCount >= 0 || gObj[TargetIndex].CloseCount >= 0 )

  001cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d2	80 7c 07 0c 00	 cmp	 BYTE PTR [edi+eax+12], 0
  001d7	7d 6e		 jge	 SHORT $LN16@CGReqParty
  001d9	80 7a 0c 00	 cmp	 BYTE PTR [edx+12], 0
  001dd	7d 68		 jge	 SHORT $LN16@CGReqParty

; 1381 : 			return;
; 1382 : 		}
; 1383 : 		// ----
; 1384 : 		if( gObj[TargetIndex].PartyNumber > 0 )

  001df	83 ba 0c 06 00
	00 00		 cmp	 DWORD PTR [edx+1548], 0
  001e6	7e 21		 jle	 SHORT $LN17@CGReqParty

; 1385 : 		{
; 1386 : 			::GCServerMsgStringSend("Target user already in party", UserIndex, 1);

  001e8	6a 01		 push	 1
  001ea	56		 push	 esi
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PPICOFML@Target?5user?5already?5in?5party?$AA@
  001f0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f8	5b		 pop	 ebx
  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi

; 1407 : }

  001fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fe	33 cd		 xor	 ecx, ebp
  00200	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
$LN17@CGReqParty:

; 1387 : 			return;
; 1388 : 		}
; 1389 : 		// ----
; 1390 : 		if( gGensSystem.m_CheckForParty )

  00209	80 3d 48 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+72, 0
  00210	0f 84 9c 00 00
	00		 je	 $LN20@CGReqParty

; 1391 : 		{
; 1392 : 			if( gObj[UserIndex].m_GensInfo.btFamily != GENS_NONE && gObj[UserIndex].m_GensInfo.btFamily != gObj[TargetIndex].m_GensInfo.btFamily )

  00216	8a 84 07 ac 26
	00 00		 mov	 al, BYTE PTR [edi+eax+9900]

; 1393 : 			{
; 1394 : 				::GCResultSend(UserIndex, 0x41, 0x07);
; 1395 : 				return;
; 1396 : 			}
; 1397 : 			// ----
; 1398 : 			if( gObj[UserIndex].m_GensInfo.btFamily != gObj[TargetIndex].m_GensInfo.btFamily )

  0021d	3a 82 ac 26 00
	00		 cmp	 al, BYTE PTR [edx+9900]
  00223	0f 84 89 00 00
	00		 je	 $LN20@CGReqParty

; 1399 : 			{
; 1400 : 				::GCResultSend(UserIndex, 0x41, 0x07);

  00229	6a 07		 push	 7
  0022b	6a 41		 push	 65			; 00000041H
  0022d	56		 push	 esi
  0022e	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00233	83 c4 0c	 add	 esp, 12			; 0000000cH
  00236	5b		 pop	 ebx
  00237	5f		 pop	 edi
  00238	5e		 pop	 esi

; 1407 : }

  00239	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023c	33 cd		 xor	 ecx, ebp
  0023e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c3		 ret	 0
$LN16@CGReqParty:

; 1379 : 		{
; 1380 : 			::GCResultSend(UserIndex, 0x41, 0x00);

  00247	6a 00		 push	 0
  00249	6a 41		 push	 65			; 00000041H
  0024b	56		 push	 esi
  0024c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH
  00254	5b		 pop	 ebx
  00255	5f		 pop	 edi
  00256	5e		 pop	 esi

; 1407 : }

  00257	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025a	33 cd		 xor	 ecx, ebp
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
$LN8@CGReqParty:

; 1352 : 		{
; 1353 : 			::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 198)), UserIndex, 1);

  00265	6a 01		 push	 1
  00267	56		 push	 esi
  00268	68 c6 04 00 00	 push	 1222			; 000004c6H
  0026d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00272	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0027d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00280	5b		 pop	 ebx
  00281	5f		 pop	 edi
  00282	5e		 pop	 esi

; 1407 : }

  00283	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00286	33 cd		 xor	 ecx, ebp
  00288	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028d	8b e5		 mov	 esp, ebp
  0028f	5d		 pop	 ebp
  00290	c3		 ret	 0
$LN6@CGReqParty:

; 1342 : 			gObj[TargetIndex].Connected != PLAYER_PLAYING )
; 1343 : 		{
; 1344 : 			::GCServerMsgStringSend("Target user not in game", UserIndex, 1);

  00291	6a 01		 push	 1
  00293	56		 push	 esi
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MEOHNEFK@Target?5user?5not?5in?5game?$AA@
  00299	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0029e	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a1	5b		 pop	 ebx
  002a2	5f		 pop	 edi
  002a3	5e		 pop	 esi

; 1407 : }

  002a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a7	33 cd		 xor	 ecx, ebp
  002a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ae	8b e5		 mov	 esp, ebp
  002b0	5d		 pop	 ebp
  002b1	c3		 ret	 0
$LN20@CGReqParty:

; 1401 : 				return;
; 1402 : 			}
; 1403 : 		}
; 1404 : 	}
; 1405 : 	// ----
; 1406 : 	cDBSMng.Send((PCHAR)&lpRequest, sizeof(PARTYMATCH_GDREQ_REQUESTANSWER));

  002b2	6a 17		 push	 23			; 00000017H
  002b4	8d 45 e4	 lea	 eax, DWORD PTR _lpRequest$[ebp]
  002b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002bc	50		 push	 eax
  002bd	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  002c2	5b		 pop	 ebx
$LN54@CGReqParty:
  002c3	5f		 pop	 edi
$LN3@CGReqParty:

; 1407 : }

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c7	33 cd		 xor	 ecx, ebp
  002c9	5e		 pop	 esi
  002ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cf	8b e5		 mov	 esp, ebp
  002d1	5d		 pop	 ebp
  002d2	c3		 ret	 0
?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z ENDP ; CGReqPartyMatchRequestAnswer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?CGReqPartyMatchAcceptList@@YAXH@Z
_TEXT	SEGMENT
_lpRequest$ = -24					; size = 19
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?CGReqPartyMatchAcceptList@@YAXH@Z PROC			; CGReqPartyMatchAcceptList, COMDAT

; 1264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _UserIndex$[ebp]

; 1265 : 	if(		!OBJMAX_RANGE(UserIndex) 
; 1266 : 		||	gObj[UserIndex].Connected != PLAYER_PLAYING )

  00013	85 d2		 test	 edx, edx
  00015	78 5c		 js	 SHORT $LN3@CGReqParty
  00017	33 c0		 xor	 eax, eax
  00019	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0001f	0f 9e c0	 setle	 al
  00022	85 c0		 test	 eax, eax
  00024	74 4d		 je	 SHORT $LN3@CGReqParty
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00031	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00036	75 3b		 jne	 SHORT $LN3@CGReqParty

; 1267 : 	{
; 1268 : 		return;
; 1269 : 	}
; 1270 : 	// ----
; 1271 : 	PARTYMATCH_GDREQ_REQUESTLIST lpRequest = { 0 };

  00038	0f 57 c0	 xorps	 xmm0, xmm0
  0003b	66 c7 45 f9 00
	00		 mov	 WORD PTR _lpRequest$[ebp+17], 0
  00041	0f 11 45 e9	 movups	 XMMWORD PTR _lpRequest$[ebp+1], xmm0

; 1272 : 	lpRequest.h.c			= 0xC1;

  00045	c7 45 e8 c1 13
	ef 04		 mov	 DWORD PTR _lpRequest$[ebp], 82777025 ; 04ef13c1H

; 1273 : 	lpRequest.h.headcode	= 0xEF;
; 1274 : 	lpRequest.h.subcode		= 0x04;
; 1275 : 	lpRequest.h.size		= sizeof(PARTYMATCH_GDREQ_REQUESTLIST);
; 1276 : 	lpRequest.UserIndex		= UserIndex;

  0004c	89 55 ec	 mov	 DWORD PTR _lpRequest$[ebp+4], edx

; 1277 : 	memcpy(lpRequest.PartyLeader, gObj[UserIndex].Name, 10);

  0004f	f3 0f 7e 44 01
	5d		 movq	 xmm0, QWORD PTR [ecx+eax+93]
  00055	66 0f d6 45 f0	 movq	 QWORD PTR _lpRequest$[ebp+8], xmm0
  0005a	66 8b 44 01 65	 mov	 ax, WORD PTR [ecx+eax+101]

; 1278 : 	cDBSMng.Send((PCHAR)&lpRequest, sizeof(PARTYMATCH_GDREQ_REQUESTLIST));

  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00064	66 89 45 f8	 mov	 WORD PTR _lpRequest$[ebp+16], ax
  00068	8d 45 e8	 lea	 eax, DWORD PTR _lpRequest$[ebp]
  0006b	6a 13		 push	 19			; 00000013H
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@CGReqParty:

; 1279 : }

  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	33 cd		 xor	 ecx, ebp
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?CGReqPartyMatchAcceptList@@YAXH@Z ENDP			; CGReqPartyMatchAcceptList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z PROC ; CGReqPartyMatchCancel, COMDAT

; 1024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 1025 : 	if( !gObjIsConnected(aIndex) )

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 28		 jne	 SHORT $LN2@CGReqParty

; 1026 : 	{
; 1027 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00025	68 03 04 00 00	 push	 1027			; 00000403H
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 1040 : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN2@CGReqParty:

; 1028 : 		return;
; 1029 : 	}
; 1030 : 
; 1031 : 	PMSG_PARTYMATCHING_CANCEL_REQ pMsg;
; 1032 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x06,sizeof(pMsg));

  0004d	6a 14		 push	 20			; 00000014H
  0004f	6a 06		 push	 6
  00051	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00054	68 ef 00 00 00	 push	 239			; 000000efH
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1033 : 
; 1034 : 	pMsg.aIndex = aIndex;
; 1035 : 	pMsg.btType = lpMsg->btType;

  0005f	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00062	83 c4 10	 add	 esp, 16			; 00000010H

; 1036 : 	memcpy(pMsg.szName,gObj[aIndex].Name,sizeof(pMsg.szName)-1);

  00065	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0006b	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+19], al
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00073	89 75 ec	 mov	 DWORD PTR _pMsg$[ebp+4], esi

; 1037 : 	pMsg.szName[sizeof(pMsg.szName)-1] = '\0';
; 1038 : 
; 1039 : 	cDBSMng.Send((PCHAR)&pMsg,sizeof(pMsg));

  00076	6a 14		 push	 20			; 00000014H
  00078	f3 0f 7e 44 01
	5d		 movq	 xmm0, QWORD PTR [ecx+eax+93]
  0007e	66 0f d6 45 f0	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  00083	66 8b 44 01 65	 mov	 ax, WORD PTR [ecx+eax+101]
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0008d	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+16], ax
  00091	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00094	50		 push	 eax
  00095	c6 45 fa 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  00099	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 1040 : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	5f		 pop	 edi
  000a2	33 cd		 xor	 ecx, ebp
  000a4	5e		 pop	 esi
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z ENDP ; CGReqPartyMatchCancel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?CGReqPartyMatchWaitingList@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGReqPartyMatchWaitingList@@YAXH@Z PROC		; CGReqPartyMatchWaitingList, COMDAT

; 1001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 1002 : 	if( !gObjIsConnected(aIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	75 27		 jne	 SHORT $LN2@CGReqParty

; 1003 : 	{
; 1004 : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00021	68 ec 03 00 00	 push	 1004			; 000003ecH
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	5e		 pop	 esi

; 1021 : }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003d	33 cd		 xor	 ecx, ebp
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
$LN2@CGReqParty:

; 1005 : 		return;
; 1006 : 	}
; 1007 : 
; 1008 : //	if( !gObj[aIndex].m_bIsPartyWaiting )
; 1009 : //	{
; 1010 : //		return;
; 1011 : //	}
; 1012 : 
; 1013 : 	PMSG_PARTYMATCHING_WAIT_REQ pMsg;
; 1014 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x03,sizeof(pMsg));

  00048	6a 14		 push	 20			; 00000014H
  0004a	6a 03		 push	 3
  0004c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004f	68 ef 00 00 00	 push	 239			; 000000efH
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1015 : 
; 1016 : 	pMsg.aIndex = aIndex;
; 1017 : 	memcpy(pMsg.szName,gObj[aIndex].Name,sizeof(pMsg.szName)-1);

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00068	89 75 ec	 mov	 DWORD PTR _pMsg$[ebp+4], esi

; 1018 : 	pMsg.szName[sizeof(pMsg.szName)-1] = '\0';
; 1019 : 
; 1020 : 	cDBSMng.Send((PCHAR)&pMsg,sizeof(pMsg));

  0006b	6a 14		 push	 20			; 00000014H
  0006d	f3 0f 7e 44 01
	5d		 movq	 xmm0, QWORD PTR [ecx+eax+93]
  00073	66 0f d6 45 f0	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  00078	66 8b 44 01 65	 mov	 ax, WORD PTR [ecx+eax+101]
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00082	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+16], ax
  00086	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00089	50		 push	 eax
  0008a	c6 45 fa 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  0008e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 1021 : }

  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	5e		 pop	 esi
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?CGReqPartyMatchWaitingList@@YAXH@Z ENDP		; CGReqPartyMatchWaitingList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z
_TEXT	SEGMENT
tv272 = -64						; size = 4
_pResult$ = -60						; size = 8
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z PROC ; CGReqPartyMatchJoin, COMDAT

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 922  : 	// -7 Request limit reached
; 923  : 	// -6 Cannot request while in party
; 924  : 	// -5 Cannot apply to your own group
; 925  : 	// -4 Waiting for acceptance
; 926  : 	// -3 No open party avaible
; 927  : 	// -2 Party does not exists
; 928  : 	// -1 The password entered is incorect
; 929  : 	// 0 - Successful post
; 930  : 
; 931  : 	if( !gObjIsConnected(aIndex) )

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 28		 jne	 SHORT $LN2@CGReqParty

; 932  : 	{
; 933  : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00025	68 a5 03 00 00	 push	 933			; 000003a5H
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 998  : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN2@CGReqParty:

; 934  : 		return;
; 935  : 	}
; 936  : 
; 937  : 	PMSG_PARTYMATCH_JOIN_ANS pResult;
; 938  : 	PHeadSubSetB((LPBYTE)&pResult,0xEF,0x02,sizeof(pResult));

  0004d	6a 08		 push	 8
  0004f	6a 02		 push	 2
  00051	8d 45 c4	 lea	 eax, DWORD PTR _pResult$[ebp]
  00054	68 ef 00 00 00	 push	 239			; 000000efH
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 939  : 
; 940  : 
; 941  : 	int TargetIndex = gObjGetIndex(lpMsg->szLeader);

  0005f	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?gObjGetIndex@@YAHPAD@Z	; gObjGetIndex
  00068	83 c4 14	 add	 esp, 20			; 00000014H

; 942  : 
; 943  : 	if( !OBJMAX_RANGE(TargetIndex) ||

  0006b	85 c0		 test	 eax, eax
  0006d	0f 88 4e 01 00
	00		 js	 $LN4@CGReqParty
  00073	33 c9		 xor	 ecx, ecx
  00075	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0007a	0f 9e c1	 setle	 cl
  0007d	85 c9		 test	 ecx, ecx
  0007f	0f 84 3c 01 00
	00		 je	 $LN4@CGReqParty
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008b	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00091	03 c1		 add	 eax, ecx
  00093	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00097	0f 85 24 01 00
	00		 jne	 $LN4@CGReqParty

; 948  : 		return;
; 949  : 	}
; 950  : 
; 951  : 	if( !strcmp(gObj[TargetIndex].Name, gObj[aIndex].Name) )

  0009d	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  000a3	83 c0 5d	 add	 eax, 93			; 0000005dH
  000a6	57		 push	 edi
  000a7	89 55 c0	 mov	 DWORD PTR tv272[ebp], edx
  000aa	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]
  000ad	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
$LL10@CGReqParty:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN11@CGReqParty
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN12@CGReqParty
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN11@CGReqParty
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL10@CGReqParty
$LN12@CGReqParty:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN13@CGReqParty
$LN11@CGReqParty:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 c8 01	 or	 eax, 1
$LN13@CGReqParty:
  000d5	85 c0		 test	 eax, eax
  000d7	75 09		 jne	 SHORT $LN5@CGReqParty

; 952  : 	{
; 953  : 		pResult.iResult = -5;

  000d9	c7 45 c8 fb ff
	ff ff		 mov	 DWORD PTR _pResult$[ebp+4], -5 ; fffffffbH

; 954  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);
; 955  : 		return;

  000e0	eb 10		 jmp	 SHORT $LN15@CGReqParty
$LN5@CGReqParty:

; 956  : 	}
; 957  : 
; 958  : 	if( gObj[aIndex].PartyNumber >= 0 )

  000e2	83 bf 0c 06 00
	00 00		 cmp	 DWORD PTR [edi+1548], 0
  000e9	7c 2a		 jl	 SHORT $LN6@CGReqParty

; 959  : 	{
; 960  : 		pResult.iResult = -6;

  000eb	c7 45 c8 fa ff
	ff ff		 mov	 DWORD PTR _pResult$[ebp+4], -6 ; fffffffaH
$LN15@CGReqParty:

; 961  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  000f2	0f b6 45 c5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000f6	50		 push	 eax
  000f7	8d 45 c4	 lea	 eax, DWORD PTR _pResult$[ebp]
  000fa	50		 push	 eax
  000fb	56		 push	 esi
  000fc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 998  : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
$LN6@CGReqParty:

; 962  : 		return;
; 963  : 	}
; 964  : 
; 965  : //	if( gObj[aIndex].m_bIsPartyWaiting == TRUE )
; 966  : //	{
; 967  : //		pResult.iResult = -4;
; 968  : //		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);
; 969  : //		return;
; 970  : //	}
; 971  : 
; 972  : //	gObj[aIndex].m_bIsPartyWaiting = TRUE;
; 973  : 
; 974  : 	PMSG_PARTYMATCHING_JOIN_REQ pMsg;
; 975  : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x02,sizeof(pMsg));

  00115	6a 30		 push	 48			; 00000030H
  00117	6a 02		 push	 2
  00119	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0011c	68 ef 00 00 00	 push	 239			; 000000efH
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 976  : 
; 977  : 	memcpy(pMsg.szName,gObj[aIndex].Name,sizeof(pMsg.szName)-1);

  00127	8b 4d c0	 mov	 ecx, DWORD PTR tv272[ebp]
  0012a	83 c4 10	 add	 esp, 16			; 00000010H
  0012d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 978  : 	pMsg.szName[sizeof(pMsg.szName)-1] = '\0';
; 979  : 
; 980  : 	memcpy(pMsg.szPartyLeader,lpMsg->szLeader,sizeof(pMsg.szPartyLeader)-1);
; 981  : 	pMsg.szPartyLeader[sizeof(pMsg.szPartyLeader)-1] = '\0';
; 982  : 
; 983  : 	memcpy(pMsg.szPassword,lpMsg->szPassword,sizeof(pMsg.szPassword)-1);
; 984  : 	pMsg.szPassword[sizeof(pMsg.szPassword)-1] = '\0';
; 985  : 
; 986  : 	pMsg.aIndex = aIndex;
; 987  : 	pMsg.RequestType = lpMsg->btType;
; 988  : 	pMsg.ServerCode = gGameServerCode;
; 989  : 	pMsg.Class = gObj[aIndex].Class;
; 990  : 	pMsg.Level = gObj[aIndex].Level;
; 991  : #if (__GENS_SYSTEM__ == 1)
; 992  : 	pMsg.Gens = gObj[aIndex].m_GensInfo.btFamily;
; 993  : #else
; 994  : 	pMsg.Gens = 0;
; 995  : #endif
; 996  : 
; 997  : 	cDBSMng.Send((PCHAR)&pMsg,sizeof(pMsg));

  00133	6a 30		 push	 48			; 00000030H
  00135	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  0013a	66 0f d6 45 d4	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  0013f	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  00143	f3 0f 7e 43 04	 movq	 xmm0, QWORD PTR [ebx+4]
  00148	66 89 45 dc	 mov	 WORD PTR _pMsg$[ebp+16], ax
  0014c	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  00150	66 89 45 e7	 mov	 WORD PTR _pMsg$[ebp+27], ax
  00154	8b 43 0f	 mov	 eax, DWORD PTR [ebx+15]
  00157	89 45 ea	 mov	 DWORD PTR _pMsg$[ebp+30], eax
  0015a	0f b6 43 15	 movzx	 eax, BYTE PTR [ebx+21]
  0015e	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+38], ax
  00162	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00169	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+36], ax
  0016d	c6 45 de 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  00171	66 0f d6 45 df	 movq	 QWORD PTR _pMsg$[ebp+19], xmm0
  00176	c6 45 e9 00	 mov	 BYTE PTR _pMsg$[ebp+29], 0
  0017a	c6 45 ee 00	 mov	 BYTE PTR _pMsg$[ebp+34], 0
  0017e	89 75 d0	 mov	 DWORD PTR _pMsg$[ebp+4], esi
  00181	0f b7 81 90 00
	00 00		 movzx	 eax, WORD PTR [ecx+144]
  00188	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+42], ax
  0018c	0f b7 81 96 00
	00 00		 movzx	 eax, WORD PTR [ecx+150]
  00193	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+40], ax
  00197	0f b6 81 ac 26
	00 00		 movzx	 eax, BYTE PTR [ecx+9900]
  0019e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  001a3	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+44], ax
  001a7	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  001b0	5f		 pop	 edi
  001b1	5e		 pop	 esi
  001b2	5b		 pop	 ebx

; 998  : }

  001b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b6	33 cd		 xor	 ecx, ebp
  001b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
$LN4@CGReqParty:

; 944  : 		gObj[TargetIndex].Connected != PLAYER_PLAYING )
; 945  : 	{
; 946  : 		pResult.iResult = -2;
; 947  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  001c1	0f b6 45 c5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001c5	50		 push	 eax
  001c6	8d 45 c4	 lea	 eax, DWORD PTR _pResult$[ebp]
  001c9	c7 45 c8 fe ff
	ff ff		 mov	 DWORD PTR _pResult$[ebp+4], -2 ; fffffffeH
  001d0	50		 push	 eax
  001d1	56		 push	 esi
  001d2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 998  : }

  001d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH
  001dd	33 cd		 xor	 ecx, ebp
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx
  001e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c3		 ret	 0
?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z ENDP ; CGReqPartyMatchJoin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -92						; size = 8
_pDBMsg$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z PROC ; CGReqPartyMatchReg, COMDAT

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 838  : 	// iResult
; 839  : 	// 0 - Success
; 840  : 	// -1 -> There has been an error
; 841  : 	// -2 -> Included in waiting list
; 842  : 	// -3 -> Can only be used by party leader
; 843  : 
; 844  : 	PMSG_PARTYMATCH_REG_ANS pMsg;
; 845  : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x00,sizeof(pMsg));

  00014	8d 45 a4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001b	6a 08		 push	 8
  0001d	6a 00		 push	 0
  0001f	68 ef 00 00 00	 push	 239			; 000000efH
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 846  : 
; 847  : 	pMsg.iResult = 0;
; 848  : 
; 849  : 	if( !gObjIsConnected(aIndex) )

  0002a	56		 push	 esi
  0002b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+4], 0
  00032	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00037	83 c4 14	 add	 esp, 20			; 00000014H
  0003a	85 c0		 test	 eax, eax
  0003c	75 28		 jne	 SHORT $LN2@CGReqParty

; 850  : 	{
; 851  : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  0003e	68 53 03 00 00	 push	 851			; 00000353H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 886  : }

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	33 cd		 xor	 ecx, ebp
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN2@CGReqParty:

; 852  : 		return;
; 853  : 	}
; 854  : 
; 855  : 	if ( gObj[aIndex].CloseCount >= 0 )

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	53		 push	 ebx
  0006c	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00072	80 7c 18 0c 00	 cmp	 BYTE PTR [eax+ebx+12], 0
  00077	7c 2a		 jl	 SHORT $LN3@CGReqParty

; 856  : 	{
; 857  : 		pMsg.iResult = -1;
; 858  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00079	0f b6 45 a5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0007d	50		 push	 eax
  0007e	8d 45 a4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00081	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+4], -1
  00088	50		 push	 eax
  00089	56		 push	 esi
  0008a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00092	5b		 pop	 ebx
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 886  : }

  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 cd		 xor	 ecx, ebp
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN3@CGReqParty:

; 859  : 		return;
; 860  : 	}
; 861  : 
; 862  : 	gObj[aIndex].m_bIsPartyMatch = TRUE;
; 863  : 
; 864  : 	PMSG_PARTYMATCHING_REG_REQ pDBMsg;
; 865  : 	PHeadSubSetB((LPBYTE)&pDBMsg,0xEF,0x00,sizeof(pDBMsg));

  000a3	6a 50		 push	 80			; 00000050H
  000a5	6a 00		 push	 0
  000a7	c6 84 18 cd 26
	00 00 01	 mov	 BYTE PTR [eax+ebx+9933], 1
  000af	8d 45 ac	 lea	 eax, DWORD PTR _pDBMsg$[ebp]
  000b2	68 ef 00 00 00	 push	 239			; 000000efH
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 866  : 
; 867  : 	memcpy(pDBMsg.szDesc,lpMsg->szDesc,sizeof(pDBMsg.szDesc));

  000bd	0f 10 47 04	 movups	 xmm0, XMMWORD PTR [edi+4]

; 868  : 	pDBMsg.szDesc[sizeof(pDBMsg.szDesc)-1] = '\0';
; 869  : 
; 870  : 	memcpy(pDBMsg.szName,gObj[aIndex].Name,sizeof(pDBMsg.szName));

  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c7	83 c4 10	 add	 esp, 16			; 00000010H
  000ca	03 cb		 add	 ecx, ebx
  000cc	c6 45 eb 00	 mov	 BYTE PTR _pDBMsg$[ebp+63], 0
  000d0	0f 11 45 c3	 movups	 XMMWORD PTR _pDBMsg$[ebp+23], xmm0
  000d4	0f 10 47 14	 movups	 xmm0, XMMWORD PTR [edi+20]

; 871  : 	pDBMsg.szName[sizeof(pDBMsg.szName)-1] = '\0';
; 872  : 
; 873  : 	memcpy(pDBMsg.szPass,lpMsg->szPass,sizeof(pDBMsg.szPass));
; 874  : 	pDBMsg.szPass[sizeof(pDBMsg.szPass)-1] = '\0';
; 875  : 
; 876  : 	pDBMsg.ServerCode = gGameServerCode;
; 877  : 	pDBMsg.aIndex = aIndex;
; 878  : 	pDBMsg.btAutoAccept = lpMsg->btAutoAccept;
; 879  : 	pDBMsg.ClassInfo = lpMsg->ClassInfo;
; 880  : 	pDBMsg.MaxLevel = lpMsg->MaxLevel;
; 881  : 	pDBMsg.MinLevel = lpMsg->MinLevel;
; 882  : 	pDBMsg.MoveReqId = lpMsg->MoveReqId;
; 883  : 	pDBMsg.Gens = gObj[aIndex].m_GensInfo.btFamily;
; 884  : 
; 885  : 	cDBSMng.Send((PCHAR)&pDBMsg,sizeof(pDBMsg));

  000d8	6a 50		 push	 80			; 00000050H
  000da	0f 11 45 d3	 movups	 XMMWORD PTR _pDBMsg$[ebp+39], xmm0
  000de	f3 0f 7e 47 24	 movq	 xmm0, QWORD PTR [edi+36]
  000e3	66 0f d6 45 e3	 movq	 QWORD PTR _pDBMsg$[ebp+55], xmm0
  000e8	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  000ed	66 0f d6 45 b8	 movq	 QWORD PTR _pDBMsg$[ebp+12], xmm0
  000f2	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  000f6	66 89 45 c0	 mov	 WORD PTR _pDBMsg$[ebp+20], ax
  000fa	8b 47 2d	 mov	 eax, DWORD PTR [edi+45]
  000fd	89 45 ec	 mov	 DWORD PTR _pDBMsg$[ebp+64], eax
  00100	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00107	89 45 b4	 mov	 DWORD PTR _pDBMsg$[ebp+8], eax
  0010a	0f b6 47 41	 movzx	 eax, BYTE PTR [edi+65]
  0010e	88 45 fa	 mov	 BYTE PTR _pDBMsg$[ebp+78], al
  00111	0f b7 47 38	 movzx	 eax, WORD PTR [edi+56]
  00115	66 89 45 f8	 mov	 WORD PTR _pDBMsg$[ebp+76], ax
  00119	0f b7 47 34	 movzx	 eax, WORD PTR [edi+52]
  0011d	66 89 45 f4	 mov	 WORD PTR _pDBMsg$[ebp+72], ax
  00121	0f b7 47 32	 movzx	 eax, WORD PTR [edi+50]
  00125	66 89 45 f2	 mov	 WORD PTR _pDBMsg$[ebp+70], ax
  00129	0f b7 47 36	 movzx	 eax, WORD PTR [edi+54]
  0012d	66 89 45 f6	 mov	 WORD PTR _pDBMsg$[ebp+74], ax
  00131	c6 45 c2 00	 mov	 BYTE PTR _pDBMsg$[ebp+22], 0
  00135	c6 45 f0 00	 mov	 BYTE PTR _pDBMsg$[ebp+68], 0
  00139	89 75 b0	 mov	 DWORD PTR _pDBMsg$[ebp+4], esi
  0013c	0f b6 81 ac 26
	00 00		 movzx	 eax, BYTE PTR [ecx+9900]
  00143	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00148	88 45 fb	 mov	 BYTE PTR _pDBMsg$[ebp+79], al
  0014b	8d 45 ac	 lea	 eax, DWORD PTR _pDBMsg$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 886  : }

  00154	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00157	5b		 pop	 ebx
  00158	5f		 pop	 edi
  00159	33 cd		 xor	 ecx, ebp
  0015b	5e		 pop	 esi
  0015c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z ENDP ; CGReqPartyMatchReg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z PROC ; CGReqPartyMatchWindow, COMDAT

; 889  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 890  : 	if( !gObjIsConnected(aIndex) )

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 28		 jne	 SHORT $LN2@CGReqParty

; 891  : 	{
; 892  : 		LogAdd("error: %s %d",__FILE__,__LINE__);

  00025	68 7c 03 00 00	 push	 892			; 0000037cH
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAONGKIG@PartyClass?4cpp?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NOFHGNOC@error?3?5?$CFs?5?$CFd?$AA@
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 918  : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN2@CGReqParty:

; 893  : 		return;
; 894  : 	}
; 895  : 
; 896  : 	PMSG_PARTYMATCHING_INFO_REQ pMsg;
; 897  : 	PHeadSubSetB((LPBYTE)&pMsg,0xEF,0x01,sizeof(pMsg));

  0004d	6a 2c		 push	 44			; 0000002cH
  0004f	6a 01		 push	 1
  00051	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00054	68 ef 00 00 00	 push	 239			; 000000efH
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 898  : 
; 899  : 	pMsg.RequestPage = lpMsg->RequestPage;

  0005f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 900  : 	pMsg.ReqType = lpMsg->ReqType;

  00068	8a 47 13	 mov	 al, BYTE PTR [edi+19]

; 901  : 	pMsg.aIndex = aIndex;
; 902  : 	pMsg.Class = gObj[aIndex].Class;

  0006b	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00071	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+35], al
  00074	89 75 d4	 mov	 DWORD PTR _pMsg$[ebp+4], esi

; 903  : 	pMsg.Level = gObj[aIndex].Level;
; 904  : 
; 905  : #if (__GENS_SYSTEM__ == 1)
; 906  : 	pMsg.Gens = gObj[aIndex].m_GensInfo.btFamily;
; 907  : #else
; 908  : 	pMsg.Gens = 0;
; 909  : #endif
; 910  : 
; 911  : 	memcpy(pMsg.szName,gObj[aIndex].Name,sizeof(pMsg.szName)-1);
; 912  : 	pMsg.szName[sizeof(pMsg.szName)-1] = '\0';
; 913  : 
; 914  : 	memcpy(pMsg.szSearch,lpMsg->szSearch,sizeof(pMsg.szSearch)-1);
; 915  : 	pMsg.szSearch[sizeof(pMsg.szSearch)-1] = '\0';
; 916  : 
; 917  : 	cDBSMng.Send((PCHAR)&pMsg,sizeof(pMsg));

  00077	6a 2c		 push	 44			; 0000002cH
  00079	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007f	0f b7 81 90 00
	00 00		 movzx	 eax, WORD PTR [ecx+144]
  00086	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+38], ax
  0008a	0f b7 81 96 00
	00 00		 movzx	 eax, WORD PTR [ecx+150]
  00091	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+36], ax
  00095	0f b6 81 ac 26
	00 00		 movzx	 eax, BYTE PTR [ecx+9900]
  0009c	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+40], ax
  000a0	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  000a5	66 0f d6 45 d8	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  000aa	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000b3	f3 0f 7e 47 08	 movq	 xmm0, QWORD PTR [edi+8]
  000b8	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+16], ax
  000bc	0f b7 47 10	 movzx	 eax, WORD PTR [edi+16]
  000c0	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+32], ax
  000c4	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c7	50		 push	 eax
  000c8	c6 45 e2 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  000cc	66 0f d6 45 e8	 movq	 QWORD PTR _pMsg$[ebp+24], xmm0
  000d1	c6 45 f2 00	 mov	 BYTE PTR _pMsg$[ebp+34], 0
  000d5	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 918  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	5f		 pop	 edi
  000de	33 cd		 xor	 ecx, ebp
  000e0	5e		 pop	 esi
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z ENDP ; CGReqPartyMatchWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GPartyClass@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPartyClass@@UAEPAXI@Z PROC				; PartyClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1PartyClass@@UAE@XZ	; PartyClass::~PartyClass
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 70 88 0a 00	 push	 690288			; 000a8870H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GPartyClass@@UAEPAXI@Z ENDP				; PartyClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?SetLeader@PartyClass@@QAE_NHH@Z
_TEXT	SEGMENT
_lpTargetObj$1$ = -116					; size = 4
tv383 = -112						; size = 4
tv375 = -112						; size = 4
_this$GSCopy$1$ = -108					; size = 4
_Text$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_OldLeader$ = 8						; size = 4
_NewLeader$ = 12					; size = 4
?SetLeader@PartyClass@@QAE_NHH@Z PROC			; PartyClass::SetLeader, COMDAT
; _this$ = ecx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _NewLeader$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _OldLeader$[ebp]
  00017	89 4d 94	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx

; 781  : 	if( !OBJMAX_RANGE(OldLeader) )

  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 8d 01 00
	00		 js	 $LN21@SetLeader
  00022	33 c0		 xor	 eax, eax
  00024	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 7a 01 00
	00		 je	 $LN21@SetLeader

; 782  : 		return false;
; 783  : 
; 784  : 	if( !OBJMAX_RANGE(NewLeader) )

  00035	85 d2		 test	 edx, edx
  00037	0f 88 72 01 00
	00		 js	 $LN21@SetLeader
  0003d	33 c0		 xor	 eax, eax
  0003f	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00045	0f 9e c0	 setle	 al
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 5f 01 00
	00		 je	 $LN21@SetLeader

; 785  : 		return false;
; 786  : 
; 787  : 	LPOBJ lpObj			= &gObj[OldLeader];

  00050	53		 push	 ebx
  00051	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00057	57		 push	 edi

; 788  : 	LPOBJ lpTargetObj	= &gObj[NewLeader];		

  00058	69 fa 40 27 00
	00		 imul	 edi, edx, 10048
  0005e	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	89 7d 8c	 mov	 DWORD PTR _lpTargetObj$1$[ebp], edi

; 789  : 	// ----
; 790  : 	int PartyNumber		= lpObj->PartyNumber;

  0006d	8b b3 0c 06 00
	00		 mov	 esi, DWORD PTR [ebx+1548]

; 791  : 	// ----
; 792  : 	if( !this->IsParty(PartyNumber) )

  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00079	85 c0		 test	 eax, eax
  0007b	75 26		 jne	 SHORT $LN7@SetLeader

; 793  : 	{
; 794  : 		GCServerMsgStringSend("Your character is not in party", lpObj->m_Index, 1);

  0007d	6a 01		 push	 1
  0007f	ff 33		 push	 DWORD PTR [ebx]
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GIPBDNCJ@Your?5character?5is?5not?5in?5party?$AA@
$LN24@SetLeader:

; 799  : 	{
; 800  : 		GCServerMsgStringSend("Target is not party member", lpObj->m_Index, 1);

  00086	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 801  : 		return false;

  0008e	32 c0		 xor	 al, al
  00090	5f		 pop	 edi
  00091	5b		 pop	 ebx
  00092	5e		 pop	 esi

; 834  : }

  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
$LN7@SetLeader:

; 795  : 		return false;
; 796  : 	}
; 797  : 	// ----
; 798  : 	if( lpObj->PartyNumber != lpTargetObj->PartyNumber )

  000a3	3b b7 0c 06 00
	00		 cmp	 esi, DWORD PTR [edi+1548]
  000a9	74 0b		 je	 SHORT $LN8@SetLeader

; 799  : 	{
; 800  : 		GCServerMsgStringSend("Target is not party member", lpObj->m_Index, 1);

  000ab	6a 01		 push	 1
  000ad	ff 33		 push	 DWORD PTR [ebx]
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DDDPOLAI@Target?5is?5not?5party?5member?$AA@

; 801  : 		return false;

  000b4	eb d0		 jmp	 SHORT $LN24@SetLeader
$LN8@SetLeader:

; 802  : 	}
; 803  : 	// ----
; 804  : 	if( !this->Isleader(PartyNumber, lpObj->m_Index, lpObj->DBNumber) )

  000b6	ff 73 30	 push	 DWORD PTR [ebx+48]
  000b9	8b 03		 mov	 eax, DWORD PTR [ebx]
  000bb	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000be	50		 push	 eax
  000bf	56		 push	 esi
  000c0	89 45 90	 mov	 DWORD PTR tv383[ebp], eax
  000c3	e8 00 00 00 00	 call	 ?Isleader@PartyClass@@QAEHHHH@Z ; PartyClass::Isleader
  000c8	85 c0		 test	 eax, eax
  000ca	75 0c		 jne	 SHORT $LN9@SetLeader

; 805  : 	{
; 806  : 		GCServerMsgStringSend("Your character is not party leader", lpObj->m_Index, 1);

  000cc	6a 01		 push	 1
  000ce	ff 75 90	 push	 DWORD PTR tv383[ebp]
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LEEFHALA@Your?5character?5is?5not?5party?5lead@

; 807  : 		return false;

  000d6	eb ae		 jmp	 SHORT $LN24@SetLeader
$LN9@SetLeader:

; 808  : 	}
; 809  : 	// ----
; 810  : 	int TempIndex = this->GetIndex(PartyNumber, lpTargetObj->m_Index, lpTargetObj->DBNumber);

  000d8	ff 77 30	 push	 DWORD PTR [edi+48]
  000db	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000de	ff 37		 push	 DWORD PTR [edi]
  000e0	56		 push	 esi
  000e1	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex
  000e6	8b f8		 mov	 edi, eax

; 811  : 	// ----
; 812  : 	this->m_PartyS[PartyNumber].Number[0]					= this->m_PartyS[PartyNumber].Number[TempIndex];

  000e8	8b ce		 mov	 ecx, esi
  000ea	8b 45 94	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  000ed	8b d6		 mov	 edx, esi
  000ef	c1 e1 04	 shl	 ecx, 4
  000f2	c1 e2 04	 shl	 edx, 4
  000f5	2b ce		 sub	 ecx, esi
  000f7	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  000fa	2b d6		 sub	 edx, esi
  000fc	03 d7		 add	 edx, edi
  000fe	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
  00101	89 75 90	 mov	 DWORD PTR tv375[ebp], esi
  00104	6a 64		 push	 100			; 00000064H
  00106	6a 00		 push	 0
  00108	8b 44 90 0c	 mov	 eax, DWORD PTR [eax+edx*4+12]
  0010c	89 06		 mov	 DWORD PTR [esi], eax

; 813  : 	this->m_PartyS[PartyNumber].DbNumber[0]					= this->m_PartyS[PartyNumber].DbNumber[TempIndex];

  0010e	8b 45 94	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]

; 814  : 	this->m_PartyS[PartyNumber].m_PkLevel[0]				= this->m_PartyS[PartyNumber].m_PkLevel[TempIndex];
; 815  : 	// ----
; 816  : 	this->m_PartyS[PartyNumber].Number[TempIndex]			= lpObj->m_Index;

  00111	8b 75 94	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00114	8b 44 90 20	 mov	 eax, DWORD PTR [eax+edx*4+32]
  00118	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0011b	0f b6 44 39 38	 movzx	 eax, BYTE PTR [ecx+edi+56]
  00120	88 41 38	 mov	 BYTE PTR [ecx+56], al
  00123	8b 03		 mov	 eax, DWORD PTR [ebx]
  00125	89 44 96 0c	 mov	 DWORD PTR [esi+edx*4+12], eax

; 817  : 	this->m_PartyS[PartyNumber].DbNumber[TempIndex]			= lpObj->DBNumber;

  00129	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0012c	89 44 96 20	 mov	 DWORD PTR [esi+edx*4+32], eax

; 818  : 	this->m_PartyS[PartyNumber].m_PkLevel[TempIndex]		= lpObj->m_PK_Level;

  00130	0f b6 83 19 01
	00 00		 movzx	 eax, BYTE PTR [ebx+281]
  00137	88 44 39 38	 mov	 BYTE PTR [ecx+edi+56], al
  0013b	8d 45 98	 lea	 eax, DWORD PTR _Text$[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _memset

; 819  : 	// ----
; 820  : 	char Text[100] = { 0 };
; 821  : 	sprintf(Text, "New party leader: %s", lpTargetObj->Name);

  00144	8b 45 8c	 mov	 eax, DWORD PTR _lpTargetObj$1$[ebp]
  00147	83 c0 5d	 add	 eax, 93			; 0000005dH
  0014a	50		 push	 eax
  0014b	8d 45 98	 lea	 eax, DWORD PTR _Text$[ebp]
  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OFNDHPCK@New?5party?5leader?3?5?$CFs?$AA@
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _sprintf
  00159	8b 75 90	 mov	 esi, DWORD PTR tv375[ebp]
  0015c	83 c4 18	 add	 esp, 24			; 00000018H
  0015f	bf 05 00 00 00	 mov	 edi, 5
$LL4@SetLeader:

; 824  : 	{
; 825  : 		int UserIndex = this->m_PartyS[PartyNumber].Number[i];

  00164	8b 16		 mov	 edx, DWORD PTR [esi]

; 826  : 		// ----
; 827  : 		if( UserIndex >= 0 && gObj[UserIndex].Connected == 3 )

  00166	85 d2		 test	 edx, edx
  00168	78 28		 js	 SHORT $LN2@SetLeader
  0016a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016f	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00175	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0017a	75 16		 jne	 SHORT $LN2@SetLeader

; 828  : 		{
; 829  : 			GCServerMsgStringSend(Text, this->m_PartyS[PartyNumber].Number[i], 1);

  0017c	6a 01		 push	 1
  0017e	52		 push	 edx
  0017f	8d 45 98	 lea	 eax, DWORD PTR _Text$[ebp]
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 830  : 			CGPartyList(this->m_PartyS[PartyNumber].Number[i]);

  00188	ff 36		 push	 DWORD PTR [esi]
  0018a	e8 00 00 00 00	 call	 ?CGPartyList@@YAXH@Z	; CGPartyList
  0018f	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@SetLeader:

; 822  : 	// ----
; 823  : 	for( int i = 0; i < MAX_USER_IN_PARTY; i++ )

  00192	83 c6 04	 add	 esi, 4
  00195	83 ef 01	 sub	 edi, 1
  00198	75 ca		 jne	 SHORT $LL4@SetLeader

; 831  : 		}
; 832  : 	}
; 833  : 	return true;

  0019a	5f		 pop	 edi
  0019b	5b		 pop	 ebx
  0019c	b0 01		 mov	 al, 1
  0019e	5e		 pop	 esi

; 834  : }

  0019f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a2	33 cd		 xor	 ecx, ebp
  001a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c2 08 00	 ret	 8
$LN21@SetLeader:
  001af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b2	32 c0		 xor	 al, al
  001b4	33 cd		 xor	 ecx, ebp
  001b6	5e		 pop	 esi
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 08 00	 ret	 8
?SetLeader@PartyClass@@QAE_NHH@Z ENDP			; PartyClass::SetLeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetExpBonus@PartyClass@@QAEHPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_NearbyBonus$1$ = -32					; size = 4
_ClassBonus$1$ = -28					; size = 4
tv499 = -24						; size = 4
_lpMonster$GSCopy$1$ = -20				; size = 4
_this$1$ = -16						; size = 4
_ClassTable$ = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
_lpMonster$ = 12					; size = 4
_PartyNumber$ = 16					; size = 4
?GetExpBonus@PartyClass@@QAEHPAUOBJECTSTRUCT@@0H@Z PROC	; PartyClass::GetExpBonus, COMDAT
; _this$ = ecx

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 10	 mov	 edx, DWORD PTR _PartyNumber$[ebp]

; 557  : 	if( !lpUser )
; 558  : 	{
; 559  : 		return 0;

  00013	33 c0		 xor	 eax, eax
  00015	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMonster$[ebp]
  0001b	89 4d ec	 mov	 DWORD PTR _lpMonster$GSCopy$1$[ebp], ecx
  0001e	39 45 08	 cmp	 DWORD PTR _lpUser$[ebp], eax
  00021	0f 84 34 01 00
	00		 je	 $LN1@GetExpBonu

; 560  : 	}
; 561  : 	// ----
; 562  : 	int NearbyCount = 0;
; 563  : 	int NearbyBonus = 0;
; 564  : 	int ClassBonus = 0;
; 565  : 	BYTE ClassTable[MAX_TYPE_PLAYER] = { 0 };

  00027	89 45 f5	 mov	 DWORD PTR _ClassTable$[ebp+1], eax
  0002a	66 89 45 f9	 mov	 WORD PTR _ClassTable$[ebp+5], ax
  0002e	8b c2		 mov	 eax, edx
  00030	53		 push	 ebx
  00031	33 db		 xor	 ebx, ebx
  00033	c1 e0 04	 shl	 eax, 4
  00036	2b c2		 sub	 eax, edx
  00038	89 5d e0	 mov	 DWORD PTR _NearbyBonus$1$[ebp], ebx
  0003b	56		 push	 esi
  0003c	57		 push	 edi
  0003d	89 5d e4	 mov	 DWORD PTR _ClassBonus$1$[ebp], ebx
  00040	88 5d f4	 mov	 BYTE PTR _ClassTable$[ebp], bl
  00043	8d 3c 85 0c 00
	00 00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  0004a	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR tv499[ebp], 5
$LL4@GetExpBonu:

; 568  : 	{
; 569  : 		int UserIndex = gParty.m_PartyS[PartyNumber].Number[i];

  00051	8b 07		 mov	 eax, DWORD PTR [edi]

; 570  : 		// ----
; 571  : 		if( UserIndex < 0 )

  00053	85 c0		 test	 eax, eax
  00055	78 3b		 js	 SHORT $LN2@GetExpBonu

; 572  : 		{
; 573  : 			continue;
; 574  : 		}
; 575  : 		// ----
; 576  : 		LPOBJ lpPartyUser = &gObj[UserIndex];

  00057	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  0005d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 577  : 		// ----
; 578  : 		if( !lpPartyUser )

  00063	74 2d		 je	 SHORT $LN2@GetExpBonu

; 579  : 		{
; 580  : 			continue;
; 581  : 		}
; 582  : 		// ----
; 583  : 		if( lpMonster->MapNumber != lpPartyUser->MapNumber )

  00065	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  0006b	3a 86 23 01 00
	00		 cmp	 al, BYTE PTR [esi+291]
  00071	75 1f		 jne	 SHORT $LN2@GetExpBonu

; 584  : 		{
; 585  : 			continue;
; 586  : 		}
; 587  : 		// ----
; 588  : 		if( gObjCalDistance(lpMonster, lpPartyUser) >= 10 )

  00073	56		 push	 esi
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _lpMonster$GSCopy$1$[ebp]
  0007d	83 c4 08	 add	 esp, 8
  00080	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00083	7d 0d		 jge	 SHORT $LN2@GetExpBonu

; 589  : 		{
; 590  : 			continue;
; 591  : 		}
; 592  : 		// ----
; 593  : 		NearbyCount++;
; 594  : 		ClassTable[lpPartyUser->Class] = 1;

  00085	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  0008c	43		 inc	 ebx
  0008d	c6 44 05 f4 01	 mov	 BYTE PTR _ClassTable$[ebp+eax], 1
$LN2@GetExpBonu:

; 566  : 	// ----
; 567  : 	for( int i = 0; i < MAX_USER_IN_PARTY; i++ )

  00092	83 c7 04	 add	 edi, 4
  00095	83 6d e8 01	 sub	 DWORD PTR tv499[ebp], 1
  00099	75 b6		 jne	 SHORT $LL4@GetExpBonu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0009b	8b 55 f0	 mov	 edx, DWORD PTR _this$1$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 597  : 	for( int j = 0; j < this->m_BonusInfo.m_NearbyBonus.size(); j++ )

  0009e	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  000a0	8b 82 5c 88 0a
	00		 mov	 eax, DWORD PTR [edx+690268]
  000a6	2b 82 58 88 0a
	00		 sub	 eax, DWORD PTR [edx+690264]
  000ac	c1 f8 03	 sar	 eax, 3
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 597  : 	for( int j = 0; j < this->m_BonusInfo.m_NearbyBonus.size(); j++ )

  000af	85 c0		 test	 eax, eax
  000b1	74 34		 je	 SHORT $LN6@GetExpBonu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  000b3	8b b2 58 88 0a
	00		 mov	 esi, DWORD PTR [edx+690264]
  000b9	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]
  000bc	8b 92 5c 88 0a
	00		 mov	 edx, DWORD PTR [edx+690268]
  000c2	2b 90 58 88 0a
	00		 sub	 edx, DWORD PTR [eax+690264]
  000c8	c1 fa 03	 sar	 edx, 3
  000cb	0f 1f 44 00 00	 npad	 5
$LL7@GetExpBonu:
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 599  : 		if( this->m_BonusInfo.m_NearbyBonus[j].m_NearbyCount == NearbyCount )

  000d0	0f b6 04 ce	 movzx	 eax, BYTE PTR [esi+ecx*8]
  000d4	3b c3		 cmp	 eax, ebx
  000d6	75 07		 jne	 SHORT $LN5@GetExpBonu

; 600  : 		{
; 601  : 			NearbyBonus = this->m_BonusInfo.m_NearbyBonus[j].m_AddExp;

  000d8	8b 44 ce 04	 mov	 eax, DWORD PTR [esi+ecx*8+4]
  000dc	89 45 e0	 mov	 DWORD PTR _NearbyBonus$1$[ebp], eax
$LN5@GetExpBonu:

; 597  : 	for( int j = 0; j < this->m_BonusInfo.m_NearbyBonus.size(); j++ )

  000df	41		 inc	 ecx
  000e0	3b ca		 cmp	 ecx, edx
  000e2	72 ec		 jb	 SHORT $LL7@GetExpBonu
  000e4	8b 55 f0	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN6@GetExpBonu:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  000e7	8b 8a 68 88 0a
	00		 mov	 ecx, DWORD PTR [edx+690280]
  000ed	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000f2	2b 8a 64 88 0a
	00		 sub	 ecx, DWORD PTR [edx+690276]
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 605  : 	for( int n = 0; n < this->m_BonusInfo.m_ClassBonus.size(); n++ )

  000f8	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  000fa	f7 e9		 imul	 ecx
  000fc	d1 fa		 sar	 edx, 1
  000fe	8b ca		 mov	 ecx, edx
  00100	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00103	03 ca		 add	 ecx, edx
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 605  : 	for( int n = 0; n < this->m_BonusInfo.m_ClassBonus.size(); n++ )

  00105	74 4b		 je	 SHORT $LN9@GetExpBonu

; 606  : 	{
; 607  : 		if( memcmp(this->m_BonusInfo.m_ClassBonus[n].m_ClassTable, 
; 608  : 			ClassTable, MAX_TYPE_PLAYER) == 0 )

  00107	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]
  0010a	8b 88 68 88 0a
	00		 mov	 ecx, DWORD PTR [eax+690280]
  00110	8b b0 64 88 0a
	00		 mov	 esi, DWORD PTR [eax+690276]
  00116	2b ce		 sub	 ecx, esi
  00118	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0011d	f7 e9		 imul	 ecx
  0011f	d1 fa		 sar	 edx, 1
  00121	8b ca		 mov	 ecx, edx
  00123	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00126	03 ca		 add	 ecx, edx
$LL10@GetExpBonu:
  00128	8b 06		 mov	 eax, DWORD PTR [esi]
  0012a	8d 55 f4	 lea	 edx, DWORD PTR _ClassTable$[ebp]
  0012d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0012f	75 19		 jne	 SHORT $LN8@GetExpBonu
  00131	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  00135	66 3b 42 04	 cmp	 ax, WORD PTR [edx+4]
  00139	75 0f		 jne	 SHORT $LN8@GetExpBonu
  0013b	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  0013f	3a 42 06	 cmp	 al, BYTE PTR [edx+6]
  00142	75 06		 jne	 SHORT $LN8@GetExpBonu

; 609  : 		{
; 610  : 			ClassBonus = this->m_BonusInfo.m_ClassBonus[n].m_AddExp;

  00144	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00147	89 45 e4	 mov	 DWORD PTR _ClassBonus$1$[ebp], eax
$LN8@GetExpBonu:

; 605  : 	for( int n = 0; n < this->m_BonusInfo.m_ClassBonus.size(); n++ )

  0014a	47		 inc	 edi
  0014b	83 c6 0c	 add	 esi, 12			; 0000000cH
  0014e	3b f9		 cmp	 edi, ecx
  00150	72 d6		 jb	 SHORT $LL10@GetExpBonu
$LN9@GetExpBonu:

; 611  : 		}
; 612  : 	}
; 613  : 	// ----
; 614  : 	return ClassBonus + NearbyBonus;

  00152	8b 45 e4	 mov	 eax, DWORD PTR _ClassBonus$1$[ebp]
  00155	03 45 e0	 add	 eax, DWORD PTR _NearbyBonus$1$[ebp]
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
$LN1@GetExpBonu:

; 615  : }

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015e	33 cd		 xor	 ecx, ebp
  00160	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c2 0c 00	 ret	 12			; 0000000cH
?GetExpBonus@PartyClass@@QAEHPAUOBJECTSTRUCT@@0H@Z ENDP	; PartyClass::GetExpBonus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?ReadBonusInfo@PartyClass@@QAEXPAD@Z
_TEXT	SEGMENT
_Result$ = -296						; size = 12
$T2 = -284						; size = 4
$T3 = -280						; size = 4
$T4 = -276						; size = 4
$T5 = -272						; size = 4
$T6 = -268						; size = 4
$T7 = -264						; size = 4
$T8 = -264						; size = 4
_ClassBonus$ = -260					; size = 4
_NearbyBonus$ = -256					; size = 4
$T9 = -252						; size = 4
$T10 = -252						; size = 4
$T11 = -252						; size = 4
$T12 = -248						; size = 4
$T13 = -248						; size = 4
$T14 = -248						; size = 4
_BonusInfo$ = -244					; size = 4
_lpInfo$15 = -240					; size = 8
$T16 = -236						; size = 4
_Node$ = -232						; size = 4
_Document$ = -228					; size = 200
_lpInfo$17 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_File$ = 8						; size = 4
?ReadBonusInfo@PartyClass@@QAEXPAD@Z PROC		; PartyClass::ReadBonusInfo, COMDAT
; _this$ = ecx

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReadBonusInfo@PartyClass@@QAEXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f9		 mov	 edi, ecx
  00030	8b 75 08	 mov	 esi, DWORD PTR _File$[ebp]

; 515  : 	xml_document Document;

  00033	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00039	e8 00 00 00 00	 call	 ??0xml_document@pugi@@QAE@XZ ; pugi::xml_document::xml_document

; 516  : 	xml_parse_result Result = Document.load_file(File);

  0003e	6a 00		 push	 0
  00040	6a 74		 push	 116			; 00000074H
  00042	56		 push	 esi
  00043	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _Result$[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	50		 push	 eax
  00051	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00057	e8 00 00 00 00	 call	 ?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z ; pugi::xml_document::load_file

; 517  : 	// ----
; 518  : 	if( Result.status != status_ok )

  0005c	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _Result$[ebp], 0
  00063	74 13		 je	 SHORT $LN8@ReadBonusI

; 519  : 	{
; 520  : 		MsgBox("[Notice] File %s not found!", File);

  00065	56		 push	 esi
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LALPKKLG@?$FLNotice?$FN?5File?5?$CFs?5not?5found?$CB?$AA@
  0006b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00070	83 c4 08	 add	 esp, 8
  00073	e9 03 03 00 00	 jmp	 $LN6@ReadBonusI
$LN8@ReadBonusI:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00078	8b 87 58 88 0a
	00		 mov	 eax, DWORD PTR [edi+690264]
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 524  : 	this->m_BonusInfo.m_NearbyBonus.clear();

  0007e	8d b7 58 88 0a
	00		 lea	 esi, DWORD PTR [edi+690264]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00084	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 525  : 	this->m_BonusInfo.m_ClassBonus.clear();

  00087	8d 9f 64 88 0a
	00		 lea	 ebx, DWORD PTR [edi+690276]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0008d	8b 03		 mov	 eax, DWORD PTR [ebx]
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 527  : 	xml_node BonusInfo = Document.child("partybonus");

  0008f	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00095	89 43 04	 mov	 DWORD PTR [ebx+4], eax
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 527  : 	xml_node BonusInfo = Document.child("partybonus");

  00098	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _BonusInfo$[ebp]
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IEPNMBM@partybonus?$AA@
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 528  : 	xml_node NearbyBonus = BonusInfo.child("partymembernearby");

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CJJHODAB@partymembernearby?$AA@
  000ae	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _NearbyBonus$[ebp]
  000b4	50		 push	 eax
  000b5	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _BonusInfo$[ebp]
  000bb	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 529  : 	xml_node ClassBonus = BonusInfo.child("partymemberclass");

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IEGGGIGJ@partymemberclass?$AA@
  000c5	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _ClassBonus$[ebp]
  000cb	50		 push	 eax
  000cc	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _BonusInfo$[ebp]
  000d2	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 530  : 	xml_node Node;

  000d7	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  000dd	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node

; 532  : 	for( Node = NearbyBonus.child("bonus"); Node; Node = Node.next_sibling() )

  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_05JNLCBACP@bonus?$AA@
  000e7	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  000ed	50		 push	 eax
  000ee	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _NearbyBonus$[ebp]
  000f4	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  000f9	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  000ff	8b 00		 mov	 eax, DWORD PTR [eax]
  00101	89 85 18 ff ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  00107	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  0010c	85 c0		 test	 eax, eax
  0010e	0f 84 e5 00 00
	00		 je	 $LN3@ReadBonusI
  00114	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@ReadBonusI:

; 533  : 	{
; 534  : 		PartyBonusByNearby lpInfo;
; 535  : 		lpInfo.m_NearbyCount = Node.attribute("nearbycount").as_int();

  00120	6a 00		 push	 0
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KPHNJNMB@nearbycount?$AA@
  00127	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  0012d	50		 push	 eax
  0012e	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00134	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00139	8b c8		 mov	 ecx, eax
  0013b	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00140	88 85 10 ff ff
	ff		 mov	 BYTE PTR _lpInfo$15[ebp], al

; 536  : 		lpInfo.m_AddExp = Node.text().as_int();

  00146	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0014c	6a 00		 push	 0
  0014e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  0015a	8b c8		 mov	 ecx, eax
  0015c	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00161	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 536  : 		lpInfo.m_AddExp = Node.text().as_int();

  00164	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00166	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _lpInfo$15[ebp]
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 536  : 		lpInfo.m_AddExp = Node.text().as_int();

  0016c	89 bd 14 ff ff
	ff		 mov	 DWORD PTR _lpInfo$15[ebp+4], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00172	3b c1		 cmp	 eax, ecx
  00174	73 32		 jae	 SHORT $LN91@ReadBonusI
  00176	8b 16		 mov	 edx, DWORD PTR [esi]
  00178	3b d0		 cmp	 edx, eax
  0017a	77 2c		 ja	 SHORT $LN91@ReadBonusI

; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  0017c	8b f8		 mov	 edi, eax
  0017e	2b fa		 sub	 edi, edx
  00180	c1 ff 03	 sar	 edi, 3

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00183	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00186	75 09		 jne	 SHORT $LN93@ReadBonusI

; 1279 : 				_Reserve(1);

  00188	6a 01		 push	 1
  0018a	8b ce		 mov	 ecx, esi
  0018c	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reserve
$LN93@ReadBonusI:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00191	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00194	85 d2		 test	 edx, edx
  00196	74 30		 je	 SHORT $LN294@ReadBonusI
  00198	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019a	8b 04 f9	 mov	 eax, DWORD PTR [ecx+edi*8]
  0019d	89 02		 mov	 DWORD PTR [edx], eax
  0019f	8b 44 f9 04	 mov	 eax, DWORD PTR [ecx+edi*8+4]
  001a3	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 		else

  001a6	eb 20		 jmp	 SHORT $LN294@ReadBonusI
$LN91@ReadBonusI:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  001a8	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  001ab	75 09		 jne	 SHORT $LN94@ReadBonusI

; 1288 : 				_Reserve(1);

  001ad	6a 01		 push	 1
  001af	8b ce		 mov	 ecx, esi
  001b1	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reserve
$LN94@ReadBonusI:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  001b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001b9	85 c9		 test	 ecx, ecx
  001bb	74 0b		 je	 SHORT $LN294@ReadBonusI
  001bd	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _lpInfo$15[ebp]
  001c3	89 01		 mov	 DWORD PTR [ecx], eax
  001c5	89 79 04	 mov	 DWORD PTR [ecx+4], edi
$LN294@ReadBonusI:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  001c8	83 46 04 08	 add	 DWORD PTR [esi+4], 8
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 532  : 	for( Node = NearbyBonus.child("bonus"); Node; Node = Node.next_sibling() )

  001cc	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  001d2	50		 push	 eax
  001d3	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  001d9	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  001de	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  001e4	8b 00		 mov	 eax, DWORD PTR [eax]
  001e6	89 85 18 ff ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  001ec	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  001f1	85 c0		 test	 eax, eax
  001f3	0f 85 27 ff ff
	ff		 jne	 $LL4@ReadBonusI
$LN3@ReadBonusI:

; 537  : 		this->m_BonusInfo.m_NearbyBonus.push_back(lpInfo);
; 538  : 	}
; 539  : 	// ----
; 540  : 	for( Node = ClassBonus.child("bonus"); Node; Node = Node.next_sibling() )

  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_05JNLCBACP@bonus?$AA@
  001fe	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00204	50		 push	 eax
  00205	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _ClassBonus$[ebp]
  0020b	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00210	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00216	8b 00		 mov	 eax, DWORD PTR [eax]
  00218	89 85 18 ff ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  0021e	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00223	85 c0		 test	 eax, eax
  00225	0f 84 50 01 00
	00		 je	 $LN6@ReadBonusI
  0022b	0f 1f 44 00 00	 npad	 5
$LL7@ReadBonusI:

; 541  : 	{
; 542  : 		PartyBonusByClass lpInfo;
; 543  : 		lpInfo.m_ClassTable[0] = Node.attribute("dw").as_int();

  00230	6a 00		 push	 0
  00232	68 00 00 00 00	 push	 OFFSET ??_C@_02CPBOKKCA@dw?$AA@
  00237	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  0023d	50		 push	 eax
  0023e	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00244	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00249	8b c8		 mov	 ecx, eax
  0024b	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 544  : 		lpInfo.m_ClassTable[1] = Node.attribute("dk").as_int();

  00250	6a 00		 push	 0
  00252	88 45 e4	 mov	 BYTE PTR _lpInfo$17[ebp], al
  00255	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0025b	68 00 00 00 00	 push	 OFFSET ??_C@_02MJGJPHHN@dk?$AA@
  00260	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0026c	8b c8		 mov	 ecx, eax
  0026e	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 545  : 		lpInfo.m_ClassTable[2] = Node.attribute("elf").as_int();

  00273	6a 00		 push	 0
  00275	88 45 e5	 mov	 BYTE PTR _lpInfo$17[ebp+1], al
  00278	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_03KACJNJLH@elf?$AA@
  00283	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  00289	50		 push	 eax
  0028a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0028f	8b c8		 mov	 ecx, eax
  00291	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 546  : 		lpInfo.m_ClassTable[3] = Node.attribute("mg").as_int();

  00296	6a 00		 push	 0
  00298	88 45 e6	 mov	 BYTE PTR _lpInfo$17[ebp+2], al
  0029b	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002a1	68 00 00 00 00	 push	 OFFSET ??_C@_02GKANIDPO@mg?$AA@
  002a6	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  002ac	50		 push	 eax
  002ad	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  002b2	8b c8		 mov	 ecx, eax
  002b4	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 547  : 		lpInfo.m_ClassTable[4] = Node.attribute("dl").as_int();

  002b9	6a 00		 push	 0
  002bb	88 45 e7	 mov	 BYTE PTR _lpInfo$17[ebp+3], al
  002be	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_02IGCIGBLK@dl?$AA@
  002c9	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  002d5	8b c8		 mov	 ecx, eax
  002d7	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 548  : 		lpInfo.m_ClassTable[5] = Node.attribute("sum").as_int();

  002dc	6a 00		 push	 0
  002de	88 45 e8	 mov	 BYTE PTR _lpInfo$17[ebp+4], al
  002e1	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002e7	68 00 00 00 00	 push	 OFFSET ??_C@_03CFFIJAMA@sum?$AA@
  002ec	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  002f2	50		 push	 eax
  002f3	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  002f8	8b c8		 mov	 ecx, eax
  002fa	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 549  : 		lpInfo.m_ClassTable[6] = Node.attribute("rf").as_int();

  002ff	6a 00		 push	 0
  00301	88 45 e9	 mov	 BYTE PTR _lpInfo$17[ebp+5], al
  00304	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0030a	68 00 00 00 00	 push	 OFFSET ??_C@_02GEGMFGPC@rf?$AA@
  0030f	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00315	50		 push	 eax
  00316	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0031b	8b c8		 mov	 ecx, eax
  0031d	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
  00322	88 45 ea	 mov	 BYTE PTR _lpInfo$17[ebp+6], al

; 550  : 		lpInfo.m_AddExp = Node.text().as_int();

  00325	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0032b	6a 00		 push	 0
  0032d	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00333	50		 push	 eax
  00334	e8 00 00 00 00	 call	 ?text@xml_node@pugi@@QBE?AVxml_text@2@XZ ; pugi::xml_node::text
  00339	8b c8		 mov	 ecx, eax
  0033b	e8 00 00 00 00	 call	 ?as_int@xml_text@pugi@@QBEHH@Z ; pugi::xml_text::as_int
  00340	89 45 ec	 mov	 DWORD PTR _lpInfo$17[ebp+8], eax

; 551  : 		this->m_BonusInfo.m_ClassBonus.push_back(lpInfo);

  00343	8b cb		 mov	 ecx, ebx
  00345	8d 45 e4	 lea	 eax, DWORD PTR _lpInfo$17[ebp]
  00348	50		 push	 eax
  00349	e8 00 00 00 00	 call	 ?push_back@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXABUPartyBonusByClass@@@Z ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::push_back
  0034e	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00354	50		 push	 eax
  00355	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0035b	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  00360	8b 00		 mov	 eax, DWORD PTR [eax]
  00362	89 85 18 ff ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax

; 537  : 		this->m_BonusInfo.m_NearbyBonus.push_back(lpInfo);
; 538  : 	}
; 539  : 	// ----
; 540  : 	for( Node = ClassBonus.child("bonus"); Node; Node = Node.next_sibling() )

  00368	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0036e	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00373	85 c0		 test	 eax, eax
  00375	0f 85 b5 fe ff
	ff		 jne	 $LL7@ReadBonusI
$LN6@ReadBonusI:

; 552  : 	}
; 553  : }

  0037b	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00381	e8 00 00 00 00	 call	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
  00386	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00389	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00390	59		 pop	 ecx
  00391	5f		 pop	 edi
  00392	5e		 pop	 esi
  00393	5b		 pop	 ebx
  00394	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00397	33 cd		 xor	 ecx, ebp
  00399	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039e	8b e5		 mov	 esp, ebp
  003a0	5d		 pop	 ebp
  003a1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadBonusInfo@PartyClass@@QAEXPAD@Z$0:
  00000	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
__ehhandler$?ReadBonusInfo@PartyClass@@QAEXPAD@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a d4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-300]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReadBonusInfo@PartyClass@@QAEXPAD@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReadBonusInfo@PartyClass@@QAEXPAD@Z ENDP		; PartyClass::ReadBonusInfo
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?ResetLeader@PartyClass@@QAEXH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?ResetLeader@PartyClass@@QAEXH@Z PROC			; PartyClass::ResetLeader, COMDAT
; _this$ = ecx

; 491  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 492  : 	int Number = 0;
; 493  : 
; 494  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++ )

  00003	8b 55 08	 mov	 edx, DWORD PTR _party_number$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b f2		 mov	 esi, edx
  0000c	c1 e6 04	 shl	 esi, 4
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	2b f2		 sub	 esi, edx
  00014	8d 1c b7	 lea	 ebx, DWORD PTR [edi+esi*4]
  00017	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@ResetLeade:

; 495  : 	{
; 496  : 		Number = m_PartyS[party_number].Number[i];
; 497  : 
; 498  : 		if( Number >= 0 )

  00020	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00023	7d 10		 jge	 SHORT $LN8@ResetLeade

; 492  : 	int Number = 0;
; 493  : 
; 494  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++ )

  00025	40		 inc	 eax
  00026	83 c1 04	 add	 ecx, 4
  00029	83 f8 05	 cmp	 eax, 5
  0002c	7c f2		 jl	 SHORT $LL4@ResetLeade
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx

; 508  : 			break;
; 509  : 		}
; 510  : 	}
; 511  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN8@ResetLeade:

; 499  : 		{
; 500  : 			m_PartyS[party_number].Number[0] = m_PartyS[party_number].Number[i];

  00035	8b ca		 mov	 ecx, edx
  00037	c1 e1 04	 shl	 ecx, 4
  0003a	2b ca		 sub	 ecx, edx
  0003c	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  0003f	8b 4c 97 0c	 mov	 ecx, DWORD PTR [edi+edx*4+12]
  00043	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx

; 501  : 			m_PartyS[party_number].Number[i] = -1;
; 502  : 
; 503  : 			m_PartyS[party_number].DbNumber[0] = m_PartyS[party_number].DbNumber[i];

  00046	8b 4c 97 20	 mov	 ecx, DWORD PTR [edi+edx*4+32]
  0004a	c7 44 97 0c ff
	ff ff ff	 mov	 DWORD PTR [edi+edx*4+12], -1
  00052	89 4c b7 20	 mov	 DWORD PTR [edi+esi*4+32], ecx

; 504  : 			m_PartyS[party_number].DbNumber[i] = -1;
; 505  : 
; 506  : 			m_PartyS[party_number].m_PkLevel[0] = m_PartyS[party_number].m_PkLevel[i];

  00056	8d 0c b0	 lea	 ecx, DWORD PTR [eax+esi*4]
  00059	c7 44 97 20 ff
	ff ff ff	 mov	 DWORD PTR [edi+edx*4+32], -1
  00061	8a 44 39 38	 mov	 al, BYTE PTR [ecx+edi+56]
  00065	88 44 b7 38	 mov	 BYTE PTR [edi+esi*4+56], al

; 507  : 			m_PartyS[party_number].m_PkLevel[i] = 3;

  00069	c6 44 39 38 03	 mov	 BYTE PTR [ecx+edi+56], 3
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 508  : 			break;
; 509  : 		}
; 510  : 	}
; 511  : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?ResetLeader@PartyClass@@QAEXH@Z ENDP			; PartyClass::ResetLeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?SetPkCount@PartyClass@@QAEXH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?SetPkCount@PartyClass@@QAEXH@Z PROC			; PartyClass::SetPkCount, COMDAT
; _this$ = ecx

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 461  : 	int PkCount = 0;
; 462  : 	int Number = 0;
; 463  : 
; 464  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 465  : 	{
; 466  : 		Number = this->m_PartyS[party_number].Number[i];
; 467  : 
; 468  : 		if( Number >= 0 )

  00005	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00008	33 d2		 xor	 edx, edx
  0000a	57		 push	 edi
  0000b	8b fe		 mov	 edi, esi
  0000d	c1 e7 04	 shl	 edi, 4
  00010	2b fe		 sub	 edi, esi
  00012	39 54 b9 0c	 cmp	 DWORD PTR [ecx+edi*4+12], edx
  00016	7c 1f		 jl	 SHORT $LN2@SetPkCount

; 469  : 		{
; 470  : 			if( m_PartyS[party_number].m_PkLevel[i] >= 5 )

  00018	8b c6		 mov	 eax, esi
  0001a	c1 e0 04	 shl	 eax, 4
  0001d	2b c6		 sub	 eax, esi
  0001f	8a 5c 81 38	 mov	 bl, BYTE PTR [ecx+eax*4+56]
  00023	80 fb 05	 cmp	 bl, 5
  00026	7c 0f		 jl	 SHORT $LN2@SetPkCount

; 471  : 			{
; 472  : 				if( m_PartyS[party_number].m_PartyPkLevel < m_PartyS[party_number].m_PkLevel[i] )

  00028	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  0002c	7d 04		 jge	 SHORT $LN7@SetPkCount

; 473  : 				{
; 474  : 					m_PartyS[party_number].m_PartyPkLevel = m_PartyS[party_number].m_PkLevel[i];

  0002e	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN7@SetPkCount:

; 475  : 				}
; 476  : 
; 477  : 				PkCount++;

  00032	ba 01 00 00 00	 mov	 edx, 1
$LN2@SetPkCount:

; 461  : 	int PkCount = 0;
; 462  : 	int Number = 0;
; 463  : 
; 464  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 465  : 	{
; 466  : 		Number = this->m_PartyS[party_number].Number[i];
; 467  : 
; 468  : 		if( Number >= 0 )

  00037	83 7c b9 10 00	 cmp	 DWORD PTR [ecx+edi*4+16], 0
  0003c	7c 1b		 jl	 SHORT $LN19@SetPkCount

; 469  : 		{
; 470  : 			if( m_PartyS[party_number].m_PkLevel[i] >= 5 )

  0003e	8b c6		 mov	 eax, esi
  00040	c1 e0 04	 shl	 eax, 4
  00043	2b c6		 sub	 eax, esi
  00045	8a 5c 81 39	 mov	 bl, BYTE PTR [ecx+eax*4+57]
  00049	80 fb 05	 cmp	 bl, 5
  0004c	7c 0b		 jl	 SHORT $LN19@SetPkCount

; 471  : 			{
; 472  : 				if( m_PartyS[party_number].m_PartyPkLevel < m_PartyS[party_number].m_PkLevel[i] )

  0004e	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  00052	7d 04		 jge	 SHORT $LN18@SetPkCount

; 473  : 				{
; 474  : 					m_PartyS[party_number].m_PartyPkLevel = m_PartyS[party_number].m_PkLevel[i];

  00054	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN18@SetPkCount:

; 475  : 				}
; 476  : 
; 477  : 				PkCount++;

  00058	42		 inc	 edx
$LN19@SetPkCount:

; 461  : 	int PkCount = 0;
; 462  : 	int Number = 0;
; 463  : 
; 464  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 465  : 	{
; 466  : 		Number = this->m_PartyS[party_number].Number[i];
; 467  : 
; 468  : 		if( Number >= 0 )

  00059	83 7c b9 14 00	 cmp	 DWORD PTR [ecx+edi*4+20], 0
  0005e	7c 1b		 jl	 SHORT $LN22@SetPkCount

; 469  : 		{
; 470  : 			if( m_PartyS[party_number].m_PkLevel[i] >= 5 )

  00060	8b c6		 mov	 eax, esi
  00062	c1 e0 04	 shl	 eax, 4
  00065	2b c6		 sub	 eax, esi
  00067	8a 5c 81 3a	 mov	 bl, BYTE PTR [ecx+eax*4+58]
  0006b	80 fb 05	 cmp	 bl, 5
  0006e	7c 0b		 jl	 SHORT $LN22@SetPkCount

; 471  : 			{
; 472  : 				if( m_PartyS[party_number].m_PartyPkLevel < m_PartyS[party_number].m_PkLevel[i] )

  00070	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  00074	7d 04		 jge	 SHORT $LN21@SetPkCount

; 473  : 				{
; 474  : 					m_PartyS[party_number].m_PartyPkLevel = m_PartyS[party_number].m_PkLevel[i];

  00076	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN21@SetPkCount:

; 475  : 				}
; 476  : 
; 477  : 				PkCount++;

  0007a	42		 inc	 edx
$LN22@SetPkCount:

; 461  : 	int PkCount = 0;
; 462  : 	int Number = 0;
; 463  : 
; 464  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 465  : 	{
; 466  : 		Number = this->m_PartyS[party_number].Number[i];
; 467  : 
; 468  : 		if( Number >= 0 )

  0007b	83 7c b9 18 00	 cmp	 DWORD PTR [ecx+edi*4+24], 0
  00080	7c 1b		 jl	 SHORT $LN25@SetPkCount

; 469  : 		{
; 470  : 			if( m_PartyS[party_number].m_PkLevel[i] >= 5 )

  00082	8b c6		 mov	 eax, esi
  00084	c1 e0 04	 shl	 eax, 4
  00087	2b c6		 sub	 eax, esi
  00089	8a 5c 81 3b	 mov	 bl, BYTE PTR [ecx+eax*4+59]
  0008d	80 fb 05	 cmp	 bl, 5
  00090	7c 0b		 jl	 SHORT $LN25@SetPkCount

; 471  : 			{
; 472  : 				if( m_PartyS[party_number].m_PartyPkLevel < m_PartyS[party_number].m_PkLevel[i] )

  00092	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  00096	7d 04		 jge	 SHORT $LN24@SetPkCount

; 473  : 				{
; 474  : 					m_PartyS[party_number].m_PartyPkLevel = m_PartyS[party_number].m_PkLevel[i];

  00098	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN24@SetPkCount:

; 475  : 				}
; 476  : 
; 477  : 				PkCount++;

  0009c	42		 inc	 edx
$LN25@SetPkCount:

; 461  : 	int PkCount = 0;
; 462  : 	int Number = 0;
; 463  : 
; 464  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 465  : 	{
; 466  : 		Number = this->m_PartyS[party_number].Number[i];
; 467  : 
; 468  : 		if( Number >= 0 )

  0009d	83 7c b9 1c 00	 cmp	 DWORD PTR [ecx+edi*4+28], 0
  000a2	7c 1b		 jl	 SHORT $LN28@SetPkCount

; 469  : 		{
; 470  : 			if( m_PartyS[party_number].m_PkLevel[i] >= 5 )

  000a4	8b c6		 mov	 eax, esi
  000a6	c1 e0 04	 shl	 eax, 4
  000a9	2b c6		 sub	 eax, esi
  000ab	8a 5c 81 3c	 mov	 bl, BYTE PTR [ecx+eax*4+60]
  000af	80 fb 05	 cmp	 bl, 5
  000b2	7c 0b		 jl	 SHORT $LN28@SetPkCount

; 471  : 			{
; 472  : 				if( m_PartyS[party_number].m_PartyPkLevel < m_PartyS[party_number].m_PkLevel[i] )

  000b4	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  000b8	7d 04		 jge	 SHORT $LN27@SetPkCount

; 473  : 				{
; 474  : 					m_PartyS[party_number].m_PartyPkLevel = m_PartyS[party_number].m_PkLevel[i];

  000ba	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN27@SetPkCount:

; 475  : 				}
; 476  : 
; 477  : 				PkCount++;

  000be	42		 inc	 edx
$LN28@SetPkCount:

; 478  : 			}
; 479  : 		}
; 480  : 	}
; 481  : 
; 482  : 	m_PartyS[party_number].m_PkCount = PkCount;

  000bf	8b c6		 mov	 eax, esi
  000c1	c1 e0 04	 shl	 eax, 4
  000c4	2b c6		 sub	 eax, esi
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	89 54 81 40	 mov	 DWORD PTR [ecx+eax*4+64], edx

; 483  : 
; 484  : 	if( PkCount = 0 )
; 485  : 	{
; 486  : 		m_PartyS[party_number].m_PartyPkLevel = 3;
; 487  : 	}
; 488  : }

  000cd	5d		 pop	 ebp
  000ce	c2 04 00	 ret	 4
?SetPkCount@PartyClass@@QAEXH@Z ENDP			; PartyClass::SetPkCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?SetPkLevel@PartyClass@@QAEXHHHE@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_usernumber$ = 12					; size = 4
_dbnumber$ = 16						; size = 4
_PkLevel$ = 20						; size = 1
?SetPkLevel@PartyClass@@QAEXHHHE@Z PROC			; PartyClass::SetPkLevel, COMDAT
; _this$ = ecx

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 441  : 	if( this->IsParty(party_number) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _party_number$[ebp]
  00007	56		 push	 esi
  00008	53		 push	 ebx
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	74 4b		 je	 SHORT $LN14@SetPkLevel

; 442  : 	{
; 443  : 		return;
; 444  : 	}
; 445  : 
; 446  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  00017	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0001a	57		 push	 edi
  0001b	8b fb		 mov	 edi, ebx
  0001d	33 c0		 xor	 eax, eax
  0001f	c1 e7 04	 shl	 edi, 4
  00022	2b fb		 sub	 edi, ebx
  00024	8d 14 ba	 lea	 edx, DWORD PTR [edx+edi*4]
$LL4@SetPkLevel:

; 447  : 	{
; 448  : 		if( this->m_PartyS[party_number].Number[i] == usernumber )

  00027	39 0a		 cmp	 DWORD PTR [edx], ecx
  00029	75 12		 jne	 SHORT $LN2@SetPkLevel

; 449  : 		{
; 450  : 			if( this->m_PartyS[party_number].DbNumber[i] == dbnumber )

  0002b	8b 5d 10	 mov	 ebx, DWORD PTR _dbnumber$[ebp]
  0002e	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00031	39 5c 8e 20	 cmp	 DWORD PTR [esi+ecx*4+32], ebx
  00035	8b 5d 08	 mov	 ebx, DWORD PTR _party_number$[ebp]
  00038	74 13		 je	 SHORT $LN10@SetPkLevel
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _usernumber$[ebp]
$LN2@SetPkLevel:

; 442  : 	{
; 443  : 		return;
; 444  : 	}
; 445  : 
; 446  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)

  0003d	40		 inc	 eax
  0003e	83 c2 04	 add	 edx, 4
  00041	83 f8 05	 cmp	 eax, 5
  00044	7c e1		 jl	 SHORT $LL4@SetPkLevel
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx

; 453  : 				break;
; 454  : 			}
; 455  : 		}
; 456  : 	}
; 457  : }

  00049	5d		 pop	 ebp
  0004a	c2 10 00	 ret	 16			; 00000010H
$LN10@SetPkLevel:

; 451  : 			{
; 452  : 				this->m_PartyS[party_number].m_PkLevel[i] = PkLevel;

  0004d	8b cb		 mov	 ecx, ebx
  0004f	c1 e1 04	 shl	 ecx, 4
  00052	2b cb		 sub	 ecx, ebx
  00054	5f		 pop	 edi
  00055	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00058	8a 45 14	 mov	 al, BYTE PTR _PkLevel$[ebp]
  0005b	88 44 31 38	 mov	 BYTE PTR [ecx+esi+56], al
$LN14@SetPkLevel:
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 453  : 				break;
; 454  : 			}
; 455  : 		}
; 456  : 	}
; 457  : }

  00061	5d		 pop	 ebp
  00062	c2 10 00	 ret	 16			; 00000010H
?SetPkLevel@PartyClass@@QAEXHHHE@Z ENDP			; PartyClass::SetPkLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetPartyPkLevel@PartyClass@@QAEDH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?GetPartyPkLevel@PartyClass@@QAEDH@Z PROC		; PartyClass::GetPartyPkLevel, COMDAT
; _this$ = ecx

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 436  : 	return this->m_PartyS[party_number].m_PartyPkLevel;

  00003	8b 45 08	 mov	 eax, DWORD PTR _party_number$[ebp]
  00006	c1 e0 04	 shl	 eax, 4
  00009	2b 45 08	 sub	 eax, DWORD PTR _party_number$[ebp]
  0000c	8a 44 81 3d	 mov	 al, BYTE PTR [ecx+eax*4+61]

; 437  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?GetPartyPkLevel@PartyClass@@QAEDH@Z ENDP		; PartyClass::GetPartyPkLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?ChangeLeader@PartyClass@@QAEXH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?ChangeLeader@PartyClass@@QAEXH@Z PROC			; PartyClass::ChangeLeader, COMDAT
; _this$ = ecx

; 757  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 758  : 	int usern = 0;
; 759  : 
; 760  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)

  00003	8b 55 08	 mov	 edx, DWORD PTR _party_number$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b f2		 mov	 esi, edx
  0000c	c1 e6 04	 shl	 esi, 4
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	2b f2		 sub	 esi, edx
  00014	8d 1c b7	 lea	 ebx, DWORD PTR [edi+esi*4]
  00017	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@ChangeLead:

; 761  : 	{
; 762  : 		usern = this->m_PartyS[party_number].Number[i];
; 763  : 
; 764  : 		if( usern >= 0 )

  00020	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00023	7d 10		 jge	 SHORT $LN8@ChangeLead

; 758  : 	int usern = 0;
; 759  : 
; 760  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)

  00025	40		 inc	 eax
  00026	83 c1 04	 add	 ecx, 4
  00029	83 f8 05	 cmp	 eax, 5
  0002c	7c f2		 jl	 SHORT $LL4@ChangeLead
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx

; 774  : 			break;
; 775  : 		}
; 776  : 	}
; 777  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN8@ChangeLead:

; 765  : 		{
; 766  : 			this->m_PartyS[party_number].Number[0] = this->m_PartyS[party_number].Number[i];

  00035	8b ca		 mov	 ecx, edx
  00037	c1 e1 04	 shl	 ecx, 4
  0003a	2b ca		 sub	 ecx, edx
  0003c	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  0003f	8b 4c 97 0c	 mov	 ecx, DWORD PTR [edi+edx*4+12]
  00043	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx

; 767  : 			this->m_PartyS[party_number].Number[i] = -1;
; 768  : 
; 769  : 			this->m_PartyS[party_number].DbNumber[0] = this->m_PartyS[party_number].DbNumber[i];

  00046	8b 4c 97 20	 mov	 ecx, DWORD PTR [edi+edx*4+32]
  0004a	c7 44 97 0c ff
	ff ff ff	 mov	 DWORD PTR [edi+edx*4+12], -1
  00052	89 4c b7 20	 mov	 DWORD PTR [edi+esi*4+32], ecx

; 770  : 			this->m_PartyS[party_number].DbNumber[i] = -1;
; 771  : 
; 772  : 			this->m_PartyS[party_number].m_PkLevel[0] = this->m_PartyS[party_number].m_PkLevel[i];

  00056	8d 0c b0	 lea	 ecx, DWORD PTR [eax+esi*4]
  00059	c7 44 97 20 ff
	ff ff ff	 mov	 DWORD PTR [edi+edx*4+32], -1
  00061	8a 44 39 38	 mov	 al, BYTE PTR [ecx+edi+56]
  00065	88 44 b7 38	 mov	 BYTE PTR [edi+esi*4+56], al

; 773  : 			this->m_PartyS[party_number].m_PkLevel[i] = -1;

  00069	c6 44 39 38 ff	 mov	 BYTE PTR [ecx+edi+56], -1
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 774  : 			break;
; 775  : 		}
; 776  : 	}
; 777  : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?ChangeLeader@PartyClass@@QAEXH@Z ENDP			; PartyClass::ChangeLeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?SwitchLeader@PartyClass@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv287 = 8						; size = 4
_party_number$ = 8					; size = 4
?SwitchLeader@PartyClass@@QAEXH@Z PROC			; PartyClass::SwitchLeader, COMDAT
; _this$ = ecx

; 725  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 726  : 	int usern = 0;
; 727  : 	int tempUserNumber = 0;
; 728  : 	int tempDbNumber = 0;
; 729  : 	char tempUserPKLevel = 3;
; 730  : 
; 731  : 	if( !this->IsParty(party_number) )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _party_number$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	53		 push	 ebx
  0000c	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
  0000f	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00014	85 c0		 test	 eax, eax
  00016	0f 84 86 00 00
	00		 je	 $LN13@SwitchLead

; 732  : 		return;
; 733  : 
; 734  : 	for(int i = 1; i < MAX_USER_IN_PARTY; i++)

  0001c	57		 push	 edi
  0001d	8b fb		 mov	 edi, ebx
  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	c1 e7 04	 shl	 edi, 4
  00027	2b fb		 sub	 edi, ebx
  00029	8d 0c be	 lea	 ecx, DWORD PTR [esi+edi*4]
  0002c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	89 4d 08	 mov	 DWORD PTR tv287[ebp], ecx
  00035	8d 51 10	 lea	 edx, DWORD PTR [ecx+16]
$LL4@SwitchLead:

; 735  : 	{
; 736  : 		usern = this->m_PartyS[party_number].Number[i];

  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 737  : 
; 738  : 		if( usern >= 0 && gObj[usern].Connected == PLAYER_PLAYING )

  0003a	85 c9		 test	 ecx, ecx
  0003c	78 0d		 js	 SHORT $LN2@SwitchLead
  0003e	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  00044	83 7c 31 04 03	 cmp	 DWORD PTR [ecx+esi+4], 3
  00049	74 12		 je	 SHORT $LN9@SwitchLead
$LN2@SwitchLead:

; 732  : 		return;
; 733  : 
; 734  : 	for(int i = 1; i < MAX_USER_IN_PARTY; i++)

  0004b	40		 inc	 eax
  0004c	83 c2 04	 add	 edx, 4
  0004f	83 f8 05	 cmp	 eax, 5
  00052	7c e4		 jl	 SHORT $LL4@SwitchLead
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 751  : 			break;
; 752  : 		}
; 753  : 	}
; 754  : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN9@SwitchLead:

; 739  : 		{
; 740  : 			tempUserNumber = this->m_PartyS[party_number].Number[0];

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR tv287[ebp]

; 741  : 			this->m_PartyS[party_number].Number[0] = this->m_PartyS[party_number].Number[i];

  00060	8b f3		 mov	 esi, ebx
  00062	c1 e6 04	 shl	 esi, 4
  00065	2b f3		 sub	 esi, ebx
  00067	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0006a	03 f0		 add	 esi, eax
  0006c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006f	8b 4c b3 0c	 mov	 ecx, DWORD PTR [ebx+esi*4+12]
  00073	89 4c bb 0c	 mov	 DWORD PTR [ebx+edi*4+12], ecx

; 742  : 			this->m_PartyS[party_number].Number[i] = tempUserNumber;
; 743  : 
; 744  : 			tempDbNumber = this->m_PartyS[party_number].DbNumber[0];

  00077	8d 0c bb	 lea	 ecx, DWORD PTR [ebx+edi*4]
  0007a	89 54 b3 0c	 mov	 DWORD PTR [ebx+esi*4+12], edx
  0007e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]

; 745  : 			this->m_PartyS[party_number].DbNumber[0] = this->m_PartyS[party_number].DbNumber[i];

  00081	8b 4c b3 20	 mov	 ecx, DWORD PTR [ebx+esi*4+32]
  00085	89 4c bb 20	 mov	 DWORD PTR [ebx+edi*4+32], ecx

; 746  : 			this->m_PartyS[party_number].DbNumber[i] = tempDbNumber;
; 747  : 
; 748  : 			tempUserPKLevel = this->m_PartyS[party_number].m_PkLevel[0];
; 749  : 			this->m_PartyS[party_number].m_PkLevel[0] = this->m_PartyS[party_number].m_PkLevel[i];

  00089	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  0008c	89 54 b3 20	 mov	 DWORD PTR [ebx+esi*4+32], edx
  00090	8d 34 bb	 lea	 esi, DWORD PTR [ebx+edi*4]
  00093	8a 44 19 38	 mov	 al, BYTE PTR [ecx+ebx+56]
  00097	8a 56 38	 mov	 dl, BYTE PTR [esi+56]
  0009a	88 46 38	 mov	 BYTE PTR [esi+56], al

; 750  : 			this->m_PartyS[party_number].m_PkLevel[i] = tempUserPKLevel;

  0009d	88 54 19 38	 mov	 BYTE PTR [ecx+ebx+56], dl
  000a1	5f		 pop	 edi
$LN13@SwitchLead:
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 751  : 			break;
; 752  : 		}
; 753  : 	}
; 754  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?SwitchLeader@PartyClass@@QAEXH@Z ENDP			; PartyClass::SwitchLeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z PROC ; PartyClass::GetReallyConnectPartyMemberCount, COMDAT
; _this$ = ecx

; 704  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 705  : 	int nValidUserCount = 0;
; 706  : 	int usern = 0;
; 707  : 
; 708  : 	if( !this->IsParty(party_number) )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _party_number$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	53		 push	 ebx
  0000a	8b f9		 mov	 edi, ecx
  0000c	33 f6		 xor	 esi, esi
  0000e	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00013	85 c0		 test	 eax, eax
  00015	75 0a		 jne	 SHORT $LN5@GetReallyC

; 709  : 		return -1;

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	83 c8 ff	 or	 eax, -1
  0001c	5b		 pop	 ebx

; 722  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN5@GetReallyC:

; 714  : 
; 715  : 		if( usern >= 0 && gObj[usern].Connected == PLAYER_PLAYING )

  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	8b cb		 mov	 ecx, ebx
  00029	c1 e1 04	 shl	 ecx, 4
  0002c	2b cb		 sub	 ecx, ebx
  0002e	8b 44 8f 0c	 mov	 eax, DWORD PTR [edi+ecx*4+12]
  00032	85 c0		 test	 eax, eax
  00034	78 13		 js	 SHORT $LN2@GetReallyC
  00036	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0003c	bb 01 00 00 00	 mov	 ebx, 1
  00041	83 7c 10 04 03	 cmp	 DWORD PTR [eax+edx+4], 3
  00046	0f 44 f3	 cmove	 esi, ebx
$LN2@GetReallyC:
  00049	8b 44 8f 10	 mov	 eax, DWORD PTR [edi+ecx*4+16]
  0004d	85 c0		 test	 eax, eax
  0004f	78 0e		 js	 SHORT $LN15@GetReallyC
  00051	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00057	83 7c 10 04 03	 cmp	 DWORD PTR [eax+edx+4], 3
  0005c	75 01		 jne	 SHORT $LN15@GetReallyC

; 716  : 		{
; 717  : 			nValidUserCount++;

  0005e	46		 inc	 esi
$LN15@GetReallyC:

; 710  : 
; 711  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 712  : 	{
; 713  : 		usern = this->m_PartyS[party_number].Number[i];

  0005f	8b 44 8f 14	 mov	 eax, DWORD PTR [edi+ecx*4+20]

; 714  : 
; 715  : 		if( usern >= 0 && gObj[usern].Connected == PLAYER_PLAYING )

  00063	85 c0		 test	 eax, eax
  00065	78 0e		 js	 SHORT $LN17@GetReallyC
  00067	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0006d	83 7c 10 04 03	 cmp	 DWORD PTR [eax+edx+4], 3
  00072	75 01		 jne	 SHORT $LN17@GetReallyC

; 716  : 		{
; 717  : 			nValidUserCount++;

  00074	46		 inc	 esi
$LN17@GetReallyC:

; 710  : 
; 711  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 712  : 	{
; 713  : 		usern = this->m_PartyS[party_number].Number[i];

  00075	8b 44 8f 18	 mov	 eax, DWORD PTR [edi+ecx*4+24]

; 714  : 
; 715  : 		if( usern >= 0 && gObj[usern].Connected == PLAYER_PLAYING )

  00079	85 c0		 test	 eax, eax
  0007b	78 0e		 js	 SHORT $LN19@GetReallyC
  0007d	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00083	83 7c 10 04 03	 cmp	 DWORD PTR [eax+edx+4], 3
  00088	75 01		 jne	 SHORT $LN19@GetReallyC

; 716  : 		{
; 717  : 			nValidUserCount++;

  0008a	46		 inc	 esi
$LN19@GetReallyC:

; 710  : 
; 711  : 	for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 712  : 	{
; 713  : 		usern = this->m_PartyS[party_number].Number[i];

  0008b	8b 44 8f 1c	 mov	 eax, DWORD PTR [edi+ecx*4+28]

; 714  : 
; 715  : 		if( usern >= 0 && gObj[usern].Connected == PLAYER_PLAYING )

  0008f	85 c0		 test	 eax, eax
  00091	78 0e		 js	 SHORT $LN21@GetReallyC
  00093	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00099	83 7c 11 04 03	 cmp	 DWORD PTR [ecx+edx+4], 3
  0009e	75 01		 jne	 SHORT $LN21@GetReallyC

; 716  : 		{
; 717  : 			nValidUserCount++;

  000a0	46		 inc	 esi
$LN21@GetReallyC:
  000a1	5f		 pop	 edi

; 718  : 		}
; 719  : 	}
; 720  : 
; 721  : return nValidUserCount;

  000a2	8b c6		 mov	 eax, esi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx

; 722  : }

  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z ENDP ; PartyClass::GetReallyConnectPartyMemberCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z PROC		; PartyClass::UpdatePKPartyPanalty, COMDAT
; _this$ = ecx

; 672  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 673  : 	int PKUserCount = 0;
; 674  : 	int usern = 0;
; 675  : 	int i;
; 676  : 
; 677  : 	for( i = 0 ; i < MAX_USER_IN_PARTY; i++)
; 678  : 	{
; 679  : 		usern = this->m_PartyS[party_number].Number[i];
; 680  : 
; 681  : 		if( usern >= 0 )

  00005	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00008	33 d2		 xor	 edx, edx
  0000a	57		 push	 edi
  0000b	8b fe		 mov	 edi, esi
  0000d	c1 e7 04	 shl	 edi, 4
  00010	2b fe		 sub	 edi, esi
  00012	39 54 b9 0c	 cmp	 DWORD PTR [ecx+edi*4+12], edx
  00016	7c 1f		 jl	 SHORT $LN2@UpdatePKPa

; 682  : 		{
; 683  : 			if( this->m_PartyS[party_number].m_PkLevel[i] >= 5 )

  00018	8b c6		 mov	 eax, esi
  0001a	c1 e0 04	 shl	 eax, 4
  0001d	2b c6		 sub	 eax, esi
  0001f	8a 5c 81 38	 mov	 bl, BYTE PTR [ecx+eax*4+56]
  00023	80 fb 05	 cmp	 bl, 5
  00026	7c 0f		 jl	 SHORT $LN2@UpdatePKPa

; 684  : 			{
; 685  : 				if( this->m_PartyS[party_number].m_PartyPkLevel < this->m_PartyS[party_number].m_PkLevel[i] )

  00028	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  0002c	7d 04		 jge	 SHORT $LN7@UpdatePKPa

; 686  : 				{
; 687  : 					this->m_PartyS[party_number].m_PartyPkLevel = this->m_PartyS[party_number].m_PkLevel[i];

  0002e	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN7@UpdatePKPa:

; 688  : 				}
; 689  : 
; 690  : 				PKUserCount++;

  00032	ba 01 00 00 00	 mov	 edx, 1
$LN2@UpdatePKPa:

; 673  : 	int PKUserCount = 0;
; 674  : 	int usern = 0;
; 675  : 	int i;
; 676  : 
; 677  : 	for( i = 0 ; i < MAX_USER_IN_PARTY; i++)
; 678  : 	{
; 679  : 		usern = this->m_PartyS[party_number].Number[i];
; 680  : 
; 681  : 		if( usern >= 0 )

  00037	83 7c b9 10 00	 cmp	 DWORD PTR [ecx+edi*4+16], 0
  0003c	7c 1b		 jl	 SHORT $LN19@UpdatePKPa

; 682  : 		{
; 683  : 			if( this->m_PartyS[party_number].m_PkLevel[i] >= 5 )

  0003e	8b c6		 mov	 eax, esi
  00040	c1 e0 04	 shl	 eax, 4
  00043	2b c6		 sub	 eax, esi
  00045	8a 5c 81 39	 mov	 bl, BYTE PTR [ecx+eax*4+57]
  00049	80 fb 05	 cmp	 bl, 5
  0004c	7c 0b		 jl	 SHORT $LN19@UpdatePKPa

; 684  : 			{
; 685  : 				if( this->m_PartyS[party_number].m_PartyPkLevel < this->m_PartyS[party_number].m_PkLevel[i] )

  0004e	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  00052	7d 04		 jge	 SHORT $LN18@UpdatePKPa

; 686  : 				{
; 687  : 					this->m_PartyS[party_number].m_PartyPkLevel = this->m_PartyS[party_number].m_PkLevel[i];

  00054	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN18@UpdatePKPa:

; 688  : 				}
; 689  : 
; 690  : 				PKUserCount++;

  00058	42		 inc	 edx
$LN19@UpdatePKPa:

; 673  : 	int PKUserCount = 0;
; 674  : 	int usern = 0;
; 675  : 	int i;
; 676  : 
; 677  : 	for( i = 0 ; i < MAX_USER_IN_PARTY; i++)
; 678  : 	{
; 679  : 		usern = this->m_PartyS[party_number].Number[i];
; 680  : 
; 681  : 		if( usern >= 0 )

  00059	83 7c b9 14 00	 cmp	 DWORD PTR [ecx+edi*4+20], 0
  0005e	7c 1b		 jl	 SHORT $LN22@UpdatePKPa

; 682  : 		{
; 683  : 			if( this->m_PartyS[party_number].m_PkLevel[i] >= 5 )

  00060	8b c6		 mov	 eax, esi
  00062	c1 e0 04	 shl	 eax, 4
  00065	2b c6		 sub	 eax, esi
  00067	8a 5c 81 3a	 mov	 bl, BYTE PTR [ecx+eax*4+58]
  0006b	80 fb 05	 cmp	 bl, 5
  0006e	7c 0b		 jl	 SHORT $LN22@UpdatePKPa

; 684  : 			{
; 685  : 				if( this->m_PartyS[party_number].m_PartyPkLevel < this->m_PartyS[party_number].m_PkLevel[i] )

  00070	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  00074	7d 04		 jge	 SHORT $LN21@UpdatePKPa

; 686  : 				{
; 687  : 					this->m_PartyS[party_number].m_PartyPkLevel = this->m_PartyS[party_number].m_PkLevel[i];

  00076	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN21@UpdatePKPa:

; 688  : 				}
; 689  : 
; 690  : 				PKUserCount++;

  0007a	42		 inc	 edx
$LN22@UpdatePKPa:

; 673  : 	int PKUserCount = 0;
; 674  : 	int usern = 0;
; 675  : 	int i;
; 676  : 
; 677  : 	for( i = 0 ; i < MAX_USER_IN_PARTY; i++)
; 678  : 	{
; 679  : 		usern = this->m_PartyS[party_number].Number[i];
; 680  : 
; 681  : 		if( usern >= 0 )

  0007b	83 7c b9 18 00	 cmp	 DWORD PTR [ecx+edi*4+24], 0
  00080	7c 1b		 jl	 SHORT $LN25@UpdatePKPa

; 682  : 		{
; 683  : 			if( this->m_PartyS[party_number].m_PkLevel[i] >= 5 )

  00082	8b c6		 mov	 eax, esi
  00084	c1 e0 04	 shl	 eax, 4
  00087	2b c6		 sub	 eax, esi
  00089	8a 5c 81 3b	 mov	 bl, BYTE PTR [ecx+eax*4+59]
  0008d	80 fb 05	 cmp	 bl, 5
  00090	7c 0b		 jl	 SHORT $LN25@UpdatePKPa

; 684  : 			{
; 685  : 				if( this->m_PartyS[party_number].m_PartyPkLevel < this->m_PartyS[party_number].m_PkLevel[i] )

  00092	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  00096	7d 04		 jge	 SHORT $LN24@UpdatePKPa

; 686  : 				{
; 687  : 					this->m_PartyS[party_number].m_PartyPkLevel = this->m_PartyS[party_number].m_PkLevel[i];

  00098	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN24@UpdatePKPa:

; 688  : 				}
; 689  : 
; 690  : 				PKUserCount++;

  0009c	42		 inc	 edx
$LN25@UpdatePKPa:

; 673  : 	int PKUserCount = 0;
; 674  : 	int usern = 0;
; 675  : 	int i;
; 676  : 
; 677  : 	for( i = 0 ; i < MAX_USER_IN_PARTY; i++)
; 678  : 	{
; 679  : 		usern = this->m_PartyS[party_number].Number[i];
; 680  : 
; 681  : 		if( usern >= 0 )

  0009d	83 7c b9 1c 00	 cmp	 DWORD PTR [ecx+edi*4+28], 0
  000a2	7c 1b		 jl	 SHORT $LN28@UpdatePKPa

; 682  : 		{
; 683  : 			if( this->m_PartyS[party_number].m_PkLevel[i] >= 5 )

  000a4	8b c6		 mov	 eax, esi
  000a6	c1 e0 04	 shl	 eax, 4
  000a9	2b c6		 sub	 eax, esi
  000ab	8a 5c 81 3c	 mov	 bl, BYTE PTR [ecx+eax*4+60]
  000af	80 fb 05	 cmp	 bl, 5
  000b2	7c 0b		 jl	 SHORT $LN28@UpdatePKPa

; 684  : 			{
; 685  : 				if( this->m_PartyS[party_number].m_PartyPkLevel < this->m_PartyS[party_number].m_PkLevel[i] )

  000b4	38 5c 81 3d	 cmp	 BYTE PTR [ecx+eax*4+61], bl
  000b8	7d 04		 jge	 SHORT $LN27@UpdatePKPa

; 686  : 				{
; 687  : 					this->m_PartyS[party_number].m_PartyPkLevel = this->m_PartyS[party_number].m_PkLevel[i];

  000ba	88 5c 81 3d	 mov	 BYTE PTR [ecx+eax*4+61], bl
$LN27@UpdatePKPa:

; 688  : 				}
; 689  : 
; 690  : 				PKUserCount++;

  000be	42		 inc	 edx
$LN28@UpdatePKPa:

; 691  : 			}
; 692  : 		}
; 693  : 	}
; 694  : 
; 695  : 	this->m_PartyS[party_number].m_PkCount = PKUserCount;

  000bf	8b c6		 mov	 eax, esi
  000c1	c1 e0 04	 shl	 eax, 4
  000c4	2b c6		 sub	 eax, esi
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	89 54 81 40	 mov	 DWORD PTR [ecx+eax*4+64], edx

; 696  : 
; 697  : 	if( PKUserCount == 0 )

  000cd	85 d2		 test	 edx, edx
  000cf	75 05		 jne	 SHORT $LN8@UpdatePKPa

; 698  : 	{
; 699  : 		this->m_PartyS[party_number].m_PartyPkLevel = 3;

  000d1	c6 44 81 3d 03	 mov	 BYTE PTR [ecx+eax*4+61], 3
$LN8@UpdatePKPa:

; 700  : 	}
; 701  : }

  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ENDP		; PartyClass::UpdatePKPartyPanalty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?PartyLog@PartyClass@@QAEXHHH@Z
_TEXT	SEGMENT
_iUserNumber$GSCopy$1$ = -1296				; size = 4
tv176 = -1292						; size = 4
_strPartyInfo$ = -1288					; size = 1024
_strTemp$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_iPartyNumber$ = 8					; size = 4
_iUserNumber$ = 12					; size = 4
_iFlag$ = 16						; size = 4
?PartyLog@PartyClass@@QAEXHHH@Z PROC			; PartyClass::PartyLog, COMDAT
; _this$ = ecx

; 618  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 05 00
	00		 sub	 esp, 1296		; 00000510H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iPartyNumber$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _iUserNumber$[ebp]
  0001d	89 8d f0 fa ff
	ff		 mov	 DWORD PTR _iUserNumber$GSCopy$1$[ebp], ecx

; 619  : 	if( !OBJMAX_RANGE(iPartyNumber) )

  00023	85 f6		 test	 esi, esi
  00025	0f 88 20 02 00
	00		 js	 $LN13@PartyLog
  0002b	33 c0		 xor	 eax, eax
  0002d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00033	0f 9e c0	 setle	 al
  00036	85 c0		 test	 eax, eax
  00038	0f 84 0d 02 00
	00		 je	 $LN13@PartyLog

; 620  : 		return;
; 621  : 
; 622  : 	if( !OBJMAX_RANGE(iUserNumber) )

  0003e	85 c9		 test	 ecx, ecx
  00040	0f 88 05 02 00
	00		 js	 $LN13@PartyLog
  00046	33 c0		 xor	 eax, eax
  00048	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0004e	0f 9e c0	 setle	 al
  00051	85 c0		 test	 eax, eax
  00053	0f 84 f2 01 00
	00		 je	 $LN13@PartyLog

; 623  : 		return;
; 624  : 
; 625  : 	char strTemp[260] = {0};
; 626  : 	char strPartyInfo[1024] = {0};
; 627  : 	int i;
; 628  : 
; 629  : 	if( iFlag == 0 )

  00059	68 04 01 00 00	 push	 260			; 00000104H
  0005e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  00064	6a 00		 push	 0
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _memset
  0006c	68 00 04 00 00	 push	 1024			; 00000400H
  00071	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _strPartyInfo$[ebp]
  00077	6a 00		 push	 0
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _memset
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	83 7d 10 00	 cmp	 DWORD PTR _iFlag$[ebp], 0
  00086	75 35		 jne	 SHORT $LN7@PartyLog

; 630  : 	{
; 631  : 		wsprintf(strPartyInfo,"[Party System] PartyIndex(%d): PartyBreak",iPartyNumber);

  00088	56		 push	 esi
  00089	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _strPartyInfo$[ebp]
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FNDAOIBL@?$FLParty?5System?$FN?5PartyIndex?$CI?$CFd?$CJ?3?5P@
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 632  : 		LogAddTD(strPartyInfo);

  0009b	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _strPartyInfo$[ebp]
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a8	83 c4 10	 add	 esp, 16			; 00000010H
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi

; 669  : }

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 0c 00	 ret	 12			; 0000000cH
$LN7@PartyLog:
  000bd	53		 push	 ebx

; 633  : 		return;
; 634  : 	}
; 635  : 
; 636  : 	wsprintf(strPartyInfo,"[Party System] PartyMember(%d), PartyIndex(%d) ",this->GetCount(iPartyNumber),iPartyNumber);

  000be	56		 push	 esi
  000bf	56		 push	 esi
  000c0	8b cf		 mov	 ecx, edi
  000c2	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  000c7	50		 push	 eax
  000c8	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _strPartyInfo$[ebp]
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@MHAFDPJC@?$FLParty?5System?$FN?5PartyMember?$CI?$CFd?$CJ?0?5@
  000d3	50		 push	 eax
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e0	8b de		 mov	 ebx, esi
  000e2	c1 e3 04	 shl	 ebx, 4
  000e5	83 c4 10	 add	 esp, 16			; 00000010H
  000e8	2b de		 sub	 ebx, esi
  000ea	be 05 00 00 00	 mov	 esi, 5
  000ef	83 c3 03	 add	 ebx, 3
  000f2	89 b5 f4 fa ff
	ff		 mov	 DWORD PTR tv176[ebp], esi
  000f8	8d 1c 9f	 lea	 ebx, DWORD PTR [edi+ebx*4]
  000fb	0f 1f 44 00 00	 npad	 5
$LL4@PartyLog:

; 639  : 	{
; 640  : 		int usern = this->m_PartyS[iPartyNumber].Number[i];

  00100	8b 03		 mov	 eax, DWORD PTR [ebx]

; 641  : 
; 642  : 		if( usern >= 0 )

  00102	85 c0		 test	 eax, eax
  00104	78 6f		 js	 SHORT $LN2@PartyLog

; 643  : 		{
; 644  : 			if( gObj[usern].Connected == PLAYER_PLAYING ||

  00106	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  0010c	8b 44 11 04	 mov	 eax, DWORD PTR [ecx+edx+4]
  00110	83 f8 03	 cmp	 eax, 3
  00113	74 05		 je	 SHORT $LN10@PartyLog
  00115	83 f8 04	 cmp	 eax, 4
  00118	75 5b		 jne	 SHORT $LN2@PartyLog
$LN10@PartyLog:

; 645  : 				gObj[usern].Connected == 4 )
; 646  : 			{
; 647  : 				wsprintf(strTemp,"[%s][%s] ",gObj[usern].AccountID,gObj[usern].Name);

  0011a	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  0011d	03 c1		 add	 eax, ecx
  0011f	50		 push	 eax
  00120	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00123	03 c1		 add	 eax, ecx
  00125	50		 push	 eax
  00126	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_09BCDIPNKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@
  00131	50		 push	 eax
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 648  : 				strcat(strPartyInfo,strTemp);

  00138	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  0013e	83 c4 10	 add	 esp, 16			; 00000010H
  00141	8b f0		 mov	 esi, eax
$LL24@PartyLog:
  00143	8a 08		 mov	 cl, BYTE PTR [eax]
  00145	40		 inc	 eax
  00146	84 c9		 test	 cl, cl
  00148	75 f9		 jne	 SHORT $LL24@PartyLog
  0014a	8d bd f8 fa ff
	ff		 lea	 edi, DWORD PTR _strPartyInfo$[ebp]
  00150	2b c6		 sub	 eax, esi
  00152	4f		 dec	 edi
$LL25@PartyLog:
  00153	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00156	47		 inc	 edi
  00157	84 c9		 test	 cl, cl
  00159	75 f8		 jne	 SHORT $LL25@PartyLog
  0015b	8b c8		 mov	 ecx, eax
  0015d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00163	c1 e9 02	 shr	 ecx, 2
  00166	f3 a5		 rep movsd
  00168	8b c8		 mov	 ecx, eax
  0016a	83 e1 03	 and	 ecx, 3
  0016d	f3 a4		 rep movsb
  0016f	8b b5 f4 fa ff
	ff		 mov	 esi, DWORD PTR tv176[ebp]
$LN2@PartyLog:

; 637  : 
; 638  : 	for( i = 0; i < MAX_USER_IN_PARTY; i++)

  00175	83 c3 04	 add	 ebx, 4
  00178	83 ee 01	 sub	 esi, 1
  0017b	89 b5 f4 fa ff
	ff		 mov	 DWORD PTR tv176[ebp], esi
  00181	0f 85 79 ff ff
	ff		 jne	 $LL4@PartyLog

; 649  : 			}
; 650  : 		}
; 651  : 	}
; 652  : 
; 653  : 	if( iFlag == 1 )

  00187	8b 45 10	 mov	 eax, DWORD PTR _iFlag$[ebp]
  0018a	5b		 pop	 ebx
  0018b	83 f8 01	 cmp	 eax, 1
  0018e	75 4d		 jne	 SHORT $LN11@PartyLog

; 654  : 	{
; 655  : 		wsprintf(strTemp,"PartyOut : [%s][%s] ",gObj[iUserNumber].AccountID,gObj[iUserNumber].Name);

  00190	69 8d f0 fa ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _iUserNumber$GSCopy$1$[ebp], 10048
  0019a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0019d	03 c2		 add	 eax, edx
  0019f	50		 push	 eax
  001a0	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001a3	03 c2		 add	 eax, edx
  001a5	50		 push	 eax
  001a6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CDBILJMP@PartyOut?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@
  001b1	50		 push	 eax
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 656  : 		strcat(strPartyInfo,strTemp);

  001b8	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _strTemp$[ebp]
  001be	83 c4 10	 add	 esp, 16			; 00000010H
  001c1	8b f2		 mov	 esi, edx
$LL26@PartyLog:
  001c3	8a 02		 mov	 al, BYTE PTR [edx]
  001c5	42		 inc	 edx
  001c6	84 c0		 test	 al, al
  001c8	75 f9		 jne	 SHORT $LL26@PartyLog
  001ca	8d bd f8 fa ff
	ff		 lea	 edi, DWORD PTR _strPartyInfo$[ebp]
  001d0	2b d6		 sub	 edx, esi
  001d2	4f		 dec	 edi
$LL27@PartyLog:
  001d3	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  001d6	47		 inc	 edi
  001d7	84 c0		 test	 al, al
  001d9	75 f8		 jne	 SHORT $LL27@PartyLog
  001db	eb 50		 jmp	 SHORT $LN30@PartyLog
$LN11@PartyLog:

; 657  : 	}
; 658  : 	else if( iFlag == 2 )

  001dd	83 f8 02	 cmp	 eax, 2
  001e0	75 69		 jne	 SHORT $LN13@PartyLog

; 659  : 	{
; 660  : 		wsprintf(strTemp,"PartyRejoin : [%s][%s] ",gObj[iUserNumber].AccountID,gObj[iUserNumber].Name);

  001e2	69 8d f0 fa ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _iUserNumber$GSCopy$1$[ebp], 10048
  001ec	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001ef	03 c2		 add	 eax, edx
  001f1	50		 push	 eax
  001f2	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001f5	03 c2		 add	 eax, edx
  001f7	50		 push	 eax
  001f8	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _strTemp$[ebp]
  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DIPPFHJE@PartyRejoin?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$AA@
  00203	50		 push	 eax
  00204	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 661  : 		strcat(strPartyInfo,strTemp);

  0020a	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _strTemp$[ebp]
  00210	83 c4 10	 add	 esp, 16			; 00000010H
  00213	8b f2		 mov	 esi, edx
$LL28@PartyLog:
  00215	8a 02		 mov	 al, BYTE PTR [edx]
  00217	42		 inc	 edx
  00218	84 c0		 test	 al, al
  0021a	75 f9		 jne	 SHORT $LL28@PartyLog
  0021c	8d bd f8 fa ff
	ff		 lea	 edi, DWORD PTR _strPartyInfo$[ebp]
  00222	2b d6		 sub	 edx, esi
  00224	4f		 dec	 edi
$LL29@PartyLog:
  00225	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00228	47		 inc	 edi
  00229	84 c0		 test	 al, al
  0022b	75 f8		 jne	 SHORT $LL29@PartyLog
$LN30@PartyLog:
  0022d	8b ca		 mov	 ecx, edx

; 662  : 	}
; 663  : 	else
; 664  : 	{
; 665  : 		return;
; 666  : 	}
; 667  : 
; 668  : 	LogAddTD(strPartyInfo);

  0022f	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _strPartyInfo$[ebp]
  00235	c1 e9 02	 shr	 ecx, 2
  00238	f3 a5		 rep movsd
  0023a	8b ca		 mov	 ecx, edx
  0023c	83 e1 03	 and	 ecx, 3
  0023f	f3 a4		 rep movsb
  00241	50		 push	 eax
  00242	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00248	83 c4 04	 add	 esp, 4
$LN13@PartyLog:

; 669  : }

  0024b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024e	5f		 pop	 edi
  0024f	33 cd		 xor	 ecx, ebp
  00251	5e		 pop	 esi
  00252	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00257	8b e5		 mov	 esp, ebp
  00259	5d		 pop	 ebp
  0025a	c2 0c 00	 ret	 12			; 0000000cH
?PartyLog@PartyClass@@QAEXHHH@Z ENDP			; PartyClass::PartyLog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?PartyMemberLifeSend@PartyClass@@QAEXH@Z
_TEXT	SEGMENT
_usern$1$ = -1068					; size = 4
_pList$ = -1064						; size = 13
tv343 = -1048						; size = 4
tv377 = -1044						; size = 4
tv374 = -1040						; size = 4
_pCount$ = -1036					; size = 4
_lOfs$1$ = -1032					; size = 4
_sendbuf$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_party_number$ = 8					; size = 4
?PartyMemberLifeSend@PartyClass@@QAEXH@Z PROC		; PartyClass::PartyMemberLifeSend, COMDAT
; _this$ = ecx

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 04 00
	00		 sub	 esp, 1068		; 0000042cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _party_number$[ebp]
  00018	8b f1		 mov	 esi, ecx

; 379  : 	if ( this->IsParty(party_number) == FALSE )

  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00020	85 c0		 test	 eax, eax
  00022	0f 84 dd 01 00
	00		 je	 $LN6@PartyMembe

; 380  : 	{
; 381  : 		return;
; 382  : 	}
; 383  : 
; 384  : 	PMSG_DEFAULT_COUNT pCount;
; 385  : 	PMSG_PARTYLIFEALL pList;
; 386  : 	int usern;
; 387  : 	char sendbuf[1024];
; 388  : 	int lOfs = 0;
; 389  : 	int tlife = 0;
; 390  : 
; 391  : 	PHeadSetB((LPBYTE)&pCount, 0x44, sizeof(pCount));

  00028	53		 push	 ebx
  00029	6a 04		 push	 4
  0002b	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  00031	6a 44		 push	 68			; 00000044H
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 392  : 	pCount.Count = this->m_PartyS[party_number].Count;

  00039	8b cf		 mov	 ecx, edi

; 393  : 	lOfs += sizeof(pCount);

  0003b	c7 85 f8 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR _lOfs$1$[ebp], 4
  00045	c1 e1 04	 shl	 ecx, 4
  00048	8b d7		 mov	 edx, edi
  0004a	2b cf		 sub	 ecx, edi
  0004c	c1 e2 04	 shl	 edx, 4
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	89 8d e8 fb ff
	ff		 mov	 DWORD PTR tv343[ebp], ecx

; 394  : 	
; 395  : 	int i;
; 396  : 	for ( i = 0; i<MAX_USER_IN_PARTY ; i++ )

  00058	33 db		 xor	 ebx, ebx
  0005a	2b d7		 sub	 edx, edi
  0005c	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  0005f	89 95 ec fb ff
	ff		 mov	 DWORD PTR tv377[ebp], edx
  00065	8a 44 8e 08	 mov	 al, BYTE PTR [esi+ecx*4+8]
  00069	88 85 f7 fb ff
	ff		 mov	 BYTE PTR _pCount$[ebp+3], al
  0006f	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp+4]
  00075	89 85 f0 fb ff
	ff		 mov	 DWORD PTR tv374[ebp], eax
  0007b	8d 3c 97	 lea	 edi, DWORD PTR [edi+edx*4]
  0007e	eb 06		 jmp	 SHORT $LN4@PartyMembe
$LL24@PartyMembe:
  00080	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR tv377[ebp]
$LN4@PartyMembe:

; 397  : 	{
; 398  : 		if ( (this->m_PartyS[party_number].Number[i] >= 0 ) && (this->m_PartyS[party_number].DbNumber[i] >= 0) )

  00086	8b 07		 mov	 eax, DWORD PTR [edi]
  00088	89 85 d4 fb ff
	ff		 mov	 DWORD PTR _usern$1$[ebp], eax
  0008e	85 c0		 test	 eax, eax
  00090	0f 88 14 01 00
	00		 js	 $LN23@PartyMembe
  00096	03 d3		 add	 edx, ebx
  00098	83 7c 96 20 00	 cmp	 DWORD PTR [esi+edx*4+32], 0
  0009d	0f 8c 07 01 00
	00		 jl	 $LN23@PartyMembe

; 399  : 		{
; 400  : 			usern = this->m_PartyS[party_number].Number[i];
; 401  : 
; 402  : 			if ( gObjIsConnected(usern) != PLAYER_EMPTY )

  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000a9	83 c4 04	 add	 esp, 4
  000ac	85 c0		 test	 eax, eax
  000ae	0f 84 d6 00 00
	00		 je	 $LN10@PartyMembe

; 403  : 			{
; 404  : 				memcpy(pList.szName,gObj[usern].Name,10);

  000b4	69 95 d4 fb ff
	ff 40 27 00 00	 imul	 edx, DWORD PTR _usern$1$[ebp], 10048
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	f3 0f 7e 44 0a
	5d		 movq	 xmm0, QWORD PTR [edx+ecx+93]

; 405  : 				//pList.btUnk = 9;
; 406  : 				pList.Life = (BYTE)(((float)gObj[usern].Life / (float)(gObj[usern].MaxLife + gObj[usern].AddLife ))*100.0f);

  000ca	f3 0f 10 8c 0a
	d8 00 00 00	 movss	 xmm1, DWORD PTR [edx+ecx+216]
  000d3	66 0f d6 85 da
	fb ff ff	 movq	 QWORD PTR _pList$[ebp+2], xmm0
  000db	66 0f 6e 84 0a
	24 01 00 00	 movd	 xmm0, DWORD PTR [edx+ecx+292]
  000e4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000e7	66 8b 44 0a 65	 mov	 ax, WORD PTR [edx+ecx+101]
  000ec	66 89 85 e2 fb
	ff ff		 mov	 WORD PTR _pList$[ebp+10], ax
  000f3	f3 0f 58 84 0a
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edx+ecx+220]
  000fc	f3 0f 5e c8	 divss	 xmm1, xmm0
  00100	66 0f 6e 84 0a
	28 01 00 00	 movd	 xmm0, DWORD PTR [edx+ecx+296]
  00109	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42c80000

; 407  : 				pList.Mana = (BYTE)(((float)gObj[usern].Mana / (float)(gObj[usern].MaxMana + gObj[usern].AddMana ))*100.0f);

  00111	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00114	f3 0f 2c c1	 cvttss2si eax, xmm1
  00118	f3 0f 58 84 0a
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edx+ecx+240]
  00121	f3 0f 10 8c 0a
	ec 00 00 00	 movss	 xmm1, DWORD PTR [edx+ecx+236]

; 408  : 				memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  0012a	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR tv374[ebp]

; 409  : 				lOfs += sizeof(pList);

  00130	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _lOfs$1$[ebp]
  00136	88 85 d8 fb ff
	ff		 mov	 BYTE PTR _pList$[ebp], al
  0013c	83 c2 0d	 add	 edx, 13			; 0000000dH
  0013f	f3 0f 5e c8	 divss	 xmm1, xmm0
  00143	89 95 f8 fb ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], edx
  00149	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42c80000
  00151	f3 0f 2c c1	 cvttss2si eax, xmm1
  00155	88 85 d9 fb ff
	ff		 mov	 BYTE PTR _pList$[ebp+1], al
  0015b	f3 0f 7e 85 d8
	fb ff ff	 movq	 xmm0, QWORD PTR _pList$[ebp]
  00163	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp+8]
  00169	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0016d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00170	8a 85 e4 fb ff
	ff		 mov	 al, BYTE PTR _pList$[ebp+12]
  00176	88 41 0c	 mov	 BYTE PTR [ecx+12], al
  00179	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0017c	89 8d f0 fb ff
	ff		 mov	 DWORD PTR tv374[ebp], ecx

; 410  : 			}
; 411  : 			else

  00182	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR tv343[ebp]
  00188	eb 26		 jmp	 SHORT $LN2@PartyMembe
$LN10@PartyMembe:

; 412  : 			{
; 413  : 				this->m_PartyS[party_number].Number[i] = -1;
; 414  : 				this->m_PartyS[party_number].DbNumber[i] = -1;

  0018a	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR tv377[ebp]

; 415  : 				this->m_PartyS[party_number].Count--;

  00190	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR tv343[ebp]
  00196	03 c3		 add	 eax, ebx
  00198	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
  0019e	c7 44 86 20 ff
	ff ff ff	 mov	 DWORD PTR [esi+eax*4+32], -1
  001a6	ff 4c 8e 08	 dec	 DWORD PTR [esi+ecx*4+8]
$LN23@PartyMembe:
  001aa	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _lOfs$1$[ebp]
$LN2@PartyMembe:

; 394  : 	
; 395  : 	int i;
; 396  : 	for ( i = 0; i<MAX_USER_IN_PARTY ; i++ )

  001b0	43		 inc	 ebx
  001b1	83 c7 04	 add	 edi, 4
  001b4	83 fb 05	 cmp	 ebx, 5
  001b7	0f 8c c3 fe ff
	ff		 jl	 $LL24@PartyMembe

; 416  : 			}
; 417  : 		}
; 418  : 	}
; 419  : 
; 420  : 	pCount.h.size = lOfs;

  001bd	88 95 f5 fb ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], dl
  001c3	8d 34 8e	 lea	 esi, DWORD PTR [esi+ecx*4]

; 421  : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  001c6	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  001cc	83 c6 0c	 add	 esi, 12			; 0000000cH
  001cf	89 85 fc fb ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  001d5	bf 05 00 00 00	 mov	 edi, 5
  001da	5b		 pop	 ebx
  001db	0f 1f 44 00 00	 npad	 5
$LL7@PartyMembe:

; 424  : 	{
; 425  : 		usern = this->m_PartyS[party_number].Number[i];

  001e0	8b 06		 mov	 eax, DWORD PTR [esi]

; 426  : 
; 427  : 		if ( usern >= 0 )

  001e2	85 c0		 test	 eax, eax
  001e4	78 17		 js	 SHORT $LN5@PartyMembe

; 428  : 		{
; 429  : 			DataSend(usern, (unsigned char*)sendbuf, lOfs);

  001e6	52		 push	 edx
  001e7	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  001ed	51		 push	 ecx
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f4	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _lOfs$1$[ebp]
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@PartyMembe:

; 422  : 
; 423  : 	for ( i=0 ; i<MAX_USER_IN_PARTY ; i++ )

  001fd	83 c6 04	 add	 esi, 4
  00200	83 ef 01	 sub	 edi, 1
  00203	75 db		 jne	 SHORT $LL7@PartyMembe
$LN6@PartyMembe:

; 430  : 		}
; 431  : 	}
; 432  : }

  00205	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00208	5f		 pop	 edi
  00209	33 cd		 xor	 ecx, ebp
  0020b	5e		 pop	 esi
  0020c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c2 04 00	 ret	 4
?PartyMemberLifeSend@PartyClass@@QAEXH@Z ENDP		; PartyClass::PartyMemberLifeSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?Paint@PartyClass@@QAEXH@Z
_TEXT	SEGMENT
tv300 = -16						; size = 4
tv310 = -12						; size = 4
tv298 = -8						; size = 4
_this$1$ = -4						; size = 4
tv297 = 8						; size = 4
_party_number$ = 8					; size = 4
?Paint@PartyClass@@QAEXH@Z PROC				; PartyClass::Paint, COMDAT
; _this$ = ecx

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 332  : 	if (this->IsParty(party_number) == FALSE )

  00008	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	56		 push	 esi
  0000e	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  00011	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00016	85 c0		 test	 eax, eax
  00018	0f 84 6a 01 00
	00		 je	 $LN1@Paint

; 333  : 	{
; 334  : 		return;
; 335  : 	}
; 336  : 
; 337  : 	int usern = 0;
; 338  : 	wsprintf( this->m_szTempPaint, "PartyMember(%d) :", this->m_PartyS[party_number].Count);

  0001e	8b c6		 mov	 eax, esi
  00020	c1 e0 04	 shl	 eax, 4
  00023	2b c6		 sub	 eax, esi
  00025	57		 push	 edi
  00026	8d bb 58 87 0a
	00		 lea	 edi, DWORD PTR [ebx+690008]
  0002c	89 7d 08	 mov	 DWORD PTR tv297[ebp], edi
  0002f	ff 74 83 08	 push	 DWORD PTR [ebx+eax*4+8]
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JDIKBIFA@PartyMember?$CI?$CFd?$CJ?5?3?$AA@
  00038	57		 push	 edi
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00042	8b c6		 mov	 eax, esi
  00044	c1 e0 04	 shl	 eax, 4
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  : 
; 340  : 	for ( int i = 0; i< MAX_USER_IN_PARTY ; i++ )

  0004a	33 db		 xor	 ebx, ebx
  0004c	2b c6		 sub	 eax, esi
  0004e	89 45 f8	 mov	 DWORD PTR tv298[ebp], eax
  00051	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
  00054	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
  00057	89 75 f4	 mov	 DWORD PTR tv310[ebp], esi
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Paint:

; 341  : 	{
; 342  : 		if ( (this->m_PartyS[party_number].Number[i] != 0 ) && (this->m_PartyS[party_number].DbNumber[i] != 0 ) )

  00060	8b 36		 mov	 esi, DWORD PTR [esi]
  00062	85 f6		 test	 esi, esi
  00064	0f 84 00 01 00
	00		 je	 $LN2@Paint
  0006a	03 c3		 add	 eax, ebx
  0006c	83 7c 81 20 00	 cmp	 DWORD PTR [ecx+eax*4+32], 0
  00071	0f 84 f0 00 00
	00		 je	 $LN21@Paint

; 343  : 		{
; 344  : 			usern = this->m_PartyS[party_number].Number[i];
; 345  : 
; 346  : 			if ( !gObjIsConnected(usern) )

  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0007d	83 c4 04	 add	 esp, 4
  00080	85 c0		 test	 eax, eax
  00082	0f 84 dc 00 00
	00		 je	 $LN20@Paint

; 347  : 				continue;
; 348  : 
; 349  : 			strcat(this->m_szTempPaint, "[");

  00088	4f		 dec	 edi
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@Paint:
  00090	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00093	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00096	84 c0		 test	 al, al
  00098	75 f6		 jne	 SHORT $LL13@Paint
  0009a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01OHGJGJJP@?$FL?$AA@

; 350  : 			strcat(this->m_szTempPaint, gObj[usern].AccountID);

  000a0	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000a6	66 89 07	 mov	 WORD PTR [edi], ax
  000a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000af	83 c2 52	 add	 edx, 82			; 00000052H
  000b2	03 d1		 add	 edx, ecx
  000b4	89 4d f0	 mov	 DWORD PTR tv300[ebp], ecx
  000b7	8b f2		 mov	 esi, edx
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL14@Paint:
  000c0	8a 02		 mov	 al, BYTE PTR [edx]
  000c2	42		 inc	 edx
  000c3	84 c0		 test	 al, al
  000c5	75 f9		 jne	 SHORT $LL14@Paint
  000c7	8b 7d 08	 mov	 edi, DWORD PTR tv297[ebp]
  000ca	2b d6		 sub	 edx, esi
  000cc	4f		 dec	 edi
  000cd	0f 1f 00	 npad	 3
$LL15@Paint:
  000d0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000d3	47		 inc	 edi
  000d4	84 c0		 test	 al, al
  000d6	75 f8		 jne	 SHORT $LL15@Paint
  000d8	8b ca		 mov	 ecx, edx
  000da	c1 e9 02	 shr	 ecx, 2
  000dd	f3 a5		 rep movsd
  000df	8b ca		 mov	 ecx, edx
  000e1	83 e1 03	 and	 ecx, 3
  000e4	f3 a4		 rep movsb

; 351  : 			strcat(this->m_szTempPaint, "][");

  000e6	8b 7d 08	 mov	 edi, DWORD PTR tv297[ebp]
  000e9	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  000ec	0f 1f 40 00	 npad	 4
$LL16@Paint:
  000f0	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000f3	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000f6	84 c0		 test	 al, al
  000f8	75 f6		 jne	 SHORT $LL16@Paint
  000fa	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02DNJFBPJB@?$FN?$FL?$AA@
  00100	66 89 01	 mov	 WORD PTR [ecx], ax
  00103	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02DNJFBPJB@?$FN?$FL?$AA@+2
  00108	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 352  : 			strcat(this->m_szTempPaint, gObj[usern].Name);

  0010b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	83 c2 5d	 add	 edx, 93			; 0000005dH
  00114	03 55 f0	 add	 edx, DWORD PTR tv300[ebp]
  00117	8b f2		 mov	 esi, edx
  00119	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@Paint:
  00120	8a 02		 mov	 al, BYTE PTR [edx]
  00122	42		 inc	 edx
  00123	84 c0		 test	 al, al
  00125	75 f9		 jne	 SHORT $LL17@Paint
  00127	2b d6		 sub	 edx, esi
  00129	4f		 dec	 edi
  0012a	66 0f 1f 44 00
	00		 npad	 6
$LL18@Paint:
  00130	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00133	47		 inc	 edi
  00134	84 c0		 test	 al, al
  00136	75 f8		 jne	 SHORT $LL18@Paint
  00138	8b ca		 mov	 ecx, edx
  0013a	c1 e9 02	 shr	 ecx, 2
  0013d	f3 a5		 rep movsd
  0013f	8b ca		 mov	 ecx, edx
  00141	83 e1 03	 and	 ecx, 3
  00144	f3 a4		 rep movsb

; 353  : 			strcat(this->m_szTempPaint, "], ");

  00146	8b 7d 08	 mov	 edi, DWORD PTR tv297[ebp]
  00149	4f		 dec	 edi
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL19@Paint:
  00150	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00153	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00156	84 c0		 test	 al, al
  00158	75 f6		 jne	 SHORT $LL19@Paint
  0015a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_03EDAPGMLK@?$FN?0?5?$AA@
  0015f	89 07		 mov	 DWORD PTR [edi], eax
  00161	8b 7d 08	 mov	 edi, DWORD PTR tv297[ebp]
$LN20@Paint:
  00164	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN21@Paint:
  00167	8b 45 f8	 mov	 eax, DWORD PTR tv298[ebp]
$LN2@Paint:

; 339  : 
; 340  : 	for ( int i = 0; i< MAX_USER_IN_PARTY ; i++ )

  0016a	8b 75 f4	 mov	 esi, DWORD PTR tv310[ebp]
  0016d	43		 inc	 ebx
  0016e	83 c6 04	 add	 esi, 4
  00171	89 75 f4	 mov	 DWORD PTR tv310[ebp], esi
  00174	83 fb 05	 cmp	 ebx, 5
  00177	0f 8c e3 fe ff
	ff		 jl	 $LL4@Paint

; 354  : 		}
; 355  : 	}
; 356  : 
; 357  : 	LogAddTD(this->m_szTempPaint);

  0017d	57		 push	 edi
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00184	83 c4 04	 add	 esp, 4
  00187	5f		 pop	 edi
$LN1@Paint:
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx

; 358  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 04 00	 ret	 4
?Paint@PartyClass@@QAEXH@Z ENDP				; PartyClass::Paint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?Isleader@PartyClass@@QAEHHHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_usernumber$ = 12					; size = 4
_dbnumber$ = 16						; size = 4
?Isleader@PartyClass@@QAEHHHH@Z PROC			; PartyClass::Isleader, COMDAT
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 47   : 	if ( this->IsParty(party_number) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	74 25		 je	 SHORT $LN3@Isleader

; 48   : 	{
; 49   : 		return FALSE;
; 50   : 	}
; 51   : 
; 52   : 	if ( this->m_PartyS[party_number].Number[0] == usernumber && this->m_PartyS[party_number].DbNumber[0] == dbnumber )

  00014	8b c6		 mov	 eax, esi
  00016	c1 e0 04	 shl	 eax, 4
  00019	2b c6		 sub	 eax, esi
  0001b	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  0001e	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00021	3b 45 0c	 cmp	 eax, DWORD PTR _usernumber$[ebp]
  00024	75 13		 jne	 SHORT $LN3@Isleader
  00026	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00029	3b 45 10	 cmp	 eax, DWORD PTR _dbnumber$[ebp]
  0002c	75 0b		 jne	 SHORT $LN3@Isleader

; 53   : 	{
; 54   : 		return TRUE;

  0002e	5f		 pop	 edi
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	5e		 pop	 esi

; 58   : }

  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
$LN3@Isleader:
  00039	5f		 pop	 edi

; 55   : 	}
; 56   : 
; 57   : 	return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	5e		 pop	 esi

; 58   : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
?Isleader@PartyClass@@QAEHHHH@Z ENDP			; PartyClass::Isleader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetLevel@PartyClass@@QAEHHAAH0@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_maxlevel$ = 12						; size = 4
_minlevel$ = 16						; size = 4
?GetLevel@PartyClass@@QAEHHAAH0@Z PROC			; PartyClass::GetLevel, COMDAT
; _this$ = ecx

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 197  : 	if ( this->IsParty(party_number) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	75 06		 jne	 SHORT $LN2@GetLevel
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi

; 206  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
$LN2@GetLevel:

; 198  : 	{
; 199  : 		return FALSE;
; 200  : 	}
; 201  : 
; 202  : 	maxlevel = this->m_PartyS[party_number].m_MaxLevel;

  0001a	8b c6		 mov	 eax, esi
  0001c	c1 e0 04	 shl	 eax, 4
  0001f	2b c6		 sub	 eax, esi
  00021	0f bf 4c 87 34	 movsx	 ecx, WORD PTR [edi+eax*4+52]
  00026	8d 14 87	 lea	 edx, DWORD PTR [edi+eax*4]
  00029	8b 45 0c	 mov	 eax, DWORD PTR _maxlevel$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 203  : 	minlevel = this->m_PartyS[party_number].m_MinLevel;

  00030	8b 45 10	 mov	 eax, DWORD PTR _minlevel$[ebp]
  00033	0f bf 4a 36	 movsx	 ecx, WORD PTR [edx+54]
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 204  : 
; 205  : 	return TRUE;

  00039	b8 01 00 00 00	 mov	 eax, 1

; 206  : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?GetLevel@PartyClass@@QAEHHAAH0@Z ENDP			; PartyClass::GetLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?SetLevel@PartyClass@@QAEHHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_level$ = 12						; size = 4
?SetLevel@PartyClass@@QAEHHH@Z PROC			; PartyClass::SetLevel, COMDAT
; _this$ = ecx

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 176  : 	if ( this->m_PartyS[party_number].m_MaxLevel  < level )

  00003	8b 55 08	 mov	 edx, DWORD PTR _party_number$[ebp]
  00006	c1 e2 04	 shl	 edx, 4
  00009	2b 55 08	 sub	 edx, DWORD PTR _party_number$[ebp]
  0000c	56		 push	 esi
  0000d	8b 75 0c	 mov	 esi, DWORD PTR _level$[ebp]
  00010	0f bf 44 91 34	 movsx	 eax, WORD PTR [ecx+edx*4+52]
  00015	3b c6		 cmp	 eax, esi
  00017	7d 05		 jge	 SHORT $LN2@SetLevel

; 177  : 	{
; 178  : 		this->m_PartyS[party_number].m_MaxLevel  = level;

  00019	66 89 74 91 34	 mov	 WORD PTR [ecx+edx*4+52], si
$LN2@SetLevel:

; 179  : 	}
; 180  : 
; 181  : 	if ( this->m_PartyS[party_number].m_MinLevel  == 0 )

  0001e	66 83 7c 91 36
	00		 cmp	 WORD PTR [ecx+edx*4+54], 0
  00024	75 05		 jne	 SHORT $LN3@SetLevel

; 182  : 	{
; 183  : 		this->m_PartyS[party_number].m_MinLevel = level;

  00026	66 89 74 91 36	 mov	 WORD PTR [ecx+edx*4+54], si
$LN3@SetLevel:

; 184  : 	}
; 185  : 
; 186  : 	if ( this->m_PartyS[party_number].m_MinLevel > level )	// In Case of Error

  0002b	0f bf 44 91 36	 movsx	 eax, WORD PTR [ecx+edx*4+54]
  00030	3b c6		 cmp	 eax, esi

; 189  : 	}
; 190  : 
; 191  : 	return TRUE;

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	7e 05		 jle	 SHORT $LN4@SetLevel

; 187  : 	{
; 188  : 		this->m_PartyS[party_number].m_MinLevel = level;

  00039	66 89 74 91 36	 mov	 WORD PTR [ecx+edx*4+54], si
$LN4@SetLevel:
  0003e	5e		 pop	 esi

; 192  : }

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?SetLevel@PartyClass@@QAEHHH@Z ENDP			; PartyClass::SetLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetIndex@PartyClass@@QAEHHHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_usernumber$ = 12					; size = 4
_dbnumber$ = 16						; size = 4
?GetIndex@PartyClass@@QAEHHHH@Z PROC			; PartyClass::GetIndex, COMDAT
; _this$ = ecx

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 94   : 	if ( this->IsParty(party_number) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _party_number$[ebp]
  00007	57		 push	 edi
  00008	53		 push	 ebx
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	75 06		 jne	 SHORT $LN5@GetIndex
  00014	5f		 pop	 edi
  00015	5b		 pop	 ebx

; 108  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
$LN5@GetIndex:
  0001a	56		 push	 esi
  0001b	8b f3		 mov	 esi, ebx

; 95   : 	{
; 96   : 		return 0;
; 97   : 	}
; 98   : 
; 99   : 	for ( int n=0; n<MAX_USER_IN_PARTY;n++)

  0001d	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  00020	c1 e6 04	 shl	 esi, 4
  00023	33 c0		 xor	 eax, eax
  00025	2b f3		 sub	 esi, ebx
  00027	8b 5d 0c	 mov	 ebx, DWORD PTR _usernumber$[ebp]
  0002a	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]
  0002d	0f 1f 00	 npad	 3
$LL4@GetIndex:

; 100  : 	{
; 101  : 		if ( this->m_PartyS[party_number].Number[n] == usernumber || this->m_PartyS[party_number].DbNumber[n] == dbnumber )

  00030	39 1a		 cmp	 DWORD PTR [edx], ebx
  00032	74 1b		 je	 SHORT $LN14@GetIndex
  00034	8b 5d 10	 mov	 ebx, DWORD PTR _dbnumber$[ebp]
  00037	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0003a	39 5c 8f 20	 cmp	 DWORD PTR [edi+ecx*4+32], ebx
  0003e	8b 5d 0c	 mov	 ebx, DWORD PTR _usernumber$[ebp]
  00041	74 0c		 je	 SHORT $LN14@GetIndex

; 95   : 	{
; 96   : 		return 0;
; 97   : 	}
; 98   : 
; 99   : 	for ( int n=0; n<MAX_USER_IN_PARTY;n++)

  00043	40		 inc	 eax
  00044	83 c2 04	 add	 edx, 4
  00047	83 f8 05	 cmp	 eax, 5
  0004a	7c e4		 jl	 SHORT $LL4@GetIndex

; 102  : 		{
; 103  : 			return n;
; 104  : 		}
; 105  : 	}
; 106  : 
; 107  : 	return -1;

  0004c	83 c8 ff	 or	 eax, -1
$LN14@GetIndex:
  0004f	5e		 pop	 esi
  00050	5f		 pop	 edi
  00051	5b		 pop	 ebx

; 108  : }

  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
?GetIndex@PartyClass@@QAEHHHH@Z ENDP			; PartyClass::GetIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetPartyCount@PartyClass@@QAEHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?GetPartyCount@PartyClass@@QAEHH@Z PROC			; PartyClass::GetPartyCount, COMDAT
; _this$ = ecx

; 320  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 321  : 	if ( this->IsParty( party_number ) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	75 09		 jne	 SHORT $LN2@GetPartyCo

; 322  : 	{
; 323  : 		return -1;

  00014	5f		 pop	 edi
  00015	83 c8 ff	 or	 eax, -1
  00018	5e		 pop	 esi

; 327  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN2@GetPartyCo:

; 324  : 	}
; 325  : 
; 326  : 	return this->m_PartyS[party_number].Count;

  0001d	8b c6		 mov	 eax, esi
  0001f	c1 e0 04	 shl	 eax, 4
  00022	2b c6		 sub	 eax, esi
  00024	8b 44 87 08	 mov	 eax, DWORD PTR [edi+eax*4+8]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 327  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetPartyCount@PartyClass@@QAEHH@Z ENDP			; PartyClass::GetPartyCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_index$ = 12						; size = 4
_usernumber$ = 16					; size = 4
_dbnumber$ = 20						; size = 4
?GetIndexUser@PartyClass@@QAEHHHAAH0@Z PROC		; PartyClass::GetIndexUser, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 74   : 	if ( this->IsParty(party_number) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _party_number$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	74 2e		 je	 SHORT $LN4@GetIndexUs

; 75   : 	{
; 76   : 		return FALSE;
; 77   : 	}
; 78   : 
; 79   : 	if ( index <0 || index > MAX_USER_IN_PARTY-1 )

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  00017	83 f9 04	 cmp	 ecx, 4
  0001a	77 26		 ja	 SHORT $LN4@GetIndexUs

; 82   : 	}
; 83   : 
; 84   : 	usernumber = this->m_PartyS[party_number].Number[index];

  0001c	8b 45 10	 mov	 eax, DWORD PTR _usernumber$[ebp]
  0001f	8b d7		 mov	 edx, edi
  00021	c1 e2 04	 shl	 edx, 4
  00024	2b d7		 sub	 edx, edi
  00026	03 d1		 add	 edx, ecx
  00028	5f		 pop	 edi
  00029	8b 4c 96 0c	 mov	 ecx, DWORD PTR [esi+edx*4+12]
  0002d	89 08		 mov	 DWORD PTR [eax], ecx

; 85   : 	dbnumber = this->m_PartyS[party_number].DbNumber[index];

  0002f	8b 45 14	 mov	 eax, DWORD PTR _dbnumber$[ebp]
  00032	8b 4c 96 20	 mov	 ecx, DWORD PTR [esi+edx*4+32]
  00036	5e		 pop	 esi
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 86   : 
; 87   : 	return TRUE;

  00039	b8 01 00 00 00	 mov	 eax, 1

; 88   : }

  0003e	5d		 pop	 ebp
  0003f	c2 10 00	 ret	 16			; 00000010H
$LN4@GetIndexUs:
  00042	5f		 pop	 edi

; 80   : 	{
; 81   : 		return FALSE;

  00043	33 c0		 xor	 eax, eax
  00045	5e		 pop	 esi

; 88   : }

  00046	5d		 pop	 ebp
  00047	c2 10 00	 ret	 16			; 00000010H
?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ENDP		; PartyClass::GetIndexUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?GetCount@PartyClass@@QAEHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?GetCount@PartyClass@@QAEHH@Z PROC			; PartyClass::GetCount, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 63   : 	if ( this->IsParty(party_number) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	75 06		 jne	 SHORT $LN2@GetCount
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi

; 69   : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@GetCount:

; 64   : 	{
; 65   : 		return 0;
; 66   : 	}
; 67   : 
; 68   : 	return this->m_PartyS[party_number].Count;

  0001a	8b c6		 mov	 eax, esi
  0001c	c1 e0 04	 shl	 eax, 4
  0001f	2b c6		 sub	 eax, esi
  00021	8b 44 87 08	 mov	 eax, DWORD PTR [edi+eax*4+8]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 69   : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?GetCount@PartyClass@@QAEHH@Z ENDP			; PartyClass::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?Delete@PartyClass@@QAEHHHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_usernumber$ = 12					; size = 4
_dbnumber$ = 16						; size = 4
?Delete@PartyClass@@QAEHHHH@Z PROC			; PartyClass::Delete, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 276  : 	if ( this->IsParty(party_number) == FALSE )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _party_number$[ebp]
  00007	56		 push	 esi
  00008	53		 push	 ebx
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	75 09		 jne	 SHORT $LN5@Delete

; 277  : 	{
; 278  : 		return -1;

  00014	5e		 pop	 esi
  00015	83 c8 ff	 or	 eax, -1
  00018	5b		 pop	 ebx

; 294  : }

  00019	5d		 pop	 ebp
  0001a	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Delete:
  0001d	57		 push	 edi
  0001e	8b fb		 mov	 edi, ebx

; 279  : 	}
; 280  : 
; 281  : 	for ( int i = 0 ; i<MAX_USER_IN_PARTY ; i++ )

  00020	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00023	c1 e7 04	 shl	 edi, 4
  00026	33 d2		 xor	 edx, edx
  00028	2b fb		 sub	 edi, ebx
  0002a	8b 5d 0c	 mov	 ebx, DWORD PTR _usernumber$[ebp]
  0002d	8d 0c b9	 lea	 ecx, DWORD PTR [ecx+edi*4]
$LL4@Delete:

; 282  : 	{
; 283  : 		if ( (this->m_PartyS[party_number].Number[i] == usernumber) && (this->m_PartyS[party_number].DbNumber[i] == dbnumber) )

  00030	39 19		 cmp	 DWORD PTR [ecx], ebx
  00032	75 0f		 jne	 SHORT $LN2@Delete
  00034	8b 5d 10	 mov	 ebx, DWORD PTR _dbnumber$[ebp]
  00037	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  0003a	39 5c 86 20	 cmp	 DWORD PTR [esi+eax*4+32], ebx
  0003e	8b 5d 0c	 mov	 ebx, DWORD PTR _usernumber$[ebp]
  00041	74 13		 je	 SHORT $LN9@Delete
$LN2@Delete:

; 279  : 	}
; 280  : 
; 281  : 	for ( int i = 0 ; i<MAX_USER_IN_PARTY ; i++ )

  00043	42		 inc	 edx
  00044	83 c1 04	 add	 ecx, 4
  00047	83 fa 05	 cmp	 edx, 5
  0004a	7c e4		 jl	 SHORT $LL4@Delete

; 290  : 		}
; 291  : 	}
; 292  : 
; 293  : 	return -1;

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	83 c8 ff	 or	 eax, -1
  00051	5b		 pop	 ebx

; 294  : }

  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
$LN9@Delete:

; 284  : 		{
; 285  : 			this->m_PartyS[party_number].Number[i] = -1;

  00056	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]

; 286  : 			this->m_PartyS[party_number].DbNumber[i] = -1;
; 287  : 			this->m_PartyS[party_number].Count--;
; 288  : 			this->m_PartyS[party_number].m_PkLevel[0] = 3;
; 289  : 			return i;

  00059	8b c2		 mov	 eax, edx
  0005b	c7 44 8e 0c ff
	ff ff ff	 mov	 DWORD PTR [esi+ecx*4+12], -1
  00063	c7 44 8e 20 ff
	ff ff ff	 mov	 DWORD PTR [esi+ecx*4+32], -1
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _party_number$[ebp]
  0006e	c1 e1 04	 shl	 ecx, 4
  00071	2b 4d 08	 sub	 ecx, DWORD PTR _party_number$[ebp]
  00074	5f		 pop	 edi
  00075	ff 4c 8e 08	 dec	 DWORD PTR [esi+ecx*4+8]
  00079	c6 44 8e 38 03	 mov	 BYTE PTR [esi+ecx*4+56], 3
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx

; 294  : }

  00080	5d		 pop	 ebp
  00081	c2 0c 00	 ret	 12			; 0000000cH
?Delete@PartyClass@@QAEHHHH@Z ENDP			; PartyClass::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?Delete@PartyClass@@QAEXHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
_index$ = 12						; size = 4
?Delete@PartyClass@@QAEXHH@Z PROC			; PartyClass::Delete, COMDAT
; _this$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 299  : 	if ( this->IsParty(party_number) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	74 38		 je	 SHORT $LN4@Delete

; 300  : 	{
; 301  : 		return;
; 302  : 	}
; 303  : 
; 304  : 	if ( index < 0 || index > MAX_USER_IN_PARTY -1 )

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  00017	83 f9 04	 cmp	 ecx, 4
  0001a	77 30		 ja	 SHORT $LN4@Delete

; 305  : 	{
; 306  : 		return;
; 307  : 	}
; 308  : 
; 309  : 	if ( this->m_PartyS[party_number].Number[index] >= 0 )

  0001c	8b c6		 mov	 eax, esi
  0001e	c1 e0 04	 shl	 eax, 4
  00021	2b c6		 sub	 eax, esi
  00023	03 c1		 add	 eax, ecx
  00025	83 7c 87 0c 00	 cmp	 DWORD PTR [edi+eax*4+12], 0
  0002a	7c 20		 jl	 SHORT $LN4@Delete

; 310  : 	{
; 311  : 		this->m_PartyS[party_number].Number[index] = -1;

  0002c	c7 44 87 0c ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+12], -1

; 312  : 		this->m_PartyS[party_number].DbNumber[index] = -1;

  00034	c7 44 87 20 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+32], -1

; 313  : 		this->m_PartyS[party_number].Count--;

  0003c	8b c6		 mov	 eax, esi
  0003e	c1 e0 04	 shl	 eax, 4
  00041	2b c6		 sub	 eax, esi
  00043	ff 4c 87 08	 dec	 DWORD PTR [edi+eax*4+8]

; 314  : 		this->m_PartyS[party_number].m_PkLevel[0] = 3;

  00047	c6 44 87 38 03	 mov	 BYTE PTR [edi+eax*4+56], 3
$LN4@Delete:
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 315  : 	}
; 316  : }

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?Delete@PartyClass@@QAEXHH@Z ENDP			; PartyClass::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?Add@PartyClass@@QAEHHHHH@Z
_TEXT	SEGMENT
tv374 = -4						; size = 4
_party_number$ = 8					; size = 4
_usernumber$ = 12					; size = 4
_dbnumber$ = 16						; size = 4
_level$ = 20						; size = 4
?Add@PartyClass@@QAEHHHHH@Z PROC			; PartyClass::Add, COMDAT
; _this$ = ecx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 227  : 	if ( this->IsParty(party_number ) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _party_number$[ebp]
  00008	57		 push	 edi
  00009	56		 push	 esi
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00011	85 c0		 test	 eax, eax
  00013	75 0b		 jne	 SHORT $LN8@Add

; 228  : 	{
; 229  : 		return -1;

  00015	5f		 pop	 edi
  00016	83 c8 ff	 or	 eax, -1
  00019	5e		 pop	 esi

; 272  : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 10 00	 ret	 16			; 00000010H
$LN8@Add:
  00020	53		 push	 ebx

; 230  : 	}
; 231  : 
; 232  : 	if ( this->m_PartyS[party_number].Count >= OBJMAX )	// Useless

  00021	8b de		 mov	 ebx, esi
  00023	c1 e3 04	 shl	 ebx, 4
  00026	2b de		 sub	 ebx, esi
  00028	c1 e3 02	 shl	 ebx, 2
  0002b	81 7c 3b 08 ec
	2c 00 00	 cmp	 DWORD PTR [ebx+edi+8], 11500 ; 00002cecH
  00033	7d 49		 jge	 SHORT $LN27@Add

; 233  : 	{
; 234  : 		return -1;
; 235  : 	}
; 236  : 
; 237  : 	int i;
; 238  : 	for ( i = 0; i<MAX_USER_IN_PARTY ; i++)

  00035	c1 e6 04	 shl	 esi, 4
  00038	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  0003b	33 c9		 xor	 ecx, ecx
  0003d	2b 75 08	 sub	 esi, DWORD PTR _party_number$[ebp]
  00040	89 75 fc	 mov	 DWORD PTR tv374[ebp], esi
  00043	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]
$LL4@Add:

; 239  : 	{
; 240  : 		if ( (this->m_PartyS[party_number].Number[i] >= 0) && (this->m_PartyS[party_number].Number[i] == usernumber) && (this->m_PartyS[party_number].DbNumber[i] == dbnumber) )

  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	85 c0		 test	 eax, eax
  0004a	78 14		 js	 SHORT $LN2@Add
  0004c	3b 45 0c	 cmp	 eax, DWORD PTR _usernumber$[ebp]
  0004f	75 0f		 jne	 SHORT $LN2@Add
  00051	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00054	8b 75 10	 mov	 esi, DWORD PTR _dbnumber$[ebp]
  00057	39 74 87 20	 cmp	 DWORD PTR [edi+eax*4+32], esi
  0005b	8b 75 fc	 mov	 esi, DWORD PTR tv374[ebp]
  0005e	74 2a		 je	 SHORT $LN17@Add
$LN2@Add:

; 233  : 	{
; 234  : 		return -1;
; 235  : 	}
; 236  : 
; 237  : 	int i;
; 238  : 	for ( i = 0; i<MAX_USER_IN_PARTY ; i++)

  00060	41		 inc	 ecx
  00061	83 c2 04	 add	 edx, 4
  00064	83 f9 05	 cmp	 ecx, 5
  00067	7c dd		 jl	 SHORT $LL4@Add

; 243  : 		}
; 244  : 	}
; 245  : 
; 246  : 	for ( i = 0; i<MAX_USER_IN_PARTY ; i++ )

  00069	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  0006c	33 f6		 xor	 esi, esi
  0006e	03 c3		 add	 eax, ebx
$LL7@Add:

; 247  : 	{
; 248  : 		if ( this->m_PartyS[party_number].Number[i] == -1 )

  00070	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00073	74 23		 je	 SHORT $LN18@Add

; 243  : 		}
; 244  : 	}
; 245  : 
; 246  : 	for ( i = 0; i<MAX_USER_IN_PARTY ; i++ )

  00075	46		 inc	 esi
  00076	83 c0 04	 add	 eax, 4
  00079	83 fe 05	 cmp	 esi, 5
  0007c	7c f2		 jl	 SHORT $LL7@Add
$LN27@Add:
  0007e	5b		 pop	 ebx
  0007f	5f		 pop	 edi

; 268  : 		}
; 269  : 	}
; 270  : 
; 271  : 	return -1;

  00080	83 c8 ff	 or	 eax, -1
  00083	5e		 pop	 esi

; 272  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 10 00	 ret	 16			; 00000010H
$LN17@Add:
  0008a	5b		 pop	 ebx
  0008b	5f		 pop	 edi

; 241  : 		{
; 242  : 			return -2;

  0008c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00091	5e		 pop	 esi

; 272  : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 10 00	 ret	 16			; 00000010H
$LN18@Add:

; 249  : 		{
; 250  : 			this->m_PartyS[party_number].Number[i] = usernumber;

  00098	8b 45 fc	 mov	 eax, DWORD PTR tv374[ebp]
  0009b	8b 4d 0c	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  0009e	03 c6		 add	 eax, esi

; 251  : 			this->m_PartyS[party_number].DbNumber[i] = dbnumber;
; 252  : 			this->m_PartyS[party_number].Count++;
; 253  : 			this->SetLevel(party_number, level);

  000a0	ff 75 14	 push	 DWORD PTR _level$[ebp]
  000a3	ff 75 08	 push	 DWORD PTR _party_number$[ebp]
  000a6	89 4c 87 0c	 mov	 DWORD PTR [edi+eax*4+12], ecx
  000aa	8b 4d 10	 mov	 ecx, DWORD PTR _dbnumber$[ebp]
  000ad	89 4c 87 20	 mov	 DWORD PTR [edi+eax*4+32], ecx
  000b1	8b cf		 mov	 ecx, edi
  000b3	ff 44 3b 08	 inc	 DWORD PTR [ebx+edi+8]
  000b7	e8 00 00 00 00	 call	 ?SetLevel@PartyClass@@QAEHHH@Z ; PartyClass::SetLevel

; 254  : 
; 255  : 			this->m_PartyS[party_number].m_PkLevel[i] = gObj[usernumber].m_PK_Level;

  000bc	69 4d 0c 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  000c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c8	8a 8c 01 19 01
	00 00		 mov	 cl, BYTE PTR [ecx+eax+281]
  000cf	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  000d2	88 4c 38 38	 mov	 BYTE PTR [eax+edi+56], cl

; 256  : 
; 257  : 			if( m_PartyS[party_number].m_PkLevel[i] >= 5 )

  000d6	80 f9 05	 cmp	 cl, 5
  000d9	7c 0e		 jl	 SHORT $LN12@Add

; 258  : 			{
; 259  : 				if( m_PartyS[party_number].m_PartyPkLevel < m_PartyS[party_number].m_PkLevel[i] )

  000db	38 4c 3b 3d	 cmp	 BYTE PTR [ebx+edi+61], cl
  000df	7d 04		 jge	 SHORT $LN13@Add

; 260  : 				{
; 261  : 					m_PartyS[party_number].m_PartyPkLevel = m_PartyS[party_number].m_PkLevel[i];

  000e1	88 4c 3b 3d	 mov	 BYTE PTR [ebx+edi+61], cl
$LN13@Add:

; 262  : 				}
; 263  : 
; 264  : 				m_PartyS[party_number].m_PkCount++;

  000e5	ff 44 3b 40	 inc	 DWORD PTR [ebx+edi+64]
$LN12@Add:
  000e9	5b		 pop	 ebx
  000ea	5f		 pop	 edi

; 265  : 			}
; 266  : 
; 267  : 			return i;

  000eb	8b c6		 mov	 eax, esi
  000ed	5e		 pop	 esi

; 272  : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 10 00	 ret	 16			; 00000010H
?Add@PartyClass@@QAEHHHHH@Z ENDP			; PartyClass::Add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?Destroy@PartyClass@@QAEHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?Destroy@PartyClass@@QAEHH@Z PROC			; PartyClass::Destroy, COMDAT
; _this$ = ecx

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 211  : 	if ( this->IsParty(party_number) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _party_number$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00010	85 c0		 test	 eax, eax
  00012	74 22		 je	 SHORT $LN4@Destroy

; 212  : 	{
; 213  : 		return FALSE;
; 214  : 	}
; 215  : 
; 216  : 	this->m_PartyS[party_number].Count = 0;

  00014	8b c7		 mov	 eax, edi
  00016	c1 e0 04	 shl	 eax, 4
  00019	2b c7		 sub	 eax, edi
  0001b	c7 44 86 08 00
	00 00 00	 mov	 DWORD PTR [esi+eax*4+8], 0

; 217  : 	this->m_PartyS[party_number].Number[0] = -1;

  00023	c7 44 86 0c ff
	ff ff ff	 mov	 DWORD PTR [esi+eax*4+12], -1

; 218  : 	this->m_PartyS[party_number].DbNumber[0] = -1;

  0002b	c7 44 86 20 ff
	ff ff ff	 mov	 DWORD PTR [esi+eax*4+32], -1

; 219  : 	this->m_PartyCount--;

  00033	ff 4e 04	 dec	 DWORD PTR [esi+4]
$LN4@Destroy:

; 220  : 
; 221  : 	return FALSE;

  00036	5f		 pop	 edi
  00037	33 c0		 xor	 eax, eax
  00039	5e		 pop	 esi

; 222  : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?Destroy@PartyClass@@QAEHH@Z ENDP			; PartyClass::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?Create@PartyClass@@QAEHHHH@Z
_TEXT	SEGMENT
_usernumber$ = 8					; size = 4
_dbnumber$ = 12						; size = 4
_level$ = 16						; size = 4
?Create@PartyClass@@QAEHHHH@Z PROC			; PartyClass::Create, COMDAT
; _this$ = ecx

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 113  : 	int n = this->m_PartyCount;
; 114  : 	int loopcount = 0;

  00007	33 d2		 xor	 edx, edx
  00009	8b 77 04	 mov	 esi, DWORD PTR [edi+4]

; 115  : 
; 116  : 	while ( true )
; 117  : 	{
; 118  : 		if ( this->m_PartyS[n].Count == 0 )

  0000c	8b c6		 mov	 eax, esi
  0000e	c1 e0 04	 shl	 eax, 4
  00011	2b c6		 sub	 eax, esi
  00013	39 54 87 08	 cmp	 DWORD PTR [edi+eax*4+8], edx
  00017	74 2e		 je	 SHORT $LN17@Create
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Create:

; 154  : 		}
; 155  : 
; 156  : 		n++;

  00020	46		 inc	 esi

; 157  : 
; 158  : 		if ( n> OBJMAX-1 )

  00021	33 c0		 xor	 eax, eax
  00023	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00029	0f 4f f0	 cmovg	 esi, eax

; 159  : 		{
; 160  : 			n=0;
; 161  : 		}
; 162  : 
; 163  : 		loopcount++;

  0002c	42		 inc	 edx

; 164  : 
; 165  : 		if ( loopcount > OBJMAX-1 )

  0002d	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00033	0f 8f c2 00 00
	00		 jg	 $LN18@Create

; 115  : 
; 116  : 	while ( true )
; 117  : 	{
; 118  : 		if ( this->m_PartyS[n].Count == 0 )

  00039	8b c6		 mov	 eax, esi
  0003b	c1 e0 04	 shl	 eax, 4
  0003e	2b c6		 sub	 eax, esi
  00040	83 7c 87 08 00	 cmp	 DWORD PTR [edi+eax*4+8], 0
  00045	75 d9		 jne	 SHORT $LL2@Create
$LN17@Create:

; 119  : 		{
; 120  : 			this->m_PartyS[n].Count = 1;

  00047	8b c6		 mov	 eax, esi
  00049	c1 e0 04	 shl	 eax, 4
  0004c	2b c6		 sub	 eax, esi
  0004e	c7 44 87 08 01
	00 00 00	 mov	 DWORD PTR [edi+eax*4+8], 1
  00056	53		 push	 ebx

; 121  : 			this->m_PartyS[n].Number[0] = usernumber;
; 122  : 			this->m_PartyS[n].DbNumber[0] = dbnumber;
; 123  : 
; 124  : 			for ( int i=1;i<MAX_USER_IN_PARTY;i++)
; 125  : 			{
; 126  : 				this->m_PartyS[n].DbNumber[i] = -1;
; 127  : 				this->m_PartyS[n].Number[i] = -1;
; 128  : 			}
; 129  : 
; 130  : 			this->m_PartyCount++;
; 131  : 			this->m_PartyS[n].m_MaxLevel = 0;
; 132  : 			this->m_PartyS[n].m_MinLevel = 0;
; 133  : 			this->SetLevel(n, level);

  00057	ff 75 10	 push	 DWORD PTR _level$[ebp]
  0005a	8d 1c 87	 lea	 ebx, DWORD PTR [edi+eax*4]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00060	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00063	8b 45 0c	 mov	 eax, DWORD PTR _dbnumber$[ebp]
  00066	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00069	8b c6		 mov	 eax, esi
  0006b	c1 e0 04	 shl	 eax, 4
  0006e	2b c6		 sub	 eax, esi
  00070	56		 push	 esi
  00071	c7 44 87 24 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+36], -1
  00079	c7 44 87 10 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+16], -1
  00081	c7 44 87 28 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+40], -1
  00089	c7 44 87 14 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+20], -1
  00091	c7 44 87 2c ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+44], -1
  00099	c7 44 87 18 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+24], -1
  000a1	c7 44 87 30 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+48], -1
  000a9	c7 44 87 1c ff
	ff ff ff	 mov	 DWORD PTR [edi+eax*4+28], -1
  000b1	33 c0		 xor	 eax, eax
  000b3	ff 47 04	 inc	 DWORD PTR [edi+4]
  000b6	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  000b9	e8 00 00 00 00	 call	 ?SetLevel@PartyClass@@QAEHHH@Z ; PartyClass::SetLevel

; 134  : 
; 135  : 			if ( this->m_PartyCount > OBJMAX-1 )

  000be	81 7f 04 eb 2c
	00 00		 cmp	 DWORD PTR [edi+4], 11499 ; 00002cebH
  000c5	7e 07		 jle	 SHORT $LN8@Create

; 136  : 			{
; 137  : 				this->m_PartyCount=0;

  000c7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN8@Create:

; 138  : 			}
; 139  : 
; 140  : 			this->m_PartyS[n].m_PkLevel[0] = gObj[usernumber].m_PK_Level;

  000ce	69 4d 08 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000da	8a 84 01 19 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+281]
  000e1	88 43 38	 mov	 BYTE PTR [ebx+56], al

; 141  : 
; 142  : 			if( this->m_PartyS[n].m_PkLevel[0] >= 5 )

  000e4	3c 05		 cmp	 al, 5
  000e6	7c 1c		 jl	 SHORT $LN9@Create

; 143  : 			{
; 144  : 				this->m_PartyS[n].m_PartyPkLevel = m_PartyS[n].m_PkLevel[0];

  000e8	88 43 3d	 mov	 BYTE PTR [ebx+61], al

; 150  : 				this->m_PartyS[n].m_PkCount = 0;
; 151  : 			}
; 152  : 
; 153  : 			return n;

  000eb	8b c6		 mov	 eax, esi
  000ed	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [ebx+64], 1
  000f4	5b		 pop	 ebx
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi

; 172  : }

  000f7	5d		 pop	 ebp
  000f8	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Create:
  000fb	5f		 pop	 edi

; 166  : 		{
; 167  : 			break;
; 168  : 		}
; 169  : 	}
; 170  : 
; 171  : 	return -1;

  000fc	83 c8 ff	 or	 eax, -1
  000ff	5e		 pop	 esi

; 172  : }

  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
$LN9@Create:

; 145  : 				this->m_PartyS[n].m_PkCount = 1;
; 146  : 			}
; 147  : 			else
; 148  : 			{
; 149  : 				this->m_PartyS[n].m_PartyPkLevel = 3;

  00104	c6 43 3d 03	 mov	 BYTE PTR [ebx+61], 3

; 150  : 				this->m_PartyS[n].m_PkCount = 0;
; 151  : 			}
; 152  : 
; 153  : 			return n;

  00108	8b c6		 mov	 eax, esi
  0010a	c7 43 40 00 00
	00 00		 mov	 DWORD PTR [ebx+64], 0
  00111	5b		 pop	 ebx
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi

; 172  : }

  00114	5d		 pop	 ebp
  00115	c2 0c 00	 ret	 12			; 0000000cH
?Create@PartyClass@@QAEHHHH@Z ENDP			; PartyClass::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?IsParty@PartyClass@@QAEHH@Z
_TEXT	SEGMENT
_party_number$ = 8					; size = 4
?IsParty@PartyClass@@QAEHH@Z PROC			; PartyClass::IsParty, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	if ( party_number < 0 || party_number >= OBJMAX )

  00003	8b 45 08	 mov	 eax, DWORD PTR _party_number$[ebp]
  00006	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0000b	77 10		 ja	 SHORT $LN3@IsParty

; 34   : 	}
; 35   : 
; 36   : 	if ( this->m_PartyS[party_number].Count == 0 )

  0000d	6b d0 0f	 imul	 edx, eax, 15
  00010	33 c0		 xor	 eax, eax
  00012	39 44 91 08	 cmp	 DWORD PTR [ecx+edx*4+8], eax
  00016	0f 95 c0	 setne	 al

; 37   : 	{
; 38   : 		return FALSE;
; 39   : 	}
; 40   : 
; 41   : 	return TRUE;
; 42   : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN3@IsParty:

; 32   : 	{
; 33   : 		return FALSE;

  0001d	33 c0		 xor	 eax, eax

; 37   : 	{
; 38   : 		return FALSE;
; 39   : 	}
; 40   : 
; 41   : 	return TRUE;
; 42   : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?IsParty@PartyClass@@QAEHH@Z ENDP			; PartyClass::IsParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ??1PartyClass@@UAE@XZ
_TEXT	SEGMENT
??1PartyClass@@UAE@XZ PROC				; PartyClass::~PartyClass, COMDAT
; _this$ = ecx

; 24   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7PartyClass@@6B@

; 25   : 
; 26   : }

  00006	81 c1 58 88 0a
	00		 add	 ecx, 690264		; 000a8858H
  0000c	e9 00 00 00 00	 jmp	 ??1PartyBonusInfo@@QAE@XZ
??1PartyClass@@UAE@XZ ENDP				; PartyClass::~PartyClass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ??0PartyClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PartyClass@@QAE@XZ PROC				; PartyClass::PartyClass, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7PartyClass@@6B@

; 20   : }

  0000a	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  0000c	c7 81 58 88 0a
	00 00 00 00 00	 mov	 DWORD PTR [ecx+690264], 0

; 481  : 		_Mylast = pointer();

  00016	c7 81 5c 88 0a
	00 00 00 00 00	 mov	 DWORD PTR [ecx+690268], 0

; 482  : 		_Myend = pointer();

  00020	c7 81 60 88 0a
	00 00 00 00 00	 mov	 DWORD PTR [ecx+690272], 0
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 18   : {

  0002a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  0002d	c7 81 64 88 0a
	00 00 00 00 00	 mov	 DWORD PTR [ecx+690276], 0

; 481  : 		_Mylast = pointer();

  00037	c7 81 68 88 0a
	00 00 00 00 00	 mov	 DWORD PTR [ecx+690280], 0

; 482  : 		_Myend = pointer();

  00041	c7 81 6c 88 0a
	00 00 00 00 00	 mov	 DWORD PTR [ecx+690284], 0
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp

; 20   : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??0PartyClass@@QAE@XZ ENDP				; PartyClass::PartyClass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1PartyBonusInfo@@QAE@XZ
_TEXT	SEGMENT
??1PartyBonusInfo@@QAE@XZ PROC				; PartyBonusInfo::~PartyBonusInfo, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 1656 : 		if (this->_Myfirst() != pointer())

  00004	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00007	85 c9		 test	 ecx, ecx
  00009	74 34		 je	 SHORT $LN7@PartyBonus

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0000b	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0000e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00013	2b d1		 sub	 edx, ecx
  00015	f7 ea		 imul	 edx
  00017	d1 fa		 sar	 edx, 1
  00019	8b c2		 mov	 eax, edx
  0001b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001e	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00020	50		 push	 eax
  00021	51		 push	 ecx
  00022	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00025	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  0002a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1663 : 			this->_Mylast() = pointer();

  00031	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1664 : 			this->_Myend() = pointer();

  00038	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN7@PartyBonus:

; 1656 : 		if (this->_Myfirst() != pointer())

  0003f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00041	85 c9		 test	 ecx, ecx
  00043	74 25		 je	 SHORT $LN102@PartyBonus

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00045	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00048	2b c1		 sub	 eax, ecx
  0004a	c1 f8 03	 sar	 eax, 3
  0004d	50		 push	 eax
  0004e	51		 push	 ecx
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate

; 1662 : 			this->_Myfirst() = pointer();

  00056	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0005c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00063	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN102@PartyBonus:
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	c3		 ret	 0
??1PartyBonusInfo@@QAE@XZ ENDP				; PartyBonusInfo::~PartyBonusInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0PartyBonusInfo@@QAE@XZ
_TEXT	SEGMENT
??0PartyBonusInfo@@QAE@XZ PROC				; PartyBonusInfo::PartyBonusInfo, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 480  : 		_Myfirst = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 481  : 		_Mylast = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 482  : 		_Myend = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0002b	c3		 ret	 0
??0PartyBonusInfo@@QAE@XZ ENDP				; PartyBonusInfo::PartyBonusInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEXPAUPartyBonusByClass@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEXPAUPartyBonusByClass@@0@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEXPAUPartyBonusByClass@@0@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEXXZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEXXZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXXZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 32		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	d1 fa		 sar	 edx, 1
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00034	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0003b	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0003c	c3		 ret	 0
?_Tidy@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXXZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv202 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 1646 : 		if (_Unused_capacity() < _Count)

  0000d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00010	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00013	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	d1 fa		 sar	 edx, 1
  0001c	8b c2		 mov	 eax, edx
  0001e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00021	03 c2		 add	 eax, edx

; 1646 : 		if (_Unused_capacity() < _Count)

  00023	3b c7		 cmp	 eax, edi
  00025	73 5f		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00027	8b 03		 mov	 eax, DWORD PTR [ebx]
  00029	2b f0		 sub	 esi, eax
  0002b	89 45 08	 mov	 DWORD PTR tv202[ebp], eax
  0002e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00033	f7 ee		 imul	 esi

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00035	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003a	d1 fa		 sar	 edx, 1
  0003c	8b ca		 mov	 ecx, edx
  0003e	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00041	03 ca		 add	 ecx, edx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00043	2b c1		 sub	 eax, ecx
  00045	3b c7		 cmp	 eax, edi
  00047	72 44		 jb	 SHORT $LN134@Reserve

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00049	03 f9		 add	 edi, ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0004b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00050	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00053	2b 4d 08	 sub	 ecx, DWORD PTR tv202[ebp]
  00056	f7 e9		 imul	 ecx
  00058	d1 fa		 sar	 edx, 1
  0005a	8b f2		 mov	 esi, edx
  0005c	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0005f	03 f2		 add	 esi, edx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00061	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  00066	8b c6		 mov	 eax, esi
  00068	d1 e8		 shr	 eax, 1
  0006a	2b d0		 sub	 edx, eax
  0006c	3b d6		 cmp	 edx, esi
  0006e	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00071	b8 00 00 00 00	 mov	 eax, 0
  00076	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00079	3b cf		 cmp	 ecx, edi
  0007b	0f 42 cf	 cmovb	 ecx, edi

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0007e	51		 push	 ecx
  0007f	8b cb		 mov	 ecx, ebx
  00081	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reallocate
$LN2@Reserve:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 1651 : 			}
; 1652 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00092	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  00097	cc		 int	 3
?_Reserve@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UPartyBonusByClass@@@std@@QAEPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	8b f8		 mov	 edi, eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00044	6a 00		 push	 0
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	ff 76 04	 push	 DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0004b	89 7d ec	 mov	 DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004e	ff 36		 push	 DWORD PTR [esi]
  00050	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByClass@@PAU1@V?$allocator@UPartyBonusByClass@@@std@@U1@@std@@YAPAUPartyBonusByClass@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByClass *,PartyBonusByClass *,std::allocator<PartyBonusByClass>,PartyBonusByClass>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00055	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00058	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005d	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0005f	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00062	f7 e9		 imul	 ecx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00064	8b 06		 mov	 eax, DWORD PTR [esi]

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00066	d1 fa		 sar	 edx, 1
  00068	8b da		 mov	 ebx, edx
  0006a	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0006d	03 da		 add	 ebx, edx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  0006f	85 c0		 test	 eax, eax
  00071	74 1f		 je	 SHORT $LN3@Reallocate

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00073	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00076	2b c8		 sub	 ecx, eax
  00078	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007d	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0007f	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00081	d1 fa		 sar	 edx, 1
  00083	8b c2		 mov	 eax, edx
  00085	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00088	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0008a	50		 push	 eax
  0008b	ff 36		 push	 DWORD PTR [esi]
  0008d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1639 : 		this->_Myend() = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00098	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  0009b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  0009e	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  000a1	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  000a4	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  000a7	89 3e		 mov	 DWORD PTR [esi], edi

; 1642 : 		}

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000bd	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000c0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000c6	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1627 : 		_RERAISE;

  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN179@Reallocate:
$LN178@Reallocate:
  000d4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBE_NPBUPartyBonusByClass@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBE_NPBUPartyBonusByClass@@@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBE_NPBUPartyBonusByClass@@@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEII@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0000d	b9 55 55 55 15	 mov	 ecx, 357913941		; 15555555H

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00012	f7 ea		 imul	 edx
  00014	56		 push	 esi
  00015	d1 fa		 sar	 edx, 1
  00017	8b f2		 mov	 esi, edx
  00019	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001c	03 f2		 add	 esi, edx

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001e	8b c6		 mov	 eax, esi
  00020	d1 e8		 shr	 eax, 1
  00022	57		 push	 edi
  00023	2b c8		 sub	 ecx, eax
  00025	33 ff		 xor	 edi, edi
  00027	3b ce		 cmp	 ecx, esi
  00029	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0002c	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  0002f	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00032	5f		 pop	 edi
  00033	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  00037	8b c2		 mov	 eax, edx
  00039	5e		 pop	 esi

; 1612 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?_Grow_to@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IBEII@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXPAUPartyBonusByClass@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXPAUPartyBonusByClass@@0@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXPAUPartyBonusByClass@@0@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXXZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1543 : 		}

  00005	c3		 ret	 0
?clear@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXXZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXABUPartyBonusByClass@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXABUPartyBonusByClass@@@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4c		 jae	 SHORT $LN2@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 46		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	d1 fa		 sar	 edx, 1
  00022	8b fa		 mov	 edi, edx
  00024	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00027	03 fa		 add	 edi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00029	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002c	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  0002e	6a 01		 push	 1
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	85 d2		 test	 edx, edx
  0003c	74 42		 je	 SHORT $LN205@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00043	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00044	f3 0f 7e 04 88	 movq	 xmm0, QWORD PTR [eax+ecx*4]
  00049	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  0004d	8b 44 88 08	 mov	 eax, DWORD PTR [eax+ecx*4+8]
  00051	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00054	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00058	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN2@push_back:

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  0005d	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00060	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  00062	6a 01		 push	 1
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0006b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006e	85 c9		 test	 ecx, ecx
  00070	74 0e		 je	 SHORT $LN205@push_back
  00072	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00076	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0007a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN205@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00080	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?push_back@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXABUPartyBonusByClass@@@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEAAUPartyBonusByClass@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEAAUPartyBonusByClass@@I@Z PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1241 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEAAUPartyBonusByClass@@I@Z ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1180 : 		}

  00015	c3		 ret	 0
?size@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	d1 fa		 sar	 edx, 1
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1048 : 		}

  00016	c3		 ret	 0
?_Unused_capacity@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1043 : 		}

  00015	c3		 ret	 0
?capacity@?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@XZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::~vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 32		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	d1 fa		 sar	 edx, 1
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00034	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0003b	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0003c	c3		 ret	 0
??1?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@XZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::~vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@XZ PROC ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@XZ ENDP ; std::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >::vector<PartyBonusByClass,std::allocator<PartyBonusByClass> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByClass> >,std::_Vector_val<std::_Simple_types<PartyBonusByClass> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PartyBonusByClass> >::_Vector_val<std::_Simple_types<PartyBonusByClass> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PartyBonusByClass> >::_Vector_val<std::_Simple_types<PartyBonusByClass> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABQAUPartyBonusByClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAPAUPartyBonusByClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByClass@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByClass@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByClass@@V?$allocator@UPartyBonusByClass@@@std@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByClass@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >::_Vector_alloc<std::_Vec_base_types<PartyBonusByClass,std::allocator<PartyBonusByClass> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEXPAUPartyBonusByClass@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEPAUPartyBonusByClass@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEPAUPartyBonusByClass@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UPartyBonusByClass@@@std@@QAEPAUPartyBonusByClass@@I@Z ; std::allocator<PartyBonusByClass>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAEPAUPartyBonusByClass@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByClass@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByClass@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::_Wrap_alloc<std::allocator<PartyBonusByClass> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UPartyBonusByClass@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByClass@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByClass> >::_Wrap_alloc<std::allocator<PartyBonusByClass> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAIABV?$allocator@UPartyBonusByClass@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAIABV?$allocator@UPartyBonusByClass@@@2@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByClass> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UPartyBonusByClass@@@std@@@std@@SAIABV?$allocator@UPartyBonusByClass@@@2@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByClass> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UPartyBonusByClass@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UPartyBonusByClass@@@std@@QBEIXZ PROC ; std::allocator<PartyBonusByClass>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UPartyBonusByClass@@@std@@QBEIXZ ENDP ; std::allocator<PartyBonusByClass>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UPartyBonusByClass@@@std@@QAEPAUPartyBonusByClass@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UPartyBonusByClass@@@std@@QAEPAUPartyBonusByClass@@I@Z PROC ; std::allocator<PartyBonusByClass>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00013	77 3f		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00018	c1 e0 02	 shl	 eax, 2

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@UPartyBonusByClass@@@std@@QAEPAUPartyBonusByClass@@I@Z ENDP ; std::allocator<PartyBonusByClass>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z PROC ; std::allocator<PartyBonusByClass>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0000e	77 34		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00013	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 639  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@UPartyBonusByClass@@@std@@QAEXPAUPartyBonusByClass@@I@Z ENDP ; std::allocator<PartyBonusByClass>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UPartyBonusByClass@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UPartyBonusByClass@@@std@@QAE@ABV01@@Z PROC ; std::allocator<PartyBonusByClass>::allocator<PartyBonusByClass>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UPartyBonusByClass@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<PartyBonusByClass>::allocator<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UPartyBonusByClass@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UPartyBonusByClass@@@std@@QAE@XZ PROC	; std::allocator<PartyBonusByClass>::allocator<PartyBonusByClass>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UPartyBonusByClass@@@std@@QAE@XZ ENDP	; std::allocator<PartyBonusByClass>::allocator<PartyBonusByClass>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEXPAUPartyBonusByNearby@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEXPAUPartyBonusByNearby@@0@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEXPAUPartyBonusByNearby@@0@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEXXZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEXXZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXXZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 03	 sar	 eax, 3
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0002e	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0002f	c3		 ret	 0
?_Tidy@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXXZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1646 : 		if (_Unused_capacity() < _Count)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	57		 push	 edi

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  0000a	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0000d	8b c7		 mov	 eax, edi
  0000f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00012	2b c2		 sub	 eax, edx
  00014	c1 f8 03	 sar	 eax, 3

; 1646 : 		if (_Unused_capacity() < _Count)

  00017	3b c1		 cmp	 eax, ecx
  00019	73 3b		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0001b	2b 16		 sub	 edx, DWORD PTR [esi]
  0001d	53		 push	 ebx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  0001e	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00023	c1 fa 03	 sar	 edx, 3

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00026	8b c3		 mov	 eax, ebx
  00028	2b c2		 sub	 eax, edx
  0002a	3b c1		 cmp	 eax, ecx
  0002c	72 2e		 jb	 SHORT $LN134@Reserve

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0002e	2b 3e		 sub	 edi, DWORD PTR [esi]

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00030	03 d1		 add	 edx, ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00032	c1 ff 03	 sar	 edi, 3

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00035	8b c7		 mov	 eax, edi
  00037	d1 e8		 shr	 eax, 1
  00039	2b d8		 sub	 ebx, eax
  0003b	3b df		 cmp	 ebx, edi
  0003d	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00040	b8 00 00 00 00	 mov	 eax, 0
  00045	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00048	3b ca		 cmp	 ecx, edx
  0004a	0f 42 ca	 cmovb	 ecx, edx

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0004d	51		 push	 ecx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reallocate
  00055	5b		 pop	 ebx
$LN2@Reserve:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1651 : 			}
; 1652 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00061	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  00066	cc		 int	 3
?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UPartyBonusByNearby@@@std@@QAEPAUPartyBonusByNearby@@I@Z ; std::allocator<PartyBonusByNearby>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	8b f8		 mov	 edi, eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00044	6a 00		 push	 0
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	ff 76 04	 push	 DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0004b	89 7d ec	 mov	 DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004e	ff 36		 push	 DWORD PTR [esi]
  00050	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUPartyBonusByNearby@@PAU1@V?$allocator@UPartyBonusByNearby@@@std@@U1@@std@@YAPAUPartyBonusByNearby@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PartyBonusByNearby *,PartyBonusByNearby *,std::allocator<PartyBonusByNearby>,PartyBonusByNearby>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00055	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00057	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0005a	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0005d	2b d9		 sub	 ebx, ecx
  0005f	c1 fb 03	 sar	 ebx, 3

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00062	85 c9		 test	 ecx, ecx
  00064	74 11		 je	 SHORT $LN3@Reallocate

; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00066	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00069	2b c1		 sub	 eax, ecx
  0006b	c1 f8 03	 sar	 eax, 3
  0006e	50		 push	 eax
  0006f	51		 push	 ecx
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate
$LN3@Reallocate:

; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0007a	8d 04 c7	 lea	 eax, DWORD PTR [edi+eax*8]
  0007d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  00080	8d 04 df	 lea	 eax, DWORD PTR [edi+ebx*8]
  00083	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  00086	89 3e		 mov	 DWORD PTR [esi], edi

; 1642 : 		}

  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z$0:

; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);

  0009c	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0009f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000a5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate

; 1627 : 		_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN175@Reallocate:
$LN174@Reallocate:
  000b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBE_NPBUPartyBonusByNearby@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBE_NPBUPartyBonusByNearby@@@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBE_NPBUPartyBonusByNearby@@@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEII@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	2b 31		 sub	 esi, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00009	b9 ff ff ff 1f	 mov	 ecx, 536870911		; 1fffffffH

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0000e	c1 fe 03	 sar	 esi, 3

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00011	8b c6		 mov	 eax, esi
  00013	d1 e8		 shr	 eax, 1
  00015	57		 push	 edi
  00016	2b c8		 sub	 ecx, eax
  00018	33 ff		 xor	 edi, edi
  0001a	3b ce		 cmp	 ecx, esi
  0001c	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0001f	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00022	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00025	5f		 pop	 edi
  00026	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  0002a	8b c2		 mov	 eax, edx
  0002c	5e		 pop	 esi

; 1612 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?_Grow_to@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IBEII@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXPAUPartyBonusByNearby@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXPAUPartyBonusByNearby@@0@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXPAUPartyBonusByNearby@@0@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXXZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1543 : 		}

  00005	c3		 ret	 0
?clear@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXXZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXABUPartyBonusByNearby@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXABUPartyBonusByNearby@@@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 38		 jae	 SHORT $LN2@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 32		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 1278 : 			if (this->_Mylast() == this->_Myend())

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002d	85 d2		 test	 edx, edx
  0002f	74 37		 je	 SHORT $LN205@push_back
  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00033	8b 04 f9	 mov	 eax, DWORD PTR [ecx+edi*8]
  00036	89 02		 mov	 DWORD PTR [edx], eax
  00038	8b 44 f9 04	 mov	 eax, DWORD PTR [ecx+edi*8+4]
  0003c	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  0003f	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN2@push_back:

; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  00049	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004c	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  0004e	6a 01		 push	 1
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@IAEXI@Z ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00057	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005a	85 c9		 test	 ecx, ecx
  0005c	74 0a		 je	 SHORT $LN205@push_back
  0005e	8b 07		 mov	 eax, DWORD PTR [edi]
  00060	89 01		 mov	 DWORD PTR [ecx], eax
  00062	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00065	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN205@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00068	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?push_back@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXABUPartyBonusByNearby@@@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEAAUPartyBonusByNearby@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEAAUPartyBonusByNearby@@I@Z PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1241 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEAAUPartyBonusByNearby@@I@Z ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1180 : 		}

  00008	c3		 ret	 0
?size@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 03	 sar	 eax, 3

; 1048 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1043 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIXZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@XZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::~vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 03	 sar	 eax, 3
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0002e	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0002f	c3		 ret	 0
??1?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@XZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::~vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@XZ PROC ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@XZ ENDP ; std::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >::vector<PartyBonusByNearby,std::allocator<PartyBonusByNearby> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >,std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >::_Vector_val<std::_Simple_types<PartyBonusByNearby> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PartyBonusByNearby> >::_Vector_val<std::_Simple_types<PartyBonusByNearby> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABQAUPartyBonusByNearby@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAPAUPartyBonusByNearby@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByNearby@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByNearby@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UPartyBonusByNearby@@V?$allocator@UPartyBonusByNearby@@@std@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByNearby@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >::_Vector_alloc<std::_Vec_base_types<PartyBonusByNearby,std::allocator<PartyBonusByNearby> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	77 31		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEPAUPartyBonusByNearby@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEPAUPartyBonusByNearby@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UPartyBonusByNearby@@@std@@QAEPAUPartyBonusByNearby@@I@Z ; std::allocator<PartyBonusByNearby>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAEPAUPartyBonusByNearby@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByNearby@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByNearby@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::_Wrap_alloc<std::allocator<PartyBonusByNearby> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UPartyBonusByNearby@@@std@@@std@@QAE@ABV?$allocator@UPartyBonusByNearby@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<PartyBonusByNearby> >::_Wrap_alloc<std::allocator<PartyBonusByNearby> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAIABV?$allocator@UPartyBonusByNearby@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAIABV?$allocator@UPartyBonusByNearby@@@2@@Z PROC ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UPartyBonusByNearby@@@std@@@std@@SAIABV?$allocator@UPartyBonusByNearby@@@2@@Z ENDP ; std::allocator_traits<std::allocator<PartyBonusByNearby> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UPartyBonusByNearby@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UPartyBonusByNearby@@@std@@QBEIXZ PROC ; std::allocator<PartyBonusByNearby>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UPartyBonusByNearby@@@std@@QBEIXZ ENDP ; std::allocator<PartyBonusByNearby>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UPartyBonusByNearby@@@std@@QAEPAUPartyBonusByNearby@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UPartyBonusByNearby@@@std@@QAEPAUPartyBonusByNearby@@I@Z PROC ; std::allocator<PartyBonusByNearby>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00013	77 3c		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	c1 e0 03	 shl	 eax, 3

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@UPartyBonusByNearby@@@std@@QAEPAUPartyBonusByNearby@@I@Z ENDP ; std::allocator<PartyBonusByNearby>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@I@Z PROC ; std::allocator<PartyBonusByNearby>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	77 31		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@UPartyBonusByNearby@@@std@@QAEXPAUPartyBonusByNearby@@I@Z ENDP ; std::allocator<PartyBonusByNearby>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UPartyBonusByNearby@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UPartyBonusByNearby@@@std@@QAE@ABV01@@Z PROC ; std::allocator<PartyBonusByNearby>::allocator<PartyBonusByNearby>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UPartyBonusByNearby@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<PartyBonusByNearby>::allocator<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UPartyBonusByNearby@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UPartyBonusByNearby@@@std@@QAE@XZ PROC	; std::allocator<PartyBonusByNearby>::allocator<PartyBonusByNearby>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UPartyBonusByNearby@@@std@@QAE@XZ ENDP	; std::allocator<PartyBonusByNearby>::allocator<PartyBonusByNearby>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\partyclass.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
