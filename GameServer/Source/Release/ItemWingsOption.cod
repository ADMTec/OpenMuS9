; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\ItemWingsOption.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?Load@ItemWingsOption@@QAEXXZ			; ItemWingsOption::Load
PUBLIC	?Init@ItemWingsOption@@QAEXXZ			; ItemWingsOption::Init
PUBLIC	?Read@ItemWingsOption@@QAEXPBD@Z		; ItemWingsOption::Read
PUBLIC	?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Orphan_all
PUBLIC	?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Destroy
PUBLIC	?g_ItemWingsOption@@3VItemWingsOption@@A	; g_ItemWingsOption
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
_BSS	SEGMENT
?g_ItemWingsOption@@3VItemWingsOption@@A DB 0cH DUP (?)	; g_ItemWingsOption
_BSS	ENDS
CRT$XCU	SEGMENT
?g_ItemWingsOption$initializer$@@3P6AXXZA DD FLAT:??__Eg_ItemWingsOption@@YAXXZ ; g_ItemWingsOption$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemWingsOptionInfo@@@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UItemWingsOptionInfo@@@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@@Z PROC ; std::allocator<ItemWingsOptionInfo>::destroy<ItemWingsOptionInfo>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UItemWingsOptionInfo@@@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@@Z ENDP ; std::allocator<ItemWingsOptionInfo>::destroy<ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemWingsOptionInfo@@@?$allocator_traits@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@SAXAAV?$allocator@UItemWingsOptionInfo@@@1@PAUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UItemWingsOptionInfo@@@?$allocator_traits@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@SAXAAV?$allocator@UItemWingsOptionInfo@@@1@PAUItemWingsOptionInfo@@@Z PROC ; std::allocator_traits<std::allocator<ItemWingsOptionInfo> >::destroy<ItemWingsOptionInfo>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@UItemWingsOptionInfo@@@?$allocator_traits@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@SAXAAV?$allocator@UItemWingsOptionInfo@@@1@PAUItemWingsOptionInfo@@@Z ENDP ; std::allocator_traits<std::allocator<ItemWingsOptionInfo> >::destroy<ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ItemWingsOptionInfo>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemWingsOptionInfo@@@?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXPAUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UItemWingsOptionInfo@@@?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXPAUItemWingsOptionInfo@@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::destroy<ItemWingsOptionInfo>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UItemWingsOptionInfo@@@?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXPAUItemWingsOptionInfo@@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::destroy<ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@@Z PROC ; std::addressof<ItemWingsOptionInfo>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@@Z ENDP ; std::addressof<ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAUItemWingsOptionInfo@@@std@@YA$$QAPAUItemWingsOptionInfo@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAUItemWingsOptionInfo@@@std@@YA$$QAPAUItemWingsOptionInfo@@AAPAU1@@Z PROC ; std::_Move<ItemWingsOptionInfo * &>, COMDAT

; 1257 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1258 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1259 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAUItemWingsOptionInfo@@@std@@YA$$QAPAUItemWingsOptionInfo@@AAPAU1@@Z ENDP ; std::_Move<ItemWingsOptionInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UItemWingsOptionInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UItemWingsOptionInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemWingsOptionInfo@@0@Z PROC ; std::_Ptr_cat<ItemWingsOptionInfo,ItemWingsOptionInfo>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UItemWingsOptionInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemWingsOptionInfo@@0@Z ENDP ; std::_Ptr_cat<ItemWingsOptionInfo,ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAABV?$allocator@UItemWingsOptionInfo@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAABV?$allocator@UItemWingsOptionInfo@@@0@ABV10@@Z PROC ; std::forward<std::allocator<ItemWingsOptionInfo> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAABV?$allocator@UItemWingsOptionInfo@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<ItemWingsOptionInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >, COMDAT

; 999  : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UItemWingsOptionInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UItemWingsOptionInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1><std::allocator<ItemWingsOptionInfo> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UItemWingsOptionInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1><std::allocator<ItemWingsOptionInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >, COMDAT

; 1004 : 	typename _Alty::propagate_on_container_swap _Tag;
; 1005 : 	_Pocs(_Left, _Right, _Tag);
; 1006 : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z PROC ; std::swap<ItemWingsOptionInfo *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z ENDP ; std::swap<ItemWingsOptionInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$_Swap_adl@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z PROC ; std::_Swap_adl<ItemWingsOptionInfo *>, COMDAT

; 61   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 62   : 	swap(_Left, _Right);
; 63   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z ENDP ; std::_Swap_adl<ItemWingsOptionInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z PROC ; std::operator==<ItemWingsOptionInfo,ItemWingsOptionInfo>, COMDAT

; 712  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 713  : 	}

  00002	c3		 ret	 0
??$?8UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z ENDP ; std::operator==<ItemWingsOptionInfo,ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@UItemWingsOptionInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@UItemWingsOptionInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<ItemWingsOptionInfo>,std::allocator<ItemWingsOptionInfo> >, COMDAT

; 939  : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 940  : 		== static_cast<const _Other&>(_Right));
; 941  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@UItemWingsOptionInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<ItemWingsOptionInfo>,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??__Fg_ItemWingsOption@@YAXXZ
text$yd	SEGMENT
??__Fg_ItemWingsOption@@YAXXZ PROC			; `dynamic atexit destructor for 'g_ItemWingsOption'', COMDAT

; 1656 : 		if (this->_Myfirst() != pointer())

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A, 0
  00007	74 69		 je	 SHORT $LN10@dynamic

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();

  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemWingsOption@@3VItemWingsOption@@A ; g_ItemWingsOption
  0000e	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Orphan_all

; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00013	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+4
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemWingsOption@@3VItemWingsOption@@A ; g_ItemWingsOption
  0001e	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A
  00024	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Destroy

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00029	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+8
  0002f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00034	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemWingsOption@@3VItemWingsOption@@A ; g_ItemWingsOption
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0003f	f7 ea		 imul	 edx
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00046	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00048	50		 push	 eax
  00049	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A
  0004f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00054	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A, 0

; 1663 : 			this->_Mylast() = pointer();

  0005e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+4, 0

; 1664 : 			this->_Myend() = pointer();

  00068	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+8, 0
$LN10@dynamic:
  00072	c3		 ret	 0
??__Fg_ItemWingsOption@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_ItemWingsOption''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
;	COMDAT ??__Eg_ItemWingsOption@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eg_ItemWingsOption@@YAXXZ PROC			; `dynamic initializer for 'g_ItemWingsOption'', COMDAT

; 5    : ItemWingsOption g_ItemWingsOption;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 286  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

  00004	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemWingsOption@@3VItemWingsOption@@A ; g_ItemWingsOption
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp

; 5    : ItemWingsOption g_ItemWingsOption;

  00012	68 00 00 00 00	 push	 OFFSET ??__Fg_ItemWingsOption@@YAXXZ ; `dynamic atexit destructor for 'g_ItemWingsOption''
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A, 0

; 481  : 		_Mylast = pointer();

  00021	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+4, 0

; 482  : 		_Myend = pointer();

  0002b	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+8, 0
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp

; 5    : ItemWingsOption g_ItemWingsOption;

  00035	e8 00 00 00 00	 call	 _atexit
  0003a	83 c4 04	 add	 esp, 4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__Eg_ItemWingsOption@@YAXXZ ENDP			; `dynamic initializer for 'g_ItemWingsOption''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 30		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	8b c2		 mov	 eax, edx
  00017	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001c	50		 push	 eax
  0001d	51		 push	 ecx
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00032	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  00039	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0003a	c3		 ret	 0
?_Tidy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::swap, COMDAT
; _this$ = ecx

; 1548 : 		{	// exchange contents with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1549 : 		if (this == &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 20		 je	 SHORT $LN7@swap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 16		 mov	 edx, DWORD PTR [esi]
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 54   : 	_Right = _Move(_Tmp);

  00014	89 17		 mov	 DWORD PTR [edi], edx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00019	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0001f	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00022	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 53   : 	_Left = _Move(_Right);

  00025	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 	_Right = _Move(_Tmp);

  0002b	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
$LN7@swap:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1576 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1543 : 		}

  00005	c3		 ret	 0
?clear@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	8b c2		 mov	 eax, edx
  0000e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00011	03 c2		 add	 eax, edx

; 1043 : 		}

  00013	c3		 ret	 0
?capacity@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 30		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	8b c2		 mov	 eax, edx
  00017	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001c	50		 push	 eax
  0001d	51		 push	 ecx
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00032	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00039	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0003a	c3		 ret	 0
??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >,std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >::_Vector_val<std::_Simple_types<ItemWingsOptionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABQAUItemWingsOptionInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABQAUItemWingsOptionInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABQAUItemWingsOptionInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABQAUItemWingsOptionInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABQAUItemWingsOptionInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABQAUItemWingsOptionInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAPAUItemWingsOptionInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemWingsOptionInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Swap_all, COMDAT
; _this$ = ecx

; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Swap_alloc, COMDAT
; _this$ = ecx

; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Swap_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@ABV?$allocator@UItemWingsOptionInfo@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >::_Wrap_alloc<std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z PROC ; std::allocator<ItemWingsOptionInfo>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d aa aa aa 2a	 cmp	 eax, 715827882		; 2aaaaaaaH
  0000e	77 33		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00013	03 c0		 add	 eax, eax

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00015	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001a	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001c	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001f	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00021	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00024	3b c1		 cmp	 eax, ecx
  00026	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00028	2b c8		 sub	 ecx, eax
  0002a	83 f9 04	 cmp	 ecx, 4
  0002d	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002f	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00032	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00034	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00043	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00048	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00052	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00057	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005c	cc		 int	 3
?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ENDP ; std::allocator<ItemWingsOptionInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@XZ PROC	; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@XZ ENDP	; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
;	COMDAT ?Read@ItemWingsOption@@QAEXPBD@Z
_TEXT	SEGMENT
_File$ = 8						; size = 4
?Read@ItemWingsOption@@QAEXPBD@Z PROC			; ItemWingsOption::Read, COMDAT
; _this$ = ecx

; 21   : 	
; 22   : }

  00000	c2 04 00	 ret	 4
?Read@ItemWingsOption@@QAEXPBD@Z ENDP			; ItemWingsOption::Read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
;	COMDAT ?Init@ItemWingsOption@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?Init@ItemWingsOption@@QAEXXZ PROC			; ItemWingsOption::Init, COMDAT
; _this$ = ecx

; 13   : void ItemWingsOption::Init() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp

; 13   : void ItemWingsOption::Init() {

  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0000b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00010	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00013	56		 push	 esi
  00014	8b 31		 mov	 esi, DWORD PTR [ecx]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	8b c2		 mov	 eax, edx
  0001c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001f	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp

; 15   : 	if (m_OptionInfo.capacity() > 0) {

  00021	74 3c		 je	 SHORT $LN310@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1549 : 		if (this == &_Right)

  00023	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00026	3b c1		 cmp	 eax, ecx
  00028	74 35		 je	 SHORT $LN310@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00030	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 53   : 	_Left = _Move(_Right);

  00037	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 54   : 	_Right = _Move(_Tmp);

  0003a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00041	85 f6		 test	 esi, esi
  00043	74 1a		 je	 SHORT $LN310@Init

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00045	2b d6		 sub	 edx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00047	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0004a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004f	f7 ea		 imul	 edx
  00051	8b c2		 mov	 eax, edx
  00053	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00056	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
$LN310@Init:
  0005f	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp

; 18   : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?Init@ItemWingsOption@@QAEXXZ ENDP			; ItemWingsOption::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
;	COMDAT ?Load@ItemWingsOption@@QAEXXZ
_TEXT	SEGMENT
?Load@ItemWingsOption@@QAEXXZ PROC			; ItemWingsOption::Load, COMDAT
; _this$ = ecx

; 9    : 	Init();

  00000	e9 00 00 00 00	 jmp	 ?Init@ItemWingsOption@@QAEXXZ ; ItemWingsOption::Init
?Load@ItemWingsOption@@QAEXXZ ENDP			; ItemWingsOption::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.h
;	COMDAT ??1ItemWingsOption@@QAE@XZ
_TEXT	SEGMENT
??1ItemWingsOption@@QAE@XZ PROC				; ItemWingsOption::~ItemWingsOption, COMDAT
; _this$ = ecx

; 16   : 	~ItemWingsOption() { };

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 30		 je	 SHORT $LN7@ItemWingsO

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	8b c2		 mov	 eax, edx
  00017	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001c	50		 push	 eax
  0001d	51		 push	 ecx
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00032	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN7@ItemWingsO:
  00039	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.h

; 16   : 	~ItemWingsOption() { };

  0003a	c3		 ret	 0
??1ItemWingsOption@@QAE@XZ ENDP				; ItemWingsOption::~ItemWingsOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.h
;	COMDAT ??0ItemWingsOption@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ItemWingsOption@@QAE@XZ PROC				; ItemWingsOption::ItemWingsOption, COMDAT
; _this$ = ecx

; 15   : 	ItemWingsOption() { };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();

  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  00016	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.h

; 15   : 	ItemWingsOption() { };

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0ItemWingsOption@@QAE@XZ ENDP				; ItemWingsOption::ItemWingsOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 48   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemwingsoption.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
