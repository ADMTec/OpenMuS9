; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\ItemUpgradeJewels.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
PUBLIC	?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocate
PUBLIC	??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
PUBLIC	?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reserve
PUBLIC	?_Tidy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXXZ ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Tidy
PUBLIC	??1ItemUpgradeJewelsInfo@@QAE@XZ		; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
PUBLIC	??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z		; ItemUpgradeJewelsInfo::ItemUpgradeJewelsInfo
PUBLIC	??0ItemUpgradeJewels@@QAE@XZ			; ItemUpgradeJewels::ItemUpgradeJewels
PUBLIC	??1ItemUpgradeJewels@@UAE@XZ			; ItemUpgradeJewels::~ItemUpgradeJewels
PUBLIC	?Init@ItemUpgradeJewels@@QAEXXZ			; ItemUpgradeJewels::Init
PUBLIC	?Load@ItemUpgradeJewels@@QAEXXZ			; ItemUpgradeJewels::Load
PUBLIC	?Read@ItemUpgradeJewels@@QAEXPAD@Z		; ItemUpgradeJewels::Read
PUBLIC	?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z ; ItemUpgradeJewels::ProcInsert
PUBLIC	?ProcUpgrade@ItemUpgradeJewels@@QAE_NPAUOBJECTSTRUCT@@HHPAUItemUpgradeJewelsInfo@@@Z ; ItemUpgradeJewels::ProcUpgrade
PUBLIC	?IsJewel@ItemUpgradeJewels@@QAE_NH@Z		; ItemUpgradeJewels::IsJewel
PUBLIC	?GetRateChangeRule@ItemUpgradeJewels@@QAEPAUItemUpgradeJewelsRateChangeInfo@@PAUItemUpgradeJewelsInfo@@E@Z ; ItemUpgradeJewels::GetRateChangeRule
PUBLIC	?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::deallocate
PUBLIC	?allocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::allocate
PUBLIC	?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::push_back
PUBLIC	?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reserve
PUBLIC	?_Tidy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXXZ ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Tidy
PUBLIC	??_GItemUpgradeJewels@@UAEPAXI@Z		; ItemUpgradeJewels::`scalar deleting destructor'
PUBLIC	??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::allocator<ItemUpgradeJewelsInfo>,ItemUpgradeJewelsInfo>
PUBLIC	??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo>,ItemUpgradeJewelsRateChangeInfo>
PUBLIC	??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
PUBLIC	??_7ItemUpgradeJewels@@6B@			; ItemUpgradeJewels::`vftable'
PUBLIC	?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A	; g_ItemUpgradeJewels
PUBLIC	??_C@_0BL@BDIDLPMO@Item?2ItemUpgradeJewels?4xml?$AA@ ; `string'
PUBLIC	??_C@_0CH@JADJMKEP@?$FLItemUpgradeJewels?$FN?5File?5?$CFs?5not?5@ ; `string'
PUBLIC	??_C@_0BC@JBIPBODA@itemupgradejewels?$AA@	; `string'
PUBLIC	??_C@_05MHDMDPBI@jewel?$AA@			; `string'
PUBLIC	??_C@_04GPMDFGEJ@type?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_04HCCHHEEF@rate?$AA@			; `string'
PUBLIC	??_C@_05CBLPGGM@rules?$AA@			; `string'
PUBLIC	??_C@_05KJNJLLGA@level?$AA@			; `string'
PUBLIC	??_C@_03KLIPLJLL@min?$AA@			; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
PUBLIC	??_C@_04PNBFHPGN@rank?$AA@			; `string'
PUBLIC	??_C@_06IKLLLDHL@normal?$AA@			; `string'
PUBLIC	??_C@_09MBDMPFOO@excellent?$AA@			; `string'
PUBLIC	??_C@_07ECLFICCK@ancient?$AA@			; `string'
PUBLIC	??_C@_06HBELJPBO@socket?$AA@			; `string'
PUBLIC	??_C@_0L@ENBHLBKM@ratechange?$AA@		; `string'
PUBLIC	??_C@_06OGMGCFPO@option?$AA@			; `string'
PUBLIC	??_C@_08EMJGLFCF@increase?$AA@			; `string'
PUBLIC	??_C@_08OALDEOCE@decrease?$AA@			; `string'
PUBLIC	??_C@_0DB@JGAJMHKC@?$FLFENRIR?5REPAIR?$FN?$FLSUCCESS?$FN?5?$FL?$CFs?$FN?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0DA@PNDNNHGN@?$FLFENRIR?5REPAIR?$FN?$FLFAILED?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0DO@KOLBHFBF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ ; `string'
PUBLIC	??_C@_0GM@BCEBDMP@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ ; `string'
PUBLIC	??_C@_0HB@BFMNEGMJ@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ ; `string'
PUBLIC	??_C@_0IA@PFHJPDOF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ ; `string'
PUBLIC	??_C@_0GF@EOLHJPBK@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4ItemUpgradeJewels@@6B@			; ItemUpgradeJewels::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVItemUpgradeJewels@@@8			; ItemUpgradeJewels `RTTI Type Descriptor'
PUBLIC	??_R3ItemUpgradeJewels@@8			; ItemUpgradeJewels::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ItemUpgradeJewels@@8			; ItemUpgradeJewels::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ItemUpgradeJewels@@8		; ItemUpgradeJewels::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@437f0000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_rand:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEE@Z:PROC		; CItem::Convert
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
EXTRN	?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::_GetItemType
EXTRN	?_GetSelectRandomOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z:PROC ; CJewelOfHarmonySystem::_GetSelectRandomOption
EXTRN	?_MakeOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@EE@Z:PROC ; CJewelOfHarmonySystem::_MakeOption
EXTRN	?IsSocketItem@CSocketItems@@QAE_NH@Z:PROC	; CSocketItems::IsSocketItem
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCInventoryItemOneSend@@YAXHH@Z:PROC		; GCInventoryItemOneSend
EXTRN	?GCReFillSend@@YAXHGEEG@Z:PROC			; GCReFillSend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?gObjItemLevelUpPickAxe@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjItemLevelUpPickAxe
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	??_EItemUpgradeJewels@@UAEPAXI@Z:PROC		; ItemUpgradeJewels::`vector deleting destructor'
EXTRN	?as_int@xml_attribute@pugi@@QBEHH@Z:PROC	; pugi::xml_attribute::as_int
EXTRN	?as_uint@xml_attribute@pugi@@QBEII@Z:PROC	; pugi::xml_attribute::as_uint
EXTRN	??0xml_node@pugi@@QAE@XZ:PROC			; pugi::xml_node::xml_node
EXTRN	??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ:PROC	; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
EXTRN	?next_sibling@xml_node@pugi@@QBE?AV12@XZ:PROC	; pugi::xml_node::next_sibling
EXTRN	?child@xml_node@pugi@@QBE?AV12@PBD@Z:PROC	; pugi::xml_node::child
EXTRN	?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z:PROC ; pugi::xml_node::attribute
EXTRN	??0xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::xml_document
EXTRN	??1xml_document@pugi@@QAE@XZ:PROC		; pugi::xml_document::~xml_document
EXTRN	?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z:PROC ; pugi::xml_document::load_file
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?IsSetItem@CSetItemOption@@QAEHH@Z:PROC		; CSetItemOption::IsSetItem
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	?g_SocketItem@@3VCSocketItems@@A:BYTE		; g_SocketItem
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_iFenrirRepairRate@@3HA:DWORD			; g_iFenrirRepairRate
EXTRN	?gSetItemOption@@3VCSetItemOption@@A:BYTE	; gSetItemOption
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A DB 010H DUP (?) ; g_ItemUpgradeJewels
_BSS	ENDS
CRT$XCU	SEGMENT
?g_ItemUpgradeJewels$initializer$@@3P6AXXZA DD FLAT:??__Eg_ItemUpgradeJewels@@YAXXZ ; g_ItemUpgradeJewels$initializer$
CRT$XCU	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@ItemUpgradeJewels@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ItemUpgradeJewels@@8 DD FLAT:??_R0?AVItemUpgradeJewels@@@8 ; ItemUpgradeJewels::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ItemUpgradeJewels@@8
rdata$r	ENDS
;	COMDAT ??_R2ItemUpgradeJewels@@8
rdata$r	SEGMENT
??_R2ItemUpgradeJewels@@8 DD FLAT:??_R1A@?0A@EA@ItemUpgradeJewels@@8 ; ItemUpgradeJewels::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ItemUpgradeJewels@@8
rdata$r	SEGMENT
??_R3ItemUpgradeJewels@@8 DD 00H			; ItemUpgradeJewels::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ItemUpgradeJewels@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVItemUpgradeJewels@@@8
data$r	SEGMENT
??_R0?AVItemUpgradeJewels@@@8 DD FLAT:??_7type_info@@6B@ ; ItemUpgradeJewels `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVItemUpgradeJewels@@', 00H
data$r	ENDS
;	COMDAT ??_R4ItemUpgradeJewels@@6B@
rdata$r	SEGMENT
??_R4ItemUpgradeJewels@@6B@ DD 00H			; ItemUpgradeJewels::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVItemUpgradeJewels@@@8
	DD	FLAT:??_R3ItemUpgradeJewels@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@EOLHJPBK@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
CONST	SEGMENT
??_C@_0GF@EOLHJPBK@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ DB '[Je'
	DB	'welOfHarmony][Strengten Item] Strenghten Fail [%s][%s] Name[%'
	DB	's] Type[%d] Serial[%d]  Rate (%d/%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@PFHJPDOF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
CONST	SEGMENT
??_C@_0IA@PFHJPDOF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ DB '[Je'
	DB	'welOfHarmony][Strengten Item] Strenghten Success [%s][%s] Nam'
	DB	'e[%s] Type[%d] Serial[%d] Rate (%d/%d) Option %d OptionLevel '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@BFMNEGMJ@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
CONST	SEGMENT
??_C@_0HB@BFMNEGMJ@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ DB '[Je'
	DB	'welOfHarmony][Strengten Item] Strenghten Fail - NOT OPTION [%'
	DB	's][%s] Name[%s] Type[%d] Serial[%d] ItemType[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@BCEBDMP@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
CONST	SEGMENT
??_C@_0GM@BCEBDMP@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ DB '[Jew'
	DB	'elOfHarmony][Strengten Item] Strenghten Fail [%s][%s] Name[%s'
	DB	'] Type[%d] Serial[%d] Invalid ItemType[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@KOLBHFBF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
CONST	SEGMENT
??_C@_0DO@KOLBHFBF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@ DB '[Je'
	DB	'welOfHarmony][Strengten Item] Already Strengtened [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PNDNNHGN@?$FLFENRIR?5REPAIR?$FN?$FLFAILED?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0DA@PNDNNHGN@?$FLFENRIR?5REPAIR?$FN?$FLFAILED?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'FENRIR REPAIR][FAILED] [%s][%s] - %d/255 (+%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JGAJMHKC@?$FLFENRIR?5REPAIR?$FN?$FLSUCCESS?$FN?5?$FL?$CFs?$FN?$FL?$CFs@
CONST	SEGMENT
??_C@_0DB@JGAJMHKC@?$FLFENRIR?5REPAIR?$FN?$FLSUCCESS?$FN?5?$FL?$CFs?$FN?$FL?$CFs@ DB '['
	DB	'FENRIR REPAIR][SUCCESS] [%s][%s] - %d/255 (+%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OALDEOCE@decrease?$AA@
CONST	SEGMENT
??_C@_08OALDEOCE@decrease?$AA@ DB 'decrease', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMJGLFCF@increase?$AA@
CONST	SEGMENT
??_C@_08EMJGLFCF@increase?$AA@ DB 'increase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGMGCFPO@option?$AA@
CONST	SEGMENT
??_C@_06OGMGCFPO@option?$AA@ DB 'option', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ENBHLBKM@ratechange?$AA@
CONST	SEGMENT
??_C@_0L@ENBHLBKM@ratechange?$AA@ DB 'ratechange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBELJPBO@socket?$AA@
CONST	SEGMENT
??_C@_06HBELJPBO@socket?$AA@ DB 'socket', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECLFICCK@ancient?$AA@
CONST	SEGMENT
??_C@_07ECLFICCK@ancient?$AA@ DB 'ancient', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBDMPFOO@excellent?$AA@
CONST	SEGMENT
??_C@_09MBDMPFOO@excellent?$AA@ DB 'excellent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT
??_C@_06IKLLLDHL@normal?$AA@ DB 'normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNBFHPGN@rank?$AA@
CONST	SEGMENT
??_C@_04PNBFHPGN@rank?$AA@ DB 'rank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min?$AA@
CONST	SEGMENT
??_C@_03KLIPLJLL@min?$AA@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJNJLLGA@level?$AA@
CONST	SEGMENT
??_C@_05KJNJLLGA@level?$AA@ DB 'level', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CBLPGGM@rules?$AA@
CONST	SEGMENT
??_C@_05CBLPGGM@rules?$AA@ DB 'rules', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate?$AA@
CONST	SEGMENT
??_C@_04HCCHHEEF@rate?$AA@ DB 'rate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type?$AA@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type?$AA@ DB 'type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MHDMDPBI@jewel?$AA@
CONST	SEGMENT
??_C@_05MHDMDPBI@jewel?$AA@ DB 'jewel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBIPBODA@itemupgradejewels?$AA@
CONST	SEGMENT
??_C@_0BC@JBIPBODA@itemupgradejewels?$AA@ DB 'itemupgradejewels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JADJMKEP@?$FLItemUpgradeJewels?$FN?5File?5?$CFs?5not?5@
CONST	SEGMENT
??_C@_0CH@JADJMKEP@?$FLItemUpgradeJewels?$FN?5File?5?$CFs?5not?5@ DB '[It'
	DB	'emUpgradeJewels] File %s not found!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BDIDLPMO@Item?2ItemUpgradeJewels?4xml?$AA@
CONST	SEGMENT
??_C@_0BL@BDIDLPMO@Item?2ItemUpgradeJewels?4xml?$AA@ DB 'Item\ItemUpgrade'
	DB	'Jewels.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7ItemUpgradeJewels@@6B@
CONST	SEGMENT
??_7ItemUpgradeJewels@@6B@ DD FLAT:??_R4ItemUpgradeJewels@@6B@ ; ItemUpgradeJewels::`vftable'
	DD	FLAT:??_EItemUpgradeJewels@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z$0
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z$1
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z$2
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$8
__unwindtable$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z$0
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z$0
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z$1
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z$1
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z$2
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z$2
__ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z$55 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z$55
__ehfuncinfo$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z$59
__ehfuncinfo$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Read@ItemUpgradeJewels@@QAEXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@ItemUpgradeJewels@@QAEXPAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Read@ItemUpgradeJewels@@QAEXPAD@Z$1
__ehfuncinfo$?Read@ItemUpgradeJewels@@QAEXPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Read@ItemUpgradeJewels@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z$50 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z$50
__ehfuncinfo$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z$66 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z$66
__ehfuncinfo$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT

; 373  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 378  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 1c		 je	 SHORT $LN3@Uninit_cop
$LL4@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN2@Uninit_cop
  00015	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00019	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN2@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 378  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00023	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00026	83 c0 0c	 add	 eax, 12			; 0000000cH
  00029	3b ce		 cmp	 ecx, esi
  0002b	75 e4		 jne	 SHORT $LL4@Uninit_cop
$LN3@Uninit_cop:
  0002d	5e		 pop	 esi

; 379  : 		_Al.construct(_Dest, *_First);
; 380  : 	_CATCH_ALL
; 381  : 	for (; _Next != _Dest; ++_Next)
; 382  : 		_Al.destroy(_Next);
; 383  : 	_RERAISE;
; 384  : 	_CATCH_END
; 385  : 	return (_Dest);
; 386  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@$$QAU2@@Z PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 656  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@$$QAU2@@Z ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z PROC ; std::allocator<ItemUpgradeJewelsInfo>::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN3@construct:

; 656  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z ENDP ; std::allocator<ItemUpgradeJewelsInfo>::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z PROC ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z ENDP ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 265  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 266  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 267  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UItemUpgradeJewelsRateChangeInfo@@@std@@YA$$QAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UItemUpgradeJewelsRateChangeInfo@@@std@@YA$$QAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z PROC ; std::forward<ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UItemUpgradeJewelsRateChangeInfo@@@std@@YA$$QAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z ENDP ; std::forward<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@U1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UItemUpgradeJewelsInfo@@@std@@YA$$QAUItemUpgradeJewelsInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UItemUpgradeJewelsInfo@@@std@@YA$$QAUItemUpgradeJewelsInfo@@AAU1@@Z PROC ; std::forward<ItemUpgradeJewelsInfo>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UItemUpgradeJewelsInfo@@@std@@YA$$QAUItemUpgradeJewelsInfo@@AAU1@@Z ENDP ; std::forward<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YA$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YA$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@AAV10@@Z PROC ; std::forward<std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YA$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@PAUItemUpgradeJewelsRateChangeInfo@@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@PAUItemUpgradeJewelsRateChangeInfo@@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
  00017	83 c4 14	 add	 esp, 20			; 00000014H

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@PAUItemUpgradeJewelsRateChangeInfo@@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UItemUpgradeJewelsRateChangeInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@U1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@@Z PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::destroy<ItemUpgradeJewelsRateChangeInfo>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@@Z ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::destroy<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemUpgradeJewelsInfo@@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UItemUpgradeJewelsInfo@@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@@Z PROC ; std::allocator<ItemUpgradeJewelsInfo>::destroy<ItemUpgradeJewelsInfo>, COMDAT
; _this$ = ecx

; 661  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UItemUpgradeJewelsInfo@@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@@Z ENDP ; std::allocator<ItemUpgradeJewelsInfo>::destroy<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1><std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1><std::allocator<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YA$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YA$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@AAV10@@Z PROC ; std::move<std::allocator<ItemUpgradeJewelsRateChangeInfo> &>, COMDAT

; 1249 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1251 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YA$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@AAV10@@Z ENDP ; std::move<std::allocator<ItemUpgradeJewelsRateChangeInfo> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@1@0PAU2@@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > > >, COMDAT
; _this$ = ecx

; 1670 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	51		 push	 ecx
  00007	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
  00015	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1673 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsRateChangeInfo@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@1@0PAU2@@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEPBUItemUpgradeJewelsRateChangeInfo@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEPBUItemUpgradeJewelsRateChangeInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEPBUItemUpgradeJewelsRateChangeInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@PAUItemUpgradeJewelsRateChangeInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@PAUItemUpgradeJewelsRateChangeInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@PAUItemUpgradeJewelsRateChangeInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo>,ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 1c		 je	 SHORT $LN3@Uninit_mov
$LL4@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN2@Uninit_mov
  00015	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00019	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN2@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00023	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00026	83 c0 0c	 add	 eax, 12			; 0000000cH
  00029	3b ce		 cmp	 ecx, esi
  0002b	75 e4		 jne	 SHORT $LL4@Uninit_mov
$LN3@Uninit_mov:
  0002d	5e		 pop	 esi

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);
; 450  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo>,ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@@Z PROC ; std::_Val_type<ItemUpgradeJewelsRateChangeInfo *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@@Z ENDP ; std::_Val_type<ItemUpgradeJewelsRateChangeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::allocator<ItemUpgradeJewelsInfo>,ItemUpgradeJewelsInfo>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 438  : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 439  : 	_FwdIt _Next = _Dest;

  0002b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 440  : 
; 441  : 	_TRY_BEGIN

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00031	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00034	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	66 90		 npad	 2
$LL4@Uninit_mov:

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00040	3b fb		 cmp	 edi, ebx
  00042	0f 84 85 00 00
	00		 je	 $LN3@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00048	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004f	85 f6		 test	 esi, esi
  00051	74 4a		 je	 SHORT $LN26@Uninit_mov
  00053	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00056	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00059	66 89 06	 mov	 WORD PTR [esi], ax
  0005c	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  00060	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  00064	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00067	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0006a	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  0006e	88 46 08	 mov	 BYTE PTR [esi+8], al
  00071	0f b6 47 09	 movzx	 eax, BYTE PTR [edi+9]
  00075	88 46 09	 mov	 BYTE PTR [esi+9], al
  00078	0f b6 47 0a	 movzx	 eax, BYTE PTR [edi+10]
  0007c	88 46 0a	 mov	 BYTE PTR [esi+10], al
  0007f	0f b6 47 0b	 movzx	 eax, BYTE PTR [edi+11]
  00083	88 46 0b	 mov	 BYTE PTR [esi+11], al
  00086	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  0008a	88 46 0c	 mov	 BYTE PTR [esi+12], al
  0008d	0f b6 47 0d	 movzx	 eax, BYTE PTR [edi+13]
  00091	88 46 0d	 mov	 BYTE PTR [esi+13], al
  00094	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
$LN26@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0009d	83 c6 1c	 add	 esi, 28			; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  000a0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  000a4	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  000a7	83 c7 1c	 add	 edi, 28			; 0000001cH
  000aa	eb 94		 jmp	 SHORT $LL4@Uninit_mov
__catch$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)

  000ac	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  000af	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  000b2	3b f7		 cmp	 esi, edi
  000b4	74 0e		 je	 SHORT $LN6@Uninit_mov
$LL7@Uninit_mov:
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  000bd	83 c6 1c	 add	 esi, 28			; 0000001cH
  000c0	3b f7		 cmp	 esi, edi
  000c2	75 f2		 jne	 SHORT $LL7@Uninit_mov
$LN6@Uninit_mov:

; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;

  000c4	6a 00		 push	 0
  000c6	6a 00		 push	 0
  000c8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN56@Uninit_mov:
$LN3@Uninit_mov:

; 448  : 	_CATCH_END
; 449  : 	return (_Dest);

  000cd	8b c6		 mov	 eax, esi

; 450  : 	}

  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN55@Uninit_mov:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$4:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::allocator<ItemUpgradeJewelsInfo>,ItemUpgradeJewelsInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@@Z PROC ; std::_Val_type<ItemUpgradeJewelsInfo *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@@Z ENDP ; std::_Val_type<ItemUpgradeJewelsInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::destroy<ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::destroy<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemUpgradeJewelsInfo@@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UItemUpgradeJewelsInfo@@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::destroy<ItemUpgradeJewelsInfo>, COMDAT

; 779  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00006	5d		 pop	 ebp
  00007	e9 00 00 00 00	 jmp	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
??$destroy@UItemUpgradeJewelsInfo@@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::destroy<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@UItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@UItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ItemUpgradeJewelsInfo>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@UItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@@std@@YAAAPAUItemUpgradeJewelsRateChangeInfo@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@@std@@YAAAPAUItemUpgradeJewelsRateChangeInfo@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@@std@@YAAAPAUItemUpgradeJewelsRateChangeInfo@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z PROC ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo>,ItemUpgradeJewelsRateChangeInfo>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z ENDP ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@@Z PROC ; std::_Unchecked<ItemUpgradeJewelsRateChangeInfo *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@@Z ENDP ; std::_Unchecked<ItemUpgradeJewelsRateChangeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUItemUpgradeJewelsInfo@@PAU1@@std@@YAAAPAUItemUpgradeJewelsInfo@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUItemUpgradeJewelsInfo@@PAU1@@std@@YAAAPAUItemUpgradeJewelsInfo@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUItemUpgradeJewelsInfo@@PAU1@@std@@YAAAPAUItemUpgradeJewelsInfo@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z PROC ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::allocator<ItemUpgradeJewelsInfo>,ItemUpgradeJewelsInfo>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z ENDP ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@@Z PROC ; std::_Unchecked<ItemUpgradeJewelsInfo *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@@Z ENDP ; std::_Unchecked<ItemUpgradeJewelsInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::destroy<ItemUpgradeJewelsRateChangeInfo>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UItemUpgradeJewelsRateChangeInfo@@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::destroy<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z PROC ; std::addressof<ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UItemUpgradeJewelsRateChangeInfo@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z ENDP ; std::addressof<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UItemUpgradeJewelsInfo@@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UItemUpgradeJewelsInfo@@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::destroy<ItemUpgradeJewelsInfo>, COMDAT
; _this$ = ecx

; 924  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UItemUpgradeJewelsInfo@@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::destroy<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@AAU1@@Z PROC ; std::addressof<ItemUpgradeJewelsInfo>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UItemUpgradeJewelsInfo@@@std@@YAPAUItemUpgradeJewelsInfo@@AAU1@@Z ENDP ; std::addressof<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@ABU2@@Z PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 656  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@ABU2@@Z ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@AAU2@@Z PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 656  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@AAU2@@Z ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z PROC ; std::allocator<ItemUpgradeJewelsInfo>::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN3@construct:

; 656  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z ENDP ; std::allocator<ItemUpgradeJewelsInfo>::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z PROC ; std::allocator<ItemUpgradeJewelsInfo>::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN3@construct:

; 656  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z ENDP ; std::allocator<ItemUpgradeJewelsInfo>::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAUItemUpgradeJewelsRateChangeInfo@@@std@@YA$$QAPAUItemUpgradeJewelsRateChangeInfo@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAUItemUpgradeJewelsRateChangeInfo@@@std@@YA$$QAPAUItemUpgradeJewelsRateChangeInfo@@AAPAU1@@Z PROC ; std::_Move<ItemUpgradeJewelsRateChangeInfo * &>, COMDAT

; 1257 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1258 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1259 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAUItemUpgradeJewelsRateChangeInfo@@@std@@YA$$QAPAUItemUpgradeJewelsRateChangeInfo@@AAPAU1@@Z ENDP ; std::_Move<ItemUpgradeJewelsRateChangeInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAUItemUpgradeJewelsInfo@@@std@@YA$$QAPAUItemUpgradeJewelsInfo@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAUItemUpgradeJewelsInfo@@@std@@YA$$QAPAUItemUpgradeJewelsInfo@@AAPAU1@@Z PROC ; std::_Move<ItemUpgradeJewelsInfo * &>, COMDAT

; 1257 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1258 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1259 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAUItemUpgradeJewelsInfo@@@std@@YA$$QAPAUItemUpgradeJewelsInfo@@AAPAU1@@Z ENDP ; std::_Move<ItemUpgradeJewelsInfo * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z PROC ; std::_Uninitialized_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo>,ItemUpgradeJewelsRateChangeInfo>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUItemUpgradeJewelsInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUItemUpgradeJewelsInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z PROC ; std::_Uninitialized_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::allocator<ItemUpgradeJewelsInfo>,ItemUpgradeJewelsInfo>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUItemUpgradeJewelsInfo@@PAU1@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsRateChangeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsRateChangeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsRateChangeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UItemUpgradeJewelsRateChangeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemUpgradeJewelsRateChangeInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UItemUpgradeJewelsRateChangeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemUpgradeJewelsRateChangeInfo@@0@Z PROC ; std::_Ptr_cat<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UItemUpgradeJewelsRateChangeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemUpgradeJewelsRateChangeInfo@@0@Z ENDP ; std::_Ptr_cat<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UItemUpgradeJewelsRateChangeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUItemUpgradeJewelsRateChangeInfo@@PAU2@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UItemUpgradeJewelsRateChangeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUItemUpgradeJewelsRateChangeInfo@@PAU2@@Z PROC ; std::_Ptr_cat<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 649  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 650  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 651  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 652  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UItemUpgradeJewelsRateChangeInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PBUItemUpgradeJewelsRateChangeInfo@@PAU2@@Z ENDP ; std::_Ptr_cat<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@ABV10@@Z PROC ; std::forward<std::allocator<ItemUpgradeJewelsRateChangeInfo> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<ItemUpgradeJewelsRateChangeInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 999  : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >, COMDAT

; 170  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 171  : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN3@Destroy_ra
  0000f	90		 npad	 1
$LL4@Destroy_ra:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  00017	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UItemUpgradeJewelsInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemUpgradeJewelsInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UItemUpgradeJewelsInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemUpgradeJewelsInfo@@0@Z PROC ; std::_Ptr_cat<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UItemUpgradeJewelsInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemUpgradeJewelsInfo@@0@Z ENDP ; std::_Ptr_cat<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@YAABV?$allocator@UItemUpgradeJewelsInfo@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@YAABV?$allocator@UItemUpgradeJewelsInfo@@@0@ABV10@@Z PROC ; std::forward<std::allocator<ItemUpgradeJewelsInfo> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@YAABV?$allocator@UItemUpgradeJewelsInfo@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<ItemUpgradeJewelsInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >, COMDAT

; 999  : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUItemUpgradeJewelsRateChangeInfo@@@std@@YAABUItemUpgradeJewelsRateChangeInfo@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUItemUpgradeJewelsRateChangeInfo@@@std@@YAABUItemUpgradeJewelsRateChangeInfo@@ABU1@@Z PROC ; std::forward<ItemUpgradeJewelsRateChangeInfo const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUItemUpgradeJewelsRateChangeInfo@@@std@@YAABUItemUpgradeJewelsRateChangeInfo@@ABU1@@Z ENDP ; std::forward<ItemUpgradeJewelsRateChangeInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@PAUItemUpgradeJewelsRateChangeInfo@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUItemUpgradeJewelsRateChangeInfo@@@std@@YAAAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUItemUpgradeJewelsRateChangeInfo@@@std@@YAAAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z PROC ; std::forward<ItemUpgradeJewelsRateChangeInfo &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUItemUpgradeJewelsRateChangeInfo@@@std@@YAAAUItemUpgradeJewelsRateChangeInfo@@AAU1@@Z ENDP ; std::forward<ItemUpgradeJewelsRateChangeInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBUItemUpgradeJewelsRateChangeInfo@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBUItemUpgradeJewelsRateChangeInfo@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ItemUpgradeJewelsRateChangeInfo const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBUItemUpgradeJewelsRateChangeInfo@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ItemUpgradeJewelsRateChangeInfo const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUItemUpgradeJewelsInfo@@@std@@YAABUItemUpgradeJewelsInfo@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUItemUpgradeJewelsInfo@@@std@@YAABUItemUpgradeJewelsInfo@@ABU1@@Z PROC ; std::forward<ItemUpgradeJewelsInfo const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUItemUpgradeJewelsInfo@@@std@@YAABUItemUpgradeJewelsInfo@@ABU1@@Z ENDP ; std::forward<ItemUpgradeJewelsInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAXAAV?$allocator@UItemUpgradeJewelsInfo@@@1@PAUItemUpgradeJewelsInfo@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUItemUpgradeJewelsInfo@@@std@@YAAAUItemUpgradeJewelsInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUItemUpgradeJewelsInfo@@@std@@YAAAUItemUpgradeJewelsInfo@@AAU1@@Z PROC ; std::forward<ItemUpgradeJewelsInfo &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUItemUpgradeJewelsInfo@@@std@@YAAAUItemUpgradeJewelsInfo@@AAU1@@Z ENDP ; std::forward<ItemUpgradeJewelsInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBUItemUpgradeJewelsInfo@@@std@@YAPBUItemUpgradeJewelsInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBUItemUpgradeJewelsInfo@@@std@@YAPBUItemUpgradeJewelsInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<ItemUpgradeJewelsInfo const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBUItemUpgradeJewelsInfo@@@std@@YAPBUItemUpgradeJewelsInfo@@ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<ItemUpgradeJewelsInfo const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUItemUpgradeJewelsRateChangeInfo@@@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsRateChangeInfo@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUItemUpgradeJewelsRateChangeInfo@@@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsRateChangeInfo@@PAU2@00@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Umove<ItemUpgradeJewelsRateChangeInfo *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo>,ItemUpgradeJewelsRateChangeInfo>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUItemUpgradeJewelsRateChangeInfo@@@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsRateChangeInfo@@PAU2@00@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Umove<ItemUpgradeJewelsRateChangeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUItemUpgradeJewelsInfo@@@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsInfo@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUItemUpgradeJewelsInfo@@@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsInfo@@PAU2@00@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Umove<ItemUpgradeJewelsInfo *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::allocator<ItemUpgradeJewelsInfo>,ItemUpgradeJewelsInfo>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUItemUpgradeJewelsInfo@@@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEPAUItemUpgradeJewelsInfo@@PAU2@00@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Umove<ItemUpgradeJewelsInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsRateChangeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsRateChangeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsRateChangeInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1><std::allocator<ItemUpgradeJewelsRateChangeInfo> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1><std::allocator<ItemUpgradeJewelsRateChangeInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT

; 1004 : 	typename _Alty::propagate_on_container_swap _Tag;
; 1005 : 	_Pocs(_Left, _Right, _Tag);
; 1006 : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >, COMDAT

; 185  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi

; 171  : 	for (; _First != _Last; ++_First)

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN7@Destroy_ra
  0000f	90		 npad	 1
$LL8@Destroy_ra:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  00017	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL8@Destroy_ra
$LN7@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 187  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXPAUItemUpgradeJewelsInfo@@0AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@UItemUpgradeJewelsInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@UItemUpgradeJewelsInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1><std::allocator<ItemUpgradeJewelsInfo> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@UItemUpgradeJewelsInfo@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1><std::allocator<ItemUpgradeJewelsInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0@Z PROC ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >, COMDAT

; 1004 : 	typename _Alty::propagate_on_container_swap _Tag;
; 1005 : 	_Pocs(_Left, _Right, _Tag);
; 1006 : 	}

  00000	c3		 ret	 0
??$_Pocs@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0@Z ENDP ; std::_Pocs<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UItemUpgradeJewelsRateChangeInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UItemUpgradeJewelsRateChangeInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::construct<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUItemUpgradeJewelsRateChangeInfo@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUItemUpgradeJewelsRateChangeInfo@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@ABU1@@Z PROC ; std::addressof<ItemUpgradeJewelsRateChangeInfo const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUItemUpgradeJewelsRateChangeInfo@@@std@@YAPBUItemUpgradeJewelsRateChangeInfo@@ABU1@@Z ENDP ; std::addressof<ItemUpgradeJewelsRateChangeInfo const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAXAAPAUItemUpgradeJewelsRateChangeInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAXAAPAUItemUpgradeJewelsRateChangeInfo@@0@Z PROC ; std::swap<ItemUpgradeJewelsRateChangeInfo *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAXAAPAUItemUpgradeJewelsRateChangeInfo@@0@Z ENDP ; std::swap<ItemUpgradeJewelsRateChangeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$_Swap_adl@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAXAAPAUItemUpgradeJewelsRateChangeInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAXAAPAUItemUpgradeJewelsRateChangeInfo@@0@Z PROC ; std::_Swap_adl<ItemUpgradeJewelsRateChangeInfo *>, COMDAT

; 61   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 62   : 	swap(_Left, _Right);
; 63   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAUItemUpgradeJewelsRateChangeInfo@@@std@@YAXAAPAUItemUpgradeJewelsRateChangeInfo@@0@Z ENDP ; std::_Swap_adl<ItemUpgradeJewelsRateChangeInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8UItemUpgradeJewelsRateChangeInfo@@U0@@std@@YA_NABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UItemUpgradeJewelsRateChangeInfo@@U0@@std@@YA_NABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@0@Z PROC ; std::operator==<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>, COMDAT

; 712  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 713  : 	}

  00002	c3		 ret	 0
??$?8UItemUpgradeJewelsRateChangeInfo@@U0@@std@@YA_NABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@0@0@Z ENDP ; std::operator==<ItemUpgradeJewelsRateChangeInfo,ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<ItemUpgradeJewelsRateChangeInfo>,std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT

; 939  : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 940  : 		== static_cast<const _Other&>(_Right));
; 941  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<ItemUpgradeJewelsRateChangeInfo>,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@ABU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UItemUpgradeJewelsInfo@@AAU1@@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::construct<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUItemUpgradeJewelsInfo@@@std@@YAPBUItemUpgradeJewelsInfo@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUItemUpgradeJewelsInfo@@@std@@YAPBUItemUpgradeJewelsInfo@@ABU1@@Z PROC ; std::addressof<ItemUpgradeJewelsInfo const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUItemUpgradeJewelsInfo@@@std@@YAPBUItemUpgradeJewelsInfo@@ABU1@@Z ENDP ; std::addressof<ItemUpgradeJewelsInfo const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAUItemUpgradeJewelsInfo@@@std@@YAXAAPAUItemUpgradeJewelsInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAUItemUpgradeJewelsInfo@@@std@@YAXAAPAUItemUpgradeJewelsInfo@@0@Z PROC ; std::swap<ItemUpgradeJewelsInfo *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAUItemUpgradeJewelsInfo@@@std@@YAXAAPAUItemUpgradeJewelsInfo@@0@Z ENDP ; std::swap<ItemUpgradeJewelsInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$_Swap_adl@PAUItemUpgradeJewelsInfo@@@std@@YAXAAPAUItemUpgradeJewelsInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAUItemUpgradeJewelsInfo@@@std@@YAXAAPAUItemUpgradeJewelsInfo@@0@Z PROC ; std::_Swap_adl<ItemUpgradeJewelsInfo *>, COMDAT

; 61   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 62   : 	swap(_Left, _Right);
; 63   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAUItemUpgradeJewelsInfo@@@std@@YAXAAPAUItemUpgradeJewelsInfo@@0@Z ENDP ; std::_Swap_adl<ItemUpgradeJewelsInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8UItemUpgradeJewelsInfo@@U0@@std@@YA_NABV?$allocator@UItemUpgradeJewelsInfo@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UItemUpgradeJewelsInfo@@U0@@std@@YA_NABV?$allocator@UItemUpgradeJewelsInfo@@@0@0@Z PROC ; std::operator==<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>, COMDAT

; 712  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 713  : 	}

  00002	c3		 ret	 0
??$?8UItemUpgradeJewelsInfo@@U0@@std@@YA_NABV?$allocator@UItemUpgradeJewelsInfo@@@0@0@Z ENDP ; std::operator==<ItemUpgradeJewelsInfo,ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@UItemUpgradeJewelsInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@UItemUpgradeJewelsInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<ItemUpgradeJewelsInfo>,std::allocator<ItemUpgradeJewelsInfo> >, COMDAT

; 939  : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 940  : 		== static_cast<const _Other&>(_Right));
; 941  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@UItemUpgradeJewelsInfo@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<ItemUpgradeJewelsInfo>,std::allocator<ItemUpgradeJewelsInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_ItemUpgradeJewels@@YAXXZ
text$yd	SEGMENT
??__Fg_ItemUpgradeJewels@@YAXXZ PROC			; `dynamic atexit destructor for 'g_ItemUpgradeJewels'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A ; g_ItemUpgradeJewels
  00005	e9 00 00 00 00	 jmp	 ??1ItemUpgradeJewels@@UAE@XZ ; ItemUpgradeJewels::~ItemUpgradeJewels
??__Fg_ItemUpgradeJewels@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_ItemUpgradeJewels''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ??__Eg_ItemUpgradeJewels@@YAXXZ
text$di	SEGMENT
??__Eg_ItemUpgradeJewels@@YAXXZ PROC			; `dynamic initializer for 'g_ItemUpgradeJewels'', COMDAT

; 9    : ItemUpgradeJewels g_ItemUpgradeJewels;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A ; g_ItemUpgradeJewels
  00005	e8 00 00 00 00	 call	 ??0ItemUpgradeJewels@@QAE@XZ ; ItemUpgradeJewels::ItemUpgradeJewels
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_ItemUpgradeJewels@@YAXXZ ; `dynamic atexit destructor for 'g_ItemUpgradeJewels''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_ItemUpgradeJewels@@YAXXZ ENDP			; `dynamic initializer for 'g_ItemUpgradeJewels''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GItemUpgradeJewels@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GItemUpgradeJewels@@UAEPAXI@Z PROC			; ItemUpgradeJewels::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ItemUpgradeJewels@@UAE@XZ ; ItemUpgradeJewels::~ItemUpgradeJewels
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 10		 push	 16			; 00000010H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GItemUpgradeJewels@@UAEPAXI@Z ENDP			; ItemUpgradeJewels::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEXPAUItemUpgradeJewelsInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEXPAUItemUpgradeJewelsInfo@@0@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEXPAUItemUpgradeJewelsInfo@@0@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 1656 : 		if (this->_Myfirst() != pointer())

  00004	8b 33		 mov	 esi, DWORD PTR [ebx]
  00006	85 f6		 test	 esi, esi
  00008	74 4e		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0000a	57		 push	 edi
  0000b	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 171  : 	for (; _First != _Last; ++_First)

  0000e	3b f7		 cmp	 esi, edi
  00010	74 0e		 je	 SHORT $LN45@Tidy
$LL46@Tidy:
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  00019	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001c	3b f7		 cmp	 esi, edi
  0001e	75 f2		 jne	 SHORT $LL46@Tidy
$LN45@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00020	8b 33		 mov	 esi, DWORD PTR [ebx]
  00022	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00027	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0002a	2b ce		 sub	 ecx, esi
  0002c	f7 e9		 imul	 ecx
  0002e	03 d1		 add	 edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00030	8b cb		 mov	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00032	c1 fa 04	 sar	 edx, 4
  00035	8b c2		 mov	 eax, edx
  00037	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00043	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 1663 : 			this->_Mylast() = pointer();

  00049	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1664 : 			this->_Myend() = pointer();

  00050	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00057	5f		 pop	 edi
$LN2@Tidy:

; 1665 : 			}
; 1666 : 		}

  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	c3		 ret	 0
?_Tidy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv186 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00010	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00013	2b f7		 sub	 esi, edi
  00015	f7 ee		 imul	 esi
  00017	03 d6		 add	 edx, esi

; 1646 : 		if (_Unused_capacity() < _Count)

  00019	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  0001c	c1 fa 04	 sar	 edx, 4
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx

; 1646 : 		if (_Unused_capacity() < _Count)

  00026	3b c6		 cmp	 eax, esi
  00028	73 66		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0002a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002c	2b f8		 sub	 edi, eax
  0002e	89 45 08	 mov	 DWORD PTR tv186[ebp], eax
  00031	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00036	f7 ef		 imul	 edi

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00038	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003d	03 d7		 add	 edx, edi
  0003f	c1 fa 04	 sar	 edx, 4
  00042	8b ca		 mov	 ecx, edx
  00044	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00047	03 ca		 add	 ecx, edx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00049	2b c1		 sub	 eax, ecx
  0004b	3b c6		 cmp	 eax, esi
  0004d	72 48		 jb	 SHORT $LN134@Reserve

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0004f	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00052	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00057	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0005a	2b 4d 08	 sub	 ecx, DWORD PTR tv186[ebp]
  0005d	f7 e9		 imul	 ecx
  0005f	03 d1		 add	 edx, ecx
  00061	c1 fa 04	 sar	 edx, 4
  00064	8b f2		 mov	 esi, edx
  00066	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00069	03 f2		 add	 esi, edx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0006b	ba 49 92 24 09	 mov	 edx, 153391689		; 09249249H
  00070	8b c6		 mov	 eax, esi
  00072	d1 e8		 shr	 eax, 1
  00074	2b d0		 sub	 edx, eax
  00076	3b d6		 cmp	 edx, esi
  00078	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0007b	b8 00 00 00 00	 mov	 eax, 0
  00080	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00083	3b cf		 cmp	 ecx, edi
  00085	0f 42 cf	 cmovb	 ecx, edi

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00088	51		 push	 ecx
  00089	8b cb		 mov	 ecx, ebx
  0008b	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reallocate
$LN2@Reserve:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx

; 1651 : 			}
; 1652 : 		}

  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0009c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  000a1	cc		 int	 3
?_Reserve@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = -24						; size = 4
_this$ = -24						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e8	 mov	 DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0003e	6a 00		 push	 0
  00040	57		 push	 edi
  00041	50		 push	 eax
  00042	ff 77 04	 push	 DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1623 : 		_TRY_BEGIN

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004c	ff 37		 push	 DWORD PTR [edi]
  0004e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsInfo@@PAU1@V?$allocator@UItemUpgradeJewelsInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsInfo *,ItemUpgradeJewelsInfo *,std::allocator<ItemUpgradeJewelsInfo>,ItemUpgradeJewelsInfo>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00053	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00056	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0005b	8b 37		 mov	 esi, DWORD PTR [edi]
  0005d	8b cb		 mov	 ecx, ebx
  0005f	2b ce		 sub	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00061	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00064	f7 e9		 imul	 ecx
  00066	03 d1		 add	 edx, ecx
  00068	c1 fa 04	 sar	 edx, 4
  0006b	8b c2		 mov	 eax, edx
  0006d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00070	03 c2		 add	 eax, edx
  00072	89 45 e8	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00075	85 f6		 test	 esi, esi
  00077	74 38		 je	 SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 171  : 	for (; _First != _Last; ++_First)

  00079	3b f3		 cmp	 esi, ebx
  0007b	74 11		 je	 SHORT $LN129@Reallocate
  0007d	0f 1f 00	 npad	 3
$LL130@Reallocate:
  00080	8b ce		 mov	 ecx, esi
  00082	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  00087	83 c6 1c	 add	 esi, 28			; 0000001cH
  0008a	3b f3		 cmp	 esi, ebx
  0008c	75 f2		 jne	 SHORT $LL130@Reallocate
$LN129@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  0008e	8b 37		 mov	 esi, DWORD PTR [edi]
  00090	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00095	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00098	2b ce		 sub	 ecx, esi
  0009a	f7 e9		 imul	 ecx
  0009c	03 d1		 add	 edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0009e	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  000a0	c1 fa 04	 sar	 edx, 4
  000a3	8b c2		 mov	 eax, edx
  000a5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a8	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000aa	50		 push	 eax
  000ab	56		 push	 esi
  000ac	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1639 : 		this->_Myend() = _Ptr + _Count;

  000b1	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  000b4	8b 55 e8	 mov	 edx, DWORD PTR __Size$1$[ebp]
  000b7	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  000be	2b c1		 sub	 eax, ecx
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000c3	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000c6	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000c9	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  000d0	2b c2		 sub	 eax, edx
  000d2	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000d5	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  000d8	89 0f		 mov	 DWORD PTR [edi], ecx

; 1642 : 		}

  000da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e4	59		 pop	 ecx
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000ee	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000f1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000f7	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1627 : 		_RERAISE;

  000fc	6a 00		 push	 0
  000fe	6a 00		 push	 0
  00100	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN216@Reallocate:
$LN215@Reallocate:
  00105	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBE_NPBUItemUpgradeJewelsInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBE_NPBUItemUpgradeJewelsInfo@@@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBE_NPBUItemUpgradeJewelsInfo@@@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000c	2b 31		 sub	 esi, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0000e	b9 49 92 24 09	 mov	 ecx, 153391689		; 09249249H

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00013	f7 ee		 imul	 esi
  00015	57		 push	 edi
  00016	03 d6		 add	 edx, esi

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00018	33 ff		 xor	 edi, edi

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0001a	c1 fa 04	 sar	 edx, 4
  0001d	8b f2		 mov	 esi, edx
  0001f	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00022	03 f2		 add	 esi, edx

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00024	8b c6		 mov	 eax, esi
  00026	d1 e8		 shr	 eax, 1
  00028	2b c8		 sub	 ecx, eax
  0002a	3b ce		 cmp	 ecx, esi
  0002c	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0002f	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00032	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00035	5f		 pop	 edi
  00036	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  0003a	8b c2		 mov	 eax, edx
  0003c	5e		 pop	 esi

; 1612 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?_Grow_to@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXPAUItemUpgradeJewelsInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXPAUItemUpgradeJewelsInfo@@0@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1599 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi

; 171  : 	for (; _First != _Last; ++_First)

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN15@Destroy
  0000f	90		 npad	 1
$LL16@Destroy:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  00017	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL16@Destroy
$LN15@Destroy:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?_Destroy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXPAUItemUpgradeJewelsInfo@@0@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?swap@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXAAV12@@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::swap, COMDAT
; _this$ = ecx

; 1548 : 		{	// exchange contents with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1549 : 		if (this == &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 20		 je	 SHORT $LN7@swap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 16		 mov	 edx, DWORD PTR [esi]
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 54   : 	_Right = _Move(_Tmp);

  00014	89 17		 mov	 DWORD PTR [edi], edx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00019	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0001f	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00022	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 53   : 	_Left = _Move(_Right);

  00025	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 	_Right = _Move(_Tmp);

  0002b	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
$LN7@swap:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1576 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?swap@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());

  00005	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 171  : 	for (; _First != _Last; ++_First)

  00008	8b 37		 mov	 esi, DWORD PTR [edi]
  0000a	3b f3		 cmp	 esi, ebx
  0000c	74 19		 je	 SHORT $LN76@clear
  0000e	66 90		 npad	 2
$LL36@clear:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  00017	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001a	3b f3		 cmp	 esi, ebx
  0001c	75 f2		 jne	 SHORT $LL36@clear
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0001e	8b 07		 mov	 eax, DWORD PTR [edi]
  00020	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx

; 1543 : 		}

  00026	c3		 ret	 0
$LN76@clear:

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00027	8b c6		 mov	 eax, esi
  00029	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 1543 : 		}

  0002f	c3		 ret	 0
?clear@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0002d	3b f9		 cmp	 edi, ecx
  0002f	73 4e		 jae	 SHORT $LN2@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	3b c7		 cmp	 eax, edi
  00035	77 48		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00037	2b f8		 sub	 edi, eax
  00039	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0003e	f7 ef		 imul	 edi
  00040	03 d7		 add	 edx, edi
  00042	c1 fa 04	 sar	 edx, 4
  00045	8b fa		 mov	 edi, edx
  00047	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0004a	03 fa		 add	 edi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  0004c	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0004f	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reserve
$LN4@push_back:

; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  00063	2b cf		 sub	 ecx, edi
  00065	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00068	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006b	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0006e	89 4d f0	 mov	 DWORD PTR $T3[ebp], ecx
  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00078	85 c9		 test	 ecx, ecx
  0007a	74 2b		 je	 SHORT $LN206@push_back
  0007c	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 		else

  0007d	eb 23		 jmp	 SHORT $LN225@push_back
$LN2@push_back:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  0007f	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00082	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  00084	6a 01		 push	 1
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Reserve
$LN5@push_back:

; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),

  0008d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00090	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00093	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00096	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0009d	85 c9		 test	 ecx, ecx
  0009f	74 06		 je	 SHORT $LN206@push_back
  000a1	57		 push	 edi
$LN225@push_back:
  000a2	e8 00 00 00 00	 call	 ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
$LN206@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  000a7	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH

; 1293 : 			}
; 1294 : 		}

  000ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b5	59		 pop	 ecx
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z$35:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__unwindfunclet$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z$59:
  00011	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00014	50		 push	 eax
  00015	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
__ehhandler$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEAAUItemUpgradeJewelsInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEAAUItemUpgradeJewelsInfo@@I@Z PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000d	2b d0		 sub	 edx, eax
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1241 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??A?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEAAUItemUpgradeJewelsInfo@@I@Z ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::size, COMDAT
; _this$ = ecx

; 1178 : 		{	// return length of sequence

  00000	56		 push	 esi

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1180 : 		}

  0001a	c3		 ret	 0
?size@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1046 : 		{	// micro-optimization for capacity() - size()

  00000	56		 push	 esi

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 71 04	 sub	 esi, DWORD PTR [ecx+4]
  0000c	f7 ee		 imul	 esi
  0000e	03 d6		 add	 edx, esi
  00010	c1 fa 04	 sar	 edx, 4
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
  0001a	5e		 pop	 esi

; 1048 : 		}

  0001b	c3		 ret	 0
?_Unused_capacity@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::capacity, COMDAT
; _this$ = ecx

; 1041 : 		{	// return current length of allocated storage

  00000	56		 push	 esi

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1043 : 		}

  0001a	c3		 ret	 0
?capacity@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::~vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >, COMDAT
; _this$ = ecx

; 975  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXXZ ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Tidy
??1?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::~vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >::_Vector_val<std::_Simple_types<ItemUpgradeJewelsInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Swap_all, COMDAT
; _this$ = ecx

; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Swap_alloc, COMDAT
; _this$ = ecx

; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Swap_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z ; std::allocator<ItemUpgradeJewelsInfo>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsInfo@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >::_Wrap_alloc<std::allocator<ItemUpgradeJewelsInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAIABV?$allocator@UItemUpgradeJewelsInfo@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAIABV?$allocator@UItemUpgradeJewelsInfo@@@2@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@SAIABV?$allocator@UItemUpgradeJewelsInfo@@@2@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UItemUpgradeJewelsInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UItemUpgradeJewelsInfo@@@std@@QBEIXZ PROC ; std::allocator<ItemUpgradeJewelsInfo>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UItemUpgradeJewelsInfo@@@std@@QBEIXZ ENDP ; std::allocator<ItemUpgradeJewelsInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z PROC ; std::allocator<ItemUpgradeJewelsInfo>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 06		 jne	 SHORT $LN4@allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
$LN4@allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  00010	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00016	77 45		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00018	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001f	2b c1		 sub	 eax, ecx
  00021	c1 e0 02	 shl	 eax, 2

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00024	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00029	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0002b	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  0002e	3b c8		 cmp	 ecx, eax
  00030	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	8b c8		 mov	 ecx, eax
  0003a	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0003d	85 c9		 test	 ecx, ecx
  0003f	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00041	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00044	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00047	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00054	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00057	85 c0		 test	 eax, eax
  00059	75 b1		 jne	 SHORT $LN12@allocate
  0005b	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  0005d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00062	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00067	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0006c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00071	cc		 int	 3
?allocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEPAUItemUpgradeJewelsInfo@@I@Z ENDP ; std::allocator<ItemUpgradeJewelsInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z PROC ; std::allocator<ItemUpgradeJewelsInfo>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	81 fa 49 92 24
	09		 cmp	 edx, 153391689		; 09249249H
  0000f	77 3a		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00011	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00018	2b c2		 sub	 eax, edx
  0001a	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00022	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00024	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00027	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00029	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0002c	3b c1		 cmp	 eax, ecx
  0002e	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00030	2b c8		 sub	 ecx, eax
  00032	83 f9 04	 cmp	 ecx, 4
  00035	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00037	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0003a	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0003c	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00044	83 c4 04	 add	 esp, 4

; 639  : 		}

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00064	cc		 int	 3
?deallocate@?$allocator@UItemUpgradeJewelsInfo@@@std@@QAEXPAUItemUpgradeJewelsInfo@@I@Z ENDP ; std::allocator<ItemUpgradeJewelsInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UItemUpgradeJewelsInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UItemUpgradeJewelsInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<ItemUpgradeJewelsInfo>::allocator<ItemUpgradeJewelsInfo>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UItemUpgradeJewelsInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<ItemUpgradeJewelsInfo>::allocator<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UItemUpgradeJewelsInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UItemUpgradeJewelsInfo@@@std@@QAE@XZ PROC ; std::allocator<ItemUpgradeJewelsInfo>::allocator<ItemUpgradeJewelsInfo>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UItemUpgradeJewelsInfo@@@std@@QAE@XZ ENDP ; std::allocator<ItemUpgradeJewelsInfo>::allocator<ItemUpgradeJewelsInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?GetRateChangeRule@ItemUpgradeJewels@@QAEPAUItemUpgradeJewelsRateChangeInfo@@PAUItemUpgradeJewelsInfo@@E@Z
_TEXT	SEGMENT
tv218 = 8						; size = 4
_lpJewel$ = 8						; size = 4
_Type$ = 12						; size = 1
?GetRateChangeRule@ItemUpgradeJewels@@QAEPAUItemUpgradeJewelsRateChangeInfo@@PAUItemUpgradeJewelsInfo@@E@Z PROC ; ItemUpgradeJewels::GetRateChangeRule, COMDAT
; _this$ = ecx

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 509  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpJewel$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00007	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000c	56		 push	 esi
  0000d	57		 push	 edi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 509  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  0000e	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00010	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00013	2b 4b 10	 sub	 ecx, DWORD PTR [ebx+16]
  00016	f7 e9		 imul	 ecx
  00018	d1 fa		 sar	 edx, 1
  0001a	8b c2		 mov	 eax, edx
  0001c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001f	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 509  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  00021	74 28		 je	 SHORT $LN3@GetRateCha
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00023	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
$LL4@GetRateCha:
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 511  : 		if( lpJewel->m_RateChangeRules[i].Type == Type )

  00026	8a 45 0c	 mov	 al, BYTE PTR _Type$[ebp]
  00029	38 06		 cmp	 BYTE PTR [esi], al
  0002b	74 27		 je	 SHORT $LN51@GetRateCha
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0002d	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00030	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00035	2b 4b 10	 sub	 ecx, DWORD PTR [ebx+16]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 509  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  00038	47		 inc	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00039	f7 e9		 imul	 ecx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 509  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  0003b	83 c6 0c	 add	 esi, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003e	d1 fa		 sar	 edx, 1
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00045	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 509  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  00047	3b f8		 cmp	 edi, eax
  00049	72 db		 jb	 SHORT $LL4@GetRateCha
$LN3@GetRateCha:
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 512  : 		{
; 513  : 			return &lpJewel->m_RateChangeRules[i];
; 514  : 		}
; 515  : 	}
; 516  : 	return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	5b		 pop	 ebx

; 517  : }

  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
$LN51@GetRateCha:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00054	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00057	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 517  : }

  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?GetRateChangeRule@ItemUpgradeJewels@@QAEPAUItemUpgradeJewelsRateChangeInfo@@PAUItemUpgradeJewelsInfo@@E@Z ENDP ; ItemUpgradeJewels::GetRateChangeRule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?IsJewel@ItemUpgradeJewels@@QAE_NH@Z
_TEXT	SEGMENT
_ItemCode$ = 8						; size = 4
?IsJewel@ItemUpgradeJewels@@QAE_NH@Z PROC		; ItemUpgradeJewels::IsJewel, COMDAT
; _this$ = ecx

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00008	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 495  : 	for( int i = 0; i < m_UpradeInfo.size(); i++ )

  0000d	33 db		 xor	 ebx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0000f	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00012	2b 77 04	 sub	 esi, DWORD PTR [edi+4]
  00015	f7 ee		 imul	 esi
  00017	03 d6		 add	 edx, esi
  00019	c1 fa 04	 sar	 edx, 4
  0001c	8b c2		 mov	 eax, edx
  0001e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00021	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 495  : 	for( int i = 0; i < m_UpradeInfo.size(); i++ )

  00023	74 3d		 je	 SHORT $LN3@IsJewel
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00025	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@IsJewel:
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 498  : 			m_UpradeInfo[i].ItemIndex) == ItemCode)

  00030	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  00033	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  00037	c1 e1 09	 shl	 ecx, 9
  0003a	03 c8		 add	 ecx, eax
  0003c	3b 4d 08	 cmp	 ecx, DWORD PTR _ItemCode$[ebp]
  0003f	74 2a		 je	 SHORT $LN51@IsJewel
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00041	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00044	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00049	2b 4f 04	 sub	 ecx, DWORD PTR [edi+4]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 495  : 	for( int i = 0; i < m_UpradeInfo.size(); i++ )

  0004c	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0004d	f7 e9		 imul	 ecx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 495  : 	for( int i = 0; i < m_UpradeInfo.size(); i++ )

  0004f	83 c6 1c	 add	 esi, 28			; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00052	03 d1		 add	 edx, ecx
  00054	c1 fa 04	 sar	 edx, 4
  00057	8b c2		 mov	 eax, edx
  00059	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005c	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 495  : 	for( int i = 0; i < m_UpradeInfo.size(); i++ )

  0005e	3b d8		 cmp	 ebx, eax
  00060	72 ce		 jb	 SHORT $LL4@IsJewel
$LN3@IsJewel:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 501  : 		}
; 502  : 	}
; 503  : 	return false;

  00064	32 c0		 xor	 al, al
  00066	5b		 pop	 ebx

; 504  : }

  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
$LN51@IsJewel:
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi

; 499  : 		{
; 500  : 			return true;

  0006d	b0 01		 mov	 al, 1
  0006f	5b		 pop	 ebx

; 504  : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
?IsJewel@ItemUpgradeJewels@@QAE_NH@Z ENDP		; ItemUpgradeJewels::IsJewel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?ProcUpgrade@ItemUpgradeJewels@@QAE_NPAUOBJECTSTRUCT@@HHPAUItemUpgradeJewelsInfo@@@Z
_TEXT	SEGMENT
tv1208 = -12						; size = 4
_JewelCode$1$ = -8					; size = 4
tv1209 = -4						; size = 4
_iItemOptionLevel$1$ = 8				; size = 4
_lpUser$ = 8						; size = 4
_iItemOption$1$ = 12					; size = 4
_i$1$ = 12						; size = 4
_JewelPos$ = 12						; size = 4
tv1092 = 16						; size = 4
_Rate$1$ = 16						; size = 4
_TargetPos$ = 16					; size = 4
_lpJewel$ = 20						; size = 4
?ProcUpgrade@ItemUpgradeJewels@@QAE_NPAUOBJECTSTRUCT@@HHPAUItemUpgradeJewelsInfo@@@Z PROC ; ItemUpgradeJewels::ProcUpgrade, COMDAT
; _this$ = ecx

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 122  : 	if( JewelPos < 0 || JewelPos > MAIN_INVENTORY_SIZE-1 )

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _JewelPos$[ebp]
  0000a	81 fb cb 00 00
	00		 cmp	 ebx, 203		; 000000cbH
  00010	0f 87 e2 07 00
	00		 ja	 $LN6@ProcUpgrad

; 125  : 	}
; 126  : 
; 127  : 	if( TargetPos < 0 || TargetPos > MAIN_INVENTORY_SIZE-1 )

  00016	56		 push	 esi
  00017	8b 75 10	 mov	 esi, DWORD PTR _TargetPos$[ebp]
  0001a	81 fe cb 00 00
	00		 cmp	 esi, 203		; 000000cbH
  00020	0f 87 c8 07 00
	00		 ja	 $LN8@ProcUpgrad

; 130  : 	}
; 131  : 
; 132  : 	if(		!lpUser->pInventory[JewelPos].IsItem()
; 133  : 		||	!lpUser->pInventory[TargetPos].IsItem() )

  00026	57		 push	 edi
  00027	8b 7d 08	 mov	 edi, DWORD PTR _lpUser$[ebp]
  0002a	69 c3 d4 00 00
	00		 imul	 eax, ebx, 212
  00030	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00036	03 c8		 add	 ecx, eax
  00038	89 45 fc	 mov	 DWORD PTR tv1209[ebp], eax
  0003b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00040	85 c0		 test	 eax, eax
  00042	0f 84 ed 05 00
	00		 je	 $LN10@ProcUpgrad
  00048	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  0004e	69 f6 d4 00 00
	00		 imul	 esi, esi, 212
  00054	03 ce		 add	 ecx, esi
  00056	89 75 f4	 mov	 DWORD PTR tv1208[ebp], esi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 cf 05 00
	00		 je	 $LN10@ProcUpgrad

; 134  : 	{
; 135  : 		return false;
; 136  : 	}
; 137  : 	
; 138  : 	int JewelCode = lpUser->pInventory[JewelPos].m_Type;

  00066	8b 87 c0 11 00
	00		 mov	 eax, DWORD PTR [edi+4544]

; 139  : 	int TargetCode = lpUser->pInventory[TargetPos].m_Type;

  0006c	03 f0		 add	 esi, eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR tv1209[ebp]
  00071	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  00076	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0007a	89 4d f8	 mov	 DWORD PTR _JewelCode$1$[ebp], ecx

; 140  : 
; 141  : 	if(		JewelCode == ITEMGET(14, 13) 
; 142  : 		&&	TargetCode == ITEMGET(0, 41) )

  0007d	81 f9 0d 1c 00
	00		 cmp	 ecx, 7181		; 00001c0dH
  00083	0f 85 21 01 00
	00		 jne	 $LN14@ProcUpgrad
  00089	83 f8 29	 cmp	 eax, 41			; 00000029H
  0008c	75 1c		 jne	 SHORT $LN247@ProcUpgrad

; 143  : 	{
; 144  : 		if( gObjItemLevelUpPickAxe(lpUser, JewelPos, TargetPos) == TRUE )

  0008e	ff 75 10	 push	 DWORD PTR _TargetPos$[ebp]
  00091	53		 push	 ebx
  00092	57		 push	 edi
  00093	e8 00 00 00 00	 call	 ?gObjItemLevelUpPickAxe@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemLevelUpPickAxe
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	83 f8 01	 cmp	 eax, 1
  0009e	0f 94 c0	 sete	 al
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 10 00	 ret	 16			; 00000010H
$LN247@ProcUpgrad:

; 145  : 		{
; 146  : 			return true;
; 147  : 		}
; 148  : 		else
; 149  : 		{
; 150  : 			return false;
; 151  : 		}
; 152  : 	}
; 153  : 
; 154  : 	if(		JewelCode == ITEMGET(14, 13) 
; 155  : 		&&	TargetCode == ITEMGET(13, 37) )

  000aa	3d 25 1a 00 00	 cmp	 eax, 6693		; 00001a25H
  000af	0f 85 f5 00 00
	00		 jne	 $LN14@ProcUpgrad

; 156  : 	{
; 157  : 		CItem* ItemFenrir = &lpUser->pInventory[TargetPos];
; 158  : 
; 159  : 		if( ItemFenrir->m_Durability >= 255 )

  000b5	f3 0f 10 46 24	 movss	 xmm0, DWORD PTR [esi+36]
  000ba	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  000c1	0f 83 6e 05 00
	00		 jae	 $LN10@ProcUpgrad

; 160  : 		{
; 161  : 			return false;
; 162  : 		}
; 163  : 
; 164  : 		if( rand()% 10000 < g_iFenrirRepairRate )

  000c7	e8 00 00 00 00	 call	 _rand
  000cc	99		 cdq
  000cd	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  000d2	f7 f9		 idiv	 ecx
  000d4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iFenrirRepairRate@@3HA ; g_iFenrirRepairRate
  000da	0f 8d 85 00 00
	00		 jge	 $LN16@ProcUpgrad

; 165  : 		{
; 166  : 			int iAddDur = rand()%150 + 50;

  000e0	e8 00 00 00 00	 call	 _rand
  000e5	99		 cdq
  000e6	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  000eb	f7 f9		 idiv	 ecx
  000ed	8d 5a 32	 lea	 ebx, DWORD PTR [edx+50]
  000f0	66 0f 6e c3	 movd	 xmm0, ebx

; 167  : 
; 168  : 			if( (ItemFenrir->m_Durability + iAddDur) > 255 )

  000f4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f7	f3 0f 58 46 24	 addss	 xmm0, DWORD PTR [esi+36]
  000fc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  00103	76 09		 jbe	 SHORT $LN18@ProcUpgrad

; 169  : 			{
; 170  : 				ItemFenrir->m_Durability = 255.0f;

  00105	c7 46 24 00 00
	7f 43		 mov	 DWORD PTR [esi+36], 1132396544 ; 437f0000H

; 171  : 			}
; 172  : 			else

  0010c	eb 05		 jmp	 SHORT $LN19@ProcUpgrad
$LN18@ProcUpgrad:

; 173  : 			{
; 174  : 				ItemFenrir->m_Durability += iAddDur;

  0010e	f3 0f 11 46 24	 movss	 DWORD PTR [esi+36], xmm0
$LN19@ProcUpgrad:

; 175  : 			}
; 176  : 
; 177  : 			MsgOutput(lpUser->m_Index,lMsg.Get(3342),int(ItemFenrir->m_Durability));

  00113	f3 0f 2c 46 24	 cvttss2si eax, DWORD PTR [esi+36]
  00118	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0011d	50		 push	 eax
  0011e	68 0e 0d 00 00	 push	 3342			; 00000d0eH
  00123	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00128	50		 push	 eax
  00129	ff 37		 push	 DWORD PTR [edi]
  0012b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00130	f3 0f 10 46 24	 movss	 xmm0, DWORD PTR [esi+36]

; 178  : 			LogAddTD("[FENRIR REPAIR][SUCCESS] [%s][%s] - %d/255 (+%d)",lpUser->AccountID,

  00135	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0013e	53		 push	 ebx
  0013f	83 ec 08	 sub	 esp, 8
  00142	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00147	50		 push	 eax
  00148	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0014b	50		 push	 eax
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JGAJMHKC@?$FLFENRIR?5REPAIR?$FN?$FLSUCCESS?$FN?5?$FL?$CFs?$FN?$FL?$CFs@
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00157	83 c4 18	 add	 esp, 24			; 00000018H

; 185  : 				ItemFenrir->m_Durability);
; 186  : 		}
; 187  : 
; 188  : 		return true;

  0015a	b0 01		 mov	 al, 1
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 10 00	 ret	 16			; 00000010H
$LN16@ProcUpgrad:

; 179  : 				lpUser->Name,ItemFenrir->m_Durability,iAddDur);
; 180  : 		}
; 181  : 		else
; 182  : 		{
; 183  : 			MsgOutput(lpUser->m_Index,lMsg.Get(3343));

  00165	68 0f 0d 00 00	 push	 3343			; 00000d0fH
  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0016f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00174	50		 push	 eax
  00175	ff 37		 push	 DWORD PTR [edi]
  00177	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0017c	f3 0f 10 46 24	 movss	 xmm0, DWORD PTR [esi+36]

; 184  : 			LogAddTD("[FENRIR REPAIR][FAILED] [%s][%s] - %d/255 (+%d)",lpUser->AccountID,lpUser->Name,

  00181	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00184	0f 5a c0	 cvtps2pd xmm0, xmm0
  00187	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0018c	50		 push	 eax
  0018d	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00190	50		 push	 eax
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@PNDNNHGN@?$FLFENRIR?5REPAIR?$FN?$FLFAILED?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0019c	83 c4 14	 add	 esp, 20			; 00000014H

; 185  : 				ItemFenrir->m_Durability);
; 186  : 		}
; 187  : 
; 188  : 		return true;

  0019f	b0 01		 mov	 al, 1
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c2 10 00	 ret	 16			; 00000010H
$LN14@ProcUpgrad:

; 189  : 	}
; 190  : 
; 191  : 	CItem* ItemTarget = &lpUser->pInventory[TargetPos];
; 192  : 
; 193  : 	if( ItemTarget->m_bLuckySet == TRUE )

  001aa	80 be ce 00 00
	00 01		 cmp	 BYTE PTR [esi+206], 1
  001b1	0f 84 7e 04 00
	00		 je	 $LN10@ProcUpgrad

; 194  : 	{
; 195  : 		return false;
; 196  : 	}
; 197  : 	
; 198  : 	if( lpJewel->TargetLevelMax != (BYTE)-1
; 199  : 		&& ItemTarget->m_Level >= lpJewel->TargetLevelMax )

  001b7	8b 5d 14	 mov	 ebx, DWORD PTR _lpJewel$[ebp]
  001ba	8a 43 09	 mov	 al, BYTE PTR [ebx+9]
  001bd	3c ff		 cmp	 al, 255			; 000000ffH
  001bf	74 0d		 je	 SHORT $LN21@ProcUpgrad
  001c1	0f b6 c0	 movzx	 eax, al
  001c4	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  001c8	0f 8d 67 04 00
	00		 jge	 $LN10@ProcUpgrad
$LN21@ProcUpgrad:

; 200  : 	{
; 201  : 		return false;
; 202  : 	}
; 203  : 
; 204  : 	if( lpJewel->TargetLevelMin != (BYTE)-1
; 205  : 		&& ItemTarget->m_Level < lpJewel->TargetLevelMin )

  001ce	8a 43 08	 mov	 al, BYTE PTR [ebx+8]
  001d1	3c ff		 cmp	 al, 255			; 000000ffH
  001d3	74 0d		 je	 SHORT $LN22@ProcUpgrad
  001d5	0f b6 c0	 movzx	 eax, al
  001d8	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  001dc	0f 8c 53 04 00
	00		 jl	 $LN10@ProcUpgrad
$LN22@ProcUpgrad:

; 206  : 	{
; 207  : 		return false;
; 208  : 	}
; 209  : 	
; 210  : 	if( ItemTarget->m_Type >= ITEMGET(12,36) && 

  001e2	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  001e6	ba 31 18 00 00	 mov	 edx, 6193		; 00001831H
  001eb	c7 45 10 24 18
	00 00		 mov	 DWORD PTR tv1092[ebp], 6180 ; 00001824H
  001f2	8d 4a f7	 lea	 ecx, DWORD PTR [edx-9]
  001f5	66 3b 45 10	 cmp	 ax, WORD PTR tv1092[ebp]
  001f9	7c 05		 jl	 SHORT $LN23@ProcUpgrad
  001fb	66 3b c1	 cmp	 ax, cx
  001fe	7e 7f		 jle	 SHORT $LN29@ProcUpgrad
$LN23@ProcUpgrad:

; 211  : 		ItemTarget->m_Type <= ITEMGET(12,40) )
; 212  : 	{
; 213  : 
; 214  : 	}
; 215  : #if (CUSTOM_WINGS == 1)
; 216  : 	else if( ItemTarget->m_Type >= ITEMGET(12,440) && ItemTarget->m_Type <= ITEMGET(12,445) )
; 217  : 	{
; 218  : 
; 219  : 	}
; 220  : #endif
; 221  : 	else if( ItemTarget->m_Type >= ITEMGET(12,41) &&

  00200	b9 29 18 00 00	 mov	 ecx, 6185		; 00001829H
  00205	66 3b c1	 cmp	 ax, cx
  00208	7c 0a		 jl	 SHORT $LN25@ProcUpgrad
  0020a	b9 2b 18 00 00	 mov	 ecx, 6187		; 0000182bH
  0020f	66 3b c1	 cmp	 ax, cx
  00212	7e 6b		 jle	 SHORT $LN29@ProcUpgrad
$LN25@ProcUpgrad:

; 222  : 			 ItemTarget->m_Type <= ITEMGET(12,43) )
; 223  : 	{
; 224  : 
; 225  : 	}
; 226  : 	else if( ItemTarget->m_Type == ITEMGET(12,49) ||

  00214	66 3b c2	 cmp	 ax, dx
  00217	74 66		 je	 SHORT $LN29@ProcUpgrad
  00219	b9 32 18 00 00	 mov	 ecx, 6194		; 00001832H
  0021e	66 3b c1	 cmp	 ax, cx
  00221	74 5c		 je	 SHORT $LN29@ProcUpgrad

; 227  : 			 ItemTarget->m_Type == ITEMGET(12,50) )
; 228  : 	{
; 229  : 
; 230  : 	}
; 231  : 	else if( ItemTarget->m_Type >= ITEMGET(12,200) && ItemTarget->m_Type <= ITEMGET(12,214) )

  00223	b9 c8 18 00 00	 mov	 ecx, 6344		; 000018c8H
  00228	66 3b c1	 cmp	 ax, cx
  0022b	7c 0a		 jl	 SHORT $LN30@ProcUpgrad
  0022d	b9 d6 18 00 00	 mov	 ecx, 6358		; 000018d6H
  00232	66 3b c1	 cmp	 ax, cx
  00235	7e 48		 jle	 SHORT $LN29@ProcUpgrad
$LN30@ProcUpgrad:

; 232  : 	{
; 233  : 
; 234  : 	}
; 235  : 	else if( ItemTarget->m_Type >= ITEMGET(12,262) &&

  00237	b9 06 19 00 00	 mov	 ecx, 6406		; 00001906H
  0023c	66 3b c1	 cmp	 ax, cx
  0023f	7c 0a		 jl	 SHORT $LN32@ProcUpgrad
  00241	b9 09 19 00 00	 mov	 ecx, 6409		; 00001909H
  00246	66 3b c1	 cmp	 ax, cx
  00249	7e 34		 jle	 SHORT $LN29@ProcUpgrad
$LN32@ProcUpgrad:

; 236  : 			 ItemTarget->m_Type <= ITEMGET(12,265) )
; 237  : 	{
; 238  : 
; 239  : 	}
; 240  : 	else if(!(ItemTarget->m_Type < ITEMGET(12,7)
; 241  : 		|| ItemTarget->m_Type == ITEMGET(13,30) )
; 242  : 		|| ItemTarget->m_Type == ITEMGET(4,7)
; 243  : 		|| ItemTarget->m_Type == ITEMGET(4,15))

  0024b	b9 07 18 00 00	 mov	 ecx, 6151		; 00001807H
  00250	66 3b c1	 cmp	 ax, cx
  00253	7c 0e		 jl	 SHORT $LN36@ProcUpgrad
  00255	b9 1e 1a 00 00	 mov	 ecx, 6686		; 00001a1eH
  0025a	66 3b c1	 cmp	 ax, cx
  0025d	0f 85 d2 03 00
	00		 jne	 $LN10@ProcUpgrad
$LN36@ProcUpgrad:
  00263	b9 07 08 00 00	 mov	 ecx, 2055		; 00000807H
  00268	66 3b c1	 cmp	 ax, cx
  0026b	0f 84 c4 03 00
	00		 je	 $LN10@ProcUpgrad
  00271	b9 0f 08 00 00	 mov	 ecx, 2063		; 0000080fH
  00276	66 3b c1	 cmp	 ax, cx
  00279	0f 84 b6 03 00
	00		 je	 $LN10@ProcUpgrad
$LN29@ProcUpgrad:

; 244  : 	{
; 245  : 		return false;
; 246  : 	}
; 247  : 
; 248  : 	if( ItemTarget->m_NewOption && lpJewel->TargetRankExcellent != 1 )

  0027f	80 be 93 00 00
	00 00		 cmp	 BYTE PTR [esi+147], 0
  00286	74 0a		 je	 SHORT $LN37@ProcUpgrad
  00288	80 7b 0b 01	 cmp	 BYTE PTR [ebx+11], 1
  0028c	0f 85 a3 03 00
	00		 jne	 $LN10@ProcUpgrad
$LN37@ProcUpgrad:

; 249  : 	{
; 250  : 		return false;
; 251  : 	}
; 252  : 
; 253  : 	if( gSetItemOption.IsSetItem(ItemTarget->m_Type) && ItemTarget->m_SetOption > 0 
; 254  : 		&& lpJewel->TargetRankAncient != 1 )

  00292	98		 cwde
  00293	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  00298	50		 push	 eax
  00299	e8 00 00 00 00	 call	 ?IsSetItem@CSetItemOption@@QAEHH@Z ; CSetItemOption::IsSetItem
  0029e	85 c0		 test	 eax, eax
  002a0	74 13		 je	 SHORT $LN38@ProcUpgrad
  002a2	80 be aa 00 00
	00 00		 cmp	 BYTE PTR [esi+170], 0
  002a9	76 0a		 jbe	 SHORT $LN38@ProcUpgrad
  002ab	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  002af	0f 85 80 03 00
	00		 jne	 $LN10@ProcUpgrad
$LN38@ProcUpgrad:

; 255  : 	{
; 256  : 		return false;
; 257  : 	}
; 258  : 
; 259  : 	if( g_SocketItem.IsSocketItem(ItemTarget->m_Type) && lpJewel->TargetRankSocket != 1 )

  002b5	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  002b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?IsSocketItem@CSocketItems@@QAE_NH@Z ; CSocketItems::IsSocketItem
  002c4	84 c0		 test	 al, al
  002c6	74 0a		 je	 SHORT $LN39@ProcUpgrad
  002c8	80 7b 0d 01	 cmp	 BYTE PTR [ebx+13], 1
  002cc	0f 85 63 03 00
	00		 jne	 $LN10@ProcUpgrad
$LN39@ProcUpgrad:

; 260  : 	{
; 261  : 		return false;
; 262  : 	}
; 263  : 
; 264  : 	DWORD Rate = lpJewel->DefaultRate;

  002d2	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 266  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  002d5	33 c9		 xor	 ecx, ecx
  002d7	89 45 10	 mov	 DWORD PTR _Rate$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  002da	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 266  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  002df	89 4d 0c	 mov	 DWORD PTR _i$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  002e2	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  002e5	2b 4b 10	 sub	 ecx, DWORD PTR [ebx+16]
  002e8	f7 e9		 imul	 ecx
  002ea	d1 fa		 sar	 edx, 1
  002ec	8b c2		 mov	 eax, edx
  002ee	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002f1	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 266  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  002f3	0f 84 c9 00 00
	00		 je	 $LN3@ProcUpgrad

; 260  : 	{
; 261  : 		return false;
; 262  : 	}
; 263  : 
; 264  : 	DWORD Rate = lpJewel->DefaultRate;

  002f9	33 ff		 xor	 edi, edi
  002fb	0f 1f 44 00 00	 npad	 5
$LL4@ProcUpgrad:

; 267  : 	{
; 268  : 		bool Bonus = false;
; 269  : 
; 270  : 		if(		lpJewel->m_RateChangeRules[i].Type == ItemUpgradeJewelsRateType::Luck
; 271  : 			&&	ItemTarget->m_Option2 )

  00300	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00303	8a 04 07	 mov	 al, BYTE PTR [edi+eax]
  00306	84 c0		 test	 al, al
  00308	75 08		 jne	 SHORT $LN40@ProcUpgrad
  0030a	38 86 91 00 00
	00		 cmp	 BYTE PTR [esi+145], al
  00310	75 7a		 jne	 SHORT $LN248@ProcUpgrad
$LN40@ProcUpgrad:

; 272  : 		{
; 273  : 			Bonus = true;
; 274  : 		}
; 275  : 		else if(	lpJewel->m_RateChangeRules[i].Type == ItemUpgradeJewelsRateType::Excellent
; 276  : 				&&	ItemTarget->m_NewOption )

  00312	3c 01		 cmp	 al, 1
  00314	75 09		 jne	 SHORT $LN42@ProcUpgrad
  00316	80 be 93 00 00
	00 00		 cmp	 BYTE PTR [esi+147], 0
  0031d	75 6d		 jne	 SHORT $LN248@ProcUpgrad
$LN42@ProcUpgrad:

; 277  : 		{
; 278  : 			Bonus = true;
; 279  : 		}
; 280  : 		else if(	lpJewel->m_RateChangeRules[i].Type == ItemUpgradeJewelsRateType::Ancient
; 281  : 				&&	gSetItemOption.IsSetItem(ItemTarget->m_Type) && ItemTarget->m_SetOption > 0 )

  0031f	3c 02		 cmp	 al, 2
  00321	75 1c		 jne	 SHORT $LN44@ProcUpgrad
  00323	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  00327	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 ?IsSetItem@CSetItemOption@@QAEHH@Z ; CSetItemOption::IsSetItem
  00332	85 c0		 test	 eax, eax
  00334	74 09		 je	 SHORT $LN44@ProcUpgrad
  00336	80 be aa 00 00
	00 00		 cmp	 BYTE PTR [esi+170], 0
  0033d	77 4d		 ja	 SHORT $LN248@ProcUpgrad
$LN44@ProcUpgrad:

; 282  : 		{
; 283  : 			Bonus = true;
; 284  : 		}
; 285  : 		else if(	lpJewel->m_RateChangeRules[i].Type == ItemUpgradeJewelsRateType::Socket
; 286  : 				&&	g_SocketItem.IsSocketItem(ItemTarget->m_Type) )

  0033f	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00342	80 3c 07 03	 cmp	 BYTE PTR [edi+eax], 3
  00346	75 13		 jne	 SHORT $LN46@ProcUpgrad
  00348	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0034c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 ?IsSocketItem@CSocketItems@@QAE_NH@Z ; CSocketItems::IsSocketItem
  00357	84 c0		 test	 al, al
  00359	75 31		 jne	 SHORT $LN248@ProcUpgrad
$LN46@ProcUpgrad:

; 287  : 		{
; 288  : 			Bonus = true;
; 289  : 		}
; 290  : 		else if(	lpJewel->m_RateChangeRules[i].Type == ItemUpgradeJewelsRateType::Level
; 291  : 				&&	lpJewel->m_RateChangeRules[i].Level != (BYTE)-1 && lpJewel->m_RateChangeRules[i].Level == ItemTarget->m_Level )

  0035b	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0035e	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  00361	80 fa 04	 cmp	 dl, 4
  00364	75 11		 jne	 SHORT $LN48@ProcUpgrad
  00366	8a 44 0f 01	 mov	 al, BYTE PTR [edi+ecx+1]
  0036a	3c ff		 cmp	 al, 255			; 000000ffH
  0036c	74 09		 je	 SHORT $LN48@ProcUpgrad
  0036e	0f b6 c0	 movzx	 eax, al
  00371	66 3b 46 08	 cmp	 ax, WORD PTR [esi+8]
  00375	74 15		 je	 SHORT $LN248@ProcUpgrad
$LN48@ProcUpgrad:

; 292  : 		{
; 293  : 			Bonus = true;
; 294  : 		}
; 295  : 		else if(	lpJewel->m_RateChangeRules[i].Type == ItemUpgradeJewelsRateType::Option
; 296  : 				&&	lpJewel->m_RateChangeRules[i].Option != (BYTE)-1 && lpJewel->m_RateChangeRules[i].Option == ItemTarget->m_Option3 )

  00377	80 fa 05	 cmp	 dl, 5
  0037a	75 1e		 jne	 SHORT $LN2@ProcUpgrad
  0037c	8a 44 0f 02	 mov	 al, BYTE PTR [edi+ecx+2]
  00380	3c ff		 cmp	 al, 255			; 000000ffH
  00382	74 16		 je	 SHORT $LN2@ProcUpgrad
  00384	3a 86 92 00 00
	00		 cmp	 al, BYTE PTR [esi+146]
  0038a	75 0e		 jne	 SHORT $LN2@ProcUpgrad
$LN248@ProcUpgrad:

; 297  : 		{
; 298  : 			Bonus = true;
; 299  : 		}
; 300  : 
; 301  : 		if( Bonus )
; 302  : 		{
; 303  : 			Rate -= lpJewel->m_RateChangeRules[i].RateDecrease;

  0038c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 304  : 			Rate += lpJewel->m_RateChangeRules[i].RateIncrease;

  0038f	8b 44 0f 04	 mov	 eax, DWORD PTR [edi+ecx+4]
  00393	2b 44 0f 08	 sub	 eax, DWORD PTR [edi+ecx+8]
  00397	01 45 10	 add	 DWORD PTR _Rate$1$[ebp], eax
$LN2@ProcUpgrad:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0039a	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  0039d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  003a2	2b 4b 10	 sub	 ecx, DWORD PTR [ebx+16]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 266  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  003a5	83 c7 0c	 add	 edi, 12			; 0000000cH
  003a8	ff 45 0c	 inc	 DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  003ab	f7 e9		 imul	 ecx
  003ad	d1 fa		 sar	 edx, 1
  003af	8b c2		 mov	 eax, edx
  003b1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003b4	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 266  : 	for( int i = 0; i < lpJewel->m_RateChangeRules.size(); i++ )

  003b6	39 45 0c	 cmp	 DWORD PTR _i$1$[ebp], eax
  003b9	0f 82 41 ff ff
	ff		 jb	 $LL4@ProcUpgrad
  003bf	8b 7d 08	 mov	 edi, DWORD PTR _lpUser$[ebp]
$LN3@ProcUpgrad:

; 305  : 		}
; 306  : 	}
; 307  : 
; 308  : 	if( JewelCode == ITEMGET(14, 13) )

  003c2	8b 45 f8	 mov	 eax, DWORD PTR _JewelCode$1$[ebp]
  003c5	3d 0d 1c 00 00	 cmp	 eax, 7181		; 00001c0dH
  003ca	75 36		 jne	 SHORT $LN52@ProcUpgrad

; 309  : 	{
; 310  : 		if( rand() % 10000 < Rate )

  003cc	e8 00 00 00 00	 call	 _rand
  003d1	99		 cdq
  003d2	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  003d7	f7 f9		 idiv	 ecx
  003d9	3b 55 10	 cmp	 edx, DWORD PTR _Rate$1$[ebp]
  003dc	0f 83 13 03 00
	00		 jae	 $LN88@ProcUpgrad
$LN255@ProcUpgrad:

; 311  : 		{
; 312  : 			ItemTarget->m_Level++;

  003e2	66 ff 46 08	 inc	 WORD PTR [esi+8]

; 313  : 		
; 314  : 			if( ItemTarget->m_Level > lpJewel->TargetLevelMax )

  003e6	8a 4b 09	 mov	 cl, BYTE PTR [ebx+9]
  003e9	0f b6 c1	 movzx	 eax, cl
  003ec	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  003f0	0f 8e ff 02 00
	00		 jle	 $LN88@ProcUpgrad

; 315  : 			{
; 316  : 				ItemTarget->m_Level = lpJewel->TargetLevelMax;

  003f6	0f b6 c1	 movzx	 eax, cl
  003f9	66 89 46 08	 mov	 WORD PTR [esi+8], ax

; 317  : 			}
; 318  : 		}		
; 319  : 	}

  003fd	e9 f3 02 00 00	 jmp	 $LN88@ProcUpgrad
$LN52@ProcUpgrad:

; 320  : 	else if( JewelCode == ITEMGET(14, 14) )

  00402	3d 0e 1c 00 00	 cmp	 eax, 7182		; 00001c0eH
  00407	75 35		 jne	 SHORT $LN56@ProcUpgrad

; 321  : 	{
; 322  : 		if( rand() % 10000 < Rate )

  00409	e8 00 00 00 00	 call	 _rand
  0040e	99		 cdq
  0040f	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00414	f7 f9		 idiv	 ecx
  00416	3b 55 10	 cmp	 edx, DWORD PTR _Rate$1$[ebp]
  00419	72 c7		 jb	 SHORT $LN255@ProcUpgrad

; 323  : 		{
; 324  : 			ItemTarget->m_Level++;
; 325  : 		
; 326  : 			if( ItemTarget->m_Level > lpJewel->TargetLevelMax )
; 327  : 			{
; 328  : 				ItemTarget->m_Level = lpJewel->TargetLevelMax;
; 329  : 			}
; 330  : 		}
; 331  : 		else
; 332  : 		{
; 333  : 			if( ItemTarget->m_Level >= 7 )

  0041b	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0041f	66 83 f8 07	 cmp	 ax, 7
  00423	7d 0e		 jge	 SHORT $LN254@ProcUpgrad

; 334  : 			{
; 335  : 				ItemTarget->m_Level = 0;
; 336  : 			}
; 337  : 			else
; 338  : 			{
; 339  : 				ItemTarget->m_Level--;

  00425	48		 dec	 eax
  00426	66 89 46 08	 mov	 WORD PTR [esi+8], ax

; 340  : 
; 341  : 				if( ItemTarget->m_Level < 0 )

  0042a	66 85 c0	 test	 ax, ax
  0042d	0f 89 c2 02 00
	00		 jns	 $LN88@ProcUpgrad
$LN254@ProcUpgrad:

; 342  : 				{
; 343  : 					ItemTarget->m_Level = 0;

  00433	33 c0		 xor	 eax, eax
  00435	66 89 46 08	 mov	 WORD PTR [esi+8], ax

; 344  : 				}
; 345  : 			}
; 346  : 		}

  00439	e9 b7 02 00 00	 jmp	 $LN88@ProcUpgrad
$LN56@ProcUpgrad:

; 347  : 	}
; 348  : 	else if( JewelCode == ITEMGET(14, 16) )

  0043e	3d 10 1c 00 00	 cmp	 eax, 7184		; 00001c10H
  00443	0f 85 29 01 00
	00		 jne	 $LN64@ProcUpgrad

; 349  : 	{
; 350  : 		if( ItemTarget->m_Option3 == 0 )

  00449	80 be 92 00 00
	00 00		 cmp	 BYTE PTR [esi+146], 0
  00450	0f 85 e6 00 00
	00		 jne	 $LN78@ProcUpgrad

; 351  : 		{
; 352  : 			if(ItemTarget->m_Type >= ITEMGET(12,3) && ItemTarget->m_Type <= ITEMGET(12,6) ||
; 353  : 				ItemTarget->m_Type == ITEMGET(12,49) ||

  00456	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  0045a	b9 03 18 00 00	 mov	 ecx, 6147		; 00001803H
  0045f	66 3b c1	 cmp	 ax, cx
  00462	7c 0a		 jl	 SHORT $LN69@ProcUpgrad
  00464	b9 06 18 00 00	 mov	 ecx, 6150		; 00001806H
  00469	66 3b c1	 cmp	 ax, cx
  0046c	7e 14		 jle	 SHORT $LN68@ProcUpgrad
$LN69@ProcUpgrad:
  0046e	b9 31 18 00 00	 mov	 ecx, 6193		; 00001831H
  00473	66 3b c1	 cmp	 ax, cx
  00476	74 0a		 je	 SHORT $LN68@ProcUpgrad
  00478	b9 2a 18 00 00	 mov	 ecx, 6186		; 0000182aH
  0047d	66 3b c1	 cmp	 ax, cx
  00480	75 21		 jne	 SHORT $LN70@ProcUpgrad
$LN68@ProcUpgrad:

; 354  : 				ItemTarget->m_Type == ITEMGET(12,42) )
; 355  : 			{
; 356  : 				ItemTarget->m_NewOption &= 0xDF;

  00482	80 a6 93 00 00
	00 df		 and	 BYTE PTR [esi+147], 223	; 000000dfH

; 357  : 
; 358  : 				if(rand()%2)

  00489	e8 00 00 00 00	 call	 _rand
  0048e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00493	79 05		 jns	 SHORT $LN251@ProcUpgrad
  00495	48		 dec	 eax
  00496	83 c8 fe	 or	 eax, -2			; fffffffeH
  00499	40		 inc	 eax
$LN251@ProcUpgrad:
  0049a	74 07		 je	 SHORT $LN70@ProcUpgrad

; 359  : 				{
; 360  : 					ItemTarget->m_NewOption |= 0x20;

  0049c	80 8e 93 00 00
	00 20		 or	 BYTE PTR [esi+147], 32	; 00000020H
$LN70@ProcUpgrad:

; 361  : 				}
; 362  : 			}
; 363  : 			
; 364  : 			if( ItemTarget->m_Type >= ITEMGET(12,36) &&
; 365  : 				ItemTarget->m_Type <= ITEMGET(12,40) ||
; 366  : 				ItemTarget->m_Type == ITEMGET(12,43) ||

  004a3	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  004a7	b9 24 18 00 00	 mov	 ecx, 6180		; 00001824H
  004ac	66 3b c1	 cmp	 ax, cx
  004af	7c 0a		 jl	 SHORT $LN73@ProcUpgrad
  004b1	b9 28 18 00 00	 mov	 ecx, 6184		; 00001828H
  004b6	66 3b c1	 cmp	 ax, cx
  004b9	7e 14		 jle	 SHORT $LN72@ProcUpgrad
$LN73@ProcUpgrad:
  004bb	b9 2b 18 00 00	 mov	 ecx, 6187		; 0000182bH
  004c0	66 3b c1	 cmp	 ax, cx
  004c3	74 0a		 je	 SHORT $LN72@ProcUpgrad
  004c5	b9 32 18 00 00	 mov	 ecx, 6194		; 00001832H
  004ca	66 3b c1	 cmp	 ax, cx
  004cd	75 34		 jne	 SHORT $LN76@ProcUpgrad
$LN72@ProcUpgrad:

; 367  : 				ItemTarget->m_Type == ITEMGET(12,50)
; 368  : 	#if (CUSTOM_WINGS == 1)
; 369  : 				|| 
; 370  : 				ItemTarget->m_Type >= ITEMGET(12,440) &&
; 371  : 				ItemTarget->m_Type <= ITEMGET(12,445)
; 372  : 	#endif
; 373  : 				)
; 374  : 			{
; 375  : 				ItemTarget->m_NewOption &= 0xDF;

  004cf	80 a6 93 00 00
	00 df		 and	 BYTE PTR [esi+147], 223	; 000000dfH

; 376  : 
; 377  : 				if(rand()%3)

  004d6	e8 00 00 00 00	 call	 _rand
  004db	99		 cdq
  004dc	bb 03 00 00 00	 mov	 ebx, 3
  004e1	f7 fb		 idiv	 ebx
  004e3	85 d2		 test	 edx, edx
  004e5	74 09		 je	 SHORT $LN74@ProcUpgrad

; 378  : 				{
; 379  : 					ItemTarget->m_NewOption |= 0x20;

  004e7	80 8e 93 00 00
	00 20		 or	 BYTE PTR [esi+147], 32	; 00000020H
  004ee	eb 13		 jmp	 SHORT $LN76@ProcUpgrad
$LN74@ProcUpgrad:

; 380  : 				}
; 381  : 				else if(rand()%3)

  004f0	e8 00 00 00 00	 call	 _rand
  004f5	99		 cdq
  004f6	f7 fb		 idiv	 ebx
  004f8	85 d2		 test	 edx, edx
  004fa	74 07		 je	 SHORT $LN76@ProcUpgrad

; 382  : 				{
; 383  : 					ItemTarget->m_NewOption |= 0x10;

  004fc	80 8e 93 00 00
	00 10		 or	 BYTE PTR [esi+147], 16	; 00000010H
$LN76@ProcUpgrad:

; 384  : 				}
; 385  : 			}
; 386  : 
; 387  : 			if( ItemTarget->m_Type >= ITEMGET(12,262) &&

  00503	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  00507	b9 06 19 00 00	 mov	 ecx, 6406		; 00001906H
  0050c	66 3b c1	 cmp	 ax, cx
  0050f	7c 2b		 jl	 SHORT $LN78@ProcUpgrad
  00511	b9 09 19 00 00	 mov	 ecx, 6409		; 00001909H
  00516	66 3b c1	 cmp	 ax, cx
  00519	7f 21		 jg	 SHORT $LN78@ProcUpgrad

; 388  : 				ItemTarget->m_Type <= ITEMGET(12,265) )
; 389  : 			{
; 390  : 				ItemTarget->m_NewOption &= 0xDF;

  0051b	80 a6 93 00 00
	00 df		 and	 BYTE PTR [esi+147], 223	; 000000dfH

; 391  : 
; 392  : 				if( rand()%2 )

  00522	e8 00 00 00 00	 call	 _rand
  00527	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0052c	79 05		 jns	 SHORT $LN252@ProcUpgrad
  0052e	48		 dec	 eax
  0052f	83 c8 fe	 or	 eax, -2			; fffffffeH
  00532	40		 inc	 eax
$LN252@ProcUpgrad:
  00533	74 07		 je	 SHORT $LN78@ProcUpgrad

; 393  : 				{
; 394  : 					ItemTarget->m_NewOption |= 0x10;

  00535	80 8e 93 00 00
	00 10		 or	 BYTE PTR [esi+147], 16	; 00000010H
$LN78@ProcUpgrad:

; 395  : 				}
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : 		if( ItemTarget->m_Option3 >= 7 )

  0053c	80 be 92 00 00
	00 07		 cmp	 BYTE PTR [esi+146], 7
  00543	0f 83 ec 00 00
	00		 jae	 $LN10@ProcUpgrad

; 400  : 		{
; 401  : 			return false;
; 402  : 		}
; 403  : 
; 404  : 		if( rand() % 10000 < Rate )

  00549	e8 00 00 00 00	 call	 _rand
  0054e	99		 cdq
  0054f	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00554	f7 f9		 idiv	 ecx
  00556	3b 55 10	 cmp	 edx, DWORD PTR _Rate$1$[ebp]
  00559	73 0b		 jae	 SHORT $LN80@ProcUpgrad

; 405  : 		{
; 406  : 			ItemTarget->m_Option3++;

  0055b	fe 86 92 00 00
	00		 inc	 BYTE PTR [esi+146]

; 407  : 		}
; 408  : 		else

  00561	e9 8f 01 00 00	 jmp	 $LN88@ProcUpgrad
$LN80@ProcUpgrad:

; 409  : 		{
; 410  : 			ItemTarget->m_Option3 = 0;

  00566	c6 86 92 00 00
	00 00		 mov	 BYTE PTR [esi+146], 0

; 411  : 		}

  0056d	e9 83 01 00 00	 jmp	 $LN88@ProcUpgrad
$LN64@ProcUpgrad:

; 412  : 	}
; 413  : 	else if( JewelCode == ITEMGET(14, 42) )

  00572	3d 2a 1c 00 00	 cmp	 eax, 7210		; 00001c2aH
  00577	0f 85 78 01 00
	00		 jne	 $LN88@ProcUpgrad

; 414  : 	{
; 415  : 		if( g_kJewelOfHarmonySystem.m_bSystemSmeltingItem == false )

  0057d	83 3d 28 53 00
	00 00		 cmp	 DWORD PTR ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A+21288, 0
  00584	0f 84 ab 00 00
	00		 je	 $LN10@ProcUpgrad

; 416  : 		{
; 417  : 			return false;
; 418  : 		}
; 419  : 
; 420  : 		if( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony(ItemTarget) )

  0058a	56		 push	 esi
  0058b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00590	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  00595	85 c0		 test	 eax, eax
  00597	74 21		 je	 SHORT $LN84@ProcUpgrad

; 421  : 		{
; 422  : 			LogAddTD("[JewelOfHarmony][Strengten Item] Already Strengtened [%s][%s]",

  00599	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0059c	50		 push	 eax
  0059d	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  005a0	50		 push	 eax
  005a1	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@KOLBHFBF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
  005a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 423  : 				lpUser->AccountID, lpUser->Name);
; 424  : 			return false;

  005af	32 c0		 xor	 al, al
  005b1	5f		 pop	 edi
  005b2	5e		 pop	 esi
  005b3	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  005b4	8b e5		 mov	 esp, ebp
  005b6	5d		 pop	 ebp
  005b7	c2 10 00	 ret	 16			; 00000010H
$LN84@ProcUpgrad:

; 425  : 		}
; 426  : 		
; 427  : 		int iItemType = g_kJewelOfHarmonySystem._GetItemType(ItemTarget);

  005ba	56		 push	 esi
  005bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  005c0	e8 00 00 00 00	 call	 ?_GetItemType@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::_GetItemType
  005c5	8b d8		 mov	 ebx, eax

; 428  : 
; 429  : 		if( iItemType == JEWELOFHARMONY_ITEM_TYPE_NULL )

  005c7	85 db		 test	 ebx, ebx
  005c9	75 31		 jne	 SHORT $LN85@ProcUpgrad

; 430  : 		{
; 431  : 			LogAddTD("[JewelOfHarmony][Strengten Item] Strenghten Fail [%s][%s] Name[%s] Type[%d] Serial[%d] Invalid ItemType[%d]",

  005cb	50		 push	 eax
  005cc	ff 36		 push	 DWORD PTR [esi]
  005ce	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  005d2	8b ce		 mov	 ecx, esi
  005d4	50		 push	 eax
  005d5	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005da	50		 push	 eax
  005db	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  005de	50		 push	 eax
  005df	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  005e2	50		 push	 eax
  005e3	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@BCEBDMP@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
  005e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005ee	83 c4 1c	 add	 esp, 28			; 0000001cH

; 432  : 				lpUser->AccountID, lpUser->Name, ItemTarget->GetName(), ItemTarget->m_Type,
; 433  : 				ItemTarget->m_Number, iItemType);
; 434  : 			return false;

  005f1	32 c0		 xor	 al, al
  005f3	5f		 pop	 edi
  005f4	5e		 pop	 esi
  005f5	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  005f6	8b e5		 mov	 esp, ebp
  005f8	5d		 pop	 ebp
  005f9	c2 10 00	 ret	 16			; 00000010H
$LN85@ProcUpgrad:

; 435  : 		}
; 436  : 
; 437  : 		int iItemOption = g_kJewelOfHarmonySystem._GetSelectRandomOption(ItemTarget, iItemType);

  005fc	53		 push	 ebx
  005fd	56		 push	 esi
  005fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00603	e8 00 00 00 00	 call	 ?_GetSelectRandomOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@H@Z ; CJewelOfHarmonySystem::_GetSelectRandomOption
  00608	89 45 0c	 mov	 DWORD PTR _iItemOption$1$[ebp], eax

; 438  : 
; 439  : 		if( iItemOption == AT_JEWELOFHARMONY_NOT_STRENGTHEN_ITEM )

  0060b	85 c0		 test	 eax, eax
  0060d	75 31		 jne	 SHORT $LN86@ProcUpgrad

; 440  : 		{
; 441  : 			LogAddTD("[JewelOfHarmony][Strengten Item] Strenghten Fail - NOT OPTION [%s][%s] Name[%s] Type[%d] Serial[%d] ItemType[%d]",

  0060f	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  00613	8b ce		 mov	 ecx, esi
  00615	53		 push	 ebx
  00616	ff 36		 push	 DWORD PTR [esi]
  00618	50		 push	 eax
  00619	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0061e	50		 push	 eax
  0061f	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00622	50		 push	 eax
  00623	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00626	50		 push	 eax
  00627	68 00 00 00 00	 push	 OFFSET ??_C@_0HB@BFMNEGMJ@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
  0062c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00632	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN10@ProcUpgrad:

; 442  : 				lpUser->AccountID, lpUser->Name, ItemTarget->GetName(), ItemTarget->m_Type,
; 443  : 				ItemTarget->m_Number, iItemType);
; 444  : 			return false;

  00635	5f		 pop	 edi
  00636	5e		 pop	 esi
  00637	32 c0		 xor	 al, al
  00639	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  0063a	8b e5		 mov	 esp, ebp
  0063c	5d		 pop	 ebp
  0063d	c2 10 00	 ret	 16			; 00000010H
$LN86@ProcUpgrad:

; 445  : 		}
; 446  : 		
; 447  : 		int iItemOptionLevel = g_kJewelOfHarmonySystem.m_itemOption[iItemType][iItemOption].iRequireLevel;

  00640	c1 e3 04	 shl	 ebx, 4
  00643	03 d8		 add	 ebx, eax
  00645	69 c3 4c 01 00
	00		 imul	 eax, ebx, 332
  0064b	0f b6 80 1d 00
	00 00		 movzx	 eax, BYTE PTR ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A[eax+29]
  00652	89 45 08	 mov	 DWORD PTR _iItemOptionLevel$1$[ebp], eax

; 448  : 
; 449  : 		if( rand() % 10000 < Rate )

  00655	e8 00 00 00 00	 call	 _rand
  0065a	99		 cdq
  0065b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00660	f7 f9		 idiv	 ecx
  00662	8b 5d 10	 mov	 ebx, DWORD PTR _Rate$1$[ebp]
  00665	3b d3		 cmp	 edx, ebx
  00667	73 49		 jae	 SHORT $LN87@ProcUpgrad

; 450  : 		{
; 451  : 			g_kJewelOfHarmonySystem._MakeOption(ItemTarget, iItemOption, iItemOptionLevel);

  00669	ff 75 08	 push	 DWORD PTR _iItemOptionLevel$1$[ebp]
  0066c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00671	ff 75 0c	 push	 DWORD PTR _iItemOption$1$[ebp]
  00674	56		 push	 esi
  00675	e8 00 00 00 00	 call	 ?_MakeOption@CJewelOfHarmonySystem@@QAEHPAVCItem@@EE@Z ; CJewelOfHarmonySystem::_MakeOption

; 452  : 			LogAddTD("[JewelOfHarmony][Strengten Item] Strenghten Success [%s][%s] Name[%s] Type[%d] Serial[%d] Rate (%d/%d) Option %d OptionLevel %d",

  0067a	ff 75 08	 push	 DWORD PTR _iItemOptionLevel$1$[ebp]
  0067d	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  00681	8b ce		 mov	 ecx, esi
  00683	ff 75 0c	 push	 DWORD PTR _iItemOption$1$[ebp]
  00686	53		 push	 ebx
  00687	53		 push	 ebx
  00688	ff 36		 push	 DWORD PTR [esi]
  0068a	50		 push	 eax
  0068b	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00690	50		 push	 eax
  00691	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00694	50		 push	 eax
  00695	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00698	50		 push	 eax
  00699	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@PFHJPDOF@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
  0069e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006a4	83 c4 28	 add	 esp, 40			; 00000028H

; 453  : 				lpUser->AccountID, lpUser->Name, ItemTarget->GetName(), ItemTarget->m_Type,
; 454  : 				ItemTarget->m_Number, Rate, Rate,
; 455  : 				iItemOption, iItemOptionLevel);
; 456  : 
; 457  : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13, 46)), lpUser->m_Index, 1);

  006a7	6a 01		 push	 1
  006a9	ff 37		 push	 DWORD PTR [edi]
  006ab	68 2e 0d 00 00	 push	 3374			; 00000d2eH

; 458  : 		}
; 459  : 		else

  006b0	eb 30		 jmp	 SHORT $LN253@ProcUpgrad
$LN87@ProcUpgrad:

; 460  : 		{
; 461  : 			LogAddTD("[JewelOfHarmony][Strengten Item] Strenghten Fail [%s][%s] Name[%s] Type[%d] Serial[%d]  Rate (%d/%d)",

  006b2	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  006b6	8b ce		 mov	 ecx, esi
  006b8	53		 push	 ebx
  006b9	53		 push	 ebx
  006ba	ff 36		 push	 DWORD PTR [esi]
  006bc	50		 push	 eax
  006bd	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  006c2	50		 push	 eax
  006c3	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  006c6	50		 push	 eax
  006c7	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  006ca	50		 push	 eax
  006cb	68 00 00 00 00	 push	 OFFSET ??_C@_0GF@EOLHJPBK@?$FLJewelOfHarmony?$FN?$FLStrengten?5Item?$FN@
  006d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006d6	83 c4 20	 add	 esp, 32			; 00000020H

; 462  : 				lpUser->AccountID, lpUser->Name, ItemTarget->GetName(), ItemTarget->m_Type,
; 463  : 				ItemTarget->m_Number, Rate, Rate);
; 464  : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13, 45)), lpUser->m_Index, 1);

  006d9	6a 01		 push	 1
  006db	ff 37		 push	 DWORD PTR [edi]
  006dd	68 2d 0d 00 00	 push	 3373			; 00000d2dH
$LN253@ProcUpgrad:
  006e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  006e7	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  006ec	50		 push	 eax
  006ed	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN88@ProcUpgrad:

; 465  : 		}
; 466  : 	}
; 467  : 
; 468  : 	gObjMakePreviewCharSet(lpUser->m_Index);

  006f5	ff 37		 push	 DWORD PTR [edi]
  006f7	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 469  : 
; 470  : 	float levelitemdur = (float)ItemGetDurability(lpUser->pInventory[TargetPos].m_Type,

  006fc	8b b7 c0 11 00
	00		 mov	 esi, DWORD PTR [edi+4544]
  00702	83 c4 04	 add	 esp, 4
  00705	8b 5d f4	 mov	 ebx, DWORD PTR tv1208[ebp]
  00708	8d 0c 33	 lea	 ecx, DWORD PTR [ebx+esi]
  0070b	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00710	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00716	50		 push	 eax
  00717	03 cb		 add	 ecx, ebx
  00719	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  0071e	50		 push	 eax
  0071f	0f bf 44 33 08	 movsx	 eax, WORD PTR [ebx+esi+8]
  00724	50		 push	 eax
  00725	0f bf 44 33 06	 movsx	 eax, WORD PTR [ebx+esi+6]
  0072a	50		 push	 eax
  0072b	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00730	83 c4 10	 add	 esp, 16			; 00000010H
  00733	66 0f 6e c8	 movd	 xmm1, eax

; 471  : 		lpUser->pInventory[TargetPos].m_Level,
; 472  : 		lpUser->pInventory[TargetPos].IsExtItem(),
; 473  : 		lpUser->pInventory[TargetPos].IsSetItem());
; 474  : 
; 475  : 	lpUser->pInventory[TargetPos].m_Durability = levelitemdur * lpUser->pInventory[TargetPos].m_Durability / lpUser->pInventory[TargetPos].m_BaseDurability;

  00737	8b 87 c0 11 00
	00		 mov	 eax, DWORD PTR [edi+4544]
  0073d	0f 5b c9	 cvtdq2ps xmm1, xmm1

; 476  : 
; 477  : 	lpUser->pInventory[TargetPos].Convert(

  00740	6a 03		 push	 3
  00742	68 ff 00 00 00	 push	 255			; 000000ffH
  00747	6a 00		 push	 0
  00749	f3 0f 10 44 03
	24		 movss	 xmm0, DWORD PTR [ebx+eax+36]
  0074f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00753	f3 0f 5e 44 03
	2c		 divss	 xmm0, DWORD PTR [ebx+eax+44]
  00759	f3 0f 11 44 03
	24		 movss	 DWORD PTR [ebx+eax+36], xmm0
  0075f	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00765	03 cb		 add	 ecx, ebx
  00767	0f b6 81 c6 00
	00 00		 movzx	 eax, BYTE PTR [ecx+198]
  0076e	50		 push	 eax
  0076f	0f b6 81 aa 00
	00 00		 movzx	 eax, BYTE PTR [ecx+170]
  00776	50		 push	 eax
  00777	0f b6 81 93 00
	00 00		 movzx	 eax, BYTE PTR [ecx+147]
  0077e	50		 push	 eax
  0077f	0f b6 81 92 00
	00 00		 movzx	 eax, BYTE PTR [ecx+146]
  00786	50		 push	 eax
  00787	0f b6 81 91 00
	00 00		 movzx	 eax, BYTE PTR [ecx+145]
  0078e	50		 push	 eax
  0078f	0f b6 81 90 00
	00 00		 movzx	 eax, BYTE PTR [ecx+144]
  00796	50		 push	 eax
  00797	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]
  0079b	50		 push	 eax
  0079c	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 478  : 			lpUser->pInventory[TargetPos].m_Type,
; 479  : 			lpUser->pInventory[TargetPos].m_Option1,
; 480  : 			lpUser->pInventory[TargetPos].m_Option2,
; 481  : 			lpUser->pInventory[TargetPos].m_Option3,
; 482  : 			lpUser->pInventory[TargetPos].m_NewOption,
; 483  : 			lpUser->pInventory[TargetPos].m_SetOption,
; 484  : 			lpUser->pInventory[TargetPos].m_ItemOptionEx,0,-1,
; 485  : 			CURRENT_DB_VERSION);
; 486  : 
; 487  : 	LogAddTD(lMsg.Get(557),lpUser->AccountID,lpUser->Name,lpUser->pInventory[JewelPos].m_Number,

  007a1	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  007a7	03 cb		 add	 ecx, ebx
  007a9	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  007ad	50		 push	 eax
  007ae	ff 31		 push	 DWORD PTR [ecx]
  007b0	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  007b5	8b 4d fc	 mov	 ecx, DWORD PTR tv1209[ebp]
  007b8	50		 push	 eax
  007b9	8b 87 c0 11 00
	00		 mov	 eax, DWORD PTR [edi+4544]
  007bf	ff 34 01	 push	 DWORD PTR [ecx+eax]
  007c2	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  007c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  007ca	50		 push	 eax
  007cb	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  007ce	50		 push	 eax
  007cf	68 2d 02 00 00	 push	 557			; 0000022dH
  007d4	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  007d9	50		 push	 eax
  007da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007e0	83 c4 1c	 add	 esp, 28			; 0000001cH
  007e3	b0 01		 mov	 al, 1
  007e5	5f		 pop	 edi
  007e6	5e		 pop	 esi
  007e7	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  007e8	8b e5		 mov	 esp, ebp
  007ea	5d		 pop	 ebp
  007eb	c2 10 00	 ret	 16			; 00000010H
$LN8@ProcUpgrad:
  007ee	5e		 pop	 esi

; 128  : 	{
; 129  : 		return false;

  007ef	32 c0		 xor	 al, al
  007f1	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  007f2	8b e5		 mov	 esp, ebp
  007f4	5d		 pop	 ebp
  007f5	c2 10 00	 ret	 16			; 00000010H
$LN6@ProcUpgrad:

; 123  : 	{
; 124  : 		return false;

  007f8	32 c0		 xor	 al, al
  007fa	5b		 pop	 ebx

; 488  : 			lpUser->pInventory[TargetPos].GetName(),lpUser->pInventory[TargetPos].m_Number,
; 489  : 			lpUser->pInventory[TargetPos].m_Level);
; 490  : 	return true;
; 491  : }

  007fb	8b e5		 mov	 esp, ebp
  007fd	5d		 pop	 ebp
  007fe	c2 10 00	 ret	 16			; 00000010H
?ProcUpgrade@ItemUpgradeJewels@@QAE_NPAUOBJECTSTRUCT@@HHPAUItemUpgradeJewelsInfo@@@Z ENDP ; ItemUpgradeJewels::ProcUpgrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv340 = -8						; size = 4
_i$1$ = -4						; size = 4
tv337 = 8						; size = 4
_lpUser$ = 8						; size = 4
_JewelPos$ = 12						; size = 4
_TargetPos$ = 16					; size = 4
?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z PROC ; ItemUpgradeJewels::ProcInsert, COMDAT
; _this$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	53		 push	 ebx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 88   : {

  0000c	8b d9		 mov	 ebx, ecx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00010	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00013	2b 73 04	 sub	 esi, DWORD PTR [ebx+4]
  00016	f7 ee		 imul	 esi
  00018	03 d6		 add	 edx, esi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 91   : 	for( int i = 0; i < this->m_UpradeInfo.size(); i++ )

  0001a	8b 75 08	 mov	 esi, DWORD PTR _lpUser$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0001d	c1 fa 04	 sar	 edx, 4
  00020	8b c2		 mov	 eax, edx
  00022	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00025	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 91   : 	for( int i = 0; i < this->m_UpradeInfo.size(); i++ )

  00027	74 55		 je	 SHORT $LN69@ProcInsert

; 94   : 			this->m_UpradeInfo[i].ItemIndex) == lpUser->pInventory[JewelPos].m_Type)

  00029	69 4d 0c d4 00
	00 00		 imul	 ecx, DWORD PTR _JewelPos$[ebp], 212
  00030	33 d2		 xor	 edx, edx
  00032	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00038	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0003b	89 4d f8	 mov	 DWORD PTR tv340[ebp], ecx
  0003e	0f bf 44 08 06	 movsx	 eax, WORD PTR [eax+ecx+6]
  00043	89 45 08	 mov	 DWORD PTR tv337[ebp], eax
$LL4@ProcInsert:
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 94   : 			this->m_UpradeInfo[i].ItemIndex) == lpUser->pInventory[JewelPos].m_Type)

  00046	0f bf 0f	 movsx	 ecx, WORD PTR [edi]
  00049	0f bf 47 02	 movsx	 eax, WORD PTR [edi+2]
  0004d	c1 e1 09	 shl	 ecx, 9
  00050	03 c8		 add	 ecx, eax
  00052	3b 4d 08	 cmp	 ecx, DWORD PTR tv337[ebp]
  00055	74 55		 je	 SHORT $LN65@ProcInsert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00057	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 91   : 	for( int i = 0; i < this->m_UpradeInfo.size(); i++ )

  0005a	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0005b	2b 4b 04	 sub	 ecx, DWORD PTR [ebx+4]
  0005e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 91   : 	for( int i = 0; i < this->m_UpradeInfo.size(); i++ )

  00063	89 55 fc	 mov	 DWORD PTR _i$1$[ebp], edx
  00066	83 c7 1c	 add	 edi, 28			; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00069	f7 e9		 imul	 ecx
  0006b	03 d1		 add	 edx, ecx
  0006d	c1 fa 04	 sar	 edx, 4
  00070	8b c2		 mov	 eax, edx
  00072	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00075	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 91   : 	for( int i = 0; i < this->m_UpradeInfo.size(); i++ )

  00077	8b 55 fc	 mov	 edx, DWORD PTR _i$1$[ebp]
  0007a	3b d0		 cmp	 edx, eax
  0007c	72 c8		 jb	 SHORT $LL4@ProcInsert
$LN69@ProcInsert:

; 102  : 	{
; 103  : 		GCReFillSend(lpUser->m_Index, (WORD)lpUser->Life, 0xFD, 1, lpUser->iShield);

  0007e	0f b7 86 2c 01
	00 00		 movzx	 eax, WORD PTR [esi+300]
  00085	50		 push	 eax
  00086	f3 0f 2c 86 d8
	00 00 00	 cvttss2si eax, DWORD PTR [esi+216]
  0008e	6a 01		 push	 1
  00090	68 fd 00 00 00	 push	 253			; 000000fdH
  00095	0f b7 c0	 movzx	 eax, ax
  00098	50		 push	 eax
  00099	ff 36		 push	 DWORD PTR [esi]
  0009b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  000a0	83 c4 14	 add	 esp, 20			; 00000014H
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx

; 113  : 	}
; 114  : 	else
; 115  : 	{
; 116  : 		GCReFillSend(lpUser->m_Index, (WORD)lpUser->Life, 0xFD, 1, lpUser->iShield);
; 117  : 	}
; 118  : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH
$LN65@ProcInsert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1240 : 		return (*(this->_Myfirst() + _Pos));

  000ac	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000af	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  000b6	2b c2		 sub	 eax, edx
  000b8	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 101  : 	if( lpJewel == NULL )

  000bb	85 c0		 test	 eax, eax
  000bd	74 bf		 je	 SHORT $LN69@ProcInsert

; 104  : 		return;
; 105  : 	}
; 106  : 
; 107  : 	if( this->ProcUpgrade(lpUser, JewelPos, TargetPos, lpJewel) )

  000bf	8b 7d 0c	 mov	 edi, DWORD PTR _JewelPos$[ebp]
  000c2	8b cb		 mov	 ecx, ebx
  000c4	50		 push	 eax
  000c5	ff 75 10	 push	 DWORD PTR _TargetPos$[ebp]
  000c8	57		 push	 edi
  000c9	56		 push	 esi
  000ca	e8 00 00 00 00	 call	 ?ProcUpgrade@ItemUpgradeJewels@@QAE_NPAUOBJECTSTRUCT@@HHPAUItemUpgradeJewelsInfo@@@Z ; ItemUpgradeJewels::ProcUpgrade
  000cf	84 c0		 test	 al, al
  000d1	74 ab		 je	 SHORT $LN69@ProcInsert

; 108  : 	{
; 109  : 		gObjInventoryItemSet(lpUser->m_Index, JewelPos, -1);

  000d3	68 ff 00 00 00	 push	 255			; 000000ffH
  000d8	57		 push	 edi
  000d9	ff 36		 push	 DWORD PTR [esi]
  000db	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 110  : 		lpUser->pInventory[JewelPos].Clear();

  000e0	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	03 4d f8	 add	 ecx, DWORD PTR tv340[ebp]
  000ec	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 111  : 		GCInventoryItemOneSend(lpUser->m_Index, TargetPos);

  000f1	ff 75 10	 push	 DWORD PTR _TargetPos$[ebp]
  000f4	ff 36		 push	 DWORD PTR [esi]
  000f6	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 112  : 		GCInventoryItemDeleteSend(lpUser->m_Index, JewelPos, 1);

  000fb	6a 01		 push	 1
  000fd	57		 push	 edi
  000fe	ff 36		 push	 DWORD PTR [esi]
  00100	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00105	83 c4 14	 add	 esp, 20			; 00000014H
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx

; 113  : 	}
; 114  : 	else
; 115  : 	{
; 116  : 		GCReFillSend(lpUser->m_Index, (WORD)lpUser->Life, 0xFD, 1, lpUser->iShield);
; 117  : 	}
; 118  : }

  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 0c 00	 ret	 12			; 0000000cH
?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z ENDP ; ItemUpgradeJewels::ProcInsert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?Read@ItemUpgradeJewels@@QAEXPAD@Z
_TEXT	SEGMENT
_Result$ = -400						; size = 12
$T2 = -388						; size = 4
$T3 = -384						; size = 4
$T4 = -380						; size = 4
$T5 = -376						; size = 4
$T6 = -372						; size = 4
$T7 = -368						; size = 4
$T8 = -364						; size = 4
$T9 = -360						; size = 4
$T10 = -356						; size = 4
$T11 = -352						; size = 4
$T12 = -348						; size = 4
$T13 = -344						; size = 4
$T14 = -340						; size = 4
$T15 = -336						; size = 4
$T16 = -332						; size = 4
$T17 = -328						; size = 4
$T18 = -324						; size = 4
$T19 = -320						; size = 4
$T20 = -316						; size = 4
$T21 = -312						; size = 4
$T22 = -308						; size = 4
$T23 = -304						; size = 4
$T24 = -300						; size = 4
$T25 = -296						; size = 4
$T26 = -292						; size = 4
$T27 = -288						; size = 4
$T28 = -284						; size = 4
$T29 = -280						; size = 4
$T30 = -276						; size = 4
_ChildCommon$ = -272					; size = 4
tv1262 = -268						; size = 4
$T31 = -268						; size = 4
_lpRate$32 = -264					; size = 12
_lpItem$33 = -252					; size = 28
_RateNode$34 = -224					; size = 4
_Node$ = -220						; size = 4
_Document$ = -216					; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_File$ = 8						; size = 4
?Read@ItemUpgradeJewels@@QAEXPAD@Z PROC			; ItemUpgradeJewels::Read, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Read@ItemUpgradeJewels@@QAEXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 01 00
	00		 sub	 esp, 388		; 00000184H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f9		 mov	 edi, ecx
  00030	8b 75 08	 mov	 esi, DWORD PTR _File$[ebp]

; 38   : 	xml_document Document;

  00033	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00039	e8 00 00 00 00	 call	 ??0xml_document@pugi@@QAE@XZ ; pugi::xml_document::xml_document

; 39   : 	xml_parse_result Result = Document.load_file(File);

  0003e	6a 00		 push	 0
  00040	6a 74		 push	 116			; 00000074H
  00042	56		 push	 esi
  00043	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _Result$[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	50		 push	 eax
  00051	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00057	e8 00 00 00 00	 call	 ?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z ; pugi::xml_document::load_file

; 40   : 	// ----
; 41   : 	if( Result.status != status_ok )

  0005c	83 bd 70 fe ff
	ff 00		 cmp	 DWORD PTR _Result$[ebp], 0
  00063	74 13		 je	 SHORT $LN8@Read

; 42   : 	{
; 43   : 		MsgBox("[ItemUpgradeJewels] File %s not found!", File);

  00065	56		 push	 esi
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JADJMKEP@?$FLItemUpgradeJewels?$FN?5File?5?$CFs?5not?5@
  0006b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00070	83 c4 08	 add	 esp, 8
  00073	e9 f6 04 00 00	 jmp	 $LN3@Read
$LN8@Read:

; 44   : 		return;
; 45   : 	}
; 46   : 	// ----
; 47   : 	xml_node ChildCommon = Document.child("itemupgradejewels");

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JBIPBODA@itemupgradejewels?$AA@
  0007d	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _ChildCommon$[ebp]
  00083	50		 push	 eax
  00084	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  0008a	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child

; 48   : 	xml_node Node;

  0008f	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00095	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node

; 49   : 	// ----
; 50   : 	for( Node = ChildCommon.child("jewel"); Node; Node = Node.next_sibling() )

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_05MHDMDPBI@jewel?$AA@
  0009f	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  000a5	50		 push	 eax
  000a6	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _ChildCommon$[ebp]
  000ac	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  000b1	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  000b7	8b 00		 mov	 eax, DWORD PTR [eax]
  000b9	89 85 24 ff ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  000bf	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  000c4	85 c0		 test	 eax, eax
  000c6	0f 84 a2 04 00
	00		 je	 $LN3@Read
  000cc	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000cf	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv1262[ebp], eax
$LL4@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  000d5	33 db		 xor	 ebx, ebx

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();

  000d7	33 f6		 xor	 esi, esi
  000d9	89 9d 14 ff ff
	ff		 mov	 DWORD PTR _lpItem$33[ebp+16], ebx
  000df	89 9d 18 ff ff
	ff		 mov	 DWORD PTR _lpItem$33[ebp+20], ebx
  000e5	89 b5 1c ff ff
	ff		 mov	 DWORD PTR _lpItem$33[ebp+24], esi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 54   : 		lpItem.ItemType = Node.attribute("type").as_int((int)-1);

  000eb	6a ff		 push	 -1
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_04GPMDFGEJ@type?$AA@
  000f2	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000f8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000fc	50		 push	 eax
  000fd	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00103	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00108	8b c8		 mov	 ecx, eax
  0010a	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 55   : 		lpItem.ItemIndex = Node.attribute("index").as_int((int)-1);

  0010f	6a ff		 push	 -1
  00111	66 89 85 04 ff
	ff ff		 mov	 WORD PTR _lpItem$33[ebp], ax
  00118	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_05FKHKFDID@index?$AA@
  00123	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0012f	8b c8		 mov	 ecx, eax
  00131	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 56   : 		lpItem.DefaultRate = Node.attribute("rate").as_uint();

  00136	56		 push	 esi
  00137	66 89 85 06 ff
	ff ff		 mov	 WORD PTR _lpItem$33[ebp+2], ax
  0013e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_04HCCHHEEF@rate?$AA@
  00149	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR $T30[ebp]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00155	8b c8		 mov	 ecx, eax
  00157	e8 00 00 00 00	 call	 ?as_uint@xml_attribute@pugi@@QBEII@Z ; pugi::xml_attribute::as_uint

; 57   : 		lpItem.TargetLevelMin = Node.child("rules").child("level").attribute("min").as_int((BYTE)-1);

  0015c	68 ff 00 00 00	 push	 255			; 000000ffH
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_03KLIPLJLL@min?$AA@
  00166	89 85 08 ff ff
	ff		 mov	 DWORD PTR _lpItem$33[ebp+4], eax
  0016c	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00172	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T29[ebp]
  00178	50		 push	 eax
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_05KJNJLLGA@level?$AA@
  0017e	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  00184	50		 push	 eax
  00185	68 00 00 00 00	 push	 OFFSET ??_C@_05CBLPGGM@rules?$AA@
  0018a	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T27[ebp]
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00196	8b c8		 mov	 ecx, eax
  00198	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0019d	8b c8		 mov	 ecx, eax
  0019f	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001a4	8b c8		 mov	 ecx, eax
  001a6	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 58   : 		lpItem.TargetLevelMax = Node.child("rules").child("level").attribute("max").as_int((BYTE)-1);

  001ab	68 ff 00 00 00	 push	 255			; 000000ffH
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_03LJAEFNNE@max?$AA@
  001b5	88 85 0c ff ff
	ff		 mov	 BYTE PTR _lpItem$33[ebp+8], al
  001bb	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  001c1	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T26[ebp]
  001c7	50		 push	 eax
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_05KJNJLLGA@level?$AA@
  001cd	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  001d3	50		 push	 eax
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_05CBLPGGM@rules?$AA@
  001d9	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  001e5	8b c8		 mov	 ecx, eax
  001e7	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  001ec	8b c8		 mov	 ecx, eax
  001ee	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  001f3	8b c8		 mov	 ecx, eax
  001f5	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 59   : 		lpItem.TargetRankNormal = Node.child("rules").child("rank").attribute("normal").as_int((BYTE)-1);

  001fa	68 ff 00 00 00	 push	 255			; 000000ffH
  001ff	88 85 0d ff ff
	ff		 mov	 BYTE PTR _lpItem$33[ebp+9], al
  00205	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_06IKLLLDHL@normal?$AA@
  00210	50		 push	 eax
  00211	68 00 00 00 00	 push	 OFFSET ??_C@_04PNBFHPGN@rank?$AA@
  00216	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  0021c	50		 push	 eax
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_05CBLPGGM@rules?$AA@
  00222	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  00228	50		 push	 eax
  00229	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0022f	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00234	8b c8		 mov	 ecx, eax
  00236	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0023b	8b c8		 mov	 ecx, eax
  0023d	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00242	8b c8		 mov	 ecx, eax
  00244	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 60   : 		lpItem.TargetRankExcellent = Node.child("rules").child("rank").attribute("excellent").as_int((BYTE)-1);

  00249	68 ff 00 00 00	 push	 255			; 000000ffH
  0024e	68 00 00 00 00	 push	 OFFSET ??_C@_09MBDMPFOO@excellent?$AA@
  00253	88 85 0e ff ff
	ff		 mov	 BYTE PTR _lpItem$33[ebp+10], al
  00259	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0025f	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  00265	50		 push	 eax
  00266	68 00 00 00 00	 push	 OFFSET ??_C@_04PNBFHPGN@rank?$AA@
  0026b	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00271	50		 push	 eax
  00272	68 00 00 00 00	 push	 OFFSET ??_C@_05CBLPGGM@rules?$AA@
  00277	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00283	8b c8		 mov	 ecx, eax
  00285	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  0028a	8b c8		 mov	 ecx, eax
  0028c	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00291	8b c8		 mov	 ecx, eax
  00293	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 61   : 		lpItem.TargetRankAncient = Node.child("rules").child("rank").attribute("ancient").as_int((BYTE)-1);

  00298	68 ff 00 00 00	 push	 255			; 000000ffH
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_07ECLFICCK@ancient?$AA@
  002a2	88 85 0f ff ff
	ff		 mov	 BYTE PTR _lpItem$33[ebp+11], al
  002a8	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002ae	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  002b4	50		 push	 eax
  002b5	68 00 00 00 00	 push	 OFFSET ??_C@_04PNBFHPGN@rank?$AA@
  002ba	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  002c0	50		 push	 eax
  002c1	68 00 00 00 00	 push	 OFFSET ??_C@_05CBLPGGM@rules?$AA@
  002c6	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  002d2	8b c8		 mov	 ecx, eax
  002d4	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  002d9	8b c8		 mov	 ecx, eax
  002db	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  002e0	8b c8		 mov	 ecx, eax
  002e2	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 62   : 		lpItem.TargetRankSocket = Node.child("rules").child("rank").attribute("socket").as_int((BYTE)-1);

  002e7	68 ff 00 00 00	 push	 255			; 000000ffH
  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_06HBELJPBO@socket?$AA@
  002f1	88 85 10 ff ff
	ff		 mov	 BYTE PTR _lpItem$33[ebp+12], al
  002f7	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  002fd	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00303	50		 push	 eax
  00304	68 00 00 00 00	 push	 OFFSET ??_C@_04PNBFHPGN@rank?$AA@
  00309	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0030f	50		 push	 eax
  00310	68 00 00 00 00	 push	 OFFSET ??_C@_05CBLPGGM@rules?$AA@
  00315	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  0031b	50		 push	 eax
  0031c	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00321	8b c8		 mov	 ecx, eax
  00323	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00328	8b c8		 mov	 ecx, eax
  0032a	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0032f	8b c8		 mov	 ecx, eax
  00331	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00336	33 ff		 xor	 edi, edi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 62   : 		lpItem.TargetRankSocket = Node.child("rules").child("rank").attribute("socket").as_int((BYTE)-1);

  00338	88 85 11 ff ff
	ff		 mov	 BYTE PTR _lpItem$33[ebp+13], al

; 70   : 		xml_node RateNode;

  0033e	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00344	89 bd 18 ff ff
	ff		 mov	 DWORD PTR _lpItem$33[ebp+20], edi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 70   : 		xml_node RateNode;

  0034a	e8 00 00 00 00	 call	 ??0xml_node@pugi@@QAE@XZ ; pugi::xml_node::xml_node

; 72   : 		for( RateNode = Node.child("ratechange"); RateNode; RateNode = RateNode.next_sibling() )

  0034f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@ENBHLBKM@ratechange?$AA@
  00354	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  0035a	50		 push	 eax
  0035b	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00361	e8 00 00 00 00	 call	 ?child@xml_node@pugi@@QBE?AV12@PBD@Z ; pugi::xml_node::child
  00366	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
  0036c	8b 00		 mov	 eax, DWORD PTR [eax]
  0036e	89 85 20 ff ff
	ff		 mov	 DWORD PTR _RateNode$34[ebp], eax
  00374	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00379	85 c0		 test	 eax, eax
  0037b	0f 84 9f 01 00
	00		 je	 $LN6@Read
  00381	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL7@Read:

; 73   : 		{
; 74   : 			ItemUpgradeJewelsRateChangeInfo lpRate;
; 75   : 			lpRate.Type = RateNode.attribute("type").as_int((BYTE)-1);

  00390	68 ff 00 00 00	 push	 255			; 000000ffH
  00395	68 00 00 00 00	 push	 OFFSET ??_C@_04GPMDFGEJ@type?$AA@
  0039a	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  003a0	50		 push	 eax
  003a1	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
  003a7	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  003ac	8b c8		 mov	 ecx, eax
  003ae	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 76   : 			lpRate.Level = RateNode.attribute("level").as_int((BYTE)-1);

  003b3	68 ff 00 00 00	 push	 255			; 000000ffH
  003b8	88 85 f8 fe ff
	ff		 mov	 BYTE PTR _lpRate$32[ebp], al
  003be	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_05KJNJLLGA@level?$AA@
  003c9	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  003cf	50		 push	 eax
  003d0	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  003d5	8b c8		 mov	 ecx, eax
  003d7	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 77   : 			lpRate.Option = RateNode.attribute("option").as_int((BYTE)-1);

  003dc	68 ff 00 00 00	 push	 255			; 000000ffH
  003e1	88 85 f9 fe ff
	ff		 mov	 BYTE PTR _lpRate$32[ebp+1], al
  003e7	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
  003ed	68 00 00 00 00	 push	 OFFSET ??_C@_06OGMGCFPO@option?$AA@
  003f2	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  003fe	8b c8		 mov	 ecx, eax
  00400	e8 00 00 00 00	 call	 ?as_int@xml_attribute@pugi@@QBEHH@Z ; pugi::xml_attribute::as_int

; 78   : 			lpRate.RateIncrease = RateNode.attribute("increase").as_uint(0);

  00405	6a 00		 push	 0
  00407	88 85 fa fe ff
	ff		 mov	 BYTE PTR _lpRate$32[ebp+2], al
  0040d	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
  00413	68 00 00 00 00	 push	 OFFSET ??_C@_08EMJGLFCF@increase?$AA@
  00418	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  00424	8b c8		 mov	 ecx, eax
  00426	e8 00 00 00 00	 call	 ?as_uint@xml_attribute@pugi@@QBEII@Z ; pugi::xml_attribute::as_uint

; 79   : 			lpRate.RateDecrease = RateNode.attribute("decrease").as_uint(0);

  0042b	6a 00		 push	 0
  0042d	89 85 fc fe ff
	ff		 mov	 DWORD PTR _lpRate$32[ebp+4], eax
  00433	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
  00439	68 00 00 00 00	 push	 OFFSET ??_C@_08OALDEOCE@decrease?$AA@
  0043e	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00444	50		 push	 eax
  00445	e8 00 00 00 00	 call	 ?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z ; pugi::xml_node::attribute
  0044a	8b c8		 mov	 ecx, eax
  0044c	e8 00 00 00 00	 call	 ?as_uint@xml_attribute@pugi@@QBEII@Z ; pugi::xml_attribute::as_uint
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00451	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _lpRate$32[ebp]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 79   : 			lpRate.RateDecrease = RateNode.attribute("decrease").as_uint(0);

  00457	89 85 00 ff ff
	ff		 mov	 DWORD PTR _lpRate$32[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  0045d	3b cf		 cmp	 ecx, edi
  0045f	73 4d		 jae	 SHORT $LN432@Read
  00461	3b d9		 cmp	 ebx, ecx
  00463	77 49		 ja	 SHORT $LN432@Read

; 483  : 		}
; 484  : 
; 485  : 	pointer _Myfirst;	// pointer to beginning of array
; 486  : 	pointer _Mylast;	// pointer to current end of sequence
; 487  : 	pointer _Myend;	// pointer to end of array
; 488  : 	};
; 489  : 
; 490  : 		// TEMPLATE CLASS _Vector_alloc
; 491  : template<class _Alloc_types>
; 492  : 	class _Vector_alloc
; 493  : 	{	// base class for vector to hold allocator
; 494  : public:
; 495  : 	typedef _Vector_alloc<_Alloc_types> _Myt;
; 496  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 497  : 	typedef typename _Alloc_types::_Alty _Alty;
; 498  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 499  : 
; 500  : 	typedef typename _Val_types::value_type value_type;
; 501  : 	typedef typename _Val_types::size_type size_type;
; 502  : 	typedef typename _Val_types::difference_type difference_type;
; 503  : 	typedef typename _Val_types::pointer pointer;
; 504  : 	typedef typename _Val_types::const_pointer const_pointer;
; 505  : 	typedef typename _Val_types::reference reference;
; 506  : 	typedef typename _Val_types::const_reference const_reference;
; 507  : 
; 508  : 	typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
; 509  : 	typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;
; 510  : 
; 511  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 512  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 513  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 514  : 		{	// construct allocator from _Al
; 515  : 		}
; 516  : 
; 517  : 	_Vector_alloc(_Alloc&& _Al)
; 518  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 519  : 		{	// construct allocator from _Al
; 520  : 		}
; 521  : 
; 522  : 	void _Copy_alloc(const _Alty& _Al)
; 523  : 		{	// replace old allocator
; 524  : 		_Pocca(_Getal(), _Al);
; 525  : 		}
; 526  : 
; 527  : 	void _Move_alloc(_Alty& _Al)
; 528  : 		{	// replace old allocator
; 529  : 		_Pocma(_Getal(), _Al);
; 530  : 		}
; 531  : 
; 532  : 	void _Swap_alloc(_Myt& _Right)
; 533  : 		{	// swap allocators
; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}
; 536  : 
; 537  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 538  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 539  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 540  : 		{	// construct allocator from _Al
; 541  : 		_Alloc_proxy();
; 542  : 		}
; 543  : 
; 544  : 	_Vector_alloc(_Alloc&& _Al)
; 545  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 546  : 		{	// construct allocator from _Al
; 547  : 		_Alloc_proxy();
; 548  : 		}
; 549  : 
; 550  : 	~_Vector_alloc() _NOEXCEPT
; 551  : 		{	// destroy proxy
; 552  : 		_Free_proxy();
; 553  : 		}
; 554  : 
; 555  : 	void _Copy_alloc(const _Alty& _Al)
; 556  : 		{	// replace old allocator
; 557  : 		_Free_proxy();
; 558  : 		_Pocca(_Getal(), _Al);
; 559  : 		_Alloc_proxy();
; 560  : 		}
; 561  : 
; 562  : 	void _Move_alloc(_Alty& _Al)
; 563  : 		{	// replace old allocator
; 564  : 		_Free_proxy();
; 565  : 		_Pocma(_Getal(), _Al);
; 566  : 		_Alloc_proxy();
; 567  : 		}
; 568  : 
; 569  : 	void _Swap_alloc(_Myt& _Right)
; 570  : 		{	// swap allocators
; 571  : 		_Pocs(_Getal(), _Right._Getal());
; 572  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 573  : 		}
; 574  : 
; 575  : 	void _Alloc_proxy()
; 576  : 		{	// construct proxy
; 577  : 		typename _Alty::template rebind<_Container_proxy>::other
; 578  : 			_Alproxy(_Getal());
; 579  : 		_Myproxy() = _Alproxy.allocate(1);
; 580  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 581  : 		_Myproxy()->_Mycont = &_Get_data();
; 582  : 		}
; 583  : 
; 584  : 	void _Free_proxy()
; 585  : 		{	// destroy proxy
; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());
; 588  : 		_Orphan_all();
; 589  : 		_Alproxy.destroy(_Myproxy());
; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 591  : 		_Myproxy() = 0;
; 592  : 		}
; 593  : 
; 594  : 	_Iterator_base12 **_Getpfirst() const
; 595  : 		{	// get address of iterator chain
; 596  : 		return (_Get_data()._Getpfirst());
; 597  : 		}
; 598  : 
; 599  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 600  : 		{	// return reference to _Myproxy
; 601  : 		return (_Get_data()._Myproxy);
; 602  : 		}
; 603  : 
; 604  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 605  : 		{	// return const reference to _Myproxy
; 606  : 		return (_Get_data()._Myproxy);
; 607  : 		}
; 608  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 609  : 
; 610  : 	void _Orphan_all()
; 611  : 		{	// orphan all iterators
; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_all(_Myt& _Right)
; 616  : 		{	// swap all iterators
; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}
; 619  : 
; 620  : 	_Alty& _Getal() _NOEXCEPT
; 621  : 		{	// return reference to allocator
; 622  : 		return (_Mypair._Get_first());
; 623  : 		}
; 624  : 
; 625  : 	const _Alty& _Getal() const _NOEXCEPT
; 626  : 		{	// return const reference to allocator
; 627  : 		return (_Mypair._Get_first());
; 628  : 		}
; 629  : 
; 630  : 	_Vector_val<_Val_types>& _Get_data() _NOEXCEPT
; 631  : 		{	// return reference to _Vector_val
; 632  : 		return (_Mypair._Get_second());
; 633  : 		}
; 634  : 
; 635  : 	const _Vector_val<_Val_types>& _Get_data() const _NOEXCEPT
; 636  : 		{	// return const reference to _Vector_val
; 637  : 		return (_Mypair._Get_second());
; 638  : 		}
; 639  : 
; 640  : 	pointer& _Myfirst() _NOEXCEPT
; 641  : 		{	// return reference to _Myfirst
; 642  : 		return (_Get_data()._Myfirst);
; 643  : 		}
; 644  : 
; 645  : 	const pointer& _Myfirst() const _NOEXCEPT
; 646  : 		{	// return const reference to _Myfirst
; 647  : 		return (_Get_data()._Myfirst);
; 648  : 		}
; 649  : 
; 650  : 	pointer& _Mylast() _NOEXCEPT
; 651  : 		{	// return reference to _Mylast
; 652  : 		return (_Get_data()._Mylast);
; 653  : 		}
; 654  : 
; 655  : 	const pointer& _Mylast() const _NOEXCEPT
; 656  : 		{	// return const reference to _Mylast
; 657  : 		return (_Get_data()._Mylast);
; 658  : 		}
; 659  : 
; 660  : 	pointer& _Myend() _NOEXCEPT
; 661  : 		{	// return reference to _Myend
; 662  : 		return (_Get_data()._Myend);
; 663  : 		}
; 664  : 
; 665  : 	const pointer& _Myend() const _NOEXCEPT
; 666  : 		{	// return const reference to _Myend
; 667  : 		return (_Get_data()._Myend);
; 668  : 		}
; 669  : 
; 670  : private:
; 671  : 	_Compressed_pair<_Alty, _Vector_val<_Val_types> > _Mypair;
; 672  : 	};
; 673  : 
; 674  : 		// TEMPLATE CLASS vector
; 675  : template<class _Ty,
; 676  : 	class _Alloc = allocator<_Ty> >
; 677  : 	class vector
; 678  : 		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >
; 679  : 	{	// varying size array of values
; 680  : public:
; 681  : 	typedef vector<_Ty, _Alloc> _Myt;
; 682  : 	typedef _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 683  : 	typedef _Alloc allocator_type;
; 684  : 
; 685  : 	typedef typename _Mybase::_Alty _Alty;
; 686  : 
; 687  : 	typedef typename _Mybase::value_type value_type;
; 688  : 	typedef typename _Mybase::size_type size_type;
; 689  : 	typedef typename _Mybase::difference_type difference_type;
; 690  : 	typedef typename _Mybase::pointer pointer;
; 691  : 	typedef typename _Mybase::const_pointer const_pointer;
; 692  : 	typedef typename _Mybase::reference reference;
; 693  : 	typedef typename _Mybase::const_reference const_reference;
; 694  : 
; 695  :  #define _VICONT(it)	it._Getcont()
; 696  :  #define _VIPTR(it)	(it)._Ptr
; 697  : 
; 698  : 	typedef typename _Mybase::iterator iterator;
; 699  : 	typedef typename _Mybase::const_iterator const_iterator;
; 700  : 
; 701  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 702  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 703  : 
; 704  : 	vector() _NOEXCEPT
; 705  : 		: _Mybase()
; 706  : 		{	// construct empty vector
; 707  : 		}
; 708  : 
; 709  : 	explicit vector(const _Alloc& _Al) _NOEXCEPT
; 710  : 		: _Mybase(_Al)
; 711  : 		{	// construct empty vector, allocator
; 712  : 		}
; 713  : 
; 714  : 	explicit vector(size_type _Count)
; 715  : 		: _Mybase()
; 716  : 		{	// construct from _Count * value_type()
; 717  : 		if (_Buy(_Count))
; 718  : 			{	// nonzero, fill it
; 719  : 			_TRY_BEGIN
; 720  : 			_Uninitialized_default_fill_n(this->_Myfirst(), _Count,
; 721  : 				this->_Getal());
; 722  : 			this->_Mylast() += _Count;
; 723  : 			_CATCH_ALL
; 724  : 			_Tidy();
; 725  : 			_RERAISE;
; 726  : 			_CATCH_END
; 727  : 			}
; 728  : 		}
; 729  : 
; 730  : 	vector(size_type _Count, const value_type& _Val)
; 731  : 		: _Mybase()
; 732  : 		{	// construct from _Count * _Val
; 733  : 		_Construct_n(_Count, _STD addressof(_Val));
; 734  : 		}
; 735  : 
; 736  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 737  : 		: _Mybase(_Al)
; 738  : 		{	// construct from _Count * _Val, allocator
; 739  : 		_Construct_n(_Count, _STD addressof(_Val));
; 740  : 		}
; 741  : 
; 742  : 	vector(const _Myt& _Right)
; 743  : 
; 744  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 745  : 
; 746  : 
; 747  : 		{	// construct by copying _Right
; 748  : 		if (_Buy(_Right.size()))
; 749  : 			_TRY_BEGIN
; 750  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 751  : 				this->_Myfirst());
; 752  : 			_CATCH_ALL
; 753  : 			_Tidy();
; 754  : 			_RERAISE;
; 755  : 			_CATCH_END
; 756  : 		}
; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00465	2b cb		 sub	 ecx, ebx
  00467	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0046c	f7 e9		 imul	 ecx
  0046e	d1 fa		 sar	 edx, 1
  00470	8b f2		 mov	 esi, edx
  00472	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00475	03 f2		 add	 esi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00477	3b bd 1c ff ff
	ff		 cmp	 edi, DWORD PTR _lpItem$33[ebp+24]
  0047d	75 19		 jne	 SHORT $LN434@Read

; 1279 : 				_Reserve(1);

  0047f	6a 01		 push	 1
  00481	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _lpItem$33[ebp+16]
  00487	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reserve
  0048c	8b bd 18 ff ff
	ff		 mov	 edi, DWORD PTR _lpItem$33[ebp+20]
  00492	8b 9d 14 ff ff
	ff		 mov	 ebx, DWORD PTR _lpItem$33[ebp+16]
$LN434@Read:

; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),

  00498	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0049b	85 ff		 test	 edi, edi
  0049d	74 45		 je	 SHORT $LN635@Read
  0049f	f3 0f 7e 04 83	 movq	 xmm0, QWORD PTR [ebx+eax*4]
  004a4	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
  004a8	8b 44 83 08	 mov	 eax, DWORD PTR [ebx+eax*4+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 		else

  004ac	eb 33		 jmp	 SHORT $LN661@Read
$LN432@Read:

; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  004ae	3b fe		 cmp	 edi, esi
  004b0	75 1f		 jne	 SHORT $LN435@Read

; 1288 : 				_Reserve(1);

  004b2	6a 01		 push	 1
  004b4	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _lpItem$33[ebp+16]
  004ba	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reserve
  004bf	8b bd 18 ff ff
	ff		 mov	 edi, DWORD PTR _lpItem$33[ebp+20]
  004c5	8b 9d 14 ff ff
	ff		 mov	 ebx, DWORD PTR _lpItem$33[ebp+16]
  004cb	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _lpRate$32[ebp+8]
$LN435@Read:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  004d1	85 ff		 test	 edi, edi
  004d3	74 0f		 je	 SHORT $LN635@Read
  004d5	f3 0f 7e 85 f8
	fe ff ff	 movq	 xmm0, QWORD PTR _lpRate$32[ebp]
  004dd	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
$LN661@Read:
  004e1	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN635@Read:
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 72   : 		for( RateNode = Node.child("ratechange"); RateNode; RateNode = RateNode.next_sibling() )

  004e4	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  004ea	83 c7 0c	 add	 edi, 12			; 0000000cH
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 72   : 		for( RateNode = Node.child("ratechange"); RateNode; RateNode = RateNode.next_sibling() )

  004ed	50		 push	 eax
  004ee	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  004f4	89 bd 18 ff ff
	ff		 mov	 DWORD PTR _lpItem$33[ebp+20], edi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 72   : 		for( RateNode = Node.child("ratechange"); RateNode; RateNode = RateNode.next_sibling() )

  004fa	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  004ff	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _RateNode$34[ebp]
  00505	8b 00		 mov	 eax, DWORD PTR [eax]
  00507	89 85 20 ff ff
	ff		 mov	 DWORD PTR _RateNode$34[ebp], eax
  0050d	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00512	8b b5 1c ff ff
	ff		 mov	 esi, DWORD PTR _lpItem$33[ebp+24]
  00518	85 c0		 test	 eax, eax
  0051a	0f 85 70 fe ff
	ff		 jne	 $LL7@Read
$LN6@Read:

; 80   : 			lpItem.m_RateChangeRules.push_back(lpRate);
; 81   : 		}
; 82   : 
; 83   : 		this->m_UpradeInfo.push_back(lpItem);

  00520	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv1262[ebp]
  00526	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _lpItem$33[ebp]
  0052c	50		 push	 eax
  0052d	e8 00 00 00 00	 call	 ?push_back@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsInfo@@@Z ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::push_back

; 84   : 	}

  00532	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _lpItem$33[ebp]
  00538	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0053c	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  00541	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00547	50		 push	 eax
  00548	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  0054e	e8 00 00 00 00	 call	 ?next_sibling@xml_node@pugi@@QBE?AV12@XZ ; pugi::xml_node::next_sibling
  00553	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _Node$[ebp]
  00559	8b 00		 mov	 eax, DWORD PTR [eax]
  0055b	89 85 24 ff ff
	ff		 mov	 DWORD PTR _Node$[ebp], eax
  00561	e8 00 00 00 00	 call	 ??Bxml_node@pugi@@QBEP6AXPAPAPAV01@@ZXZ ; pugi::xml_node::operator void (__cdecl*)(pugi::xml_node * * *)
  00566	85 c0		 test	 eax, eax
  00568	0f 85 67 fb ff
	ff		 jne	 $LL4@Read
$LN3@Read:

; 85   : }

  0056e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00574	e8 00 00 00 00	 call	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
  00579	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0057c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00583	59		 pop	 ecx
  00584	5f		 pop	 edi
  00585	5e		 pop	 esi
  00586	5b		 pop	 ebx
  00587	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0058a	33 cd		 xor	 ecx, ebp
  0058c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00591	8b e5		 mov	 esp, ebp
  00593	5d		 pop	 ebp
  00594	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@ItemUpgradeJewels@@QAEXPAD@Z$0:
  00000	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _Document$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1xml_document@pugi@@QAE@XZ ; pugi::xml_document::~xml_document
__unwindfunclet$?Read@ItemUpgradeJewels@@QAEXPAD@Z$1:
  0000b	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _lpItem$33[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
__ehhandler$?Read@ItemUpgradeJewels@@QAEXPAD@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 6c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-404]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Read@ItemUpgradeJewels@@QAEXPAD@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Read@ItemUpgradeJewels@@QAEXPAD@Z ENDP			; ItemUpgradeJewels::Read
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?Load@ItemUpgradeJewels@@QAEXXZ
_TEXT	SEGMENT
?Load@ItemUpgradeJewels@@QAEXXZ PROC			; ItemUpgradeJewels::Load, COMDAT
; _this$ = ecx

; 31   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 32   : 	this->Init();

  00003	e8 00 00 00 00	 call	 ?Init@ItemUpgradeJewels@@QAEXXZ ; ItemUpgradeJewels::Init

; 33   : 	this->Read(gDirPath.GetNewPath(FILE_ITEM_UPGRADE_JEWELS));

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BDIDLPMO@Item?2ItemUpgradeJewels?4xml?$AA@
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00012	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00017	50		 push	 eax
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?Read@ItemUpgradeJewels@@QAEXPAD@Z ; ItemUpgradeJewels::Read
  0001f	5e		 pop	 esi

; 34   : }

  00020	c3		 ret	 0
?Load@ItemUpgradeJewels@@QAEXXZ ENDP			; ItemUpgradeJewels::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?Init@ItemUpgradeJewels@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?Init@ItemUpgradeJewels@@QAEXXZ PROC			; ItemUpgradeJewels::Init, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());

  00007	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 171  : 	for (; _First != _Last; ++_First)

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	57		 push	 edi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 23   : 	this->m_UpradeInfo.clear();

  0000f	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 171  : 	for (; _First != _Last; ++_First)

  00012	3b f3		 cmp	 esi, ebx
  00014	74 0e		 je	 SHORT $LN40@Init
$LL41@Init:
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  0001d	83 c6 1c	 add	 esi, 28			; 0000001cH
  00020	3b f3		 cmp	 esi, ebx
  00022	75 f2		 jne	 SHORT $LL41@Init
$LN40@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00024	8b 07		 mov	 eax, DWORD PTR [edi]
  00026	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00029	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0002e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00031	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00033	f7 e9		 imul	 ecx
  00035	03 d1		 add	 edx, ecx
  00037	c1 fa 04	 sar	 edx, 4
  0003a	8b c2		 mov	 eax, edx
  0003c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003f	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 24   : 	if( this->m_UpradeInfo.capacity() > 0 )

  00041	74 49		 je	 SHORT $LN340@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1549 : 		if (this == &_Right)

  00043	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]

; 480  : 		_Myfirst = pointer();

  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 481  : 		_Mylast = pointer();

  0004d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], 0

; 482  : 		_Myend = pointer();

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+8], 0

; 1549 : 		if (this == &_Right)

  0005b	3b c7		 cmp	 eax, edi
  0005d	74 25		 je	 SHORT $LN119@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0005f	8b 07		 mov	 eax, DWORD PTR [edi]

; 54   : 	_Right = _Move(_Tmp);

  00061	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00067	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 53   : 	_Left = _Move(_Right);

  0006a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 54   : 	_Right = _Move(_Tmp);

  0006d	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00074	89 45 f8	 mov	 DWORD PTR $T1[ebp+4], eax

; 53   : 	_Left = _Move(_Right);

  00077	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007a	89 45 fc	 mov	 DWORD PTR $T1[ebp+8], eax

; 54   : 	_Right = _Move(_Tmp);

  0007d	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN119@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 975  : 		_Tidy();

  00084	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00087	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXXZ ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Tidy
$LN340@Init:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 28   : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?Init@ItemUpgradeJewels@@QAEXXZ ENDP			; ItemUpgradeJewels::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ??1ItemUpgradeJewels@@UAE@XZ
_TEXT	SEGMENT
??1ItemUpgradeJewels@@UAE@XZ PROC			; ItemUpgradeJewels::~ItemUpgradeJewels, COMDAT
; _this$ = ecx

; 17   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ItemUpgradeJewels@@6B@

; 19   : }

  00006	83 c1 04	 add	 ecx, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 975  : 		_Tidy();

  00009	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UItemUpgradeJewelsInfo@@V?$allocator@UItemUpgradeJewelsInfo@@@std@@@std@@IAEXXZ ; std::vector<ItemUpgradeJewelsInfo,std::allocator<ItemUpgradeJewelsInfo> >::_Tidy
??1ItemUpgradeJewels@@UAE@XZ ENDP			; ItemUpgradeJewels::~ItemUpgradeJewels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ??0ItemUpgradeJewels@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ItemUpgradeJewels@@QAE@XZ PROC			; ItemUpgradeJewels::ItemUpgradeJewels, COMDAT
; _this$ = ecx

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ItemUpgradeJewels@@6B@

; 14   : }

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 481  : 		_Mylast = pointer();

  00016	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 482  : 		_Myend = pointer();

  0001d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp

; 14   : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0ItemUpgradeJewels@@QAE@XZ ENDP			; ItemUpgradeJewels::ItemUpgradeJewels
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GItemUpgradeJewelsInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GItemUpgradeJewelsInfo@@QAEPAXI@Z PROC		; ItemUpgradeJewelsInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1ItemUpgradeJewelsInfo@@QAE@XZ ; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 1c		 push	 28			; 0000001cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GItemUpgradeJewelsInfo@@QAEPAXI@Z ENDP		; ItemUpgradeJewelsInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z PROC		; ItemUpgradeJewelsInfo::ItemUpgradeJewelsInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00010	66 89 06	 mov	 WORD PTR [esi], ax
  00013	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00016	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0001a	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  0001e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00024	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  00028	88 46 08	 mov	 BYTE PTR [esi+8], al
  0002b	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  0002f	88 46 09	 mov	 BYTE PTR [esi+9], al
  00032	0f b6 42 0a	 movzx	 eax, BYTE PTR [edx+10]
  00036	88 46 0a	 mov	 BYTE PTR [esi+10], al
  00039	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  0003d	88 46 0b	 mov	 BYTE PTR [esi+11], al
  00040	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00044	88 46 0c	 mov	 BYTE PTR [esi+12], al
  00047	0f b6 42 0d	 movzx	 eax, BYTE PTR [edx+13]
  0004b	88 46 0d	 mov	 BYTE PTR [esi+13], al
  0004e	8d 42 10	 lea	 eax, DWORD PTR [edx+16]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??0ItemUpgradeJewelsInfo@@QAE@ABU0@@Z ENDP		; ItemUpgradeJewelsInfo::ItemUpgradeJewelsInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0ItemUpgradeJewelsInfo@@QAE@XZ
_TEXT	SEGMENT
??0ItemUpgradeJewelsInfo@@QAE@XZ PROC			; ItemUpgradeJewelsInfo::ItemUpgradeJewelsInfo, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00007	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 482  : 		_Myend = pointer();

  00010	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00017	c3		 ret	 0
??0ItemUpgradeJewelsInfo@@QAE@XZ ENDP			; ItemUpgradeJewelsInfo::ItemUpgradeJewelsInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h
;	COMDAT ??1ItemUpgradeJewelsInfo@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
??1ItemUpgradeJewelsInfo@@QAE@XZ PROC			; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo, COMDAT
; _this$ = ecx

; 37   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h

; 37   : 	{

  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00009	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	56		 push	 esi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h

; 38   : 		this->m_RateChangeRules.clear();

  00012	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00015	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00018	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0001a	f7 e9		 imul	 ecx
  0001c	57		 push	 edi
  0001d	d1 fa		 sar	 edx, 1
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h

; 39   : 		if( this->m_RateChangeRules.capacity() > 0 )

  00026	74 40		 je	 SHORT $LN309@ItemUpgrad
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1549 : 		if (this == &_Right)

  00028	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0002b	3b c6		 cmp	 eax, esi
  0002d	74 39		 je	 SHORT $LN309@ItemUpgrad
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 54   : 	_Right = _Move(_Tmp);

  00031	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 53   : 	_Left = _Move(_Right);

  0003e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 54   : 	_Right = _Move(_Tmp);

  00041	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00048	85 c9		 test	 ecx, ecx
  0004a	74 1c		 je	 SHORT $LN309@ItemUpgrad

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0004c	2b d1		 sub	 edx, ecx
  0004e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00053	f7 ea		 imul	 edx
  00055	d1 fa		 sar	 edx, 1
  00057	8b c2		 mov	 eax, edx
  00059	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005c	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0005e	50		 push	 eax
  0005f	51		 push	 ecx
  00060	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00063	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
$LN309@ItemUpgrad:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00068	8b 3e		 mov	 edi, DWORD PTR [esi]
  0006a	85 ff		 test	 edi, edi
  0006c	74 32		 je	 SHORT $LN404@ItemUpgrad

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0006e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00071	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00076	2b cf		 sub	 ecx, edi
  00078	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0007a	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0007c	d1 fa		 sar	 edx, 1
  0007e	8b c2		 mov	 eax, edx
  00080	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00083	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00085	50		 push	 eax
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  0008c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00092	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00099	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN404@ItemUpgrad:
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h

; 43   : 	}

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
??1ItemUpgradeJewelsInfo@@QAE@XZ ENDP			; ItemUpgradeJewelsInfo::~ItemUpgradeJewelsInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEXPAUItemUpgradeJewelsRateChangeInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEXPAUItemUpgradeJewelsRateChangeInfo@@0@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEXPAUItemUpgradeJewelsRateChangeInfo@@0@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 32		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	d1 fa		 sar	 edx, 1
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00034	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0003b	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0003c	c3		 ret	 0
?_Tidy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv202 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 1646 : 		if (_Unused_capacity() < _Count)

  0000d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00010	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00013	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	d1 fa		 sar	 edx, 1
  0001c	8b c2		 mov	 eax, edx
  0001e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00021	03 c2		 add	 eax, edx

; 1646 : 		if (_Unused_capacity() < _Count)

  00023	3b c7		 cmp	 eax, edi
  00025	73 5f		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00027	8b 03		 mov	 eax, DWORD PTR [ebx]
  00029	2b f0		 sub	 esi, eax
  0002b	89 45 08	 mov	 DWORD PTR tv202[ebp], eax
  0002e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00033	f7 ee		 imul	 esi

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00035	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003a	d1 fa		 sar	 edx, 1
  0003c	8b ca		 mov	 ecx, edx
  0003e	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00041	03 ca		 add	 ecx, edx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00043	2b c1		 sub	 eax, ecx
  00045	3b c7		 cmp	 eax, edi
  00047	72 44		 jb	 SHORT $LN134@Reserve

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00049	03 f9		 add	 edi, ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0004b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00050	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00053	2b 4d 08	 sub	 ecx, DWORD PTR tv202[ebp]
  00056	f7 e9		 imul	 ecx
  00058	d1 fa		 sar	 edx, 1
  0005a	8b f2		 mov	 esi, edx
  0005c	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0005f	03 f2		 add	 esi, edx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00061	ba 55 55 55 15	 mov	 edx, 357913941		; 15555555H
  00066	8b c6		 mov	 eax, esi
  00068	d1 e8		 shr	 eax, 1
  0006a	2b d0		 sub	 edx, eax
  0006c	3b d6		 cmp	 edx, esi
  0006e	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00071	b8 00 00 00 00	 mov	 eax, 0
  00076	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00079	3b cf		 cmp	 ecx, edi
  0007b	0f 42 cf	 cmovb	 ecx, edi

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0007e	51		 push	 ecx
  0007f	8b cb		 mov	 ecx, ebx
  00081	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reallocate
$LN2@Reserve:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 1651 : 			}
; 1652 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00092	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  00097	cc		 int	 3
?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	8b f8		 mov	 edi, eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00044	6a 00		 push	 0
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	ff 76 04	 push	 DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0004b	89 7d ec	 mov	 DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004e	ff 36		 push	 DWORD PTR [esi]
  00050	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@U1@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemUpgradeJewelsRateChangeInfo *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo>,ItemUpgradeJewelsRateChangeInfo>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00055	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00058	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005d	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0005f	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00062	f7 e9		 imul	 ecx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00064	8b 06		 mov	 eax, DWORD PTR [esi]

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00066	d1 fa		 sar	 edx, 1
  00068	8b da		 mov	 ebx, edx
  0006a	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0006d	03 da		 add	 ebx, edx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  0006f	85 c0		 test	 eax, eax
  00071	74 1f		 je	 SHORT $LN3@Reallocate

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00073	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00076	2b c8		 sub	 ecx, eax
  00078	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007d	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0007f	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00081	d1 fa		 sar	 edx, 1
  00083	8b c2		 mov	 eax, edx
  00085	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00088	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0008a	50		 push	 eax
  0008b	ff 36		 push	 DWORD PTR [esi]
  0008d	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1639 : 		this->_Myend() = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00098	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  0009b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  0009e	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  000a1	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  000a4	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  000a7	89 3e		 mov	 DWORD PTR [esi], edi

; 1642 : 		}

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000bd	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000c0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000c6	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1627 : 		_RERAISE;

  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN179@Reallocate:
$LN178@Reallocate:
  000d4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBE_NPBUItemUpgradeJewelsRateChangeInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBE_NPBUItemUpgradeJewelsRateChangeInfo@@@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBE_NPBUItemUpgradeJewelsRateChangeInfo@@@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0000d	b9 55 55 55 15	 mov	 ecx, 357913941		; 15555555H

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00012	f7 ea		 imul	 edx
  00014	56		 push	 esi
  00015	d1 fa		 sar	 edx, 1
  00017	8b f2		 mov	 esi, edx
  00019	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001c	03 f2		 add	 esi, edx

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001e	8b c6		 mov	 eax, esi
  00020	d1 e8		 shr	 eax, 1
  00022	57		 push	 edi
  00023	2b c8		 sub	 ecx, eax
  00025	33 ff		 xor	 edi, edi
  00027	3b ce		 cmp	 ecx, esi
  00029	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0002c	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  0002f	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00032	5f		 pop	 edi
  00033	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  00037	8b c2		 mov	 eax, edx
  00039	5e		 pop	 esi

; 1612 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?_Grow_to@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXPAUItemUpgradeJewelsRateChangeInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXPAUItemUpgradeJewelsRateChangeInfo@@0@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXPAUItemUpgradeJewelsRateChangeInfo@@0@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAE_NI@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Buy, COMDAT
; _this$ = ecx

; 1580 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1586 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 1596 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1587 : 		else if (max_size() < _Capacity)

  0002a	81 ff 55 55 55
	15		 cmp	 edi, 357913941		; 15555555H
  00030	77 1e		 ja	 SHORT $LN109@Buy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00038	89 06		 mov	 DWORD PTR [esi], eax

; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  0003a	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  0003d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	5f		 pop	 edi
  00043	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00046	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1594 : 			}
; 1595 : 		return (true);

  00049	b0 01		 mov	 al, 1
  0004b	5e		 pop	 esi

; 1596 : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
$LN109@Buy:

; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00055	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Buy:
$LN108@Buy:
  0005a	cc		 int	 3
?_Buy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?swap@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXAAV12@@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::swap, COMDAT
; _this$ = ecx

; 1548 : 		{	// exchange contents with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1549 : 		if (this == &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 20		 je	 SHORT $LN7@swap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 16		 mov	 edx, DWORD PTR [esi]
  00012	89 06		 mov	 DWORD PTR [esi], eax

; 54   : 	_Right = _Move(_Tmp);

  00014	89 17		 mov	 DWORD PTR [edi], edx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00019	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0001f	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00022	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 53   : 	_Left = _Move(_Right);

  00025	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 	_Right = _Move(_Tmp);

  0002b	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
$LN7@swap:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1576 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?swap@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1543 : 		}

  00005	c3		 ret	 0
?clear@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsRateChangeInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsRateChangeInfo@@@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4c		 jae	 SHORT $LN2@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 46		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	d1 fa		 sar	 edx, 1
  00022	8b fa		 mov	 edi, edx
  00024	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00027	03 fa		 add	 edi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  00029	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002c	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  0002e	6a 01		 push	 1
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	85 d2		 test	 edx, edx
  0003c	74 42		 je	 SHORT $LN205@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00043	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00044	f3 0f 7e 04 88	 movq	 xmm0, QWORD PTR [eax+ecx*4]
  00049	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  0004d	8b 44 88 08	 mov	 eax, DWORD PTR [eax+ecx*4+8]
  00051	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00054	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00058	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN2@push_back:

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  0005d	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00060	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  00062	6a 01		 push	 1
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0006b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006e	85 c9		 test	 ecx, ecx
  00070	74 0e		 je	 SHORT $LN205@push_back
  00072	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00076	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0007a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN205@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00080	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?push_back@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXABUItemUpgradeJewelsRateChangeInfo@@@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEAAUItemUpgradeJewelsRateChangeInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEAAUItemUpgradeJewelsRateChangeInfo@@I@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::operator[], COMDAT
; _this$ = ecx

; 1228 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1241 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEAAUItemUpgradeJewelsRateChangeInfo@@I@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1180 : 		}

  00015	c3		 ret	 0
?size@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@2@XZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::end, COMDAT
; _this$ = ecx

; 1071 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@2@XZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::begin, COMDAT
; _this$ = ecx

; 1061 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	d1 fa		 sar	 edx, 1
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1048 : 		}

  00016	c3		 ret	 0
?_Unused_capacity@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1043 : 		}

  00015	c3		 ret	 0
?capacity@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::~vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 32		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	d1 fa		 sar	 edx, 1
  00017	8b c2		 mov	 eax, edx
  00019	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001c	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00034	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0003b	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0003c	c3		 ret	 0
??1?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::~vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Right$ = 8						; size = 4
??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT
; _this$ = ecx

; 747  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 483  : 		}
; 484  : 
; 485  : 	pointer _Myfirst;	// pointer to beginning of array
; 486  : 	pointer _Mylast;	// pointer to current end of sequence
; 487  : 	pointer _Myend;	// pointer to end of array
; 488  : 	};
; 489  : 
; 490  : 		// TEMPLATE CLASS _Vector_alloc
; 491  : template<class _Alloc_types>
; 492  : 	class _Vector_alloc
; 493  : 	{	// base class for vector to hold allocator
; 494  : public:
; 495  : 	typedef _Vector_alloc<_Alloc_types> _Myt;
; 496  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 497  : 	typedef typename _Alloc_types::_Alty _Alty;
; 498  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 499  : 
; 500  : 	typedef typename _Val_types::value_type value_type;
; 501  : 	typedef typename _Val_types::size_type size_type;
; 502  : 	typedef typename _Val_types::difference_type difference_type;
; 503  : 	typedef typename _Val_types::pointer pointer;
; 504  : 	typedef typename _Val_types::const_pointer const_pointer;
; 505  : 	typedef typename _Val_types::reference reference;
; 506  : 	typedef typename _Val_types::const_reference const_reference;
; 507  : 
; 508  : 	typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
; 509  : 	typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;
; 510  : 
; 511  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 512  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 513  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 514  : 		{	// construct allocator from _Al
; 515  : 		}
; 516  : 
; 517  : 	_Vector_alloc(_Alloc&& _Al)
; 518  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 519  : 		{	// construct allocator from _Al
; 520  : 		}
; 521  : 
; 522  : 	void _Copy_alloc(const _Alty& _Al)
; 523  : 		{	// replace old allocator
; 524  : 		_Pocca(_Getal(), _Al);
; 525  : 		}
; 526  : 
; 527  : 	void _Move_alloc(_Alty& _Al)
; 528  : 		{	// replace old allocator
; 529  : 		_Pocma(_Getal(), _Al);
; 530  : 		}
; 531  : 
; 532  : 	void _Swap_alloc(_Myt& _Right)
; 533  : 		{	// swap allocators
; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}
; 536  : 
; 537  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 538  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 539  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 540  : 		{	// construct allocator from _Al
; 541  : 		_Alloc_proxy();
; 542  : 		}
; 543  : 
; 544  : 	_Vector_alloc(_Alloc&& _Al)
; 545  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 546  : 		{	// construct allocator from _Al
; 547  : 		_Alloc_proxy();
; 548  : 		}
; 549  : 
; 550  : 	~_Vector_alloc() _NOEXCEPT
; 551  : 		{	// destroy proxy
; 552  : 		_Free_proxy();
; 553  : 		}
; 554  : 
; 555  : 	void _Copy_alloc(const _Alty& _Al)
; 556  : 		{	// replace old allocator
; 557  : 		_Free_proxy();
; 558  : 		_Pocca(_Getal(), _Al);
; 559  : 		_Alloc_proxy();
; 560  : 		}
; 561  : 
; 562  : 	void _Move_alloc(_Alty& _Al)
; 563  : 		{	// replace old allocator
; 564  : 		_Free_proxy();
; 565  : 		_Pocma(_Getal(), _Al);
; 566  : 		_Alloc_proxy();
; 567  : 		}
; 568  : 
; 569  : 	void _Swap_alloc(_Myt& _Right)
; 570  : 		{	// swap allocators
; 571  : 		_Pocs(_Getal(), _Right._Getal());
; 572  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 573  : 		}
; 574  : 
; 575  : 	void _Alloc_proxy()
; 576  : 		{	// construct proxy
; 577  : 		typename _Alty::template rebind<_Container_proxy>::other
; 578  : 			_Alproxy(_Getal());
; 579  : 		_Myproxy() = _Alproxy.allocate(1);
; 580  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 581  : 		_Myproxy()->_Mycont = &_Get_data();
; 582  : 		}
; 583  : 
; 584  : 	void _Free_proxy()
; 585  : 		{	// destroy proxy
; 586  : 		typename _Alty::template rebind<_Container_proxy>::other
; 587  : 			_Alproxy(_Getal());
; 588  : 		_Orphan_all();
; 589  : 		_Alproxy.destroy(_Myproxy());
; 590  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 591  : 		_Myproxy() = 0;
; 592  : 		}
; 593  : 
; 594  : 	_Iterator_base12 **_Getpfirst() const
; 595  : 		{	// get address of iterator chain
; 596  : 		return (_Get_data()._Getpfirst());
; 597  : 		}
; 598  : 
; 599  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 600  : 		{	// return reference to _Myproxy
; 601  : 		return (_Get_data()._Myproxy);
; 602  : 		}
; 603  : 
; 604  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 605  : 		{	// return const reference to _Myproxy
; 606  : 		return (_Get_data()._Myproxy);
; 607  : 		}
; 608  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 609  : 
; 610  : 	void _Orphan_all()
; 611  : 		{	// orphan all iterators
; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_all(_Myt& _Right)
; 616  : 		{	// swap all iterators
; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}
; 619  : 
; 620  : 	_Alty& _Getal() _NOEXCEPT
; 621  : 		{	// return reference to allocator
; 622  : 		return (_Mypair._Get_first());
; 623  : 		}
; 624  : 
; 625  : 	const _Alty& _Getal() const _NOEXCEPT
; 626  : 		{	// return const reference to allocator
; 627  : 		return (_Mypair._Get_first());
; 628  : 		}
; 629  : 
; 630  : 	_Vector_val<_Val_types>& _Get_data() _NOEXCEPT
; 631  : 		{	// return reference to _Vector_val
; 632  : 		return (_Mypair._Get_second());
; 633  : 		}
; 634  : 
; 635  : 	const _Vector_val<_Val_types>& _Get_data() const _NOEXCEPT
; 636  : 		{	// return const reference to _Vector_val
; 637  : 		return (_Mypair._Get_second());
; 638  : 		}
; 639  : 
; 640  : 	pointer& _Myfirst() _NOEXCEPT
; 641  : 		{	// return reference to _Myfirst
; 642  : 		return (_Get_data()._Myfirst);
; 643  : 		}
; 644  : 
; 645  : 	const pointer& _Myfirst() const _NOEXCEPT
; 646  : 		{	// return const reference to _Myfirst
; 647  : 		return (_Get_data()._Myfirst);
; 648  : 		}
; 649  : 
; 650  : 	pointer& _Mylast() _NOEXCEPT
; 651  : 		{	// return reference to _Mylast
; 652  : 		return (_Get_data()._Mylast);
; 653  : 		}
; 654  : 
; 655  : 	const pointer& _Mylast() const _NOEXCEPT
; 656  : 		{	// return const reference to _Mylast
; 657  : 		return (_Get_data()._Mylast);

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00033	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH

; 480  : 		_Myfirst = pointer();

  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 481  : 		_Mylast = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 482  : 		_Myend = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0004c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0004f	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00051	f7 e9		 imul	 ecx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();

  00053	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00059	d1 fa		 sar	 edx, 1
  0005b	8b fa		 mov	 edi, edx

; 1582 : 		this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00064	c1 ef 1f	 shr	 edi, 31			; 0000001fH

; 1583 : 		this->_Myend() = pointer();

  00067	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 757  : 
; 758  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 759  : 		: _Mybase(_Al)
; 760  : 		{	// construct by copying _Right, allocator
; 761  : 		if (_Buy(_Right.size()))
; 762  : 			_TRY_BEGIN
; 763  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
; 764  : 				this->_Myfirst());
; 765  : 			_CATCH_ALL
; 766  : 			_Tidy();
; 767  : 			_RERAISE;
; 768  : 			_CATCH_END
; 769  : 		}
; 770  : 
; 771  : 	template<class _Iter,
; 772  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 773  : 			void>::type>
; 774  : 		vector(_Iter _First, _Iter _Last)
; 775  : 		: _Mybase()
; 776  : 		{	// construct from [_First, _Last)
; 777  : 		_Construct(_First, _Last);
; 778  : 		}
; 779  : 
; 780  : 	template<class _Iter,
; 781  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 782  : 			void>::type>
; 783  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 784  : 		: _Mybase(_Al)
; 785  : 		{	// construct from [_First, _Last) with allocator
; 786  : 		_Construct(_First, _Last);
; 787  : 		}
; 788  : 
; 789  : 	template<class _Iter>
; 790  : 		void _Construct(_Iter _First, _Iter _Last)
; 791  : 		{	// initialize with [_First, _Last)
; 792  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 793  : 		}
; 794  : 
; 795  : 	template<class _Iter>
; 796  : 		void _Construct(_Iter _First, _Iter _Last,
; 797  : 			input_iterator_tag)
; 798  : 		{	// initialize with [_First, _Last), input iterators
; 799  : 		_TRY_BEGIN
; 800  : 
; 801  : 		for (; _First != _Last; ++_First)
; 802  : 			emplace_back(*_First);
; 803  : 
; 804  : 		_CATCH_ALL
; 805  : 		_Tidy();
; 806  : 		_RERAISE;
; 807  : 		_CATCH_END
; 808  : 		}
; 809  : 
; 810  : 	template<class _Iter>
; 811  : 		void _Construct(_Iter _First, _Iter _Last,
; 812  : 			forward_iterator_tag)
; 813  : 		{	// initialize with [_First, _Last), forward iterators
; 814  : 		if (_Buy(_STD distance(_First, _Last)))
; 815  : 			{	// nonzero, fill it
; 816  : 			_TRY_BEGIN
; 817  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 818  : 			_CATCH_ALL
; 819  : 			_Tidy();
; 820  : 			_RERAISE;
; 821  : 			_CATCH_END
; 822  : 			}
; 823  : 		}
; 824  : 
; 825  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 826  : 		{	// construct from _Count * *_Pval
; 827  : 		if (_Buy(_Count))
; 828  : 			{	// nonzero, fill it
; 829  : 			_TRY_BEGIN
; 830  : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
; 831  : 			_CATCH_ALL
; 832  : 			_Tidy();
; 833  : 			_RERAISE;
; 834  : 			_CATCH_END
; 835  : 			}
; 836  : 		}
; 837  : 
; 838  : 	vector(_Myt&& _Right) _NOEXCEPT
; 839  : 		: _Mybase(_STD move(_Right._Getal()))
; 840  : 		{	// construct by moving _Right
; 841  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 842  : 		}
; 843  : 
; 844  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 845  : 		: _Mybase(_Al)
; 846  : 		{	// construct by moving _Right, allocator
; 847  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 848  : 		}
; 849  : 
; 850  : 	_Myt& operator=(_Myt&& _Right)
; 851  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 852  : 			|| _Alty::is_always_equal::value)
; 853  : 		{	// assign by moving _Right
; 854  : 		if (this != &_Right)
; 855  : 			{	// different, assign it
; 856  : 			_Tidy();
; 857  : 			if (_Alty::propagate_on_container_move_assignment::value
; 858  : 				&& this->_Getal() != _Right._Getal())
; 859  : 				this->_Move_alloc(_Right._Getal());
; 860  : 
; 861  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 862  : 			}
; 863  : 		return (*this);
; 864  : 		}
; 865  : 
; 866  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 867  : 		{	// move from _Right, stealing its contents
; 868  : 		this->_Swap_all((_Myt&)_Right);
; 869  : 		this->_Myfirst() = _Right._Myfirst();
; 870  : 		this->_Mylast() = _Right._Mylast();
; 871  : 		this->_Myend() = _Right._Myend();
; 872  : 
; 873  : 		_Right._Myfirst() = pointer();
; 874  : 		_Right._Mylast() = pointer();
; 875  : 		_Right._Myend() = pointer();
; 876  : 		}
; 877  : 
; 878  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 879  : 		{	// move from _Right, possibly moving its contents
; 880  : 		if (get_allocator() == _Right.get_allocator())
; 881  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 882  : 		else
; 883  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 884  : 				_STD make_move_iterator(_Right.end()));
; 885  : 		}
; 886  : 
; 887  : 	void _Assign_rv(_Myt&& _Right)
; 888  : 		{	// assign by moving _Right
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 890  : 			typename _Alty::propagate_on_container_move_assignment());
; 891  : 		}
; 892  : 
; 893  : 
; 894  : 	void push_back(value_type&& _Val)
; 895  : 		{	// insert by moving into element at end
; 896  : 		if (_Inside(_STD addressof(_Val)))
; 897  : 			{	// push back an element
; 898  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 899  : 			if (this->_Mylast() == this->_Myend())
; 900  : 				_Reserve(1);
; 901  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 902  : 			this->_Getal().construct(this->_Mylast(),
; 903  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 904  : 			++this->_Mylast();
; 905  : 			}
; 906  : 		else
; 907  : 			{	// push back a non-element
; 908  : 			if (this->_Mylast() == this->_Myend())
; 909  : 				_Reserve(1);
; 910  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 911  : 			this->_Getal().construct(this->_Mylast(),
; 912  : 				_STD forward<value_type>(_Val));
; 913  : 			++this->_Mylast();
; 914  : 			}
; 915  : 		}
; 916  : 
; 917  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 918  : 		{	// insert by moving _Val at _Where
; 919  : 		return (emplace(_Where, _STD move(_Val)));
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		void emplace_back(_Valty&&... _Val)
; 924  : 		{	// insert by moving into element at end
; 925  : 		if (this->_Mylast() == this->_Myend())
; 926  : 			_Reserve(1);
; 927  : 		_Orphan_range(this->_Mylast(), this->_Mylast());
; 928  : 		this->_Getal().construct(this->_Mylast(),
; 929  : 			_STD forward<_Valty>(_Val)...);
; 930  : 		++this->_Mylast();
; 931  : 		}
; 932  : 
; 933  : 	template<class... _Valty>
; 934  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 935  : 		{	// insert by moving _Val at _Where
; 936  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 937  : 
; 938  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 939  : 		if (size() < _Off)
; 940  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 941  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 942  : 
; 943  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 944  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 945  : 		return (begin() + _Off);
; 946  : 		}
; 947  : 
; 948  : 
; 949  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Construct(_Ilist.begin(), _Ilist.end());
; 954  : 		}
; 955  : 
; 956  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 957  : 		{	// assign initializer_list
; 958  : 		assign(_Ilist.begin(), _Ilist.end());
; 959  : 		return (*this);
; 960  : 		}
; 961  : 
; 962  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 963  : 		{	// assign initializer_list
; 964  : 		assign(_Ilist.begin(), _Ilist.end());
; 965  : 		}
; 966  : 
; 967  : 	iterator insert(const_iterator _Where,
; 968  : 		_XSTD initializer_list<value_type> _Ilist)
; 969  : 		{	// insert initializer_list
; 970  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 971  : 		}
; 972  : 
; 973  : 	~vector() _NOEXCEPT
; 974  : 		{	// destroy the object
; 975  : 		_Tidy();
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0006e	03 fa		 add	 edi, edx

; 1584 : 
; 1585 : 		if (_Capacity == 0)

  00070	74 47		 je	 SHORT $LN7@vector

; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)

  00072	81 ff 55 55 55
	15		 cmp	 edi, 357913941		; 15555555H
  00078	76 0a		 jbe	 SHORT $LN58@vector

; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0007f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN254@vector:
$LN58@vector:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00084	57		 push	 edi
  00085	8b ce		 mov	 ecx, esi
  00087	e8 00 00 00 00	 call	 ?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  0008c	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  0008f	89 06		 mov	 DWORD PTR [esi], eax

; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  00091	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00094	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  00099	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 749  : 			_TRY_BEGIN

  0009a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  000a1	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000a4	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,

  000a7	ff 36		 push	 DWORD PTR [esi]
  000a9	ff 73 04	 push	 DWORD PTR [ebx+4]
  000ac	ff 33		 push	 DWORD PTR [ebx]
  000ae	e8 00 00 00 00	 call	 ??$_Uninit_copy@PBUItemUpgradeJewelsRateChangeInfo@@PAU1@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@YAPAUItemUpgradeJewelsRateChangeInfo@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<ItemUpgradeJewelsRateChangeInfo const *,ItemUpgradeJewelsRateChangeInfo *,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 750  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

  000b6	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@vector:

; 755  : 			_CATCH_END
; 756  : 		}

  000b9	8b c6		 mov	 eax, esi
  000bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c5	59		 pop	 ecx
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
__catch$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z$0:

; 751  : 				this->_Myfirst());
; 752  : 			_CATCH_ALL
; 753  : 			_Tidy();

  000cf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@IAEXXZ ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Tidy

; 754  : 			_RERAISE;

  000d7	6a 00		 push	 0
  000d9	6a 00		 push	 0
  000db	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN255@vector:
$LN253@vector:
  000e0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >::vector<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >,std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >::_Vector_val<std::_Simple_types<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABQAUItemUpgradeJewelsRateChangeInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAPAUItemUpgradeJewelsRateChangeInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Swap_all, COMDAT
; _this$ = ecx

; 617  : 		_Get_data()._Swap_all(_Right._Get_data());
; 618  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Swap_alloc, COMDAT
; _this$ = ecx

; 534  : 		_Pocs(_Getal(), _Right._Getal());
; 535  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_alloc@?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Swap_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 520  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 520  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@$$QAV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@UItemUpgradeJewelsRateChangeInfo@@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >::_Vector_alloc<std::_Vec_base_types<ItemUpgradeJewelsRateChangeInfo,std::allocator<ItemUpgradeJewelsRateChangeInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QAE@ABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 828  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 829  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 830  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SA?AV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SA?AV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::select_on_container_copy_construction, COMDAT

; 790  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 791  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 792  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SA?AV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAIABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAIABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@2@@Z PROC ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@@std@@SAIABV?$allocator@UItemUpgradeJewelsRateChangeInfo@@@2@@Z ENDP ; std::allocator_traits<std::allocator<ItemUpgradeJewelsRateChangeInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QBEIXZ PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QBEIXZ ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00013	77 3f		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00018	c1 e0 02	 shl	 eax, 2

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEPAUItemUpgradeJewelsRateChangeInfo@@I@Z ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0000e	77 34		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00013	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 639  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAEXPAUItemUpgradeJewelsRateChangeInfo@@I@Z ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocator<ItemUpgradeJewelsRateChangeInfo>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocator<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAE@XZ PROC ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocator<ItemUpgradeJewelsRateChangeInfo>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UItemUpgradeJewelsRateChangeInfo@@@std@@QAE@XZ ENDP ; std::allocator<ItemUpgradeJewelsRateChangeInfo>::allocator<ItemUpgradeJewelsRateChangeInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.h
;	COMDAT ??0ItemUpgradeJewelsRateChangeInfo@@QAE@XZ
_TEXT	SEGMENT
??0ItemUpgradeJewelsRateChangeInfo@@QAE@XZ PROC		; ItemUpgradeJewelsRateChangeInfo::ItemUpgradeJewelsRateChangeInfo, COMDAT
; _this$ = ecx

; 14   : 	{
; 15   : 		this->Type			= (BYTE)-1;

  00000	66 c7 01 ff ff	 mov	 WORD PTR [ecx], 65535	; 0000ffffH

; 16   : 		this->Level			= (BYTE)-1;
; 17   : 		this->Option		= (BYTE)-1;
; 18   : 		this->RateIncrease	= 0;
; 19   : 		this->RateDecrease	= 0;
; 20   : 	}

  00005	8b c1		 mov	 eax, ecx
  00007	c6 41 02 ff	 mov	 BYTE PTR [ecx+2], 255	; 000000ffH
  0000b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00012	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00019	c3		 ret	 0
??0ItemUpgradeJewelsRateChangeInfo@@QAE@XZ ENDP		; ItemUpgradeJewelsRateChangeInfo::ItemUpgradeJewelsRateChangeInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 48   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 518  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemupgradejewels.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 518  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
