; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\TMonsterAIUtil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char *>
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??0TMonsterAIUtil@@QAE@XZ			; TMonsterAIUtil::TMonsterAIUtil
PUBLIC	??1TMonsterAIUtil@@UAE@XZ			; TMonsterAIUtil::~TMonsterAIUtil
PUBLIC	?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z ; TMonsterAIUtil::FindPathToMoveMonster
PUBLIC	?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::SendMonsterMoveMsg
PUBLIC	?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::CheckMovingCondition
PUBLIC	?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z ; TMonsterAIUtil::SendMonsterV2Msg
PUBLIC	?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z ; TMonsterAIUtil::CheckMoveRange
PUBLIC	?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::GetXYToPatrol
PUBLIC	?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::GetXYToEascape
PUBLIC	?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::GetXYToChase
PUBLIC	?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z	; TMonsterAIUtil::FindMonViewportObj
PUBLIC	?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z	; TMonsterAIUtil::FindMonViewportObj2
PUBLIC	?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ	; TMonsterAIUtil::SendChattingMsg
PUBLIC	??_GTMonsterAIUtil@@UAEPAXI@Z			; TMonsterAIUtil::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7TMonsterAIUtil@@6B@				; TMonsterAIUtil::`vftable'
PUBLIC	??_R4TMonsterAIUtil@@6B@			; TMonsterAIUtil::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIUtil@@@8			; TMonsterAIUtil `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIUtil@@8				; TMonsterAIUtil::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIUtil@@8				; TMonsterAIUtil::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIUtil@@8			; TMonsterAIUtil::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4000000000000000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_rand:PROC
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding2
EXTRN	?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding4
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetStandAttr@MapClass@@QAEHHH@Z:PROC		; MapClass::GetStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z:PROC ; ChatTargetSend
EXTRN	?GetPathPacketDirPos@@YAEHH@Z:PROC		; GetPathPacketDirPos
EXTRN	??_ETMonsterAIUtil@@UAEPAXI@Z:PROC		; TMonsterAIUtil::`vector deleting destructor'
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__except_handler4:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@TMonsterAIUtil@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIUtil@@8 DD FLAT:??_R0?AVTMonsterAIUtil@@@8 ; TMonsterAIUtil::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIUtil@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIUtil@@8
rdata$r	SEGMENT
??_R2TMonsterAIUtil@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIUtil@@8 ; TMonsterAIUtil::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIUtil@@8
rdata$r	SEGMENT
??_R3TMonsterAIUtil@@8 DD 00H				; TMonsterAIUtil::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIUtil@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIUtil@@@8
data$r	SEGMENT
??_R0?AVTMonsterAIUtil@@@8 DD FLAT:??_7type_info@@6B@	; TMonsterAIUtil `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIUtil@@', 00H
data$r	ENDS
;	COMDAT ??_R4TMonsterAIUtil@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIUtil@@6B@ DD 00H				; TMonsterAIUtil::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIUtil@@@8
	DD	FLAT:??_R3TMonsterAIUtil@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAIUtil@@6B@
CONST	SEGMENT
??_7TMonsterAIUtil@@6B@ DD FLAT:??_R4TMonsterAIUtil@@6B@ ; TMonsterAIUtil::`vftable'
	DD	FLAT:??_ETMonsterAIUtil@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetXYToPat
	DD	FLAT:$LN9@GetXYToPat
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GTMonsterAIUtil@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTMonsterAIUtil@@UAEPAXI@Z PROC			; TMonsterAIUtil::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1TMonsterAIUtil@@UAE@XZ ; TMonsterAIUtil::~TMonsterAIUtil
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 04		 push	 4
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GTMonsterAIUtil@@UAEPAXI@Z ENDP			; TMonsterAIUtil::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ
_TEXT	SEGMENT
_szBuffer$ = -576					; size = 512
_szChat$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_iObjIndex$ = 12					; size = 4
_lpszMsg$ = 16						; size = 4
?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ PROC	; TMonsterAIUtil::SendChattingMsg, COMDAT

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _iObjIndex$[ebp]
  00016	56		 push	 esi

; 441  : 	if ( !lpszMsg )

  00017	8b 75 10	 mov	 esi, DWORD PTR _lpszMsg$[ebp]
  0001a	85 f6		 test	 esi, esi
  0001c	0f 84 f3 00 00
	00		 je	 $LN3@SendChatti

; 442  : 		return;
; 443  : 
; 444  : 	if ( !OBJMAX_RANGE(iObjIndex))

  00022	85 c9		 test	 ecx, ecx
  00024	0f 88 eb 00 00
	00		 js	 $LN3@SendChatti
  0002a	33 c0		 xor	 eax, eax
  0002c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00032	0f 9e c0	 setle	 al
  00035	85 c0		 test	 eax, eax
  00037	0f 84 d8 00 00
	00		 je	 $LN3@SendChatti

; 445  : 		return;
; 446  : 
; 447  : 	LPOBJ lpObj = &gObj[iObjIndex];

  0003d	53		 push	 ebx
  0003e	57		 push	 edi
  0003f	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00045	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0004b	68 00 02 00 00	 push	 512			; 00000200H
  00050	6a 00		 push	 0
  00052	50		 push	 eax
  00053	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00059	e8 00 00 00 00	 call	 _memset
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00061	8d 45 14	 lea	 eax, DWORD PTR _lpszMsg$[ebp+4]
  00064	50		 push	 eax
  00065	6a 00		 push	 0
  00067	56		 push	 esi
  00068	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0006e	6a ff		 push	 -1
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	ff 70 04	 push	 DWORD PTR [eax+4]
  0007b	83 c9 01	 or	 ecx, 1
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp

; 455  : 	char szChat[60] = {0};

  00084	6a 3b		 push	 59			; 0000003bH
  00086	8d 45 c1	 lea	 eax, DWORD PTR _szChat$[ebp+1]
  00089	6a 00		 push	 0
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _memset

; 456  : 	memcpy(szChat, szBuffer, sizeof(szChat)-1);

  00091	0f 10 85 c0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _szBuffer$[ebp]
  00098	66 8b 85 f8 fd
	ff ff		 mov	 ax, WORD PTR _szBuffer$[ebp+56]
  0009f	8d b3 4a 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3146]
  000a5	66 89 45 f8	 mov	 WORD PTR _szChat$[ebp+56], ax
  000a9	83 c4 28	 add	 esp, 40			; 00000028H
  000ac	8a 85 fa fd ff
	ff		 mov	 al, BYTE PTR _szBuffer$[ebp+58]
  000b2	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
  000b7	0f 11 45 c0	 movups	 XMMWORD PTR _szChat$[ebp], xmm0
  000bb	88 45 fa	 mov	 BYTE PTR _szChat$[ebp+58], al
  000be	0f 10 85 d0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _szBuffer$[ebp+16]
  000c5	0f 11 45 d0	 movups	 XMMWORD PTR _szChat$[ebp+16], xmm0
  000c9	0f 10 85 e0 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _szBuffer$[ebp+32]
  000d0	0f 11 45 e0	 movups	 XMMWORD PTR _szChat$[ebp+32], xmm0
  000d4	f3 0f 7e 85 f0
	fd ff ff	 movq	 xmm0, QWORD PTR _szBuffer$[ebp+48]
  000dc	66 0f d6 45 f0	 movq	 QWORD PTR _szChat$[ebp+48], xmm0
$LL4@SendChatti:

; 459  : 	{
; 460  : 		if ( lpObj->VpPlayer2[i].state )

  000e1	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  000e5	74 24		 je	 SHORT $LN2@SendChatti

; 461  : 		{
; 462  : 			int tObjNum = lpObj->VpPlayer2[i].number;

  000e7	0f bf 0e	 movsx	 ecx, WORD PTR [esi]

; 463  : 
; 464  : 			if ( OBJMAX_RANGE(tObjNum) )

  000ea	85 c9		 test	 ecx, ecx
  000ec	78 1d		 js	 SHORT $LN2@SendChatti
  000ee	33 c0		 xor	 eax, eax
  000f0	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  000f6	0f 9e c0	 setle	 al
  000f9	85 c0		 test	 eax, eax
  000fb	74 0e		 je	 SHORT $LN2@SendChatti

; 465  : 			{
; 466  : 				ChatTargetSend(lpObj, szChat, tObjNum);

  000fd	51		 push	 ecx
  000fe	8d 45 c0	 lea	 eax, DWORD PTR _szChat$[ebp]
  00101	50		 push	 eax
  00102	53		 push	 ebx
  00103	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendChatti:

; 457  : 
; 458  : 	for(int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  0010b	83 c6 0c	 add	 esi, 12			; 0000000cH
  0010e	83 ef 01	 sub	 edi, 1
  00111	75 ce		 jne	 SHORT $LL4@SendChatti
  00113	5f		 pop	 edi
  00114	5b		 pop	 ebx
$LN3@SendChatti:

; 467  : 			}
; 468  : 		}
; 469  : 	}
; 470  : }

  00115	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00118	33 cd		 xor	 ecx, ebp
  0011a	5e		 pop	 esi
  0011b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ ENDP	; TMonsterAIUtil::SendChattingMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z
_TEXT	SEGMENT
_iObjIndex$ = 8						; size = 4
_iTargetObjIndex$ = 12					; size = 4
?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z PROC	; TMonsterAIUtil::FindMonViewportObj2, COMDAT
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	if ( OBJMON_RANGE(iObjIndex) ==  FALSE || OBJMAX_RANGE(iTargetObjIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iObjIndex$[ebp]
  00006	56		 push	 esi
  00007	85 c9		 test	 ecx, ecx
  00009	78 4f		 js	 SHORT $LN6@FindMonVie
  0000b	33 c0		 xor	 eax, eax
  0000d	81 f9 03 29 00
	00		 cmp	 ecx, 10499		; 00002903H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 40		 je	 SHORT $LN6@FindMonVie
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _iTargetObjIndex$[ebp]
  0001d	85 f6		 test	 esi, esi
  0001f	78 39		 js	 SHORT $LN6@FindMonVie
  00021	33 c0		 xor	 eax, eax
  00023	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00029	0f 9e c0	 setle	 al
  0002c	85 c0		 test	 eax, eax
  0002e	74 2a		 je	 SHORT $LN6@FindMonVie

; 49   : 
; 50   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	33 d2		 xor	 edx, edx
  00037	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  0003d	05 4a 0c 00 00	 add	 eax, 3146		; 00000c4aH
  00042	03 c8		 add	 ecx, eax
$LL4@FindMonVie:

; 51   : 	{
; 52   : 		if ( gObj[iObjIndex].VpPlayer2[i].state != FALSE )

  00044	80 79 fe 00	 cmp	 BYTE PTR [ecx-2], 0
  00048	74 07		 je	 SHORT $LN2@FindMonVie

; 53   : 		{
; 54   : 			if ( iTargetObjIndex == gObj[iObjIndex].VpPlayer2[i].number )

  0004a	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  0004d	3b f0		 cmp	 esi, eax
  0004f	74 10		 je	 SHORT $LN15@FindMonVie
$LN2@FindMonVie:

; 49   : 
; 50   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00051	42		 inc	 edx
  00052	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00055	83 fa 4b	 cmp	 edx, 75			; 0000004bH
  00058	7c ea		 jl	 SHORT $LL4@FindMonVie
$LN6@FindMonVie:

; 48   : 		return FALSE;

  0005a	33 c0		 xor	 eax, eax
  0005c	5e		 pop	 esi

; 57   : 			}
; 58   : 		}
; 59   : 	}
; 60   : 
; 61   : 	return FALSE;
; 62   : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
$LN15@FindMonVie:

; 55   : 			{
; 56   : 				return TRUE;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	5e		 pop	 esi

; 57   : 			}
; 58   : 		}
; 59   : 	}
; 60   : 
; 61   : 	return FALSE;
; 62   : }

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z ENDP	; TMonsterAIUtil::FindMonViewportObj2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z
_TEXT	SEGMENT
_iObjIndex$ = 8						; size = 4
_iTargetObjIndex$ = 12					; size = 4
?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z PROC	; TMonsterAIUtil::FindMonViewportObj, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 	if ( OBJMON_RANGE(iObjIndex) ==  FALSE || OBJMAX_RANGE(iTargetObjIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iObjIndex$[ebp]
  00006	56		 push	 esi
  00007	85 c9		 test	 ecx, ecx
  00009	78 4f		 js	 SHORT $LN6@FindMonVie
  0000b	33 c0		 xor	 eax, eax
  0000d	81 f9 03 29 00
	00		 cmp	 ecx, 10499		; 00002903H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 40		 je	 SHORT $LN6@FindMonVie
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _iTargetObjIndex$[ebp]
  0001d	85 f6		 test	 esi, esi
  0001f	78 39		 js	 SHORT $LN6@FindMonVie
  00021	33 c0		 xor	 eax, eax
  00023	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00029	0f 9e c0	 setle	 al
  0002c	85 c0		 test	 eax, eax
  0002e	74 2a		 je	 SHORT $LN6@FindMonVie

; 30   : 
; 31   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	33 d2		 xor	 edx, edx
  00037	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  0003d	05 c6 08 00 00	 add	 eax, 2246		; 000008c6H
  00042	03 c8		 add	 ecx, eax
$LL4@FindMonVie:

; 32   : 	{
; 33   : 		if ( gObj[iObjIndex].VpPlayer[i].state != FALSE )

  00044	80 79 fe 00	 cmp	 BYTE PTR [ecx-2], 0
  00048	74 07		 je	 SHORT $LN2@FindMonVie

; 34   : 		{
; 35   : 			if ( iTargetObjIndex == gObj[iObjIndex].VpPlayer[i].number )

  0004a	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  0004d	3b f0		 cmp	 esi, eax
  0004f	74 10		 je	 SHORT $LN15@FindMonVie
$LN2@FindMonVie:

; 30   : 
; 31   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00051	42		 inc	 edx
  00052	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00055	83 fa 4b	 cmp	 edx, 75			; 0000004bH
  00058	7c ea		 jl	 SHORT $LL4@FindMonVie
$LN6@FindMonVie:

; 29   : 		return FALSE;

  0005a	33 c0		 xor	 eax, eax
  0005c	5e		 pop	 esi

; 38   : 			}
; 39   : 		}
; 40   : 	}
; 41   : 
; 42   : 	return FALSE;
; 43   : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
$LN15@FindMonVie:

; 36   : 			{
; 37   : 				return TRUE;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	5e		 pop	 esi

; 38   : 			}
; 39   : 		}
; 40   : 	}
; 41   : 
; 42   : 	return FALSE;
; 43   : }

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z ENDP	; TMonsterAIUtil::FindMonViewportObj
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_tpx$1$ = -28						; size = 4
_tpy$1$ = -24						; size = 4
_mtx$1$ = -20						; size = 4
_mty$1$ = -16						; size = 4
tv353 = -12						; size = 4
_mty$2$ = -12						; size = 4
tv354 = -8						; size = 4
_searchcount$1$ = -8					; size = 4
_lpTargetObj$1$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::GetXYToChase, COMDAT
; _this$ = ecx

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 330  : 	int tpx;	// Target Player X
; 331  : 	int tpy;
; 332  : 	int mtx;	// Monster Target X
; 333  : 	int mty;
; 334  : 	int searchp = 0;
; 335  : 	int sn = 0;
; 336  : 	int searchcount = MAX_ROAD_PATH_TABLE/2-1;
; 337  : 	BYTE attr;
; 338  : 	BOOL result = 0;
; 339  : 	LPOBJ lpTargetObj;
; 340  : 
; 341  : 	if ( OBJMAX_RANGE(lpObj->TargetNumber) == FALSE )

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000f	bb 07 00 00 00	 mov	 ebx, 7
  00014	0f b7 8f 38 06
	00 00		 movzx	 ecx, WORD PTR [edi+1592]
  0001b	66 85 c9	 test	 cx, cx
  0001e	0f 88 5c 01 00
	00		 js	 $LN21@GetXYToCha
  00024	33 c0		 xor	 eax, eax
  00026	ba eb 2c 00 00	 mov	 edx, 11499		; 00002cebH
  0002b	66 3b ca	 cmp	 cx, dx
  0002e	0f 9e c0	 setle	 al
  00031	85 c0		 test	 eax, eax
  00033	0f 84 47 01 00
	00		 je	 $LN21@GetXYToCha

; 344  : 	}
; 345  : 
; 346  : 	lpTargetObj = &gObj[lpObj->TargetNumber];
; 347  : 	tpx = lpTargetObj->X;
; 348  : 	mtx = tpx;
; 349  : 	tpy = lpTargetObj->Y;
; 350  : 	mty = tpy;
; 351  : 	int dis = (int)(lpObj->m_AttackRange / sqrt(2.0));

  00039	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00041	0f bf b7 90 06
	00 00		 movsx	 esi, WORD PTR [edi+1680]
  00048	0f bf c1	 movsx	 eax, cx
  0004b	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00051	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	89 4c 24 24	 mov	 DWORD PTR _lpTargetObj$1$[esp+40], ecx
  0005b	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00062	89 44 24 20	 mov	 DWORD PTR tv354[esp+40], eax
  00066	89 44 24 0c	 mov	 DWORD PTR _tpx$1$[esp+40], eax
  0006a	89 44 24 14	 mov	 DWORD PTR _mtx$1$[esp+40], eax
  0006e	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  00075	89 44 24 1c	 mov	 DWORD PTR tv353[esp+40], eax
  00079	89 44 24 10	 mov	 DWORD PTR _tpy$1$[esp+40], eax
  0007d	89 44 24 18	 mov	 DWORD PTR _mty$1$[esp+40], eax
  00081	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00086	66 0f 6e ce	 movd	 xmm1, esi
  0008a	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1

; 352  : 
; 353  : 	if ( lpObj->X < mtx )

  0008e	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  00095	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tpx$1$[esp+40]
  00099	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0009d	f2 0f 2c d1	 cvttsd2si edx, xmm1
  000a1	3b c1		 cmp	 eax, ecx
  000a3	7d 06		 jge	 SHORT $LN5@GetXYToCha

; 354  : 	{
; 355  : 		tpx -= dis;

  000a5	2b ca		 sub	 ecx, edx
  000a7	89 4c 24 0c	 mov	 DWORD PTR _tpx$1$[esp+40], ecx
$LN5@GetXYToCha:

; 356  : 	}
; 357  : 
; 358  : 	if ( lpObj->X > mtx )

  000ab	3b 44 24 14	 cmp	 eax, DWORD PTR _mtx$1$[esp+40]
  000af	7e 06		 jle	 SHORT $LN6@GetXYToCha

; 359  : 	{
; 360  : 		tpx += dis;

  000b1	03 ca		 add	 ecx, edx
  000b3	89 4c 24 0c	 mov	 DWORD PTR _tpx$1$[esp+40], ecx
$LN6@GetXYToCha:

; 361  : 	}
; 362  : 
; 363  : 	if ( lpObj->Y < mty )

  000b7	0f b6 b7 21 01
	00 00		 movzx	 esi, BYTE PTR [edi+289]
  000be	8b 44 24 10	 mov	 eax, DWORD PTR _tpy$1$[esp+40]
  000c2	3b f0		 cmp	 esi, eax
  000c4	7d 06		 jge	 SHORT $LN7@GetXYToCha

; 364  : 	{
; 365  : 		tpy -= dis;

  000c6	2b c2		 sub	 eax, edx
  000c8	89 44 24 10	 mov	 DWORD PTR _tpy$1$[esp+40], eax
$LN7@GetXYToCha:

; 366  : 	}
; 367  : 
; 368  : 	if ( lpObj->Y > mty )

  000cc	3b 74 24 18	 cmp	 esi, DWORD PTR _mty$1$[esp+40]
  000d0	7e 06		 jle	 SHORT $LN8@GetXYToCha

; 369  : 	{
; 370  : 		tpy += dis;

  000d2	03 c2		 add	 eax, edx
  000d4	89 44 24 10	 mov	 DWORD PTR _tpy$1$[esp+40], eax
$LN8@GetXYToCha:

; 371  : 	}
; 372  : 
; 373  : 	searchp = GetPathPacketDirPos( (lpTargetObj->X - tpx), (lpTargetObj->Y - tpy) ) * 2;

  000d8	8b 54 24 1c	 mov	 edx, DWORD PTR tv353[esp+40]
  000dc	2b d0		 sub	 edx, eax
  000de	8b 44 24 20	 mov	 eax, DWORD PTR tv354[esp+40]
  000e2	52		 push	 edx
  000e3	2b c1		 sub	 eax, ecx
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  000eb	83 c4 08	 add	 esp, 8
  000ee	0f b6 f0	 movzx	 esi, al

; 374  : 
; 375  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tpx, tpy) == 0 )

  000f1	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  000f8	03 f6		 add	 esi, esi
  000fa	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00100	ff 74 24 10	 push	 DWORD PTR _tpy$1$[esp+40]
  00104	ff 74 24 10	 push	 DWORD PTR _tpx$1$[esp+44]
  00108	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0010e	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  00113	85 c0		 test	 eax, eax
  00115	0f 85 8e 00 00
	00		 jne	 $LN9@GetXYToCha
  0011b	0f 1f 44 00 00	 npad	 5
$LL2@GetXYToCha:

; 376  : 	{
; 377  : 		while ( searchcount-- )
; 378  : 		{
; 379  : 			mtx = lpTargetObj->X + RoadPathTable[searchp];

  00120	8b 54 24 24	 mov	 edx, DWORD PTR _lpTargetObj$1$[esp+40]
  00124	4b		 dec	 ebx

; 380  : 			mty = lpTargetObj->Y + RoadPathTable[1+searchp];

  00125	0f bf 0c 75 02
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[esi*2+2]
  0012d	89 5c 24 20	 mov	 DWORD PTR _searchcount$1$[esp+40], ebx
  00131	0f bf 1c 75 00
	00 00 00	 movsx	 ebx, WORD PTR ?RoadPathTable@@3PAFA[esi*2]
  00139	0f b6 82 20 01
	00 00		 movzx	 eax, BYTE PTR [edx+288]
  00140	03 d8		 add	 ebx, eax
  00142	0f b6 82 21 01
	00 00		 movzx	 eax, BYTE PTR [edx+289]
  00149	03 c8		 add	 ecx, eax

; 381  : 			attr = MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  0014b	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  00152	51		 push	 ecx
  00153	89 4c 24 20	 mov	 DWORD PTR _mty$2$[esp+44], ecx
  00157	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  0015d	53		 push	 ebx
  0015e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00164	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00169	a8 0f		 test	 al, 15			; 0000000fH

; 382  : 			
; 383  : 			if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  0016b	74 1e		 je	 SHORT $LN17@GetXYToCha

; 388  : 			}
; 389  : 
; 390  : 			searchp += 2;

  0016d	8b 5c 24 20	 mov	 ebx, DWORD PTR _searchcount$1$[esp+40]
  00171	83 c6 02	 add	 esi, 2

; 391  : 
; 392  : 			if ( searchp > MAX_ROAD_PATH_TABLE-1 )

  00174	33 c0		 xor	 eax, eax
  00176	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00179	0f 4f f0	 cmovg	 esi, eax
  0017c	85 db		 test	 ebx, ebx
  0017e	75 a0		 jne	 SHORT $LL2@GetXYToCha
$LN21@GetXYToCha:

; 342  : 	{
; 343  : 		return FALSE;

  00180	33 c0		 xor	 eax, eax

; 408  : 	}
; 409  : 
; 410  : 	return FALSE;
; 411  : }

  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c2 04 00	 ret	 4
$LN17@GetXYToCha:

; 384  : 			{
; 385  : 				lpObj->MTX = mtx;
; 386  : 				lpObj->MTY = mty;

  0018b	8b 44 24 1c	 mov	 eax, DWORD PTR _mty$2$[esp+40]
  0018f	88 87 55 01 00
	00		 mov	 BYTE PTR [edi+341], al

; 387  : 				return TRUE;

  00195	b8 01 00 00 00	 mov	 eax, 1
  0019a	88 9f 54 01 00
	00		 mov	 BYTE PTR [edi+340], bl

; 408  : 	}
; 409  : 
; 410  : 	return FALSE;
; 411  : }

  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	5b		 pop	 ebx
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c2 04 00	 ret	 4
$LN9@GetXYToCha:

; 393  : 			{
; 394  : 				searchp = 0;
; 395  : 			}
; 396  : 		}
; 397  : 
; 398  : 		return FALSE;
; 399  : 	}
; 400  : 
; 401  : 	attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  001a9	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  001b0	8b 5c 24 10	 mov	 ebx, DWORD PTR _tpy$1$[esp+40]
  001b4	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  001ba	53		 push	 ebx
  001bb	ff 74 24 10	 push	 DWORD PTR _tpx$1$[esp+44]
  001bf	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001c5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  001ca	a8 0f		 test	 al, 15			; 0000000fH

; 402  : 
; 403  : 	if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  001cc	75 b2		 jne	 SHORT $LN21@GetXYToCha

; 404  : 	{
; 405  : 		lpObj->MTX = tpx;

  001ce	8b 44 24 0c	 mov	 eax, DWORD PTR _tpx$1$[esp+40]
  001d2	88 87 54 01 00
	00		 mov	 BYTE PTR [edi+340], al

; 406  : 		lpObj->MTY = tpy;
; 407  : 		return TRUE;

  001d8	b8 01 00 00 00	 mov	 eax, 1
  001dd	88 9f 55 01 00
	00		 mov	 BYTE PTR [edi+341], bl

; 408  : 	}
; 409  : 
; 410  : 	return FALSE;
; 411  : }

  001e3	5f		 pop	 edi
  001e4	5e		 pop	 esi
  001e5	5b		 pop	 ebx
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c2 04 00	 ret	 4
?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::GetXYToChase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_tx$1$ = -24						; size = 4
_ty$1$ = -20						; size = 4
_mty$1$ = -16						; size = 4
tv350 = -12						; size = 4
_mty$2$ = -8						; size = 4
_mtx$1$ = -8						; size = 4
tv349 = -4						; size = 4
_searchcount$1$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::GetXYToEascape, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 238  : 	int tpx;	// Target Player X
; 239  : 	int tpy;
; 240  : 	int mtx;	// Monster Target X
; 241  : 	int mty;
; 242  : 	int tx;
; 243  : 	int ty;
; 244  : 	int searchp = 0;
; 245  : 	int sn = 0;
; 246  : 	int searchcount = MAX_ROAD_PATH_TABLE/2-1;
; 247  : 	BYTE attr;
; 248  : 	BOOL result = 0;
; 249  : 	LPOBJ lpTargetObj;
; 250  : 
; 251  : 	if ( OBJMAX_RANGE(lpObj->TargetNumber) == FALSE )

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000f	bb 07 00 00 00	 mov	 ebx, 7
  00014	0f b7 8f 38 06
	00 00		 movzx	 ecx, WORD PTR [edi+1592]
  0001b	66 85 c9	 test	 cx, cx
  0001e	0f 88 58 01 00
	00		 js	 $LN21@GetXYToEas
  00024	33 c0		 xor	 eax, eax
  00026	ba eb 2c 00 00	 mov	 edx, 11499		; 00002cebH
  0002b	66 3b ca	 cmp	 cx, dx
  0002e	0f 9e c0	 setle	 al
  00031	85 c0		 test	 eax, eax
  00033	0f 84 43 01 00
	00		 je	 $LN21@GetXYToEas

; 254  : 	}
; 255  : 
; 256  : 	lpTargetObj = &gObj[lpObj->TargetNumber];
; 257  : 	tpx = lpTargetObj->X;
; 258  : 	mtx = tpx;
; 259  : 	tpy = lpTargetObj->Y;
; 260  : 	mty = tpy;
; 261  : 	tx = lpObj->X;
; 262  : 	ty = lpObj->Y;
; 263  : 	int dis = (int)(lpObj->m_AttackRange / sqrt(2.0));

  00039	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00041	0f bf b7 90 06
	00 00		 movsx	 esi, WORD PTR [edi+1680]
  00048	0f bf c1	 movsx	 eax, cx
  0004b	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00051	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  0005e	0f b6 80 21 01
	00 00		 movzx	 eax, BYTE PTR [eax+289]
  00065	89 44 24 18	 mov	 DWORD PTR _mty$1$[esp+40], eax
  00069	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  00070	89 44 24 1c	 mov	 DWORD PTR tv350[esp+40], eax
  00074	89 44 24 10	 mov	 DWORD PTR _tx$1$[esp+40], eax
  00078	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  0007f	89 4c 24 20	 mov	 DWORD PTR _mtx$1$[esp+40], ecx
  00083	89 44 24 24	 mov	 DWORD PTR tv349[esp+40], eax
  00087	89 44 24 14	 mov	 DWORD PTR _ty$1$[esp+40], eax
  0008b	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00090	66 0f 6e ce	 movd	 xmm1, esi
  00094	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1

; 264  : 
; 265  : 	if ( lpObj->X < mtx )

  00098	8b 44 24 1c	 mov	 eax, DWORD PTR tv350[esp+40]
  0009c	8b 74 24 20	 mov	 esi, DWORD PTR _mtx$1$[esp+40]

; 266  : 	{
; 267  : 		tx -= dis;

  000a0	8b 4c 24 10	 mov	 ecx, DWORD PTR _tx$1$[esp+40]
  000a4	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000a8	f2 0f 2c d1	 cvttsd2si edx, xmm1
  000ac	3b c6		 cmp	 eax, esi
  000ae	7d 08		 jge	 SHORT $LN26@GetXYToEas
  000b0	2b ca		 sub	 ecx, edx

; 268  : 	}
; 269  : 
; 270  : 	if ( lpObj->X > mtx )

  000b2	3b c6		 cmp	 eax, esi
  000b4	89 4c 24 10	 mov	 DWORD PTR _tx$1$[esp+40], ecx
$LN26@GetXYToEas:
  000b8	7e 06		 jle	 SHORT $LN6@GetXYToEas

; 271  : 	{
; 272  : 		tx += dis;

  000ba	03 ca		 add	 ecx, edx
  000bc	89 4c 24 10	 mov	 DWORD PTR _tx$1$[esp+40], ecx
$LN6@GetXYToEas:

; 273  : 	}
; 274  : 
; 275  : 	if ( lpObj->Y < mty )

  000c0	8b 74 24 24	 mov	 esi, DWORD PTR tv349[esp+40]

; 276  : 	{
; 277  : 		ty -= dis;

  000c4	8b 44 24 14	 mov	 eax, DWORD PTR _ty$1$[esp+40]
  000c8	3b 74 24 18	 cmp	 esi, DWORD PTR _mty$1$[esp+40]
  000cc	7d 0a		 jge	 SHORT $LN27@GetXYToEas
  000ce	2b c2		 sub	 eax, edx

; 278  : 	}
; 279  : 
; 280  : 	if ( lpObj->Y > mty )

  000d0	3b 74 24 18	 cmp	 esi, DWORD PTR _mty$1$[esp+40]
  000d4	89 44 24 14	 mov	 DWORD PTR _ty$1$[esp+40], eax
$LN27@GetXYToEas:
  000d8	7e 06		 jle	 SHORT $LN8@GetXYToEas

; 281  : 	{
; 282  : 		ty += dis;

  000da	03 c2		 add	 eax, edx
  000dc	89 44 24 14	 mov	 DWORD PTR _ty$1$[esp+40], eax
$LN8@GetXYToEas:

; 283  : 	}
; 284  : 
; 285  : 	searchp = GetPathPacketDirPos( (lpObj->X - tx), (lpObj->Y - ty) ) * 2;

  000e0	2b f0		 sub	 esi, eax
  000e2	8b 44 24 1c	 mov	 eax, DWORD PTR tv350[esp+40]
  000e6	2b c1		 sub	 eax, ecx
  000e8	56		 push	 esi
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  000ef	83 c4 08	 add	 esp, 8
  000f2	0f b6 f0	 movzx	 esi, al

; 286  : 
; 287  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tx, ty) == 0 )

  000f5	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  000fc	03 f6		 add	 esi, esi
  000fe	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00104	ff 74 24 14	 push	 DWORD PTR _ty$1$[esp+40]
  00108	ff 74 24 14	 push	 DWORD PTR _tx$1$[esp+44]
  0010c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00112	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  00117	85 c0		 test	 eax, eax
  00119	0f 85 86 00 00
	00		 jne	 $LN9@GetXYToEas
  0011f	90		 npad	 1
$LL2@GetXYToEas:

; 288  : 	{
; 289  : 		while ( searchcount-- )
; 290  : 		{
; 291  : 			mtx = lpObj->X + RoadPathTable[searchp];

  00120	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  00127	4b		 dec	 ebx

; 292  : 			mty = lpObj->Y + RoadPathTable[1+searchp];

  00128	0f bf 0c 75 02
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[esi*2+2]
  00130	89 5c 24 24	 mov	 DWORD PTR _searchcount$1$[esp+40], ebx
  00134	0f bf 1c 75 00
	00 00 00	 movsx	 ebx, WORD PTR ?RoadPathTable@@3PAFA[esi*2]
  0013c	03 d8		 add	 ebx, eax
  0013e	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  00145	03 c8		 add	 ecx, eax

; 293  : 			attr = MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  00147	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  0014e	51		 push	 ecx
  0014f	89 4c 24 24	 mov	 DWORD PTR _mty$2$[esp+44], ecx
  00153	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00159	53		 push	 ebx
  0015a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00160	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00165	a8 0f		 test	 al, 15			; 0000000fH

; 294  : 			
; 295  : 			if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  00167	74 1e		 je	 SHORT $LN17@GetXYToEas

; 300  : 			}
; 301  : 
; 302  : 			searchp += 2;

  00169	8b 5c 24 24	 mov	 ebx, DWORD PTR _searchcount$1$[esp+40]
  0016d	83 c6 02	 add	 esi, 2

; 303  : 
; 304  : 			if ( searchp > MAX_ROAD_PATH_TABLE-1 )

  00170	33 c0		 xor	 eax, eax
  00172	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00175	0f 4f f0	 cmovg	 esi, eax
  00178	85 db		 test	 ebx, ebx
  0017a	75 a4		 jne	 SHORT $LL2@GetXYToEas
$LN21@GetXYToEas:

; 252  : 	{
; 253  : 		return FALSE;

  0017c	33 c0		 xor	 eax, eax

; 320  : 	}
; 321  : 
; 322  : 	return FALSE;
; 323  : }

  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c2 04 00	 ret	 4
$LN17@GetXYToEas:

; 296  : 			{
; 297  : 				lpObj->MTX = mtx;
; 298  : 				lpObj->MTY = mty;

  00187	8b 44 24 20	 mov	 eax, DWORD PTR _mty$2$[esp+40]
  0018b	88 87 55 01 00
	00		 mov	 BYTE PTR [edi+341], al

; 299  : 				return TRUE;

  00191	b8 01 00 00 00	 mov	 eax, 1
  00196	88 9f 54 01 00
	00		 mov	 BYTE PTR [edi+340], bl

; 320  : 	}
; 321  : 
; 322  : 	return FALSE;
; 323  : }

  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c2 04 00	 ret	 4
$LN9@GetXYToEas:

; 305  : 			{
; 306  : 				searchp = 0;
; 307  : 			}
; 308  : 		}
; 309  : 
; 310  : 		return FALSE;
; 311  : 	}
; 312  : 
; 313  : 	attr = MapC[lpObj->MapNumber].GetAttr(tx, ty);

  001a5	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  001ac	8b 5c 24 14	 mov	 ebx, DWORD PTR _ty$1$[esp+40]
  001b0	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  001b6	53		 push	 ebx
  001b7	ff 74 24 14	 push	 DWORD PTR _tx$1$[esp+44]
  001bb	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001c1	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  001c6	a8 0f		 test	 al, 15			; 0000000fH

; 314  : 
; 315  : 	if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  001c8	75 b2		 jne	 SHORT $LN21@GetXYToEas

; 316  : 	{
; 317  : 		lpObj->MTX = tx;

  001ca	8b 44 24 10	 mov	 eax, DWORD PTR _tx$1$[esp+40]
  001ce	88 87 54 01 00
	00		 mov	 BYTE PTR [edi+340], al

; 318  : 		lpObj->MTY = ty;
; 319  : 		return TRUE;

  001d4	b8 01 00 00 00	 mov	 eax, 1
  001d9	88 9f 55 01 00
	00		 mov	 BYTE PTR [edi+341], bl

; 320  : 	}
; 321  : 
; 322  : 	return FALSE;
; 323  : }

  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5b		 pop	 ebx
  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c2 04 00	 ret	 4
?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::GetXYToEascape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_searchc$ = -36						; size = 4
_maxmoverange$ = -32					; size = 4
_tpy$ = -26						; size = 1
_tpx$ = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::GetXYToPatrol, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 14	 sub	 esp, 20			; 00000014H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 204  : 	int maxmoverange = lpObj->m_MoveRange*2+1;

  00033	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00036	0f bf 87 8e 06
	00 00		 movsx	 eax, WORD PTR [edi+1678]
  0003d	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  00044	89 45 e0	 mov	 DWORD PTR _maxmoverange$[ebp], eax

; 205  : 	int searchc=10;

  00047	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH

; 206  : 	lpObj->NextActionTime = 1000;

  0004c	c7 87 a0 05 00
	00 e8 03 00 00	 mov	 DWORD PTR [edi+1440], 1000 ; 000003e8H
$LL2@GetXYToPat:

; 207  : 	BYTE tpx;
; 208  : 	BYTE tpy;
; 209  : 
; 210  : 	while ( searchc-- != 0 )

  00056	8b c6		 mov	 eax, esi
  00058	4e		 dec	 esi
  00059	89 75 dc	 mov	 DWORD PTR _searchc$[ebp], esi
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 c1 00 00
	00		 je	 $LN3@GetXYToPat

; 211  : 	{
; 212  : 		__try

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 213  : 		{
; 214  : 			tpx = (lpObj->X - lpObj->m_MoveRange) + (rand()%maxmoverange);

  0006b	e8 00 00 00 00	 call	 _rand
  00070	8b 4d e0	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  00073	99		 cdq
  00074	f7 f9		 idiv	 ecx
  00076	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  0007d	03 d0		 add	 edx, eax
  0007f	0f bf 87 8e 06
	00 00		 movsx	 eax, WORD PTR [edi+1678]
  00086	2b d0		 sub	 edx, eax
  00088	88 55 e7	 mov	 BYTE PTR _tpx$[ebp], dl

; 215  : 			tpy = (lpObj->Y - lpObj->m_MoveRange) + (rand()%maxmoverange);

  0008b	e8 00 00 00 00	 call	 _rand
  00090	8b 4d e0	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  00093	99		 cdq
  00094	f7 f9		 idiv	 ecx
  00096	0f b6 9f 21 01
	00 00		 movzx	 ebx, BYTE PTR [edi+289]
  0009d	03 da		 add	 ebx, edx
  0009f	0f bf 87 8e 06
	00 00		 movsx	 eax, WORD PTR [edi+1678]
  000a6	2b d8		 sub	 ebx, eax
  000a8	88 5d e6	 mov	 BYTE PTR _tpy$[ebp], bl

; 216  : 		}

  000ab	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000b2	eb 20		 jmp	 SHORT $LN11@GetXYToPat
$LN8@GetXYToPat:
$LN16@GetXYToPat:

; 217  : 		__except(maxmoverange=1, 1)

  000b4	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _maxmoverange$[ebp], 1
  000bb	b8 01 00 00 00	 mov	 eax, 1
$LN15@GetXYToPat:
$LN10@GetXYToPat:
  000c0	c3		 ret	 0
$LN9@GetXYToPat:
  000c1	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 216  : 		}

  000c4	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000cb	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  000ce	8b 75 dc	 mov	 esi, DWORD PTR _searchc$[ebp]
  000d1	8a 5d e6	 mov	 bl, BYTE PTR _tpy$[ebp]
$LN11@GetXYToPat:

; 218  : 		{
; 219  : 
; 220  : 		}
; 221  : 
; 222  : 		BYTE attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  000d4	0f b6 c3	 movzx	 eax, bl
  000d7	50		 push	 eax
  000d8	0f b6 45 e7	 movzx	 eax, BYTE PTR _tpx$[ebp]
  000dc	50		 push	 eax
  000dd	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  000e4	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  000ea	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000f0	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000f5	a8 0f		 test	 al, 15			; 0000000fH

; 223  : 
; 224  : 		if ( (attr&1)!=1 && (attr&2)!=2 && (attr&4)!=4 && (attr&8)!= 8 )

  000f7	0f 85 59 ff ff
	ff		 jne	 $LL2@GetXYToPat

; 225  : 		{
; 226  : 			lpObj->MTX = tpx;

  000fd	8a 45 e7	 mov	 al, BYTE PTR _tpx$[ebp]
  00100	88 87 54 01 00
	00		 mov	 BYTE PTR [edi+340], al

; 227  : 			lpObj->MTY = tpy;

  00106	88 9f 55 01 00
	00		 mov	 BYTE PTR [edi+341], bl

; 228  : 			return TRUE;

  0010c	b8 01 00 00 00	 mov	 eax, 1

; 233  : }

  00111	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 04 00	 ret	 4
$LN3@GetXYToPat:

; 229  : 		}
; 230  : 	}
; 231  : 
; 232  : 	return FALSE;

  00125	33 c0		 xor	 eax, eax

; 233  : }

  00127	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0012a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00131	59		 pop	 ecx
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 04 00	 ret	 4
?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::GetXYToPatrol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iTargetX$ = 12						; size = 4
_iTargetY$ = 16						; size = 4
?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z PROC ; TMonsterAIUtil::CheckMoveRange, COMDAT
; _this$ = ecx

; 197  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 198  : }

  00002	c2 0c 00	 ret	 12			; 0000000cH
?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z ENDP ; TMonsterAIUtil::CheckMoveRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
_size$ = 16						; size = 4
?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z PROC ; TMonsterAIUtil::SendMonsterV2Msg, COMDAT
; _this$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 69   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00009	bb 4b 00 00 00	 mov	 ebx, 75			; 0000004bH
  0000e	83 c8 ff	 or	 eax, -1
  00011	8d b7 4a 0c 00
	00		 lea	 esi, DWORD PTR [edi+3146]
$LL4@SendMonste:

; 70   : 	{
; 71   : 		if ( lpObj->VpPlayer2[i].type == OBJ_USER )

  00017	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  0001b	75 36		 jne	 SHORT $LN2@SendMonste

; 72   : 		{
; 73   : 			if ( lpObj->VpPlayer2[i].state != FALSE )

  0001d	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00021	74 30		 je	 SHORT $LN2@SendMonste

; 74   : 			{
; 75   : 				if ( lpObj->Connected > PLAYER_CONNECTED && lpObj->Live != FALSE)

  00023	83 7f 04 01	 cmp	 DWORD PTR [edi+4], 1
  00027	7e 1d		 jle	 SHORT $LN7@SendMonste
  00029	80 7f 51 00	 cmp	 BYTE PTR [edi+81], 0
  0002d	74 17		 je	 SHORT $LN7@SendMonste

; 76   : 				{
; 77   : 					DataSend(lpObj->VpPlayer2[i].number, lpMsg, size);

  0002f	ff 75 10	 push	 DWORD PTR _size$[ebp]
  00032	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00035	ff 75 0c	 push	 DWORD PTR _lpMsg$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 				}
; 79   : 				else

  00041	83 c8 ff	 or	 eax, -1
  00044	eb 0d		 jmp	 SHORT $LN2@SendMonste
$LN7@SendMonste:

; 80   : 				{
; 81   : 					lpObj->VpPlayer2[i].number = -1;

  00046	66 89 06	 mov	 WORD PTR [esi], ax

; 82   : 					lpObj->VpPlayer2[i].state = FALSE;

  00049	c6 46 fe 00	 mov	 BYTE PTR [esi-2], 0

; 83   : 					lpObj->VPCount2--;

  0004d	ff 8f d0 0f 00
	00		 dec	 DWORD PTR [edi+4048]
$LN2@SendMonste:

; 69   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00053	83 c6 0c	 add	 esi, 12			; 0000000cH
  00056	83 eb 01	 sub	 ebx, 1
  00059	75 bc		 jne	 SHORT $LL4@SendMonste
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 84   : 				}
; 85   : 			}
; 86   : 		}
; 87   : 	}
; 88   : }

  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z ENDP ; TMonsterAIUtil::SendMonsterV2Msg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::CheckMovingCondition, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 172  : 	if ( !lpObj->Live )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  0000b	74 76		 je	 SHORT $LN7@CheckMovin

; 173  : 		return FALSE;
; 174  : 
; 175  : 	if ( lpObj->RegenOk > 0 )

  0000d	80 be 8b 05 00
	00 00		 cmp	 BYTE PTR [esi+1419], 0
  00014	7f 6d		 jg	 SHORT $LN7@CheckMovin

; 176  : 		return FALSE;
; 177  : 
; 178  : 	if ( lpObj->Teleport )

  00016	80 be 88 05 00
	00 00		 cmp	 BYTE PTR [esi+1416], 0
  0001d	75 64		 jne	 SHORT $LN7@CheckMovin

; 179  : 		return FALSE;
; 180  : 
; 181  : 	if ( lpObj->m_State != 2 )

  0001f	83 be d0 01 00
	00 02		 cmp	 DWORD PTR [esi+464], 2
  00026	75 5b		 jne	 SHORT $LN7@CheckMovin

; 182  : 		return FALSE;
; 183  : 
; 184  : 	if ( gObjCheckUsedBuffEffect(lpObj,BUFF_ICEARROW) == TRUE ||
; 185  : 		 gObjCheckUsedBuffEffect(lpObj,BUFF_STUN) == TRUE ||
; 186  : 		 gObjCheckUsedBuffEffect(lpObj,BUFF_SLEEP) == TRUE ||
; 187  : 		 gObjCheckUsedBuffEffect(lpObj,BUFF_FREEZE) == TRUE ||

  00028	6a 39		 push	 57			; 00000039H
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00030	83 c4 08	 add	 esp, 8
  00033	3c 01		 cmp	 al, 1
  00035	74 4c		 je	 SHORT $LN7@CheckMovin
  00037	6a 3d		 push	 61			; 0000003dH
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0003f	83 c4 08	 add	 esp, 8
  00042	3c 01		 cmp	 al, 1
  00044	74 3d		 je	 SHORT $LN7@CheckMovin
  00046	6a 48		 push	 72			; 00000048H
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0004e	83 c4 08	 add	 esp, 8
  00051	3c 01		 cmp	 al, 1
  00053	74 2e		 je	 SHORT $LN7@CheckMovin
  00055	68 92 00 00 00	 push	 146			; 00000092H
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00060	83 c4 08	 add	 esp, 8
  00063	3c 01		 cmp	 al, 1
  00065	74 1c		 je	 SHORT $LN7@CheckMovin
  00067	68 93 00 00 00	 push	 147			; 00000093H
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00072	83 c4 08	 add	 esp, 8
  00075	3c 01		 cmp	 al, 1
  00077	74 0a		 je	 SHORT $LN7@CheckMovin

; 190  : 
; 191  : 	return TRUE;

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	5e		 pop	 esi

; 192  : }

  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
$LN7@CheckMovin:

; 188  : 		 gObjCheckUsedBuffEffect(lpObj,BUFF_EARTHBINDS) == TRUE )
; 189  : 		return FALSE;

  00083	33 c0		 xor	 eax, eax
  00085	5e		 pop	 esi

; 192  : }

  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::CheckMovingCondition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMove$ = -8						; size = 8
_lpObj$ = 8						; size = 4
?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::SendMonsterMoveMsg, COMDAT
; _this$ = ecx

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 418  : 	PMSG_RECVMOVE pMove;
; 419  : #if (__ENG__ == 1)
; 420  : 		// KOR PROTOCOL
; 421  : 	PHeadSetB((LPBYTE)&pMove, 0xD4, sizeof(pMove));

  00007	6a 08		 push	 8
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	68 d4 00 00 00	 push	 212			; 000000d4H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 422  : #else
; 423  : 	// KOR PROTOCOL
; 424  : 	PHeadSetB((LPBYTE)&pMove, 0xD7, sizeof(pMove));
; 425  : #endif
; 426  : 
; 427  : 	pMove.NumberH = SET_NUMBERH(lpObj->m_Index);

  00019	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 	pMove.NumberL = SET_NUMBERL(lpObj->m_Index);
; 429  : 	pMove.X = lpObj->MTX;
; 430  : 	pMove.Y = lpObj->MTY;
; 431  : 	pMove.Path = lpObj->Dir << 4;
; 432  : 
; 433  : 	this->SendMonsterV2Msg(lpObj, (LPBYTE)&pMove, pMove.h.size);

  0001f	8b ce		 mov	 ecx, esi
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	c1 e8 08	 shr	 eax, 8
  00026	88 45 fb	 mov	 BYTE PTR _pMove$[ebp+3], al
  00029	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002c	88 45 fc	 mov	 BYTE PTR _pMove$[ebp+4], al
  0002f	0f b6 82 54 01
	00 00		 movzx	 eax, BYTE PTR [edx+340]
  00036	88 45 fd	 mov	 BYTE PTR _pMove$[ebp+5], al
  00039	0f b6 82 55 01
	00 00		 movzx	 eax, BYTE PTR [edx+341]
  00040	88 45 fe	 mov	 BYTE PTR _pMove$[ebp+6], al
  00043	0f b6 82 22 01
	00 00		 movzx	 eax, BYTE PTR [edx+290]
  0004a	c0 e0 04	 shl	 al, 4
  0004d	88 45 ff	 mov	 BYTE PTR _pMove$[ebp+7], al
  00050	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00054	50		 push	 eax
  00055	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  00058	50		 push	 eax
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z ; TMonsterAIUtil::SendMonsterV2Msg

; 434  : 	return TRUE;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5e		 pop	 esi

; 435  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::SendMonsterMoveMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_this$1$ = -168						; size = 4
tv430 = -164						; size = 4
_iTargetY$1$ = -160					; size = 4
tv431 = -156						; size = 4
_iResultX$1$ = -152					; size = 4
_iStartY$1$ = -148					; size = 4
_iStartX$1$ = -144					; size = 4
_iResultY$1$ = -140					; size = 4
tv437 = -133						; size = 1
_Path$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iTargetX$ = 12						; size = 4
_iTargetY$ = 16						; size = 4
_iMaxPathCount$ = 20					; size = 4
_bPreventOverMoving$ = 24				; size = 4
?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z PROC ; TMonsterAIUtil::FindPathToMoveMonster, COMDAT
; _this$ = ecx

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx

; 94   : 	if ( TMonsterAIUtil::CheckMovingCondition(lpObj)==FALSE)

  0001a	56		 push	 esi
  0001b	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _this$1$[ebp], edi
  00021	e8 00 00 00 00	 call	 ?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::CheckMovingCondition
  00026	85 c0		 test	 eax, eax
  00028	0f 84 25 02 00
	00		 je	 $LN11@FindPathTo

; 95   : 		return FALSE;
; 96   : 
; 97   : 	PATH_t Path;
; 98   : 	BOOL bPathFound = FALSE;
; 99   : 
; 100  : 	if ( bPreventOverMoving )
; 101  : 		bPathFound = MapC[lpObj->MapNumber].PathFinding2(lpObj->X, lpObj->Y, iTargetX, iTargetY, &Path);

  0002e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _Path$[ebp]
  00034	50		 push	 eax
  00035	ff 75 10	 push	 DWORD PTR _iTargetY$[ebp]
  00038	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0003f	ff 75 0c	 push	 DWORD PTR _iTargetX$[ebp]
  00042	50		 push	 eax
  00043	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0004a	50		 push	 eax
  0004b	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00052	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00058	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0005e	83 7d 18 00	 cmp	 DWORD PTR _bPreventOverMoving$[ebp], 0
  00062	74 07		 je	 SHORT $LN6@FindPathTo
  00064	e8 00 00 00 00	 call	 ?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding2

; 102  : 	else

  00069	eb 05		 jmp	 SHORT $LN17@FindPathTo
$LN6@FindPathTo:

; 103  : 		bPathFound = MapC[lpObj->MapNumber].PathFinding4(lpObj->X, lpObj->Y, iTargetX, iTargetY, &Path);

  0006b	e8 00 00 00 00	 call	 ?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding4
$LN17@FindPathTo:
  00070	0f b6 c0	 movzx	 eax, al

; 104  : 
; 105  : 	if (bPathFound )

  00073	85 c0		 test	 eax, eax
  00075	0f 84 d8 01 00
	00		 je	 $LN11@FindPathTo

; 106  : 	{
; 107  : 		lpObj->m_LastMoveTime = GetTickCount();

  0007b	53		 push	 ebx
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 108  : 
; 109  : 		int iTargetX;
; 110  : 		int iTargetY;
; 111  : 		int iStartX;
; 112  : 		int iStartY;
; 113  : 		int iResultX;
; 114  : 		int iResultY;
; 115  : 		BYTE btTargetDir = 0;
; 116  : 
; 117  : 		iStartX = lpObj->X;

  00082	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  00089	89 86 58 05 00
	00		 mov	 DWORD PTR [esi+1368], eax

; 118  : 		iStartY = lpObj->Y;
; 119  : 		iResultX = lpObj->X;

  0008f	8b da		 mov	 ebx, edx
  00091	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]

; 120  : 		iResultY = lpObj->Y;

  00098	8b c8		 mov	 ecx, eax
  0009a	89 85 6c ff ff
	ff		 mov	 DWORD PTR _iStartY$1$[ebp], eax

; 121  : 		lpObj->PathCount = Path.PathNum;

  000a0	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _Path$[ebp]
  000a6	89 95 70 ff ff
	ff		 mov	 DWORD PTR _iStartX$1$[ebp], edx
  000ac	89 9d 68 ff ff
	ff		 mov	 DWORD PTR _iResultX$1$[ebp], ebx
  000b2	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _iResultY$1$[ebp], ecx
  000b8	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax

; 122  : 		lpObj->PathCur = 1;

  000be	c7 86 5c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+348], 1

; 123  : 		lpObj->PathStartEnd = 1;

  000c8	c6 86 60 01 00
	00 01		 mov	 BYTE PTR [esi+352], 1

; 124  : 
; 125  : 		if ( lpObj->PathCount > iMaxPathCount )

  000cf	3b 45 14	 cmp	 eax, DWORD PTR _iMaxPathCount$[ebp]
  000d2	7e 09		 jle	 SHORT $LN9@FindPathTo

; 126  : 			lpObj->PathCount = iMaxPathCount;

  000d4	8b 45 14	 mov	 eax, DWORD PTR _iMaxPathCount$[ebp]
  000d7	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax
$LN9@FindPathTo:

; 127  : 
; 128  : 		lpObj->PathX[0] = lpObj->X;

  000dd	8a 86 20 01 00
	00		 mov	 al, BYTE PTR [esi+288]
  000e3	88 86 80 01 00
	00		 mov	 BYTE PTR [esi+384], al

; 129  : 		lpObj->PathY[0] = lpObj->Y;

  000e9	8a 86 21 01 00
	00		 mov	 al, BYTE PTR [esi+289]
  000ef	88 86 8f 01 00
	00		 mov	 BYTE PTR [esi+399], al

; 130  : 		lpObj->PathDir[0] = lpObj->Dir;

  000f5	8a 86 22 01 00
	00		 mov	 al, BYTE PTR [esi+290]
  000fb	88 86 9e 01 00
	00		 mov	 BYTE PTR [esi+414], al

; 131  : 
; 132  : 		for(int n=1;n<lpObj->PathCount;n++)

  00101	83 be 58 01 00
	00 01		 cmp	 DWORD PTR [esi+344], 1
  00108	0f 8e ae 00 00
	00		 jle	 $LN3@FindPathTo
  0010e	b8 71 fe ff ff	 mov	 eax, -399		; fffffe71H
  00113	8d 55 c0	 lea	 edx, DWORD PTR _Path$[ebp+68]
  00116	2b c6		 sub	 eax, esi
  00118	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv431[ebp], edx
  0011e	8d be 90 01 00
	00		 lea	 edi, DWORD PTR [esi+400]
  00124	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv430[ebp], eax
  0012a	66 0f 1f 44 00
	00		 npad	 6
$LL4@FindPathTo:

; 133  : 		{
; 134  : 			iTargetX = Path.PathX[n];
; 135  : 			iTargetY = Path.PathY[n];

  00130	8b 02		 mov	 eax, DWORD PTR [edx]
  00132	8b 5a c4	 mov	 ebx, DWORD PTR [edx-60]
  00135	89 85 60 ff ff
	ff		 mov	 DWORD PTR _iTargetY$1$[ebp], eax

; 136  : 			btTargetDir = GetPathPacketDirPos(iTargetX-iStartX, iTargetY-iStartY);

  0013b	2b 85 6c ff ff
	ff		 sub	 eax, DWORD PTR _iStartY$1$[ebp]
  00141	50		 push	 eax
  00142	8b c3		 mov	 eax, ebx
  00144	2b 85 70 ff ff
	ff		 sub	 eax, DWORD PTR _iStartX$1$[ebp]
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos

; 137  : 			lpObj->PathX[n] = iTargetX;
; 138  : 			lpObj->PathY[n] = iTargetY;

  00150	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _iTargetY$1$[ebp]
  00156	83 c4 08	 add	 esp, 8
  00159	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv431[ebp]
  0015f	88 0f		 mov	 BYTE PTR [edi], cl
  00161	83 c2 04	 add	 edx, 4

; 139  : 			lpObj->PathDir[n] = btTargetDir;
; 140  : 			iResultX += RoadPathTable[btTargetDir*2];

  00164	0f b6 c8	 movzx	 ecx, al
  00167	88 5f f1	 mov	 BYTE PTR [edi-15], bl
  0016a	8b 9d 68 ff ff
	ff		 mov	 ebx, DWORD PTR _iResultX$1$[ebp]
  00170	88 47 0f	 mov	 BYTE PTR [edi+15], al
  00173	47		 inc	 edi
  00174	0f bf 04 8d 00
	00 00 00	 movsx	 eax, WORD PTR ?RoadPathTable@@3PAFA[ecx*4]
  0017c	03 d8		 add	 ebx, eax
  0017e	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv431[ebp], edx

; 141  : 			iResultY += RoadPathTable[btTargetDir*2+1];

  00184	0f bf 04 8d 02
	00 00 00	 movsx	 eax, WORD PTR ?RoadPathTable@@3PAFA[ecx*4+2]
  0018c	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iResultY$1$[ebp]
  00192	03 c8		 add	 ecx, eax
  00194	89 9d 68 ff ff
	ff		 mov	 DWORD PTR _iResultX$1$[ebp], ebx
  0019a	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv430[ebp]
  001a0	03 c7		 add	 eax, edi
  001a2	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _iResultY$1$[ebp], ecx
  001a8	3b 86 58 01 00
	00		 cmp	 eax, DWORD PTR [esi+344]
  001ae	7c 80		 jl	 SHORT $LL4@FindPathTo
  001b0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _iStartX$1$[ebp]
  001b6	8b bd 58 ff ff
	ff		 mov	 edi, DWORD PTR _this$1$[ebp]
$LN3@FindPathTo:

; 142  : 		}
; 143  : 
; 144  : 		lpObj->MTX = iResultX;
; 145  : 		lpObj->MTY = iResultY;
; 146  : 		lpObj->TX = iResultX;
; 147  : 		lpObj->TY = iResultY;
; 148  : 
; 149  : 		if ( lpObj->PathCount > 0 )

  001bc	83 be 58 01 00
	00 00		 cmp	 DWORD PTR [esi+344], 0
  001c3	88 9e 54 01 00
	00		 mov	 BYTE PTR [esi+340], bl
  001c9	88 8e 55 01 00
	00		 mov	 BYTE PTR [esi+341], cl
  001cf	88 9e 52 01 00
	00		 mov	 BYTE PTR [esi+338], bl
  001d5	88 8e 53 01 00
	00		 mov	 BYTE PTR [esi+339], cl
  001db	7e 56		 jle	 SHORT $LN10@FindPathTo

; 150  : 		{
; 151  : 			MapC[lpObj->MapNumber].ClearStandAttr(iStartX, iStartY);

  001dd	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  001e4	ff b5 6c ff ff
	ff		 push	 DWORD PTR _iStartY$1$[ebp]
  001ea	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  001f0	52		 push	 edx
  001f1	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001f7	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 152  : 			MapC[lpObj->MapNumber].SetStandAttr(iResultX, iResultY);

  001fc	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00203	ff b5 74 ff ff
	ff		 push	 DWORD PTR _iResultY$1$[ebp]
  00209	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  0020f	53		 push	 ebx
  00210	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00216	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 153  : 			lpObj->m_OldX = iStartX;

  0021b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _iStartX$1$[ebp]
  00221	88 86 50 01 00
	00		 mov	 BYTE PTR [esi+336], al

; 154  : 			lpObj->m_OldY = iStartY;

  00227	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _iStartY$1$[ebp]
  0022d	88 86 51 01 00
	00		 mov	 BYTE PTR [esi+337], al
$LN10@FindPathTo:

; 155  : 		}
; 156  : 	}
; 157  : 
; 158  : 	if ( bPathFound )
; 159  : 	{
; 160  : 		this->SendMonsterMoveMsg(lpObj);

  00233	56		 push	 esi
  00234	8b cf		 mov	 ecx, edi
  00236	e8 00 00 00 00	 call	 ?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::SendMonsterMoveMsg
  0023b	5b		 pop	 ebx
  0023c	5f		 pop	 edi

; 161  : 		return TRUE;

  0023d	b8 01 00 00 00	 mov	 eax, 1
  00242	5e		 pop	 esi

; 162  : 	}
; 163  : 
; 164  : 	return FALSE;
; 165  : }

  00243	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00246	33 cd		 xor	 ecx, ebp
  00248	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c2 14 00	 ret	 20			; 00000014H
$LN11@FindPathTo:
  00253	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00256	33 c0		 xor	 eax, eax
  00258	5f		 pop	 edi
  00259	33 cd		 xor	 ecx, ebp
  0025b	5e		 pop	 esi
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c2 14 00	 ret	 20			; 00000014H
?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z ENDP ; TMonsterAIUtil::FindPathToMoveMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ??1TMonsterAIUtil@@UAE@XZ
_TEXT	SEGMENT
??1TMonsterAIUtil@@UAE@XZ PROC				; TMonsterAIUtil::~TMonsterAIUtil, COMDAT
; _this$ = ecx

; 21   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TMonsterAIUtil@@6B@

; 22   : 	return;
; 23   : }

  00006	c3		 ret	 0
??1TMonsterAIUtil@@UAE@XZ ENDP				; TMonsterAIUtil::~TMonsterAIUtil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ??0TMonsterAIUtil@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterAIUtil@@QAE@XZ PROC				; TMonsterAIUtil::TMonsterAIUtil, COMDAT
; _this$ = ecx

; 16   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TMonsterAIUtil@@6B@

; 17   : 	return;
; 18   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0TMonsterAIUtil@@QAE@XZ ENDP				; TMonsterAIUtil::TMonsterAIUtil
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 10	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000b	6a ff		 push	 -1
  0000d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00010	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	83 c9 01	 or	 ecx, 1
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1474 :     #pragma warning(push)
; 1475 :     #pragma warning(disable: 4996) // Deprecation
; 1476 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
; 1477 :     #pragma warning(pop)
; 1478 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraiutil.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
