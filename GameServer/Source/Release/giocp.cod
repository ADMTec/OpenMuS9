; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\giocp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ErrorMsg@@3PADA				; ErrorMsg
PUBLIC	?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A	; SOCKET_FLAG
PUBLIC	?g_dwThreadCount@@3KA				; g_dwThreadCount
PUBLIC	?g_ThreadHandles@@3PAPAXA			; g_ThreadHandles
PUBLIC	?g_Listen@@3IA					; g_Listen
PUBLIC	?g_ServerPort@@3HA				; g_ServerPort
PUBLIC	?g_CompletionPort@@3PAXA			; g_CompletionPort
PUBLIC	?g_IocpThreadHandle@@3PAXA			; g_IocpThreadHandle
PUBLIC	?ExSendBuf@@3PAEA				; ExSendBuf
_BSS	SEGMENT
?ErrorMsg@@3PADA DB 0200H DUP (?)			; ErrorMsg
?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A DD 01H DUP (?) ; SOCKET_FLAG
?g_dwThreadCount@@3KA DD 01H DUP (?)			; g_dwThreadCount
?g_ThreadHandles@@3PAPAXA DD 064H DUP (?)		; g_ThreadHandles
?g_ServerPort@@3HA DD 01H DUP (?)			; g_ServerPort
?g_CompletionPort@@3PAXA DD 01H DUP (?)			; g_CompletionPort
?g_IocpThreadHandle@@3PAXA DD 01H DUP (?)		; g_IocpThreadHandle
?ExSendBuf@@3PAEA DD 01H DUP (?)			; ExSendBuf
_BSS	ENDS
_DATA	SEGMENT
?g_Listen@@3IA DD 0ffffffffH				; g_Listen
_DATA	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	??1CStreamPacketEngine_Server@@UAE@XZ		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
PUBLIC	?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z	; CStreamPacketEngine_Server::XorData
PUBLIC	?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
PUBLIC	??_GCStreamPacketEngine_Server@@UAEPAXI@Z	; CStreamPacketEngine_Server::`scalar deleting destructor'
PUBLIC	?GiocpInit@@YAXXZ				; GiocpInit
PUBLIC	?IocpServerStart@@YAHXZ				; IocpServerStart
PUBLIC	?CreateGIocp@@YAHH@Z				; CreateGIocp
PUBLIC	?DataSend@@YAHHPAEK@Z				; DataSend
PUBLIC	?UpdateCompletionPort@@YAHIHH@Z			; UpdateCompletionPort
PUBLIC	?CloseClient@@YAXH@Z				; CloseClient
PUBLIC	?DestroyGIocp@@YAXXZ				; DestroyGIocp
PUBLIC	?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z	; ParsingRecvData
PUBLIC	?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z	; CloseClient
PUBLIC	?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoSendSecond
PUBLIC	?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoMoreSend
PUBLIC	?IocpServerWorker@@YAKXZ			; IocpServerWorker
PUBLIC	?IOCPWorkerThread@@YGKPAX@Z			; IOCPWorkerThread
PUBLIC	?GiocpDelete@@YAXXZ				; GiocpDelete
PUBLIC	??0CCriticalSec@@QAE@XZ				; CCriticalSec::CCriticalSec
PUBLIC	??1CCriticalSec@@QAE@XZ				; CCriticalSec::~CCriticalSec
PUBLIC	??0CCSLock@@QAE@PAVCCriticalSec@@@Z		; CCSLock::CCSLock
PUBLIC	??1CCSLock@@QAE@XZ				; CCSLock::~CCSLock
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?GetLastErrorMsg@@YAXXZ				; GetLastErrorMsg
PUBLIC	?CreateListenSocket@@YAHXZ			; CreateListenSocket
PUBLIC	?IOCPRecvSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z ; IOCPRecvSignal
PUBLIC	?IOCPSendSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z ; IOCPSendSignal
PUBLIC	?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z	; ProcessIOCPSignal
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`vftable'
PUBLIC	??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@ ; `string'
PUBLIC	??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@ ; `string'
PUBLIC	?g_CS@@3VCCriticalSec@@A			; g_CS
PUBLIC	?g_SendLock@@3VCCriticalSec@@A			; g_SendLock
PUBLIC	??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@ ; `string'
PUBLIC	??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@ ; `string'
PUBLIC	??_C@_0CF@MEAMLEDD@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@ ; `string'
PUBLIC	??_C@_0DA@HFGJCKJJ@CreateIoCompletionPort?5failed?5wi@ ; `string'
PUBLIC	??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0CD@JEADPJBA@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0CP@JIINKMOF@IOCPRecvSignal?5?9?$DO?5User?5disconnec@ ; `string'
PUBLIC	??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_0DG@GCDCFHEB@IOCPWorkerThread?3?5GetQueueComple@ ; `string'
PUBLIC	??_C@_09ELJFIOPP@giocp?4cpp?$AA@		; `string'
PUBLIC	??_C@_0DG@FFKKCAKG@error?9L1?5?3?5Header?$CI?$CF02X?$CJ?5error?5?$CI?$CF@ ; `string'
PUBLIC	??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@ ; `string'
PUBLIC	??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@ ; `string'
PUBLIC	??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CB@MDIGBGGE@Message?5copy?5?$CFd?0?5packet?5size?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@ ; `string'
PUBLIC	??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	??_C@_0CC@BPEFPLLL@Error?5?3?5File?5?3?5?$FL?$CFs?$FN?0?5Line?5?3?5?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0P@ILILJDMA@?$CFd?5packet?5len?6?$AA@	; `string'
PUBLIC	??_C@_0CC@LDGOPEFD@Error?5CPHandle?5?$DN?5?$CFd?0?5SOCKET?5?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_R4CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCStreamPacketEngine_Server@@@8		; CStreamPacketEngine_Server `RTTI Type Descriptor'
PUBLIC	??_R3CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CStreamPacketEngine_Server@@8	; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	_strcpy_s:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateIoCompletionPort@16:PROC
EXTRN	__imp__GetQueuedCompletionStatus@20:PROC
EXTRN	__imp__PostQueuedCompletionStatus@16:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	__imp__listen@8:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSAAccept@20:PROC
EXTRN	__imp__WSARecv@28:PROC
EXTRN	__imp__WSASend@28:PROC
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?LogAddHeadHexFunc@@YAXHPADH@Z:PROC		; LogAddHeadHexFunc
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??_ECStreamPacketEngine_Server@@UAEPAXI@Z:PROC	; CStreamPacketEngine_Server::`vector deleting destructor'
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?ProtocolCore@@YAXEPAEHHHH@Z:PROC		; ProtocolCore
EXTRN	?SCPJoinResultSend@@YAXHE@Z:PROC		; SCPJoinResultSend
EXTRN	?gObjAddSearch@@YAFIPAD@Z:PROC			; gObjAddSearch
EXTRN	?gObjAdd@@YAFIPADH@Z:PROC			; gObjAdd
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?GetSendSerial@NSerialCheck@@QAEEXZ:PROC	; NSerialCheck::GetSendSerial
EXTRN	?Encrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Encrypt
EXTRN	?Decrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Decrypt
EXTRN	?CG_LiveProc@CheatGuard@@QAE_NPAUOBJECTSTRUCT@@PAUPacketCheatGuardCGClientInfo@@HH@Z:PROC ; CheatGuard::CG_LiveProc
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memcpy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
EXTRN	?g_SimpleModulus@@3VCSimpleModulus@@A:BYTE	; g_SimpleModulus
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?g_CheatGuard@@3VCheatGuard@@A:BYTE		; g_CheatGuard
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_CS@@3VCCriticalSec@@A DB 018H DUP (?)		; g_CS
?g_SendLock@@3VCCriticalSec@@A DB 018H DUP (?)		; g_SendLock
_BSS	ENDS
CRT$XCU	SEGMENT
?g_CS$initializer$@@3P6AXXZA DD FLAT:??__Eg_CS@@YAXXZ	; g_CS$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 DD FLAT:??_R0?AVCStreamPacketEngine_Server@@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R2CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R2CStreamPacketEngine_Server@@8 DD FLAT:??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R3CStreamPacketEngine_Server@@8 DD 00H		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCStreamPacketEngine_Server@@@8
data$r	SEGMENT
??_R0?AVCStreamPacketEngine_Server@@@8 DD FLAT:??_7type_info@@6B@ ; CStreamPacketEngine_Server `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCStreamPacketEngine_Server@@', 00H
data$r	ENDS
;	COMDAT ??_R4CStreamPacketEngine_Server@@6B@
rdata$r	SEGMENT
??_R4CStreamPacketEngine_Server@@6B@ DD 00H		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCStreamPacketEngine_Server@@@8
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@ DB 'CreateIoCompl'
	DB	'etionPort: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LDGOPEFD@Error?5CPHandle?5?$DN?5?$CFd?0?5SOCKET?5?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CC@LDGOPEFD@Error?5CPHandle?5?$DN?5?$CFd?0?5SOCKET?5?$FL?$CFd?$FN@ DB 'E'
	DB	'rror CPHandle = %d, SOCKET [%d]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ILILJDMA@?$CFd?5packet?5len?6?$AA@
CONST	SEGMENT
??_C@_0P@ILILJDMA@?$CFd?5packet?5len?6?$AA@ DB '%d packet len', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BPEFPLLL@Error?5?3?5File?5?3?5?$FL?$CFs?$FN?0?5Line?5?3?5?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CC@BPEFPLLL@Error?5?3?5File?5?3?5?$FL?$CFs?$FN?0?5Line?5?3?5?$FL?$CFd?$FN@ DB 'E'
	DB	'rror : File : [%s], Line : [%d]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@ DB 'W'
	DB	'SASend(%d) failed with error %d %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@
CONST	SEGMENT
??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@ DB '('
	DB	'%d)WSASend(%d) failed with error [%x][%x] %d %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
CONST	SEGMENT
??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
CONST	SEGMENT
??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@ DB 'E'
	DB	'rror : Max msg(%d) %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MDIGBGGE@Message?5copy?5?$CFd?0?5packet?5size?3?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MDIGBGGE@Message?5copy?5?$CFd?0?5packet?5size?3?5?$CFd@ DB 'Mes'
	DB	'sage copy %d, packet size: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@ DB 'er'
	DB	'ror-L1 : recvbuflen 1 %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
CONST	SEGMENT
??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@ DB 'error-L1 : '
	DB	'CStreamPacketEngine ExtractPacket Error : ip = %s account:%s '
	DB	'name:%s HEAD:%x (%s,%d) State:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@
CONST	SEGMENT
??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@ DB 'error-L1 : '
	DB	'CStreamPacketEngine Adding Error : ip = %s account:%s name:%s'
	DB	' HEAD:%x (%s,%d) State:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@ DB 'error-L1 : size %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FFKKCAKG@error?9L1?5?3?5Header?$CI?$CF02X?$CJ?5error?5?$CI?$CF@
CONST	SEGMENT
??_C@_0DG@FFKKCAKG@error?9L1?5?3?5Header?$CI?$CF02X?$CJ?5error?5?$CI?$CF@ DB 'e'
	DB	'rror-L1 : Header(%02X) error (%s %d)lOfs:%d, size:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
CONST	SEGMENT
??_C@_09ELJFIOPP@giocp?4cpp?$AA@ DB 'giocp.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GCDCFHEB@IOCPWorkerThread?3?5GetQueueComple@
CONST	SEGMENT
??_C@_0DG@GCDCFHEB@IOCPWorkerThread?3?5GetQueueComple@ DB 'IOCPWorkerThre'
	DB	'ad: GetQueueCompletionStatus( %d , %s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@ DB 'Conne'
	DB	'ction Closed, dwIoSize == 0 (Index:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ DB 'W'
	DB	'SARecv() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JIINKMOF@IOCPRecvSignal?5?9?$DO?5User?5disconnec@
CONST	SEGMENT
??_C@_0CP@JIINKMOF@IOCPRecvSignal?5?9?$DO?5User?5disconnec@ DB 'IOCPRecvS'
	DB	'ignal -> User disconnected - [%d](%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JEADPJBA@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0CD@JEADPJBA@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?0?5@ DB 'W'
	DB	'SARecv() failed with error %d, %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@
CONST	SEGMENT
??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@ DB 'e'
	DB	'rror-L1 : %d %d gObjAdd() failed with error %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HFGJCKJJ@CreateIoCompletionPort?5failed?5wi@
CONST	SEGMENT
??_C@_0DA@HFGJCKJJ@CreateIoCompletionPort?5failed?5wi@ DB 'CreateIoComple'
	DB	'tionPort failed with error %d, %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@
CONST	SEGMENT
??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@ DB 'error-L2'
	DB	' : ClientIndex = -1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MEAMLEDD@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CF@MEAMLEDD@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'WSA'
	DB	'Accept() failed with error %d, %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@
CONST	SEGMENT
??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@ DB 'CreateIoComple'
	DB	'tionPort failed with error: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ DB 'li'
	DB	'sten() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'WSA'
	DB	'Socket() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
CONST	SEGMENT
??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@ DB 'CreateT'
	DB	'hread() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
CONST	SEGMENT
??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@ DB 'CStreamPacketEn'
	DB	'gine Adding Buffer Size Error %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@
CONST	SEGMENT
??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@ DB 'CStreamPacketE'
	DB	'ngine XorData Error %d,%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CStreamPacketEngine_Server@@6B@
CONST	SEGMENT
??_7CStreamPacketEngine_Server@@6B@ DD FLAT:??_R4CStreamPacketEngine_Server@@6B@ ; CStreamPacketEngine_Server::`vftable'
	DD	FLAT:??_ECStreamPacketEngine_Server@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z$0
__ehfuncinfo$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateListenSocket@@YAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateListenSocket@@YAHXZ$0
__ehfuncinfo$?CreateListenSocket@@YAHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateListenSocket@@YAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?IocpServerWorker@@YAKXZ DD 0ffffffe4H
	DD	00H
	DD	0ffffff8cH
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN49@IocpServer
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z$0
__ehfuncinfo$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z$2
__ehfuncinfo$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DataSend@@YAHHPAEK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DataSend@@YAHHPAEK@Z$0
__ehfuncinfo$?DataSend@@YAHHPAEK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DataSend@@YAHHPAEK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_SendLock$initializer$@@3P6AXXZA DD FLAT:??__Eg_SendLock@@YAXXZ ; g_SendLock$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_cs$ = 8						; size = 4
_ClientIndex$ = 8					; size = 4
_dwIoSize$ = 12						; size = 4
_lpOverlapped$ = 16					; size = 4
?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z PROC	; ProcessIOCPSignal, COMDAT

; 421  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 422  : 	LPPER_SOCKET_CONTEXT	lpPerSocketContext = NULL;
; 423  : 	LPPER_IO_CONTEXT		lpIOContext = NULL;
; 424  : 
; 425  : 	if( ClientIndex < OBJ_STARTUSERINDEX || ClientIndex >= OBJMAX ) return;

  00023	8b 75 08	 mov	 esi, DWORD PTR _ClientIndex$[ebp]
  00026	8d 86 fc d6 ff
	ff		 lea	 eax, DWORD PTR [esi-10500]
  0002c	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00031	77 7b		 ja	 SHORT $LN3@ProcessIOC

; 426  : 
; 427  : 	CCSLock cs(&g_SendLock);

  00033	68 00 00 00 00	 push	 OFFSET ?g_SendLock@@3VCCriticalSec@@A ; g_SendLock
  00038	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0CCSLock@@QAE@PAVCCriticalSec@@@Z ; CCSLock::CCSLock

; 428  : 
; 429  : 	lpPerSocketContext = gObj[ClientIndex].PerSocketContext;

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	8b 74 01 14	 mov	 esi, DWORD PTR [ecx+eax+20]

; 430  : 	
; 431  : 	InterlockedDecrement(&lpPerSocketContext->dwIOCount);

  00056	f0 ff 8e e8 38
	01 00		 lock	  dec	 DWORD PTR [esi+80104]

; 432  : 
; 433  : 	if( 0 == dwIoSize )

  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _dwIoSize$[ebp]
  00060	85 c9		 test	 ecx, ecx
  00062	75 1b		 jne	 SHORT $LN4@ProcessIOC

; 434  : 	{
; 435  : 			////g_CS.Lock();
; 436  : 		LogAdd("Connection Closed, dwIoSize == 0 (Index:%d)", lpPerSocketContext->nIndex);

  00064	ff 76 04	 push	 DWORD PTR [esi+4]
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 437  : 		////g_CS.UnLock();
; 438  : 		CloseClient(lpPerSocketContext, FALSE);

  00072	6a 00		 push	 0
  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	eb 27		 jmp	 SHORT $LN7@ProcessIOC
$LN4@ProcessIOC:

; 439  : 		return;
; 440  : 	}
; 441  : 
; 442  : 	lpIOContext = (LPPER_IO_CONTEXT)lpOverlapped;
; 443  : 
; 444  : 	if( lpIOContext->IOOperation == SEND_IO )

  0007f	8b 45 10	 mov	 eax, DWORD PTR _lpOverlapped$[ebp]
  00082	8b 90 68 9c 00
	00		 mov	 edx, DWORD PTR [eax+40040]
  00088	83 fa 01	 cmp	 edx, 1
  0008b	75 0a		 jne	 SHORT $LN5@ProcessIOC

; 445  : 	{
; 446  : 		IOCPSendSignal(lpPerSocketContext, lpIOContext, dwIoSize);

  0008d	51		 push	 ecx
  0008e	50		 push	 eax
  0008f	56		 push	 esi
  00090	e8 00 00 00 00	 call	 ?IOCPSendSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z ; IOCPSendSignal
  00095	eb 0c		 jmp	 SHORT $LN12@ProcessIOC
$LN5@ProcessIOC:

; 447  : 	}
; 448  : 	else if( lpIOContext->IOOperation == RECV_IO )

  00097	85 d2		 test	 edx, edx
  00099	75 0b		 jne	 SHORT $LN7@ProcessIOC

; 449  : 	{
; 450  : 		IOCPRecvSignal(lpPerSocketContext, lpIOContext, dwIoSize);

  0009b	51		 push	 ecx
  0009c	50		 push	 eax
  0009d	56		 push	 esi
  0009e	e8 00 00 00 00	 call	 ?IOCPRecvSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z ; IOCPRecvSignal
$LN12@ProcessIOC:
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@ProcessIOC:

; 451  : 	}
; 452  : }

  000a6	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  000a9	e8 00 00 00 00	 call	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
$LN3@ProcessIOC:
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b8	59		 pop	 ecx
  000b9	5e		 pop	 esi
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
__ehhandler$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z ENDP	; ProcessIOCPSignal
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?IOCPSendSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z
_TEXT	SEGMENT
_lpPerSocketContext$ = 8				; size = 4
_lpIOContext$ = 12					; size = 4
_dwIoSize$ = 16						; size = 4
?IOCPSendSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z PROC ; IOCPSendSignal, COMDAT

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 401  : 	int aIndex = lpPerSocketContext->nIndex;

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpPerSocketContext$[ebp]
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 402  : 
; 403  : 	if( aIndex < OBJ_STARTUSERINDEX || aIndex >= OBJMAX ) return;

  00009	05 fc d6 ff ff	 add	 eax, -10500		; ffffd6fcH
  0000e	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00013	77 41		 ja	 SHORT $LN3@IOCPSendSi

; 404  : 
; 405  : 	lpIOContext->nSentBytes += dwIoSize;

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _lpIOContext$[ebp]
  00018	8b 45 10	 mov	 eax, DWORD PTR _dwIoSize$[ebp]
  0001b	01 81 64 9c 00
	00		 add	 DWORD PTR [ecx+40036], eax
  00021	8b 81 64 9c 00
	00		 mov	 eax, DWORD PTR [ecx+40036]

; 406  : 	if( lpIOContext->nSentBytes >= lpIOContext->nTotalBytes )

  00027	3b 81 60 9c 00
	00		 cmp	 eax, DWORD PTR [ecx+40032]
  0002d	7c 1e		 jl	 SHORT $LN4@IOCPSendSi

; 407  : 	{
; 408  : 		lpIOContext->nWaitIO = 0;
; 409  : 		if( lpIOContext->nSecondOfs > 0 )

  0002f	83 b9 5c 9c 00
	00 00		 cmp	 DWORD PTR [ecx+40028], 0
  00036	c7 81 6c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+40044], 0
  00040	7e 14		 jle	 SHORT $LN3@IOCPSendSi

; 410  : 		{
; 411  : 			IoSendSecond(lpPerSocketContext);

  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoSendSecond

; 412  : 		}
; 413  : 	}
; 414  : 	else
; 415  : 	{
; 416  : 		IoMoreSend(lpPerSocketContext);

  00048	83 c4 04	 add	 esp, 4

; 417  : 	}
; 418  : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN4@IOCPSendSi:

; 412  : 		}
; 413  : 	}
; 414  : 	else
; 415  : 	{
; 416  : 		IoMoreSend(lpPerSocketContext);

  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoMoreSend
  00053	83 c4 04	 add	 esp, 4
$LN3@IOCPSendSi:

; 417  : 	}
; 418  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?IOCPSendSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z ENDP ; IOCPSendSignal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?IOCPRecvSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z
_TEXT	SEGMENT
_RecvBytes$ = -4					; size = 4
_lpPerSocketContext$ = 8				; size = 4
_Flags$ = 12						; size = 4
_lpIOContext$ = 12					; size = 4
_dwIoSize$ = 16						; size = 4
?IOCPRecvSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z PROC ; IOCPRecvSignal, COMDAT

; 349  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 350  : 	DWORD	RecvBytes = 0;
; 351  : 	lpIOContext->nSentBytes += dwIoSize;

  00004	8b 45 10	 mov	 eax, DWORD PTR _dwIoSize$[ebp]
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _lpIOContext$[ebp]
  0000b	57		 push	 edi

; 352  : 	
; 353  : 	if( gObj[lpPerSocketContext->nIndex].Connected < 1 )

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _lpPerSocketContext$[ebp]
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _RecvBytes$[ebp], 0
  00016	01 86 64 9c 00
	00		 add	 DWORD PTR [esi+40036], eax
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00024	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  0002a	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  0002f	7d 1b		 jge	 SHORT $LN2@IOCPRecvSi

; 354  : 	{
; 355  : 		LogAdd("IOCPRecvSignal -> User disconnected - [%d](%s)",

  00031	83 c0 1c	 add	 eax, 28			; 0000001cH
  00034	03 c1		 add	 eax, ecx
  00036	50		 push	 eax
  00037	52		 push	 edx
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JIINKMOF@IOCPRecvSignal?5?9?$DO?5User?5disconnec@
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 396  : 	}
; 397  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN2@IOCPRecvSi:

; 356  : 			lpPerSocketContext->nIndex,gObj[lpPerSocketContext->nIndex].Ip_addr);
; 357  : 		return;
; 358  : 	}
; 359  : 
; 360  : 
; 361  : 	if( !ParsingRecvData(lpIOContext, lpPerSocketContext->nIndex) )

  0004c	52		 push	 edx
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 ?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z ; ParsingRecvData
  00053	83 c4 08	 add	 esp, 8

; 362  : 	{
; 363  : 		CloseClient( lpPerSocketContext, 0 );

  00056	6a 00		 push	 0
  00058	85 c0		 test	 eax, eax
  0005a	75 19		 jne	 SHORT $LN3@IOCPRecvSi
  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  00062	83 c4 08	 add	 esp, 8

; 364  : 		lpIOContext->nWaitIO =0;

  00065	c7 86 6c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40044], 0
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 396  : 	}
; 397  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN3@IOCPRecvSi:

; 365  : 		return;
; 366  : 	}
; 367  : 	
; 368  : 	lpIOContext->nWaitIO = 0;

  00075	c7 86 6c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40044], 0

; 369  : 
; 370  : 	ZeroMemory(&(lpIOContext->Overlapped), sizeof(OVERLAPPED));		
; 371  : 	lpIOContext->wsabuf.len		= MAX_BUFF_SIZE-lpIOContext->nSentBytes;

  0007f	8d 56 14	 lea	 edx, DWORD PTR [esi+20]
  00082	0f 57 c0	 xorps	 xmm0, xmm0

; 372  : 	lpIOContext->wsabuf.buf		= lpIOContext->Buffer+lpIOContext->nSentBytes;
; 373  : 	lpIOContext->IOOperation	= RECV_IO;		
; 374  : 
; 375  : 	DWORD Flags = 0;

  00085	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _Flags$[ebp], 0
  0008c	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0008f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00096	b8 20 4e 00 00	 mov	 eax, 20000		; 00004e20H
  0009b	8b 8e 64 9c 00
	00		 mov	 ecx, DWORD PTR [esi+40036]
  000a1	2b c1		 sub	 eax, ecx
  000a3	89 02		 mov	 DWORD PTR [edx], eax
  000a5	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  000a8	03 c1		 add	 eax, ecx
  000aa	c7 86 68 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40040], 0

; 376  : 	int nRet = WSARecv(lpPerSocketContext->m_socket, &(lpIOContext->wsabuf), 1, &RecvBytes, &Flags,

  000b4	56		 push	 esi
  000b5	89 46 18	 mov	 DWORD PTR [esi+24], eax
  000b8	8d 45 0c	 lea	 eax, DWORD PTR _Flags$[ebp]
  000bb	50		 push	 eax
  000bc	8d 45 fc	 lea	 eax, DWORD PTR _RecvBytes$[ebp]
  000bf	50		 push	 eax
  000c0	6a 01		 push	 1
  000c2	52		 push	 edx
  000c3	ff 37		 push	 DWORD PTR [edi]
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28

; 377  : 		&(lpIOContext->Overlapped), NULL);
; 378  : 
; 379  : 	if( nRet == SOCKET_ERROR && (WSAGetLastError() != ERROR_IO_PENDING) )

  000cb	83 f8 ff	 cmp	 eax, -1
  000ce	75 46		 jne	 SHORT $LN4@IOCPRecvSi
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000d6	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000db	74 39		 je	 SHORT $LN4@IOCPRecvSi

; 380  : 	{
; 381  : #if(ENABLE_CUSTOM_OFFLINETRADE == 1)
; 382  : 		if( !gObj[lpPerSocketContext->nIndex].bOffTrade )

  000dd	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e9	80 bc 01 31 27
	00 00 00	 cmp	 BYTE PTR [ecx+eax+10033], 0
  000f1	75 34		 jne	 SHORT $LN5@IOCPRecvSi

; 383  : 		{
; 384  : 			LogAdd("WSARecv() failed with error %d", WSAGetLastError());

  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000f9	50		 push	 eax
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 385  : 			CloseClient( lpPerSocketContext, FALSE);

  00105	6a 00		 push	 0
  00107	57		 push	 edi
  00108	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  0010d	83 c4 10	 add	 esp, 16			; 00000010H
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi

; 396  : 	}
; 397  : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
$LN4@IOCPRecvSi:

; 386  : 		}
; 387  : #else
; 388  : 		LogAdd("WSARecv() failed with error %d", WSAGetLastError());
; 389  : 		CloseClient( lpPerSocketContext, FALSE);
; 390  : #endif
; 391  : 	}
; 392  : 	else
; 393  : 	{	
; 394  : 		InterlockedIncrement(&lpPerSocketContext->dwIOCount);

  00116	f0 ff 87 e8 38
	01 00		 lock	  inc	 DWORD PTR [edi+80104]

; 395  : 		lpIOContext->nWaitIO = 1;

  0011d	c7 86 6c 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+40044], 1
$LN5@IOCPRecvSi:
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi

; 396  : 	}
; 397  : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
?IOCPRecvSignal@@YAXPAU_PER_SOCKET_CONTEXT@@PAU_PER_IO_CONTEXT@@K@Z ENDP ; IOCPRecvSignal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?CreateListenSocket@@YAHXZ
_TEXT	SEGMENT
_cs$ = -36						; size = 4
_InternetAddr$ = -32					; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CreateListenSocket@@YAHXZ PROC				; CreateListenSocket, COMDAT

; 147  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateListenSocket@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 148  : 	SOCKADDR_IN InternetAddr;
; 149  : 	int			nRet;
; 150  : 
; 151  : 	CCSLock cs(&g_CS);

  00029	68 00 00 00 00	 push	 OFFSET ?g_CS@@3VCCriticalSec@@A ; g_CS
  0002e	8d 4d dc	 lea	 ecx, DWORD PTR _cs$[ebp]
  00031	e8 00 00 00 00	 call	 ??0CCSLock@@QAE@PAVCCriticalSec@@@Z ; CCSLock::CCSLock

; 152  : 	
; 153  : 	g_Listen = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);

  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 01		 push	 1
  00040	6a 02		 push	 2
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  0004f	a3 00 00 00 00	 mov	 DWORD PTR ?g_Listen@@3IA, eax ; g_Listen

; 154  : 	
; 155  : 	if (g_Listen == INVALID_SOCKET)

  00054	83 f8 ff	 cmp	 eax, -1
  00057	75 1c		 jne	 SHORT $LN2@CreateList

; 156  : 	{
; 157  : 		LogAdd("WSASocket() failed with error %d", WSAGetLastError());

  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@

; 177  : 	{
; 178  : 		LogAdd("listen() failed with error %d", WSAGetLastError());

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0006b	83 c4 08	 add	 esp, 8
  0006e	33 f6		 xor	 esi, esi
  00070	e9 9f 00 00 00	 jmp	 $LN9@CreateList
$LN2@CreateList:

; 158  : 		return FALSE;
; 159  : 	}
; 160  : 
; 161  : 	InternetAddr.sin_family			= AF_INET;

  00075	b8 02 00 00 00	 mov	 eax, 2

; 162  : 	InternetAddr.sin_addr.s_addr	= htonl(INADDR_ANY);

  0007a	6a 00		 push	 0
  0007c	66 89 45 e0	 mov	 WORD PTR _InternetAddr$[ebp], ax
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4
  00086	89 45 e4	 mov	 DWORD PTR _InternetAddr$[ebp+4], eax

; 163  : 	InternetAddr.sin_port			= htons(g_ServerPort);

  00089	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?g_ServerPort@@3HA
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00097	66 89 45 e2	 mov	 WORD PTR _InternetAddr$[ebp+2], ax

; 164  : 
; 165  : 	nRet = bind(g_Listen, (PSOCKADDR) &InternetAddr, sizeof(InternetAddr));

  0009b	8d 45 e0	 lea	 eax, DWORD PTR _InternetAddr$[ebp]
  0009e	6a 10		 push	 16			; 00000010H
  000a0	50		 push	 eax
  000a1	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_Listen@@3IA ; g_Listen
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12

; 166  : 
; 167  : 	if( nRet == SOCKET_ERROR )

  000ad	83 f8 ff	 cmp	 eax, -1
  000b0	75 2e		 jne	 SHORT $LN3@CreateList

; 168  : 	{
; 169  : 		MsgBox(lMsg.Get(MSGGET(2, 55)));

  000b2	68 37 02 00 00	 push	 567			; 00000237H
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000bc	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000c7	83 c4 04	 add	 esp, 4

; 170  : 		SendMessage(ghWnd, WM_CLOSE, 0,0);

  000ca	6a 00		 push	 0
  000cc	6a 00		 push	 0
  000ce	6a 10		 push	 16			; 00000010H
  000d0	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  000dc	33 f6		 xor	 esi, esi
  000de	eb 34		 jmp	 SHORT $LN9@CreateList
$LN3@CreateList:

; 171  : 		return FALSE;
; 172  : 	}
; 173  : 	
; 174  : 	nRet = listen(g_Listen, SOMAXCONN);

  000e0	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  000e5	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_Listen@@3IA ; g_Listen
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__listen@8

; 175  : 
; 176  : 	if (nRet == SOCKET_ERROR)

  000f1	83 f8 ff	 cmp	 eax, -1
  000f4	75 19		 jne	 SHORT $LN4@CreateList

; 177  : 	{
; 178  : 		LogAdd("listen() failed with error %d", WSAGetLastError());

  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000fc	50		 push	 eax
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00108	83 c4 08	 add	 esp, 8
  0010b	33 f6		 xor	 esi, esi
  0010d	eb 05		 jmp	 SHORT $LN9@CreateList
$LN4@CreateList:

; 179  : 		return FALSE;
; 180  : 	}
; 181  : 
; 182  : 	return TRUE;

  0010f	be 01 00 00 00	 mov	 esi, 1
$LN9@CreateList:
  00114	8d 4d dc	 lea	 ecx, DWORD PTR _cs$[ebp]
  00117	e8 00 00 00 00	 call	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
  0011c	8b c6		 mov	 eax, esi

; 183  : }

  0011e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00121	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00128	59		 pop	 ecx
  00129	5e		 pop	 esi
  0012a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateListenSocket@@YAHXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _cs$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
__ehhandler$?CreateListenSocket@@YAHXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateListenSocket@@YAHXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateListenSocket@@YAHXZ ENDP				; CreateListenSocket
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_SendLock@@YAXXZ
text$yd	SEGMENT
??__Fg_SendLock@@YAXXZ PROC				; `dynamic atexit destructor for 'g_SendLock'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SendLock@@3VCCriticalSec@@A ; g_SendLock
  00005	e9 00 00 00 00	 jmp	 ??1CCriticalSec@@QAE@XZ	; CCriticalSec::~CCriticalSec
??__Fg_SendLock@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_SendLock''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ??__Eg_SendLock@@YAXXZ
text$di	SEGMENT
??__Eg_SendLock@@YAXXZ PROC				; `dynamic initializer for 'g_SendLock'', COMDAT

; 83   : CCriticalSec	 g_SendLock;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SendLock@@3VCCriticalSec@@A ; g_SendLock
  00005	e8 00 00 00 00	 call	 ??0CCriticalSec@@QAE@XZ	; CCriticalSec::CCriticalSec
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_SendLock@@YAXXZ ; `dynamic atexit destructor for 'g_SendLock''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_SendLock@@YAXXZ ENDP				; `dynamic initializer for 'g_SendLock''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_CS@@YAXXZ
text$yd	SEGMENT
??__Fg_CS@@YAXXZ PROC					; `dynamic atexit destructor for 'g_CS'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CS@@3VCCriticalSec@@A ; g_CS
  00005	e9 00 00 00 00	 jmp	 ??1CCriticalSec@@QAE@XZ	; CCriticalSec::~CCriticalSec
??__Fg_CS@@YAXXZ ENDP					; `dynamic atexit destructor for 'g_CS''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ??__Eg_CS@@YAXXZ
text$di	SEGMENT
??__Eg_CS@@YAXXZ PROC					; `dynamic initializer for 'g_CS'', COMDAT

; 82   : CCriticalSec	 g_CS;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CS@@3VCCriticalSec@@A ; g_CS
  00005	e8 00 00 00 00	 call	 ??0CCriticalSec@@QAE@XZ	; CCriticalSec::CCriticalSec
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_CS@@YAXXZ	; `dynamic atexit destructor for 'g_CS''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_CS@@YAXXZ ENDP					; `dynamic initializer for 'g_CS''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?GetLastErrorMsg@@YAXXZ
_TEXT	SEGMENT
_lpMsgBuf$ = -4						; size = 4
?GetLastErrorMsg@@YAXXZ PROC				; GetLastErrorMsg, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 57   : 	LPVOID lpMsgBuf;
; 58   : 	FormatMessage( 

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	8d 45 fc	 lea	 eax, DWORD PTR _lpMsgBuf$[ebp]
  0000b	50		 push	 eax
  0000c	6a 00		 push	 0
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	68 00 13 00 00	 push	 4864			; 00001300H
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 59   : 		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 60   : 		FORMAT_MESSAGE_FROM_SYSTEM | 
; 61   : 		FORMAT_MESSAGE_IGNORE_INSERTS,
; 62   : 		NULL,
; 63   : 		GetLastError(),
; 64   : 		0, // Default language
; 65   : 		(LPTSTR) &lpMsgBuf,
; 66   : 		0,
; 67   : 		NULL 
; 68   : 	);
; 69   : 
; 70   : 	strcpy_s(ErrorMsg, sizeof(ErrorMsg), (LPCTSTR)lpMsgBuf);

  00022	ff 75 fc	 push	 DWORD PTR _lpMsgBuf$[ebp]
  00025	68 00 02 00 00	 push	 512			; 00000200H
  0002a	68 00 00 00 00	 push	 OFFSET ?ErrorMsg@@3PADA	; ErrorMsg
  0002f	e8 00 00 00 00	 call	 _strcpy_s
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 71   : 	LocalFree( lpMsgBuf );

  00037	ff 75 fc	 push	 DWORD PTR _lpMsgBuf$[ebp]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 72   : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?GetLastErrorMsg@@YAXXZ ENDP				; GetLastErrorMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\giocp.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ??1CCSLock@@QAE@XZ
_TEXT	SEGMENT
??1CCSLock@@QAE@XZ PROC					; CCSLock::~CCSLock, COMDAT
; _this$ = ecx
; File c:\users\michel\desktop\source\gameserver\source\giocp.h

; 76   : 	inline void UnLock(){ LeaveCriticalSection(&sec); }

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 52   : }

  00008	c3		 ret	 0
??1CCSLock@@QAE@XZ ENDP					; CCSLock::~CCSLock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\giocp.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\giocp.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ??0CCSLock@@QAE@PAVCCriticalSec@@@Z
_TEXT	SEGMENT
_pCriticalSec$ = 8					; size = 4
??0CCSLock@@QAE@PAVCCriticalSec@@@Z PROC		; CCSLock::CCSLock, COMDAT
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : 	if( !pCriticalSec )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pCriticalSec$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 c0		 test	 eax, eax
  0000b	74 09		 je	 SHORT $LN6@CCSLock
; File c:\users\michel\desktop\source\gameserver\source\giocp.h

; 75   : 	inline void Lock(){ EnterCriticalSection(&sec); }

  0000d	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 44   : 	m_pCriticalSec = pCriticalSec;

  0000e	89 06		 mov	 DWORD PTR [esi], eax
; File c:\users\michel\desktop\source\gameserver\source\giocp.h

; 75   : 	inline void Lock(){ EnterCriticalSection(&sec); }

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
$LN6@CCSLock:
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 47   : }

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0CCSLock@@QAE@PAVCCriticalSec@@@Z ENDP		; CCSLock::CCSLock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.h
;	COMDAT ?UnLock@CCriticalSec@@QAEXXZ
_TEXT	SEGMENT
?UnLock@CCriticalSec@@QAEXXZ PROC			; CCriticalSec::UnLock, COMDAT
; _this$ = ecx

; 76   : 	inline void UnLock(){ LeaveCriticalSection(&sec); }

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00007	c3		 ret	 0
?UnLock@CCriticalSec@@QAEXXZ ENDP			; CCriticalSec::UnLock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.h
;	COMDAT ?Lock@CCriticalSec@@QAEXXZ
_TEXT	SEGMENT
?Lock@CCriticalSec@@QAEXXZ PROC				; CCriticalSec::Lock, COMDAT
; _this$ = ecx

; 75   : 	inline void Lock(){ EnterCriticalSection(&sec); }

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00007	c3		 ret	 0
?Lock@CCriticalSec@@QAEXXZ ENDP				; CCriticalSec::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ??1CCriticalSec@@QAE@XZ
_TEXT	SEGMENT
??1CCriticalSec@@QAE@XZ PROC				; CCriticalSec::~CCriticalSec, COMDAT
; _this$ = ecx

; 35   : 	DeleteCriticalSection(&sec); 

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 36   : }

  00007	c3		 ret	 0
??1CCriticalSec@@QAE@XZ ENDP				; CCriticalSec::~CCriticalSec
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ??0CCriticalSec@@QAE@XZ
_TEXT	SEGMENT
??0CCriticalSec@@QAE@XZ PROC				; CCriticalSec::CCriticalSec, COMDAT
; _this$ = ecx

; 25   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 26   : 	#if _WIN32_WINNT >= 500
; 27   : 		InitializeCriticalSectionAndSpinCount(&sec, 4000 );

  00003	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  00008	56		 push	 esi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 28   : 	#else 
; 29   : 		InitializeCriticalSection(&sec);	
; 30   : 	#endif	
; 31   : }

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi
  00012	c3		 ret	 0
??0CCriticalSec@@QAE@XZ ENDP				; CCriticalSec::CCriticalSec
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?GiocpDelete@@YAXXZ
_TEXT	SEGMENT
?GiocpDelete@@YAXXZ PROC				; GiocpDelete, COMDAT

; 101  : 	delete[] ExSendBuf;

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	59		 pop	 ecx

; 102  : }

  0000c	c3		 ret	 0
?GiocpDelete@@YAXXZ ENDP				; GiocpDelete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?IOCPWorkerThread@@YGKPAX@Z
_TEXT	SEGMENT
_dwIoSize$ = -8						; size = 4
_lpOverlapped$ = -4					; size = 4
_ClientIndex$ = 8					; size = 4
_CompletionPortID$ = 8					; size = 4
?IOCPWorkerThread@@YGKPAX@Z PROC			; IOCPWorkerThread, COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 456  : 	HANDLE	CompletionPort = (HANDLE) CompletionPortID;
; 457  : 	DWORD	dwIoSize;
; 458  : 		
; 459  : 	DWORD	dwSendNumBytes = 0;
; 460  : 	BOOL	bSuccess = FALSE;
; 461  : 	int     ClientIndex;
; 462  : 	
; 463  : 	LPOVERLAPPED			lpOverlapped = NULL; 	

  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetQueuedCompletionStatus@20
  0000d	56		 push	 esi
  0000e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _CompletionPortID$[ebp]
  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lpOverlapped$[ebp], 0
  0001f	90		 npad	 1
$LL2@IOCPWorker:

; 464  : 
; 465  : 	while(TRUE)
; 466  : 	{
; 467  : 		bSuccess = GetQueuedCompletionStatus(

  00020	6a ff		 push	 -1
  00022	8d 45 fc	 lea	 eax, DWORD PTR _lpOverlapped$[ebp]
  00025	50		 push	 eax
  00026	8d 45 08	 lea	 eax, DWORD PTR _ClientIndex$[ebp]
  00029	50		 push	 eax
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _dwIoSize$[ebp]
  0002d	50		 push	 eax
  0002e	57		 push	 edi
  0002f	ff d3		 call	 ebx

; 468  : 			CompletionPort,
; 469  : 			&dwIoSize,
; 470  : 			(LPDWORD)&ClientIndex,
; 471  : 			&lpOverlapped,
; 472  : 			INFINITE
; 473  : 		);
; 474  : 
; 475  : 		if( !bSuccess )

  00031	85 c0		 test	 eax, eax
  00033	75 46		 jne	 SHORT $LN12@IOCPWorker

; 476  : 		{
; 477  : 			if( lpOverlapped != NULL ) 

  00035	8b 45 fc	 mov	 eax, DWORD PTR _lpOverlapped$[ebp]
  00038	85 c0		 test	 eax, eax
  0003a	74 42		 je	 SHORT $LN6@IOCPWorker

; 478  : 			{
; 479  : 				int aError = GetLastError();

  0003c	ff d6		 call	 esi

; 480  : 				if ( (aError != ERROR_NETNAME_DELETED) && 
; 481  : 					 (aError != ERROR_CONNECTION_ABORTED) && 
; 482  : 					 (aError != ERROR_OPERATION_ABORTED) &&

  0003e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00041	74 38		 je	 SHORT $LN12@IOCPWorker
  00043	3d d4 04 00 00	 cmp	 eax, 1236		; 000004d4H
  00048	74 31		 je	 SHORT $LN12@IOCPWorker
  0004a	3d e3 03 00 00	 cmp	 eax, 995		; 000003e3H
  0004f	74 2a		 je	 SHORT $LN12@IOCPWorker
  00051	83 f8 79	 cmp	 eax, 121		; 00000079H
  00054	74 25		 je	 SHORT $LN12@IOCPWorker

; 483  : 					 (aError != ERROR_SEM_TIMEOUT)  )
; 484  : 				{	
; 485  : 					////g_CS.Lock();
; 486  : 					GetLastErrorMsg();					

  00056	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 487  : 					LogAdd("IOCPWorkerThread: GetQueueCompletionStatus( %d , %s)\n", GetLastError(), ErrorMsg);

  0005b	68 00 00 00 00	 push	 OFFSET ?ErrorMsg@@3PADA	; ErrorMsg
  00060	ff d6		 call	 esi
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@GCDCFHEB@IOCPWorkerThread?3?5GetQueueComple@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 488  : 					////g_CS.UnLock();
; 489  : 
; 490  : 					CloseClient( ClientIndex );

  0006e	ff 75 08	 push	 DWORD PTR _ClientIndex$[ebp]
  00071	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00076	83 c4 10	 add	 esp, 16			; 00000010H

; 491  : 					continue;

  00079	eb a5		 jmp	 SHORT $LL2@IOCPWorker
$LN12@IOCPWorker:
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _lpOverlapped$[ebp]
$LN6@IOCPWorker:

; 492  : 				}
; 493  : 			}
; 494  : 		}
; 495  : 
; 496  : 		ProcessIOCPSignal(ClientIndex, dwIoSize, (LPPER_IO_CONTEXT)lpOverlapped);

  0007e	50		 push	 eax
  0007f	ff 75 f8	 push	 DWORD PTR _dwIoSize$[ebp]
  00082	ff 75 08	 push	 DWORD PTR _ClientIndex$[ebp]
  00085	e8 00 00 00 00	 call	 ?ProcessIOCPSignal@@YAXKKPAU_PER_IO_CONTEXT@@@Z ; ProcessIOCPSignal
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 497  : 	}

  0008d	eb 91		 jmp	 SHORT $LL2@IOCPWorker
?IOCPWorkerThread@@YGKPAX@Z ENDP			; IOCPWorkerThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?IocpServerWorker@@YAKXZ
_TEXT	SEGMENT
_SystemInfo$ = -100					; size = 36
_RecvBytes$ = -64					; size = 4
_ThreadID$ = -60					; size = 4
_Flags$ = -56						; size = 4
_cAddrlen$ = -52					; size = 4
_dwCPU$2 = -48						; size = 4
_cAddr$ = -44						; size = 16
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
?IocpServerWorker@@YAKXZ PROC				; IocpServerWorker, COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?IocpServerWorker@@YAKXZ
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 54	 sub	 esp, 84			; 00000054H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 188  : 	SYSTEM_INFO SystemInfo;
; 189  : 	DWORD		ThreadID;
; 190  : 	SOCKET		Accept;
; 191  : 	int			nRet;
; 192  : 	int			ClientIndex;
; 193  : 	SOCKADDR_IN cAddr;
; 194  : 	IN_ADDR		cInAddr;
; 195  : 	int			cAddrlen = sizeof( cAddr );

  00033	c7 45 cc 10 00
	00 00		 mov	 DWORD PTR _cAddrlen$[ebp], 16 ; 00000010H

; 196  : 
; 197  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL; 
; 198  : 
; 199  : 	DWORD RecvBytes;
; 200  : 	DWORD Flags=0;

  0003a	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _Flags$[ebp], 0

; 201  : 
; 202  : 	GetSystemInfo(&SystemInfo);

  00041	8d 45 9c	 lea	 eax, DWORD PTR _SystemInfo$[ebp]
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 203  : 	g_dwThreadCount = SystemInfo.dwNumberOfProcessors * 2;

  0004b	8b 45 b0	 mov	 eax, DWORD PTR _SystemInfo$[ebp+20]
  0004e	03 c0		 add	 eax, eax
  00050	a3 00 00 00 00	 mov	 DWORD PTR ?g_dwThreadCount@@3KA, eax ; g_dwThreadCount

; 204  : 
; 205  : //	VMBEGIN
; 206  : /*	if( g_CheckedLicense.getData() != 1 )
; 207  : 	{
; 208  : 		return 0;
; 209  : 	}*/
; 210  : //	VMEND
; 211  : 	
; 212  :     __try  

  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 213  :     { 
; 214  : 		g_CompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

  0005c	6a 00		 push	 0
  0005e	6a 00		 push	 0
  00060	6a 00		 push	 0
  00062	6a ff		 push	 -1
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16
  0006a	a3 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, eax ; g_CompletionPort

; 215  : 		if ( g_CompletionPort == NULL)

  0006f	85 c0		 test	 eax, eax
  00071	75 42		 jne	 SHORT $LN11@IocpServer

; 216  : 		{
; 217  : 			//////g_CS.Lock();
; 218  : 			LogAdd("CreateIoCompletionPort failed with error: %d", GetLastError());

  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@
$LN47@IocpServer:

; 229  : 			{
; 230  : 				//////g_CS.Lock();
; 231  : 				LogAdd("CreateThread() failed with error %d", GetLastError());

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00085	83 c4 08	 add	 esp, 8
$LN6@IocpServer:

; 326  : 	}	// __try

  00088	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  0008f	e8 34 03 00 00	 call	 $LN27@IocpServer
$LN28@IocpServer:

; 343  : 		} 
; 344  : 	}
; 345  : 	return TRUE;

  00094	b8 01 00 00 00	 mov	 eax, 1

; 346  : }

  00099	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000aa	33 cd		 xor	 ecx, ebp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
$LN11@IocpServer:

; 219  : 			//////g_CS.UnLock();
; 220  : 			__leave;
; 221  : 		}
; 222  : 		
; 223  : 		for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  000b5	33 f6		 xor	 esi, esi
  000b7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateThread@24
$LN45@IocpServer:
  000bd	89 75 d0	 mov	 DWORD PTR _dwCPU$2[ebp], esi
  000c0	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  000c6	73 33		 jae	 SHORT $LN3@IocpServer

; 224  : 		{
; 225  : 			HANDLE ThreadHandle;
; 226  : 			
; 227  : 			ThreadHandle = CreateThread(NULL, 0, IOCPWorkerThread, g_CompletionPort, 0, &ThreadID);

  000c8	8d 4d c4	 lea	 ecx, DWORD PTR _ThreadID$[ebp]
  000cb	51		 push	 ecx
  000cc	6a 00		 push	 0
  000ce	50		 push	 eax
  000cf	68 00 00 00 00	 push	 OFFSET ?IOCPWorkerThread@@YGKPAX@Z ; IOCPWorkerThread
  000d4	6a 00		 push	 0
  000d6	6a 00		 push	 0
  000d8	ff d7		 call	 edi

; 228  : 			if ( ThreadHandle == NULL)

  000da	85 c0		 test	 eax, eax
  000dc	75 0e		 jne	 SHORT $LN12@IocpServer

; 229  : 			{
; 230  : 				//////g_CS.Lock();
; 231  : 				LogAdd("CreateThread() failed with error %d", GetLastError());

  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000e4	50		 push	 eax
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@

; 232  : 				//////g_CS.UnLock();
; 233  : 				__leave;

  000ea	eb 93		 jmp	 SHORT $LN47@IocpServer
$LN12@IocpServer:

; 234  : 			}
; 235  : 			g_ThreadHandles[dwCPU] = ThreadHandle;

  000ec	89 04 b5 00 00
	00 00		 mov	 DWORD PTR ?g_ThreadHandles@@3PAPAXA[esi*4], eax

; 219  : 			//////g_CS.UnLock();
; 220  : 			__leave;
; 221  : 		}
; 222  : 		
; 223  : 		for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  000f3	46		 inc	 esi
  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  000f9	eb c2		 jmp	 SHORT $LN45@IocpServer
$LN3@IocpServer:

; 236  : 		}
; 237  : 		
; 238  : 		if (!CreateListenSocket() )

  000fb	e8 00 00 00 00	 call	 ?CreateListenSocket@@YAHXZ ; CreateListenSocket
  00100	85 c0		 test	 eax, eax
  00102	74 84		 je	 SHORT $LN6@IocpServer
$LN46@IocpServer:
  00104	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WSAGetLastError@0
  0010a	66 0f 1f 44 00
	00		 npad	 6
$LL5@IocpServer:

; 239  : 			__leave;
; 240  : 
; 241  : 		while(TRUE)		
; 242  : 		{
; 243  : 			Accept = WSAAccept(g_Listen, (LPSOCKADDR)&cAddr, &cAddrlen, NULL, 0);

  00110	6a 00		 push	 0
  00112	6a 00		 push	 0
  00114	8d 45 cc	 lea	 eax, DWORD PTR _cAddrlen$[ebp]
  00117	50		 push	 eax
  00118	8d 45 d4	 lea	 eax, DWORD PTR _cAddr$[ebp]
  0011b	50		 push	 eax
  0011c	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_Listen@@3IA ; g_Listen
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAAccept@20
  00128	8b f8		 mov	 edi, eax

; 244  : 
; 245  : 			if (Accept==SOCKET_ERROR)

  0012a	83 ff ff	 cmp	 edi, -1
  0012d	75 20		 jne	 SHORT $LN14@IocpServer

; 246  : 			{				
; 247  : 				//////g_CS.Lock();
; 248  : 				GetLastErrorMsg();				

  0012f	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 249  : 				LogAdd("WSAAccept() failed with error %d, %s", WSAGetLastError(), ErrorMsg);

  00134	68 00 00 00 00	 push	 OFFSET ?ErrorMsg@@3PADA	; ErrorMsg
  00139	ff d3		 call	 ebx
  0013b	50		 push	 eax
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MEAMLEDD@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	e9 39 ff ff ff	 jmp	 $LN6@IocpServer
$LN14@IocpServer:

; 250  : 				//////g_CS.UnLock();
; 251  : 				__leave;
; 252  : 			}
; 253  : 
; 254  : 			memcpy( &cInAddr, &cAddr.sin_addr.s_addr, sizeof(cInAddr) );

  0014f	8b 75 d8	 mov	 esi, DWORD PTR _cAddr$[ebp+4]

; 255  : 
; 256  : 			ClientIndex = gObjAddSearch(Accept, inet_ntoa(cInAddr));

  00152	56		 push	 esi
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  00159	50		 push	 eax
  0015a	57		 push	 edi
  0015b	e8 00 00 00 00	 call	 ?gObjAddSearch@@YAFIPAD@Z ; gObjAddSearch
  00160	83 c4 08	 add	 esp, 8
  00163	0f bf d8	 movsx	 ebx, ax

; 257  : 
; 258  : 			if( ClientIndex == -1 ) 

  00166	83 fb ff	 cmp	 ebx, -1
  00169	75 17		 jne	 SHORT $LN15@IocpServer

; 259  : 			{
; 260  : 				//////g_CS.Lock();
; 261  : 				LogAddL("error-L2 : ClientIndex = -1");

  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00176	83 c4 04	 add	 esp, 4

; 262  : 				closesocket(Accept);

  00179	57		 push	 edi
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 263  : 				//////g_CS.UnLock();
; 264  : 				continue;

  00180	eb 82		 jmp	 SHORT $LN46@IocpServer
$LN15@IocpServer:

; 265  : 			}
; 266  : 
; 267  : 			if( UpdateCompletionPort(Accept, ClientIndex, TRUE) == FALSE )

  00182	6a 01		 push	 1
  00184	53		 push	 ebx
  00185	57		 push	 edi
  00186	e8 00 00 00 00	 call	 ?UpdateCompletionPort@@YAHIHH@Z ; UpdateCompletionPort
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018e	85 c0		 test	 eax, eax
  00190	75 2b		 jne	 SHORT $LN16@IocpServer

; 268  : 			{
; 269  : 				//////g_CS.Lock();
; 270  : 				GetLastErrorMsg();

  00192	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 271  : 				LogAddL("CreateIoCompletionPort failed with error %d, %s", GetLastError(), ErrorMsg);

  00197	68 00 00 00 00	 push	 OFFSET ?ErrorMsg@@3PADA	; ErrorMsg
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001a2	50		 push	 eax
  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HFGJCKJJ@CreateIoCompletionPort?5failed?5wi@
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  001ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 272  : 				closesocket(Accept);

  001b1	57		 push	 edi
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 273  : 				//////g_CS.UnLock();
; 274  : 				continue;

  001b8	e9 47 ff ff ff	 jmp	 $LN46@IocpServer
$LN16@IocpServer:

; 275  : 			}
; 276  : 
; 277  : 			if( gObjAdd(Accept,inet_ntoa(cInAddr), ClientIndex) == -1 )

  001bd	53		 push	 ebx
  001be	56		 push	 esi
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  001c5	50		 push	 eax
  001c6	57		 push	 edi
  001c7	e8 00 00 00 00	 call	 ?gObjAdd@@YAFIPADH@Z	; gObjAdd
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cf	66 83 f8 ff	 cmp	 ax, -1
  001d3	75 23		 jne	 SHORT $LN17@IocpServer

; 278  : 			{
; 279  : 				//////g_CS.Lock();
; 280  : 				LogAddL("error-L1 : %d %d gObjAdd() failed with error %d", Accept, ClientIndex, GetLastError() );

  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001db	50		 push	 eax
  001dc	53		 push	 ebx
  001dd	57		 push	 edi
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  001e9	83 c4 10	 add	 esp, 16			; 00000010H

; 281  : 				closesocket(Accept);

  001ec	57		 push	 edi
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 282  : 				//////g_CS.UnLock();
; 283  : 				continue;

  001f3	e9 0c ff ff ff	 jmp	 $LN46@IocpServer
$LN17@IocpServer:

; 284  : 			}
; 285  : 			
; 286  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  001f8	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  001fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00203	8b 4c 06 14	 mov	 ecx, DWORD PTR [esi+eax+20]
  00207	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  0020a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 287  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.len = MAX_BUFF_SIZE;

  0020d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00212	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00216	c7 40 1c 20 4e
	00 00		 mov	 DWORD PTR [eax+28], 20000 ; 00004e20H

; 288  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nTotalBytes = 0;

  0021d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00222	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00226	c7 80 68 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+40040], 0

; 289  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSentBytes = 0;

  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00235	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00239	c7 80 6c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+40044], 0

; 290  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO    = 0;

  00243	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00248	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  0024c	c7 80 74 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+40052], 0

; 291  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSecondOfs = 0;

  00256	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025b	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  0025f	c7 80 64 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+40036], 0

; 292  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].IOOperation = RECV_IO;

  00269	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026e	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00272	c7 80 70 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+40048], 0

; 293  : 			
; 294  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  0027c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00281	8b 4c 06 14	 mov	 ecx, DWORD PTR [esi+eax+20]
  00285	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  00288	89 81 90 9c 00
	00		 mov	 DWORD PTR [ecx+40080], eax

; 295  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.len = MAX_BUFF_SIZE;

  0028e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00293	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00297	c7 80 8c 9c 00
	00 20 4e 00 00	 mov	 DWORD PTR [eax+40076], 20000 ; 00004e20H

; 296  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nTotalBytes= 0;

  002a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a6	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  002aa	c7 80 d8 38 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+80088], 0

; 297  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSentBytes = 0;

  002b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b9	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  002bd	c7 80 dc 38 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+80092], 0

; 298  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nWaitIO    = 0;

  002c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cc	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  002d0	c7 80 e4 38 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+80100], 0

; 299  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSecondOfs = 0;

  002da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002df	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  002e3	c7 80 d4 38 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+80084], 0

; 300  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].IOOperation = SEND_IO;

  002ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f2	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  002f6	c7 80 e0 38 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+80096], 1

; 301  : 			gObj[ClientIndex].PerSocketContext->m_socket = Accept;

  00300	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00305	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00309	89 38		 mov	 DWORD PTR [eax], edi

; 302  : 			gObj[ClientIndex].PerSocketContext->nIndex   = ClientIndex;

  0030b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00310	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00314	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 303  : 
; 304  : 			nRet = WSARecv(Accept, &(gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf), 1, &RecvBytes, &Flags,

  00317	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031c	8b 4c 06 14	 mov	 ecx, DWORD PTR [esi+eax+20]
  00320	6a 00		 push	 0
  00322	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00325	50		 push	 eax
  00326	8d 45 c8	 lea	 eax, DWORD PTR _Flags$[ebp]
  00329	50		 push	 eax
  0032a	8d 45 c0	 lea	 eax, DWORD PTR _RecvBytes$[ebp]
  0032d	50		 push	 eax
  0032e	6a 01		 push	 1
  00330	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00333	50		 push	 eax
  00334	57		 push	 edi
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28

; 305  : 				&(gObj[ClientIndex].PerSocketContext->IOContext[0].Overlapped), NULL);
; 306  : 			
; 307  : 			if( nRet == SOCKET_ERROR && WSAGetLastError() != ERROR_IO_PENDING )

  0033b	83 f8 ff	 cmp	 eax, -1
  0033e	75 56		 jne	 SHORT $LN18@IocpServer
  00340	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00346	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  0034b	74 49		 je	 SHORT $LN18@IocpServer

; 308  : 			{
; 309  : 				//////g_CS.Lock();
; 310  : 				GetLastErrorMsg();

  0034d	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 311  : 				LogAdd("WSARecv() failed with error %d, %s", WSAGetLastError(), ErrorMsg);

  00352	68 00 00 00 00	 push	 OFFSET ?ErrorMsg@@3PADA	; ErrorMsg
  00357	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WSAGetLastError@0
  0035d	ff d3		 call	 ebx
  0035f	50		 push	 eax
  00360	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JEADPJBA@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?0?5@
  00365	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 312  : 				//////g_CS.UnLock();
; 313  : 				
; 314  : 				gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 4;

  0036b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00370	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  00374	c7 80 74 9c 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+40052], 4

; 315  : 				CloseClient(gObj[ClientIndex].PerSocketContext, FALSE);

  0037e	6a 00		 push	 0
  00380	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00385	ff 74 06 14	 push	 DWORD PTR [esi+eax+20]
  00389	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  0038e	83 c4 14	 add	 esp, 20			; 00000014H

; 316  : 				continue;

  00391	e9 7a fd ff ff	 jmp	 $LL5@IocpServer
$LN18@IocpServer:

; 317  : 			}
; 318  : 			else
; 319  : 			{
; 320  : 				gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 1;

  00396	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0039b	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  0039f	c7 80 74 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+40052], 1

; 321  : 				gObj[ClientIndex].PerSocketContext->dwIOCount++;

  003a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ae	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  003b2	ff 80 e8 38 01
	00		 inc	 DWORD PTR [eax+80104]

; 322  : 
; 323  : 				SCPJoinResultSend(ClientIndex, 1);

  003b8	6a 01		 push	 1
  003ba	53		 push	 ebx
  003bb	e8 00 00 00 00	 call	 ?SCPJoinResultSend@@YAXHE@Z ; SCPJoinResultSend
  003c0	83 c4 08	 add	 esp, 8

; 324  : 			}
; 325  : 		}	// while

  003c3	e9 3c fd ff ff	 jmp	 $LN46@IocpServer
$LN25@IocpServer:
$LN49@IocpServer:
$LN27@IocpServer:

; 327  : 	__finally  
; 328  : 	{
; 329  : 		if( g_CompletionPort )

  003c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  003cd	85 c0		 test	 eax, eax
  003cf	74 3c		 je	 SHORT $LN21@IocpServer

; 330  : 		{
; 331  : 			for (DWORD i = 0; i < g_dwThreadCount; i++) 

  003d1	33 f6		 xor	 esi, esi
  003d3	39 35 00 00 00
	00		 cmp	 DWORD PTR ?g_dwThreadCount@@3KA, esi ; g_dwThreadCount
  003d9	76 1d		 jbe	 SHORT $LN8@IocpServer
  003db	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PostQueuedCompletionStatus@16
$LL9@IocpServer:

; 332  : 				PostQueuedCompletionStatus(g_CompletionPort, 0, 0, NULL); 

  003e1	6a 00		 push	 0
  003e3	6a 00		 push	 0
  003e5	6a 00		 push	 0
  003e7	50		 push	 eax
  003e8	ff d7		 call	 edi

; 330  : 		{
; 331  : 			for (DWORD i = 0; i < g_dwThreadCount; i++) 

  003ea	46		 inc	 esi
  003eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  003f0	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  003f6	72 e9		 jb	 SHORT $LL9@IocpServer
$LN8@IocpServer:

; 333  : 		}
; 334  : 		if( g_CompletionPort )

  003f8	85 c0		 test	 eax, eax
  003fa	74 11		 je	 SHORT $LN21@IocpServer

; 335  : 		{
; 336  : 			CloseHandle(g_CompletionPort);

  003fc	50		 push	 eax
  003fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 337  : 			g_CompletionPort = NULL;

  00403	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
$LN21@IocpServer:

; 338  : 		}
; 339  : 		if (g_Listen != INVALID_SOCKET)  

  0040d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00412	83 f8 ff	 cmp	 eax, -1
  00415	74 11		 je	 SHORT $LN26@IocpServer

; 340  : 		{ 
; 341  :             closesocket(g_Listen);  

  00417	50		 push	 eax
  00418	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 342  :             g_Listen = INVALID_SOCKET; 

  0041e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_Listen@@3IA, -1 ; g_Listen
$LN26@IocpServer:
$LN44@IocpServer:
  00428	c3		 ret	 0
?IocpServerWorker@@YAKXZ ENDP				; IocpServerWorker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_SendBytes$ = -4					; size = 4
tv207 = 8						; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC		; IoMoreSend, COMDAT

; 1001 : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1002 : 	DWORD SendBytes;
; 1003 : 
; 1004 : 	int aIndex = lpPerSocketContext->nIndex;	

  00007	8b 7d 08	 mov	 edi, DWORD PTR _lpPerSocketContext$[ebp]

; 1005 : 
; 1006 : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];
; 1007 : 	
; 1008 : 	if( (lpIoCtxt->nTotalBytes-lpIoCtxt->nSentBytes) < 0 ) 

  0000a	8b 87 d8 38 01
	00		 mov	 eax, DWORD PTR [edi+80088]
  00010	8d b7 78 9c 00
	00		 lea	 esi, DWORD PTR [edi+40056]
  00016	2b 86 64 9c 00
	00		 sub	 eax, DWORD PTR [esi+40036]
  0001c	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0001f	0f 88 b8 00 00
	00		 js	 $LN7@IoMoreSend

; 1009 : 	{
; 1010 : 		return FALSE;
; 1011 : 	}
; 1012 : 	
; 1013 : 	////g_CS.Lock();	
; 1014 : 	printf("Error : File : [%s], Line : [%d]\n", __FILE__, __LINE__);

  00025	68 f6 03 00 00	 push	 1014			; 000003f6H
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BPEFPLLL@Error?5?3?5File?5?3?5?$FL?$CFs?$FN?0?5Line?5?3?5?$FL?$CFd?$FN@
  00034	e8 00 00 00 00	 call	 _printf

; 1015 : 	printf("%d packet len\n", lpIoCtxt->nTotalBytes-lpIoCtxt->nSentBytes);

  00039	8b 86 60 9c 00
	00		 mov	 eax, DWORD PTR [esi+40032]
  0003f	2b 86 64 9c 00
	00		 sub	 eax, DWORD PTR [esi+40036]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ILILJDMA@?$CFd?5packet?5len?6?$AA@
  0004b	e8 00 00 00 00	 call	 _printf

; 1016 : 	////g_CS.UnLock();
; 1017 : 
; 1018 : 	lpIoCtxt->wsabuf.buf	= (char*)lpIoCtxt->Buffer+lpIoCtxt->nSentBytes;

  00050	8b 8e 64 9c 00
	00		 mov	 ecx, DWORD PTR [esi+40036]
  00056	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 1019 : 	lpIoCtxt->wsabuf.len	= lpIoCtxt->nTotalBytes-lpIoCtxt->nSentBytes;
; 1020 : 	lpIoCtxt->IOOperation	= SEND_IO;

  0005c	c7 86 68 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+40040], 1
  00066	03 c1		 add	 eax, ecx
  00068	8d 56 14	 lea	 edx, DWORD PTR [esi+20]
  0006b	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0006e	8b 86 60 9c 00
	00		 mov	 eax, DWORD PTR [esi+40032]

; 1021 : 
; 1022 : 	if (WSASend(gObj[aIndex].m_socket, &(lpIoCtxt->wsabuf), 1, &SendBytes, 0,
; 1023 : 		&(lpIoCtxt->Overlapped), NULL) == SOCKET_ERROR)

  00074	6a 00		 push	 0
  00076	2b c1		 sub	 eax, ecx
  00078	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  0007e	56		 push	 esi
  0007f	89 02		 mov	 DWORD PTR [edx], eax
  00081	8d 45 fc	 lea	 eax, DWORD PTR _SendBytes$[ebp]
  00084	6a 00		 push	 0
  00086	50		 push	 eax
  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008c	6a 01		 push	 1
  0008e	52		 push	 edx
  0008f	89 4d 08	 mov	 DWORD PTR tv207[ebp], ecx
  00092	ff 74 01 18	 push	 DWORD PTR [ecx+eax+24]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  0009c	83 f8 ff	 cmp	 eax, -1
  0009f	75 45		 jne	 SHORT $LN3@IoMoreSend

; 1024 : 	{
; 1025 : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  000a1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WSAGetLastError@0
  000a7	ff d7		 call	 edi
  000a9	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000ae	74 3d		 je	 SHORT $LN4@IoMoreSend

; 1026 : 		{
; 1027 : 			////g_CS.Lock();
; 1028 : 			GetLastErrorMsg();			

  000b0	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 1029 : 			LogAdd("WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ba	83 c0 1c	 add	 eax, 28			; 0000001cH
  000bd	03 45 08	 add	 eax, DWORD PTR tv207[ebp]
  000c0	50		 push	 eax
  000c1	ff d7		 call	 edi
  000c3	50		 push	 eax
  000c4	68 05 04 00 00	 push	 1029			; 00000405H
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1030 : 			////g_CS.UnLock();
; 1031 : 			CloseClient( aIndex );			

  000d4	53		 push	 ebx
  000d5	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000da	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@IoMoreSend:

; 1032 : 			return FALSE;

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	33 c0		 xor	 eax, eax
  000e1	5b		 pop	 ebx

; 1041 : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN3@IoMoreSend:

; 1033 : 		}
; 1034 : 	}
; 1035 : 	else 
; 1036 : 	{
; 1037 : 		InterlockedIncrement(&lpPerSocketContext->dwIOCount);

  000e6	f0 ff 87 e8 38
	01 00		 lock	  inc	 DWORD PTR [edi+80104]
$LN4@IoMoreSend:
  000ed	5f		 pop	 edi

; 1038 : 	}
; 1039 : 	lpIoCtxt->nWaitIO = 1;

  000ee	c7 86 6c 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+40044], 1

; 1040 : 	return TRUE;

  000f8	b8 01 00 00 00	 mov	 eax, 1
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx

; 1041 : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP		; IoMoreSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_SendBytes$ = -8					; size = 4
_aIndex$1$ = -4						; size = 4
tv225 = 8						; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC	; IoSendSecond, COMDAT

; 946  : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 947  : 	DWORD SendBytes;
; 948  : 	int aIndex = lpPerSocketContext->nIndex;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpPerSocketContext$[ebp]
  0000a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 949  : 
; 950  : 	if( gObj[aIndex].Connected < 1 )

  0000d	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00013	89 45 fc	 mov	 DWORD PTR _aIndex$1$[ebp], eax
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001b	89 4d 08	 mov	 DWORD PTR tv225[ebp], ecx
  0001e	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00023	7d 07		 jge	 SHORT $LN2@IoSendSeco

; 951  : 	{
; 952  : 		return FALSE;

  00025	33 c0		 xor	 eax, eax
  00027	5b		 pop	 ebx

; 998  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN2@IoSendSeco:

; 953  : 	}
; 954  : 
; 955  : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];	
; 956  : 
; 957  : 	if( lpIoCtxt->nWaitIO > 0 )	

  0002c	83 bb e4 38 01
	00 00		 cmp	 DWORD PTR [ebx+80100], 0
  00033	57		 push	 edi
  00034	8d bb 78 9c 00
	00		 lea	 edi, DWORD PTR [ebx+40056]
  0003a	0f 8f e5 00 00
	00		 jg	 $LN4@IoSendSeco

; 958  : 	{
; 959  : 		return FALSE;
; 960  : 	}
; 961  : 	
; 962  : 	lpIoCtxt->nTotalBytes = 0;
; 963  : 	if( lpIoCtxt->nSecondOfs > 0 )

  00040	8b 87 5c 9c 00
	00		 mov	 eax, DWORD PTR [edi+40028]
  00046	c7 87 60 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+40032], 0
  00050	85 c0		 test	 eax, eax
  00052	0f 8e cd 00 00
	00		 jle	 $LN4@IoSendSeco

; 964  : 	{
; 965  : 		memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  00058	56		 push	 esi
  00059	50		 push	 eax
  0005a	8d 87 3c 4e 00
	00		 lea	 eax, DWORD PTR [edi+20028]
  00060	50		 push	 eax
  00061	8d 77 1c	 lea	 esi, DWORD PTR [edi+28]
  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 _memcpy

; 966  : 		lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  0006a	8b 87 5c 9c 00
	00		 mov	 eax, DWORD PTR [edi+40028]

; 972  : 	}
; 973  : 
; 974  : 	lpIoCtxt->wsabuf.buf	= (char*)lpIoCtxt->Buffer;
; 975  : 	lpIoCtxt->wsabuf.len	= lpIoCtxt->nTotalBytes;

  00070	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	89 87 60 9c 00
	00		 mov	 DWORD PTR [edi+40032], eax
  0007c	89 01		 mov	 DWORD PTR [ecx], eax

; 976  : 	lpIoCtxt->nSentBytes	= 0;
; 977  : 	lpIoCtxt->IOOperation	= SEND_IO;
; 978  : 
; 979  : 	if (WSASend(gObj[aIndex].m_socket, &(lpIoCtxt->wsabuf), 1, &SendBytes, 0,
; 980  : 		&(lpIoCtxt->Overlapped), NULL) == SOCKET_ERROR)

  0007e	8d 45 f8	 lea	 eax, DWORD PTR _SendBytes$[ebp]
  00081	89 77 18	 mov	 DWORD PTR [edi+24], esi
  00084	8b 75 08	 mov	 esi, DWORD PTR tv225[ebp]
  00087	6a 00		 push	 0
  00089	57		 push	 edi
  0008a	6a 00		 push	 0
  0008c	50		 push	 eax
  0008d	c7 87 5c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+40028], 0
  00097	c7 87 64 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+40036], 0
  000a1	c7 87 68 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+40040], 1
  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b0	6a 01		 push	 1
  000b2	51		 push	 ecx
  000b3	ff 74 06 18	 push	 DWORD PTR [esi+eax+24]
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000bd	83 f8 ff	 cmp	 eax, -1
  000c0	75 46		 jne	 SHORT $LN6@IoSendSeco

; 981  : 	{
; 982  : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  000c2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WSAGetLastError@0
  000c8	ff d3		 call	 ebx
  000ca	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000cf	74 3e		 je	 SHORT $LN7@IoSendSeco

; 983  : 		{
; 984  : 			////g_CS.Lock();
; 985  : 			GetLastErrorMsg();

  000d1	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 986  : 			LogAdd("WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000db	83 c0 1c	 add	 eax, 28			; 0000001cH
  000de	03 c6		 add	 eax, esi
  000e0	50		 push	 eax
  000e1	ff d3		 call	 ebx
  000e3	50		 push	 eax
  000e4	68 da 03 00 00	 push	 986			; 000003daH
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 987  : 			////g_CS.UnLock();
; 988  : 			CloseClient( aIndex );			

  000f4	ff 75 fc	 push	 DWORD PTR _aIndex$1$[ebp]
  000f7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000fc	83 c4 14	 add	 esp, 20			; 00000014H

; 989  : 			return FALSE;

  000ff	33 c0		 xor	 eax, eax
  00101	5e		 pop	 esi
  00102	5f		 pop	 edi
  00103	5b		 pop	 ebx

; 998  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN6@IoSendSeco:

; 990  : 		}
; 991  : 	}
; 992  : 	else 
; 993  : 	{
; 994  : 		InterlockedIncrement(&lpPerSocketContext->dwIOCount);

  00108	f0 ff 83 e8 38
	01 00		 lock	  inc	 DWORD PTR [ebx+80104]
$LN7@IoSendSeco:
  0010f	5e		 pop	 esi

; 995  : 	}
; 996  : 	lpIoCtxt->nWaitIO = 1;	

  00110	c7 87 6c 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+40044], 1

; 997  : 	return TRUE;

  0011a	b8 01 00 00 00	 mov	 eax, 1
  0011f	5f		 pop	 edi
  00120	5b		 pop	 ebx

; 998  : }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
$LN4@IoSendSeco:
  00125	5f		 pop	 edi

; 967  : 		lpIoCtxt->nSecondOfs = 0;
; 968  : 	}
; 969  : 	else 
; 970  : 	{	
; 971  : 		return FALSE;

  00126	33 c0		 xor	 eax, eax
  00128	5b		 pop	 ebx

; 998  : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP	; IoSendSecond
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_cs$ = 8						; size = 4
_lpPerSocketContext$ = 8				; size = 4
_bGraceful$ = 12					; size = 4
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z PROC	; CloseClient, COMDAT

; 1070 : { 	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1071 : 	int index = lpPerSocketContext->nIndex;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00027	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1072 : 	if( index < OBJ_STARTUSERINDEX || index >= OBJMAX ) return;

  0002a	8d 86 fc d6 ff
	ff		 lea	 eax, DWORD PTR [esi-10500]
  00030	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00035	77 6b		 ja	 SHORT $LN3@CloseClien

; 1073 : 
; 1074 : 	if( gObj[index].Connected == 0 ) return;

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00042	83 7c 07 04 00	 cmp	 DWORD PTR [edi+eax+4], 0
  00047	74 59		 je	 SHORT $LN3@CloseClien

; 1075 : 
; 1076 : 	CCSLock cs(&g_SendLock);

  00049	68 00 00 00 00	 push	 OFFSET ?g_SendLock@@3VCCriticalSec@@A ; g_SendLock
  0004e	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  00051	e8 00 00 00 00	 call	 ??0CCSLock@@QAE@PAVCCriticalSec@@@Z ; CCSLock::CCSLock

; 1077 : 
; 1078 : 	if( INVALID_SOCKET != gObj[index].m_socket )

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00062	8b 44 07 18	 mov	 eax, DWORD PTR [edi+eax+24]
  00066	83 f8 ff	 cmp	 eax, -1
  00069	74 26		 je	 SHORT $LN5@CloseClien

; 1079 : 	{
; 1080 : 		if( closesocket(gObj[index].m_socket) == SOCKET_ERROR )

  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00072	83 f8 ff	 cmp	 eax, -1
  00075	75 0d		 jne	 SHORT $LN7@CloseClien

; 1081 : 		{
; 1082 : 			if(WSAGetLastError() != 10038)

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0007d	3d 36 27 00 00	 cmp	 eax, 10038		; 00002736H
  00082	75 16		 jne	 SHORT $LN10@CloseClien
$LN7@CloseClien:

; 1083 : 			{
; 1084 : 				return;
; 1085 : 			}
; 1086 : 		}
; 1087 : 
; 1088 : 		gObj[index].m_socket = INVALID_SOCKET;

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00089	c7 44 07 18 ff
	ff ff ff	 mov	 DWORD PTR [edi+eax+24], -1
$LN5@CloseClien:

; 1089 : 	}
; 1090 : 
; 1091 : 	gObjDel(index);	

  00091	56		 push	 esi
  00092	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00097	83 c4 04	 add	 esp, 4
$LN10@CloseClien:

; 1092 : }

  0009a	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  0009d	e8 00 00 00 00	 call	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
$LN3@CloseClien:
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
__ehhandler$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ENDP	; CloseClient
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z
_TEXT	SEGMENT
_wSize$1$ = -9124					; size = 4
_recvbuf$1$ = -9120					; size = 4
_ret$1$ = -9116						; size = 4
_ret$1$ = -9116						; size = 4
_lpIOContext$GSCopy$1$ = -9112				; size = 4
_headcode$ = -9108					; size = 1
_uIndex$GSCopy$1$ = -9104				; size = 4
_hcode$1$ = -9098					; size = 1
_subhead$1$ = -9098					; size = 1
_headcode$2$ = -9097					; size = 1
_headcode$1$ = -9097					; size = 1
_ps$2 = -9096						; size = 2056
_PacketStream$3 = -9096					; size = 2056
_PacketStream$4 = -9096					; size = 2056
_byDec$ = -7040						; size = 7024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpIOContext$ = 8					; size = 4
_uIndex$ = 12						; size = 4
?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z PROC	; ParsingRecvData, COMDAT

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 98 23 00 00	 mov	 eax, 9112		; 00002398H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 55 08	 mov	 edx, DWORD PTR _lpIOContext$[ebp]
  00035	8b 45 0c	 mov	 eax, DWORD PTR _uIndex$[ebp]
  00038	89 95 68 dc ff
	ff		 mov	 DWORD PTR _lpIOContext$GSCopy$1$[ebp], edx
  0003e	89 85 70 dc ff
	ff		 mov	 DWORD PTR _uIndex$GSCopy$1$[ebp], eax

; 503  : 	if( lpIOContext->nSentBytes < 3 )

  00044	83 ba 64 9c 00
	00 03		 cmp	 DWORD PTR [edx+40036], 3
  0004b	0f 8c 8c 05 00
	00		 jl	 $LN126@ParsingRec

; 504  : 	{
; 505  : 		return FALSE;
; 506  : 	}
; 507  : 	LPBYTE	recvbuf;
; 508  : 	int		lOfs=0;
; 509  : 	int		size=0;
; 510  : 	BYTE	headcode;
; 511  : 	BYTE	xcode;
; 512  : 	BYTE	byDec[7024];
; 513  : 	
; 514  : 	recvbuf = (LPBYTE)lpIOContext->Buffer;

  00051	8d 72 1c	 lea	 esi, DWORD PTR [edx+28]
  00054	33 db		 xor	 ebx, ebx
  00056	89 b5 60 dc ff
	ff		 mov	 DWORD PTR _recvbuf$1$[ebp], esi
  0005c	0f 1f 40 00	 npad	 4
$LL2@ParsingRec:

; 515  : 
; 516  : 	while(TRUE)
; 517  : 	{
; 518  : #if (CUSTOM_ENCRYPT == 1)
; 519  : 
; 520  : 		recvbuf[lOfs] ^= 0x20;

  00060	80 34 1e 20	 xor	 BYTE PTR [esi+ebx], 32	; 00000020H
  00064	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  00067	8a 01		 mov	 al, BYTE PTR [ecx]

; 521  : 
; 522  : 		if( recvbuf[lOfs] == 0xC1 || recvbuf[lOfs] == 0xC3 )

  00069	3c c1		 cmp	 al, 193			; 000000c1H
  0006b	74 75		 je	 SHORT $LN9@ParsingRec
  0006d	3c c3		 cmp	 al, 195			; 000000c3H
  0006f	74 71		 je	 SHORT $LN9@ParsingRec

; 531  : 		}
; 532  : 		else if( recvbuf[lOfs] == 0xC2 || recvbuf[lOfs] == 0xC4 ) 

  00071	3c c2		 cmp	 al, 194			; 000000c2H
  00073	74 4c		 je	 SHORT $LN12@ParsingRec
  00075	3c c4		 cmp	 al, 196			; 000000c4H
  00077	74 48		 je	 SHORT $LN12@ParsingRec

; 543  : 		}
; 544  : 		else if( recvbuf[lOfs] == 0xC6 )

  00079	3c c6		 cmp	 al, 198			; 000000c6H
  0007b	74 6f		 je	 SHORT $LN127@ParsingRec

; 545  : 		{
; 546  : 			PBMSG_HEAD* lphead = (PBMSG_HEAD*)(recvbuf+lOfs);
; 547  : 			size				= lphead->size;
; 548  : 			headcode			= lphead->headcode;
; 549  : 			xcode				= lphead->c;
; 550  : 		}
; 551  : 		else
; 552  : 		{
; 553  : 			////g_CS.Lock();
; 554  : 			LogAdd("error-L1 : Header(%02X) error (%s %d)lOfs:%d, size:%d",recvbuf[lOfs],__FILE__, __LINE__,lOfs,lpIOContext->nSentBytes);

  0007d	ff b2 64 9c 00
	00		 push	 DWORD PTR [edx+40036]
  00083	0f b6 c0	 movzx	 eax, al
  00086	53		 push	 ebx
  00087	68 2a 02 00 00	 push	 554			; 0000022aH
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@FFKKCAKG@error?9L1?5?3?5Header?$CI?$CF02X?$CJ?5error?5?$CI?$CF@
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 555  : 			LogAddHeadHexFunc(1,(char*)&recvbuf[lOfs],lOfs);

  0009d	53		 push	 ebx
  0009e	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000a1	50		 push	 eax
  000a2	6a 01		 push	 1
  000a4	e8 00 00 00 00	 call	 ?LogAddHeadHexFunc@@YAXHPADH@Z ; LogAddHeadHexFunc

; 556  : 			////g_CS.UnLock();
; 557  : 			lpIOContext->nSentBytes = 0;

  000a9	8b 85 68 dc ff
	ff		 mov	 eax, DWORD PTR _lpIOContext$GSCopy$1$[ebp]
  000af	83 c4 24	 add	 esp, 36			; 00000024H
  000b2	c7 80 64 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+40036], 0

; 558  : 			return FALSE;

  000bc	e9 1c 05 00 00	 jmp	 $LN126@ParsingRec
$LN12@ParsingRec:

; 533  : 		{
; 534  : 			recvbuf[lOfs+1] ^= 0x11;

  000c1	80 74 1e 01 11	 xor	 BYTE PTR [esi+ebx+1], 17 ; 00000011H

; 535  : 			recvbuf[lOfs+2] ^= 0x41;

  000c6	80 74 1e 02 41	 xor	 BYTE PTR [esi+ebx+2], 65 ; 00000041H

; 536  : 			recvbuf[lOfs+3] ^= 0x31;

  000cb	80 74 1e 03 31	 xor	 BYTE PTR [esi+ebx+3], 49 ; 00000031H

; 537  : 
; 538  : 			PWMSG_HEAD* lphead	= (PWMSG_HEAD*)(recvbuf+lOfs);
; 539  : 			size				= ((WORD)(lphead->sizeH)<<8);

  000d0	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]

; 540  : 			size			   |= (WORD)(lphead->sizeL);

  000d4	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]

; 541  : 			headcode			= lphead->headcode;

  000d8	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  000db	c1 e7 08	 shl	 edi, 8
  000de	0b f8		 or	 edi, eax

; 542  : 			xcode				= lphead->c;

  000e0	eb 11		 jmp	 SHORT $LN128@ParsingRec
$LN9@ParsingRec:

; 523  : 		{
; 524  : 			recvbuf[lOfs+1] ^= 0x10;

  000e2	80 74 1e 01 10	 xor	 BYTE PTR [esi+ebx+1], 16 ; 00000010H

; 525  : 			recvbuf[lOfs+2] ^= 0x40;

  000e7	80 74 1e 02 40	 xor	 BYTE PTR [esi+ebx+2], 64 ; 00000040H
$LN127@ParsingRec:

; 526  : 
; 527  : 			PBMSG_HEAD* lphead = (PBMSG_HEAD*)(recvbuf+lOfs);
; 528  : 			size				= lphead->size;
; 529  : 			headcode			= lphead->headcode;

  000ec	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000ef	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
$LN128@ParsingRec:

; 530  : 			xcode				= lphead->c;

  000f3	8a 01		 mov	 al, BYTE PTR [ecx]
  000f5	88 95 77 dc ff
	ff		 mov	 BYTE PTR _headcode$2$[ebp], dl
  000fb	88 95 6c dc ff
	ff		 mov	 BYTE PTR _headcode$[ebp], dl

; 559  : 		}
; 560  : 
; 561  : #else
; 562  : 
; 563  : 		if( recvbuf[lOfs] == 0xC1 || recvbuf[lOfs] == 0xC3 )
; 564  : 		{
; 565  : 			PBMSG_HEAD* lphead = (PBMSG_HEAD*)(recvbuf+lOfs);
; 566  : 			size				= lphead->size;
; 567  : 			headcode			= lphead->headcode;
; 568  : 			xcode				= lphead->c;
; 569  : 		}
; 570  : 		else if( recvbuf[lOfs] == 0xC2 || recvbuf[lOfs] == 0xC4 ) 
; 571  : 		{
; 572  : 			PWMSG_HEAD* lphead	= (PWMSG_HEAD*)(recvbuf+lOfs);
; 573  : 			size				= ((WORD)(lphead->sizeH)<<8);
; 574  : 			size			   |= (WORD)(lphead->sizeL);
; 575  : 			headcode			= lphead->headcode;
; 576  : 			xcode				= lphead->c;
; 577  : 		}
; 578  : 		else
; 579  : 		{
; 580  : 			////g_CS.Lock();
; 581  : 			LogAdd("error-L1 : Header error (%s %d)lOfs:%d, size:%d",__FILE__, __LINE__,lOfs,lpIOContext->nSentBytes);
; 582  : 			LogAddHeadHexFunc(1,(char*)&recvbuf[lOfs],lOfs);
; 583  : 			////g_CS.UnLock();
; 584  : 			lpIOContext->nSentBytes = 0;
; 585  : 			return FALSE;
; 586  : 		}
; 587  : 
; 588  : #endif
; 589  : 
; 590  : 
; 591  : 		if( size <= 0 )

  00101	85 ff		 test	 edi, edi
  00103	0f 8e c5 04 00
	00		 jle	 $LN111@ParsingRec

; 597  : 		}
; 598  : 
; 599  : 		if( size <= lpIOContext->nSentBytes )

  00109	8b b5 68 dc ff
	ff		 mov	 esi, DWORD PTR _lpIOContext$GSCopy$1$[ebp]
  0010f	3b be 64 9c 00
	00		 cmp	 edi, DWORD PTR [esi+40036]
  00115	8b b5 60 dc ff
	ff		 mov	 esi, DWORD PTR _recvbuf$1$[ebp]
  0011b	0f 8f 00 04 00
	00		 jg	 $LN16@ParsingRec

; 600  : 		{
; 601  : 			if ( xcode == 0xC3 )

  00121	3c c3		 cmp	 al, 195			; 000000c3H
  00123	0f 85 eb 00 00
	00		 jne	 $LN18@ParsingRec

; 602  : 			{
; 603  : 				int ret = g_SimpleModulus.Decrypt(&byDec[2],&recvbuf[lOfs+2],size-2);

  00129	8d 47 fe	 lea	 eax, DWORD PTR [edi-2]
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulus@@3VCSimpleModulus@@A ; g_SimpleModulus
  00131	50		 push	 eax
  00132	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00135	03 c3		 add	 eax, ebx
  00137	50		 push	 eax
  00138	8d 85 82 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+2]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  00144	89 85 64 dc ff
	ff		 mov	 DWORD PTR _ret$1$[ebp], eax

; 604  : 
; 605  : 				if ( ret < 0 )

  0014a	85 c0		 test	 eax, eax
  0014c	0f 88 7d 02 00
	00		 js	 $LN108@ParsingRec

; 606  : 				{
; 607  : 
; 608  : 				}
; 609  : 				else
; 610  : 				{
; 611  : 					unsigned char* pDecBuf = &byDec[1];
; 612  : 
; 613  : 					headcode = pDecBuf[2];

  00152	8a 8d 83 e4 ff
	ff		 mov	 cl, BYTE PTR _byDec$[ebp+3]
  00158	88 8d 77 dc ff
	ff		 mov	 BYTE PTR _headcode$1$[ebp], cl
  0015e	88 8d 6c dc ff
	ff		 mov	 BYTE PTR _headcode$[ebp], cl

; 614  : 					BYTE subhead = byDec[2];

  00164	8a 8d 82 e4 ff
	ff		 mov	 cl, BYTE PTR _byDec$[ebp+2]
  0016a	88 8d 76 dc ff
	ff		 mov	 BYTE PTR _subhead$1$[ebp], cl

; 615  : 					byDec[1] = 0xC1;

  00170	c6 85 81 e4 ff
	ff c1		 mov	 BYTE PTR _byDec$[ebp+1], 193 ; 000000c1H

; 616  : 					byDec[2] = (ret&0xFF);

  00177	88 85 82 e4 ff
	ff		 mov	 BYTE PTR _byDec$[ebp+2], al
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 16   : 	{

  0017d	c7 85 78 dc ff
	ff 00 00 00 00	 mov	 DWORD PTR _PacketStream$4[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 27   : 		this->m_wSize = 0;

  00187	33 c9		 xor	 ecx, ecx
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 620  : 					CStreamPacketEngine_Server PacketStream;

  00189	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 623  : 					if ( PacketStream.AddData(&byDec[1], ret +2) == 0 )

  00190	83 c0 02	 add	 eax, 2
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 27   : 		this->m_wSize = 0;

  00193	66 89 8d 7c dc
	ff ff		 mov	 WORD PTR _PacketStream$4[ebp+4], cx
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 623  : 					if ( PacketStream.AddData(&byDec[1], ret +2) == 0 )

  0019a	0f b7 c0	 movzx	 eax, ax
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 85   : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  0019d	0f b7 c8	 movzx	 ecx, ax
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 623  : 					if ( PacketStream.AddData(&byDec[1], ret +2) == 0 )

  001a0	89 85 5c dc ff
	ff		 mov	 DWORD PTR _wSize$1$[ebp], eax
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 85   : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  001a6	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  001ac	0f 8d 88 02 00
	00		 jge	 $LN61@ParsingRec
  001b2	66 85 c0	 test	 ax, ax
  001b5	0f 84 7f 02 00
	00		 je	 $LN61@ParsingRec

; 92   : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  001bb	51		 push	 ecx
  001bc	8d 85 81 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+1]
  001c2	50		 push	 eax
  001c3	8d 85 7e dc ff
	ff		 lea	 eax, DWORD PTR _PacketStream$4[ebp+6]
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 _memcpy

; 93   : 		this->m_wSize += wSize;

  001cf	8b 85 5c dc ff
	ff		 mov	 eax, DWORD PTR _wSize$1$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 632  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  001d5	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$4[ebp]
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 93   : 		this->m_wSize += wSize;

  001db	66 01 85 7c dc
	ff ff		 add	 WORD PTR _PacketStream$4[ebp+4], ax
  001e2	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 632  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  001e5	8d 85 80 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  001f1	85 c0		 test	 eax, eax
  001f3	0f 85 fb 01 00
	00		 jne	 $LN113@ParsingRec

; 639  : 					}
; 640  : 	
; 641  : 					ProtocolCore(headcode, byDec, ret, uIndex, 1, subhead);

  001f9	0f b6 85 76 dc
	ff ff		 movzx	 eax, BYTE PTR _subhead$1$[ebp]
  00200	50		 push	 eax
  00201	6a 01		 push	 1
  00203	ff b5 70 dc ff
	ff		 push	 DWORD PTR _uIndex$GSCopy$1$[ebp]
  00209	ff b5 64 dc ff
	ff		 push	 DWORD PTR _ret$1$[ebp]

; 642  : 				}

  0020f	e9 9f 01 00 00	 jmp	 $LN129@ParsingRec
$LN18@ParsingRec:

; 643  : 			}
; 644  : 
; 645  : 			else if ( xcode == 0xC4 )

  00214	3c c4		 cmp	 al, 196			; 000000c4H
  00216	0f 85 f1 00 00
	00		 jne	 $LN24@ParsingRec

; 646  : 			{
; 647  : 				int ret = g_SimpleModulus.Decrypt(&byDec[3], &recvbuf[lOfs+3], size-3);

  0021c	8d 47 fd	 lea	 eax, DWORD PTR [edi-3]
  0021f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulus@@3VCSimpleModulus@@A ; g_SimpleModulus
  00224	50		 push	 eax
  00225	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  00228	03 c3		 add	 eax, ebx
  0022a	50		 push	 eax
  0022b	8d 85 83 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+3]
  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  00237	89 85 64 dc ff
	ff		 mov	 DWORD PTR _ret$1$[ebp], eax

; 648  : 				if ( ret < 0 )

  0023d	85 c0		 test	 eax, eax
  0023f	0f 88 8a 01 00
	00		 js	 $LN108@ParsingRec

; 649  : 				{
; 650  : 
; 651  : 				}
; 652  : 				else
; 653  : 				{
; 654  : 					unsigned char* pDecBuf = &byDec[1];
; 655  : 					
; 656  : 					
; 657  : 					BYTE hcode = byDec[3];

  00245	8a 8d 83 e4 ff
	ff		 mov	 cl, BYTE PTR _byDec$[ebp+3]

; 658  : 					byDec[1] = 0xC2;
; 659  : 					WORD wSize = (ret &0xFFFF)+3;

  0024b	8d 70 03	 lea	 esi, DWORD PTR [eax+3]
  0024e	0f b7 d6	 movzx	 edx, si
  00251	88 8d 76 dc ff
	ff		 mov	 BYTE PTR _hcode$1$[ebp], cl

; 660  : 					byDec[2] = SET_NUMBERH(wSize);

  00257	8b ca		 mov	 ecx, edx
  00259	c1 e9 08	 shr	 ecx, 8
  0025c	c6 85 81 e4 ff
	ff c2		 mov	 BYTE PTR _byDec$[ebp+1], 194 ; 000000c2H
  00263	88 8d 82 e4 ff
	ff		 mov	 BYTE PTR _byDec$[ebp+2], cl

; 661  : 					byDec[3] = SET_NUMBERL(wSize);

  00269	88 95 83 e4 ff
	ff		 mov	 BYTE PTR _byDec$[ebp+3], dl
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 16   : 	{

  0026f	c7 85 78 dc ff
	ff 00 00 00 00	 mov	 DWORD PTR _PacketStream$3[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 27   : 		this->m_wSize = 0;

  00279	33 c0		 xor	 eax, eax
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 668  : 					if ( PacketStream.AddData(&byDec[1], ret+3) == 0 )

  0027b	0f b7 f6	 movzx	 esi, si
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 27   : 		this->m_wSize = 0;

  0027e	66 89 85 7c dc
	ff ff		 mov	 WORD PTR _PacketStream$3[ebp+4], ax

; 85   : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  00285	8b c6		 mov	 eax, esi
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 665  : 					CStreamPacketEngine_Server PacketStream;

  00287	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 85   : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  0028e	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00293	0f 8d 15 02 00
	00		 jge	 $LN80@ParsingRec
  00299	66 85 f6	 test	 si, si
  0029c	0f 84 0c 02 00
	00		 je	 $LN80@ParsingRec

; 92   : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  002a2	50		 push	 eax
  002a3	8d 85 81 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+1]
  002a9	50		 push	 eax
  002aa	8d 85 7e dc ff
	ff		 lea	 eax, DWORD PTR _PacketStream$3[ebp+6]
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _memcpy

; 93   : 		this->m_wSize += wSize;

  002b6	66 01 b5 7c dc
	ff ff		 add	 WORD PTR _PacketStream$3[ebp+4], si
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 677  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  002bd	8d 85 80 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 92   : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 677  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  002c6	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$3[ebp]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  002d2	85 c0		 test	 eax, eax
  002d4	0f 85 b7 01 00
	00		 jne	 $LN115@ParsingRec

; 684  : 					}
; 685  : 
; 686  : 					headcode = pDecBuf[2];
; 687  : 	
; 688  : 					ProtocolCore(headcode, byDec, ret, uIndex, 1, hcode);

  002da	0f b6 85 76 dc
	ff ff		 movzx	 eax, BYTE PTR _hcode$1$[ebp]
  002e1	50		 push	 eax
  002e2	6a 01		 push	 1
  002e4	ff b5 70 dc ff
	ff		 push	 DWORD PTR _uIndex$GSCopy$1$[ebp]
  002ea	8d 85 80 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp]
  002f0	ff b5 64 dc ff
	ff		 push	 DWORD PTR _ret$1$[ebp]
  002f6	50		 push	 eax
  002f7	ff b5 83 e4 ff
	ff		 push	 DWORD PTR _byDec$[ebp+3]
  002fd	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore

; 689  : 				}

  00302	8b b5 60 dc ff
	ff		 mov	 esi, DWORD PTR _recvbuf$1$[ebp]
  00308	e9 b8 00 00 00	 jmp	 $LN130@ParsingRec
$LN24@ParsingRec:

; 690  : 			}
; 691  : #if (ANTI_CHEAT==1)
; 692  : 			else if( xcode == 0xC6 )

  0030d	3c c6		 cmp	 al, 198			; 000000c6H
  0030f	75 35		 jne	 SHORT $LN30@ParsingRec

; 693  : 			{
; 694  : 				switch( headcode )

  00311	80 fa 10	 cmp	 dl, 16			; 00000010H
  00314	0f 85 b5 00 00
	00		 jne	 $LN108@ParsingRec

; 695  : 				{
; 696  : 				case 0x10:
; 697  : 					{
; 698  : #if( ENABLETEST_CHEATGUARD == 1 )
; 699  : 						if (!g_CheatGuard.CG_LiveProc(&gObj[uIndex],(PacketCheatGuardCGClientInfo*)(recvbuf+lOfs),headcode,size))

  0031a	69 85 70 dc ff
	ff 40 27 00 00	 imul	 eax, DWORD PTR _uIndex$GSCopy$1$[ebp], 10048
  00324	57		 push	 edi
  00325	6a 10		 push	 16			; 00000010H
  00327	51		 push	 ecx
  00328	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CheatGuard@@3VCheatGuard@@A ; g_CheatGuard
  0032d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00333	50		 push	 eax
  00334	e8 00 00 00 00	 call	 ?CG_LiveProc@CheatGuard@@QAE_NPAUOBJECTSTRUCT@@PAUPacketCheatGuardCGClientInfo@@HH@Z ; CheatGuard::CG_LiveProc
  00339	84 c0		 test	 al, al
  0033b	0f 84 9c 02 00
	00		 je	 $LN126@ParsingRec

; 700  : #else
; 701  : 						if (!gObjSpeedCheck(uIndex,(PMSG_CHECK_ANTICHEAT*)(recvbuf+lOfs),headcode,size))
; 702  : #endif
; 703  : 						{
; 704  : 							return false;
; 705  : 						}
; 706  : 					}
; 707  : 					break;
; 708  : 				}
; 709  : 			}
; 710  : #endif
; 711  : 			else

  00341	e9 89 00 00 00	 jmp	 $LN108@ParsingRec
$LN30@ParsingRec:
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 16   : 	{

  00346	c7 85 78 dc ff
	ff 00 00 00 00	 mov	 DWORD PTR _ps$2[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 27   : 		this->m_wSize = 0;

  00350	33 c0		 xor	 eax, eax
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 715  : 				CStreamPacketEngine_Server ps;

  00352	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 27   : 		this->m_wSize = 0;

  00359	66 89 85 7c dc
	ff ff		 mov	 WORD PTR _ps$2[ebp+4], ax

; 85   : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  00360	0f b7 c7	 movzx	 eax, di
  00363	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00368	0f 8d 85 01 00
	00		 jge	 $LN99@ParsingRec
  0036e	66 85 ff	 test	 di, di
  00371	0f 84 7c 01 00
	00		 je	 $LN99@ParsingRec

; 92   : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  00377	50		 push	 eax
  00378	51		 push	 ecx
  00379	8d 85 7e dc ff
	ff		 lea	 eax, DWORD PTR _ps$2[ebp+6]
  0037f	50		 push	 eax
  00380	e8 00 00 00 00	 call	 _memcpy

; 93   : 		this->m_wSize += wSize;

  00385	66 01 bd 7c dc
	ff ff		 add	 WORD PTR _ps$2[ebp+4], di
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 727  : 				if ( ps.ExtractPacket(byDec) != 0 )

  0038c	8d 85 80 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 92   : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  00392	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 727  : 				if ( ps.ExtractPacket(byDec) != 0 )

  00395	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _ps$2[ebp]
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  003a1	85 c0		 test	 eax, eax
  003a3	0f 85 2d 01 00
	00		 jne	 $LN118@ParsingRec

; 734  : 				}
; 735  : 
; 736  : 				ProtocolCore(headcode, byDec, size, uIndex, 0, -1);

  003a9	6a ff		 push	 -1
  003ab	50		 push	 eax
  003ac	ff b5 70 dc ff
	ff		 push	 DWORD PTR _uIndex$GSCopy$1$[ebp]
  003b2	57		 push	 edi
$LN129@ParsingRec:
  003b3	8d 85 80 e4 ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp]
  003b9	50		 push	 eax
  003ba	ff b5 6c dc ff
	ff		 push	 DWORD PTR _headcode$[ebp]
  003c0	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
$LN130@ParsingRec:
  003c5	83 c4 18	 add	 esp, 24			; 00000018H

; 737  : 			}

  003c8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN108@ParsingRec:

; 738  : 
; 739  : 			lOfs += size;
; 740  : 			lpIOContext->nSentBytes -= size;			

  003cf	8b 95 68 dc ff
	ff		 mov	 edx, DWORD PTR _lpIOContext$GSCopy$1$[ebp]
  003d5	03 df		 add	 ebx, edi
  003d7	29 ba 64 9c 00
	00		 sub	 DWORD PTR [edx+40036], edi

; 741  : 			if( lpIOContext->nSentBytes <= 0 ) break;

  003dd	83 ba 64 9c 00
	00 00		 cmp	 DWORD PTR [edx+40036], 0
  003e4	0f 8f 76 fc ff
	ff		 jg	 $LL2@ParsingRec

; 776  : 					}
; 777  : 					break;
; 778  : 				}
; 779  : 			}
; 780  : 			break;
; 781  : 		}
; 782  : 	}
; 783  : 	return TRUE;

  003ea	b8 01 00 00 00	 mov	 eax, 1
  003ef	e9 eb 01 00 00	 jmp	 $LN1@ParsingRec
$LN113@ParsingRec:

; 633  : 					{
; 634  : 						////g_CS.Lock();
; 635  : 						LogAddC(2, "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",

  003f4	69 8d 70 dc ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _uIndex$GSCopy$1$[ebp], 10048
  003fe	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00404	ff 71 04	 push	 DWORD PTR [ecx+4]
  00407	68 7c 02 00 00	 push	 636			; 0000027cH
$LN131@ParsingRec:
  0040c	0f b6 85 77 dc
	ff ff		 movzx	 eax, BYTE PTR _headcode$1$[ebp]
  00413	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  00418	50		 push	 eax
  00419	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0041c	50		 push	 eax
  0041d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00420	50		 push	 eax
  00421	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00424	50		 push	 eax
  00425	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
  0042a	6a 02		 push	 2
  0042c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00432	83 c4 24	 add	 esp, 36			; 00000024H
  00435	e9 a3 01 00 00	 jmp	 $LN126@ParsingRec
$LN61@ParsingRec:
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 87   : 			LogAddC(2,"CStreamPacketEngine Adding Buffer Size Error %d", this->m_wSize + wSize);

  0043a	0f b7 c0	 movzx	 eax, ax
  0043d	50		 push	 eax
  0043e	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  00443	6a 02		 push	 2
  00445	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 626  : 						LogAddC(2, "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",

  0044b	69 8d 70 dc ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _uIndex$GSCopy$1$[ebp], 10048
  00455	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0045b	ff 71 04	 push	 DWORD PTR [ecx+4]
  0045e	68 73 02 00 00	 push	 627			; 00000273H
$LN132@ParsingRec:
  00463	0f b6 85 77 dc
	ff ff		 movzx	 eax, BYTE PTR _headcode$1$[ebp]
  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0046f	50		 push	 eax
  00470	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00473	50		 push	 eax
  00474	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00477	50		 push	 eax
  00478	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0047b	50		 push	 eax
  0047c	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@
  00481	6a 02		 push	 2
  00483	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00489	83 c4 30	 add	 esp, 48			; 00000030H

; 636  : 							gObj[uIndex].Ip_addr, gObj[uIndex].AccountID, gObj[uIndex].Name, headcode, __FILE__, __LINE__, gObj[uIndex].Connected);
; 637  : 						////g_CS.UnLock();
; 638  : 						return FALSE;

  0048c	e9 4c 01 00 00	 jmp	 $LN126@ParsingRec
$LN115@ParsingRec:

; 678  : 					{
; 679  : 						////g_CS.Lock();
; 680  : 						LogAddC(2, "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",

  00491	69 8d 70 dc ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _uIndex$GSCopy$1$[ebp], 10048
  0049b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004a1	ff 71 04	 push	 DWORD PTR [ecx+4]
  004a4	68 a9 02 00 00	 push	 681			; 000002a9H
  004a9	e9 5e ff ff ff	 jmp	 $LN131@ParsingRec
$LN80@ParsingRec:
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 87   : 			LogAddC(2,"CStreamPacketEngine Adding Buffer Size Error %d", this->m_wSize + wSize);

  004ae	56		 push	 esi
  004af	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  004b4	6a 02		 push	 2
  004b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 671  : 						LogAddC(2, "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",

  004bc	69 8d 70 dc ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _uIndex$GSCopy$1$[ebp], 10048
  004c6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004cc	ff 71 04	 push	 DWORD PTR [ecx+4]
  004cf	68 a0 02 00 00	 push	 672			; 000002a0H

; 681  : 							gObj[uIndex].Ip_addr, gObj[uIndex].AccountID, gObj[uIndex].Name, headcode, __FILE__, __LINE__, gObj[uIndex].Connected);
; 682  : 						////g_CS.UnLock();
; 683  : 						return FALSE;

  004d4	eb 8d		 jmp	 SHORT $LN132@ParsingRec
$LN118@ParsingRec:

; 728  : 				{
; 729  : 					////g_CS.Lock();
; 730  : 					LogAddC(2, "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",

  004d6	69 8d 70 dc ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _uIndex$GSCopy$1$[ebp], 10048
  004e0	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004e6	ff 71 04	 push	 DWORD PTR [ecx+4]
  004e9	68 db 02 00 00	 push	 731			; 000002dbH
  004ee	e9 19 ff ff ff	 jmp	 $LN131@ParsingRec
$LN99@ParsingRec:
; File c:\users\michel\desktop\source\gameserver\source\spe.h

; 87   : 			LogAddC(2,"CStreamPacketEngine Adding Buffer Size Error %d", this->m_wSize + wSize);

  004f3	0f b7 c7	 movzx	 eax, di
  004f6	50		 push	 eax
  004f7	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  004fc	6a 02		 push	 2
  004fe	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp

; 721  : 					LogAddC(2, "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",

  00504	69 8d 70 dc ff
	ff 40 27 00 00	 imul	 ecx, DWORD PTR _uIndex$GSCopy$1$[ebp], 10048
  0050e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00514	ff 71 04	 push	 DWORD PTR [ecx+4]
  00517	68 d2 02 00 00	 push	 722			; 000002d2H

; 731  : 						gObj[uIndex].Ip_addr, gObj[uIndex].AccountID, gObj[uIndex].Name, headcode, __FILE__, __LINE__, gObj[uIndex].Connected);
; 732  : 					////g_CS.UnLock();
; 733  : 					return FALSE;

  0051c	e9 42 ff ff ff	 jmp	 $LN132@ParsingRec
$LN16@ParsingRec:

; 742  : 		}			
; 743  : 		else 
; 744  : 		{
; 745  : 			if( lOfs > 0 )

  00521	85 db		 test	 ebx, ebx
  00523	0f 8e 9e 00 00
	00		 jle	 $LN40@ParsingRec

; 746  : 			{
; 747  : 				if( lpIOContext->nSentBytes < 1 ) 

  00529	8b 85 68 dc ff
	ff		 mov	 eax, DWORD PTR _lpIOContext$GSCopy$1$[ebp]
  0052f	8b 80 64 9c 00
	00		 mov	 eax, DWORD PTR [eax+40036]
  00535	83 f8 01	 cmp	 eax, 1
  00538	7d 1d		 jge	 SHORT $LN38@ParsingRec

; 748  : 				{
; 749  : 					////g_CS.Lock();
; 750  : 					LogAdd("error-L1 : recvbuflen 1 %s %d", __FILE__, __LINE__);

  0053a	68 ee 02 00 00	 push	 750			; 000002eeH
  0053f	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  00544	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0054f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 751  : 					////g_CS.UnLock();
; 752  : 					return false;

  00552	e9 86 00 00 00	 jmp	 $LN126@ParsingRec
$LN38@ParsingRec:

; 753  : 				}
; 754  : 				else 
; 755  : 				{
; 756  : 					if( lpIOContext->nSentBytes < MAX_BUFF_SIZE )

  00557	3d 20 4e 00 00	 cmp	 eax, 20000		; 00004e20H
  0055c	7d 69		 jge	 SHORT $LN40@ParsingRec

; 757  : 					{
; 758  : 					#if (CUSTOM_ENCRYPT == 1)
; 759  : 						LogAddHeadHexFunc(1,(char*)recvbuf,lpIOContext->nSentBytes);

  0055e	50		 push	 eax
  0055f	56		 push	 esi
  00560	6a 01		 push	 1
  00562	e8 00 00 00 00	 call	 ?LogAddHeadHexFunc@@YAXHPADH@Z ; LogAddHeadHexFunc

; 760  : 						if( recvbuf[lOfs] == 0xC1 || recvbuf[lOfs] == 0xC3 )

  00567	8a 0c 1e	 mov	 cl, BYTE PTR [esi+ebx]
  0056a	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  0056d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00570	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  00573	74 1d		 je	 SHORT $LN43@ParsingRec
  00575	80 f9 c3	 cmp	 cl, 195			; 000000c3H
  00578	74 18		 je	 SHORT $LN43@ParsingRec

; 764  : 						}
; 765  : 						else if( recvbuf[lOfs] == 0xC2 || recvbuf[lOfs] == 0xC4 ) 

  0057a	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  0057d	74 05		 je	 SHORT $LN45@ParsingRec
  0057f	80 f9 c4	 cmp	 cl, 196			; 000000c4H
  00582	75 16		 jne	 SHORT $LN44@ParsingRec
$LN45@ParsingRec:

; 766  : 						{
; 767  : 							recvbuf[lOfs+1] ^= 0x11;

  00584	80 70 01 11	 xor	 BYTE PTR [eax+1], 17	; 00000011H

; 768  : 							recvbuf[lOfs+2] ^= 0x41;

  00588	80 70 02 41	 xor	 BYTE PTR [eax+2], 65	; 00000041H

; 769  : 							recvbuf[lOfs+3] ^= 0x31;

  0058c	80 70 03 31	 xor	 BYTE PTR [eax+3], 49	; 00000031H
  00590	eb 08		 jmp	 SHORT $LN44@ParsingRec
$LN43@ParsingRec:

; 761  : 						{
; 762  : 							recvbuf[lOfs+1] ^= 0x10;

  00592	80 70 01 10	 xor	 BYTE PTR [eax+1], 16	; 00000010H

; 763  : 							recvbuf[lOfs+2] ^= 0x40;

  00596	80 70 02 40	 xor	 BYTE PTR [eax+2], 64	; 00000040H
$LN44@ParsingRec:

; 770  : 						}
; 771  : 						recvbuf[lOfs] ^= 0x20;
; 772  : 					#endif
; 773  : 
; 774  : 						memcpy(recvbuf, (recvbuf+lOfs), lpIOContext->nSentBytes);

  0059a	8b 9d 68 dc ff
	ff		 mov	 ebx, DWORD PTR _lpIOContext$GSCopy$1$[ebp]
  005a0	80 f1 20	 xor	 cl, 32			; 00000020H
  005a3	88 08		 mov	 BYTE PTR [eax], cl
  005a5	ff b3 64 9c 00
	00		 push	 DWORD PTR [ebx+40036]
  005ab	50		 push	 eax
  005ac	56		 push	 esi
  005ad	e8 00 00 00 00	 call	 _memcpy

; 775  : 						LogAdd("Message copy %d, packet size: %d", lpIOContext->nSentBytes,size);

  005b2	57		 push	 edi
  005b3	ff b3 64 9c 00
	00		 push	 DWORD PTR [ebx+40036]
  005b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MDIGBGGE@Message?5copy?5?$CFd?0?5packet?5size?3?5?$CFd@
  005be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005c4	83 c4 18	 add	 esp, 24			; 00000018H
$LN40@ParsingRec:

; 776  : 					}
; 777  : 					break;
; 778  : 				}
; 779  : 			}
; 780  : 			break;
; 781  : 		}
; 782  : 	}
; 783  : 	return TRUE;

  005c7	b8 01 00 00 00	 mov	 eax, 1
  005cc	eb 11		 jmp	 SHORT $LN1@ParsingRec
$LN111@ParsingRec:

; 592  : 		{
; 593  : 			////g_CS.Lock();			
; 594  : 			LogAdd("error-L1 : size %d",size);

  005ce	57		 push	 edi
  005cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@
  005d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005da	83 c4 08	 add	 esp, 8
$LN126@ParsingRec:

; 595  : 			////g_CS.UnLock();
; 596  : 			return FALSE;

  005dd	33 c0		 xor	 eax, eax
$LN1@ParsingRec:

; 784  : }

  005df	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005e2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005e9	59		 pop	 ecx
  005ea	5f		 pop	 edi
  005eb	5e		 pop	 esi
  005ec	5b		 pop	 ebx
  005ed	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f0	33 cd		 xor	 ecx, ebp
  005f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f7	8b e5		 mov	 esp, ebp
  005f9	5d		 pop	 ebp
  005fa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z$0:
  00000	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z$1:
  0000b	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z$2:
  00016	8d 8d 78 dc ff
	ff		 lea	 ecx, DWORD PTR _ps$2[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__ehhandler$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 58 dc ff
	ff		 mov	 ecx, DWORD PTR [edx-9128]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ParsingRecvData@@YAHPAU_PER_IO_CONTEXT@@H@Z ENDP	; ParsingRecvData
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?DestroyGIocp@@YAXXZ
_TEXT	SEGMENT
?DestroyGIocp@@YAXXZ PROC				; DestroyGIocp, COMDAT

; 132  : {

  00000	56		 push	 esi

; 133  : 	for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  00001	33 f6		 xor	 esi, esi
  00003	57		 push	 edi
  00004	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__TerminateThread@8
  0000a	39 35 00 00 00
	00		 cmp	 DWORD PTR ?g_dwThreadCount@@3KA, esi ; g_dwThreadCount
  00010	76 14		 jbe	 SHORT $LN3@DestroyGIo
$LL4@DestroyGIo:

; 134  : 	{
; 135  : 		TerminateThread(g_ThreadHandles[dwCPU], 0);

  00012	6a 00		 push	 0
  00014	ff 34 b5 00 00
	00 00		 push	 DWORD PTR ?g_ThreadHandles@@3PAPAXA[esi*4]
  0001b	ff d7		 call	 edi
  0001d	46		 inc	 esi
  0001e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  00024	72 ec		 jb	 SHORT $LL4@DestroyGIo
$LN3@DestroyGIo:

; 136  : 	}
; 137  : 	TerminateThread(g_IocpThreadHandle, 0);

  00026	6a 00		 push	 0
  00028	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_IocpThreadHandle@@3PAXA ; g_IocpThreadHandle
  0002e	ff d7		 call	 edi

; 138  : 
; 139  : 	if( g_CompletionPort )

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	85 c0		 test	 eax, eax
  00039	74 11		 je	 SHORT $LN5@DestroyGIo

; 140  : 	{
; 141  : 		CloseHandle(g_CompletionPort);

  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 142  : 		g_CompletionPort = NULL;

  00042	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
$LN5@DestroyGIo:

; 143  : 	}
; 144  : }

  0004c	c3		 ret	 0
?DestroyGIocp@@YAXXZ ENDP				; DestroyGIocp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?CloseClient@@YAXH@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_index$ = 8						; size = 4
?CloseClient@@YAXH@Z PROC				; CloseClient, COMDAT

; 1095 : { 	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1096 : 	if( index < OBJ_STARTUSERINDEX || index >= OBJMAX ) return;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00006	8d 81 fc d6 ff
	ff		 lea	 eax, DWORD PTR [ecx-10500]
  0000c	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00011	77 4d		 ja	 SHORT $LN3@CloseClien

; 1097 : 
; 1098 : 	if( gObj[index].Connected == 0 ) return;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048
  0001f	83 7c 06 04 00	 cmp	 DWORD PTR [esi+eax+4], 0
  00024	74 39		 je	 SHORT $LN8@CloseClien

; 1099 : 
; 1100 : 	CCSLock cs(&g_SendLock);

  00026	68 00 00 00 00	 push	 OFFSET ?g_SendLock@@3VCCriticalSec@@A ; g_SendLock
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0CCSLock@@QAE@PAVCCriticalSec@@@Z ; CCSLock::CCSLock

; 1101 : 
; 1102 : 	if( INVALID_SOCKET != gObj[index].m_socket )

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	8b 44 06 18	 mov	 eax, DWORD PTR [esi+eax+24]
  0003c	83 f8 ff	 cmp	 eax, -1
  0003f	74 14		 je	 SHORT $LN5@CloseClien

; 1103 : 	{
; 1104 : 		closesocket(gObj[index].m_socket);

  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 1105 : 		gObj[index].m_socket = INVALID_SOCKET;

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004d	c7 44 06 18 ff
	ff ff ff	 mov	 DWORD PTR [esi+eax+24], -1
$LN5@CloseClien:

; 1106 : 	}
; 1107 : }

  00055	8d 4d 08	 lea	 ecx, DWORD PTR _cs$[ebp]
  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	e9 00 00 00 00	 jmp	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
$LN8@CloseClien:
  0005f	5e		 pop	 esi
$LN3@CloseClien:
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?CloseClient@@YAXH@Z ENDP				; CloseClient
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?UpdateCompletionPort@@YAHIHH@Z
_TEXT	SEGMENT
_sd$ = 8						; size = 4
_ClientIndex$ = 12					; size = 4
_bAddToList$ = 16					; size = 4
?UpdateCompletionPort@@YAHIHH@Z PROC			; UpdateCompletionPort, COMDAT

; 1045 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1046 :     LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL;
; 1047 : 	
; 1048 : 	HANDLE CompletionPort;
; 1049 : 
; 1050 : 	CompletionPort = CreateIoCompletionPort((HANDLE)sd, g_CompletionPort, (DWORD)ClientIndex, 0); 

  00004	8b 75 0c	 mov	 esi, DWORD PTR _ClientIndex$[ebp]
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00010	ff 75 08	 push	 DWORD PTR _sd$[ebp]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16

; 1051 :     
; 1052 : 	if ( CompletionPort == NULL)

  00019	85 c0		 test	 eax, eax
  0001b	75 33		 jne	 SHORT $LN2@UpdateComp

; 1053 : 	{
; 1054 : 		printf("Error CPHandle = %d, SOCKET [%d]\n", CompletionPort, g_Listen);

  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_Listen@@3IA ; g_Listen
  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LDGOPEFD@Error?5CPHandle?5?$DN?5?$CFd?0?5SOCKET?5?$FL?$CFd?$FN@
  00029	e8 00 00 00 00	 call	 _printf
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1055 : 		////g_CS.Lock();
; 1056 : 
; 1057 : 		GetLastErrorMsg();		

  00031	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 1058 : 
; 1059 : 		LogAdd("CreateIoCompletionPort: %d", GetLastError() );

  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0003c	50		 push	 eax
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00048	83 c4 08	 add	 esp, 8

; 1060 : 
; 1061 : 		////g_CS.UnLock();
; 1062 :         return FALSE;

  0004b	33 c0		 xor	 eax, eax
  0004d	5e		 pop	 esi

; 1067 : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN2@UpdateComp:

; 1063 : 	}
; 1064 : 	g_CompletionPort = CompletionPort;
; 1065 : 	InterlockedExchange(&gObj[ClientIndex].PerSocketContext->dwIOCount, 0);	

  00050	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00056	33 d2		 xor	 edx, edx
  00058	a3 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, eax ; g_CompletionPort
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00062	8b 44 01 14	 mov	 eax, DWORD PTR [ecx+eax+20]
  00066	05 e8 38 01 00	 add	 eax, 80104		; 000138e8H
  0006b	87 10		 xchg	 DWORD PTR [eax], edx

; 1066 :     return TRUE;	

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	5e		 pop	 esi

; 1067 : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?UpdateCompletionPort@@YAHIHH@Z ENDP			; UpdateCompletionPort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?DataSend@@YAHHPAEK@Z
_TEXT	SEGMENT
_SendBytes$ = -28					; size = 4
_cs$ = -24						; size = 4
tv522 = -20						; size = 4
_lpPerSocketContext$1$ = -16				; size = 4
_dwSize$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
tv521 = 8						; size = 4
_aIndex$ = 8						; size = 4
_btsize$1$ = 11						; size = 1
_lpMsg$ = 12						; size = 4
_dwSize$ = 16						; size = 4
?DataSend@@YAHHPAEK@Z PROC				; DataSend, COMDAT

; 787  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DataSend@@YAHHPAEK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 788  : 	unsigned char * SendBuf;
; 789  : 
; 790  : 	if( aIndex < OBJ_STARTUSERINDEX || aIndex >= OBJMAX ) return FALSE;

  00028	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0002b	8d 87 fc d6 ff
	ff		 lea	 eax, DWORD PTR [edi-10500]
  00031	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00036	0f 87 97 03 00
	00		 ja	 $LN3@DataSend

; 791  : 
; 792  : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 793  : 
; 794  : 	if( gObj[aIndex].bOffTrade )

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00041	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  00047	89 5d ec	 mov	 DWORD PTR tv522[ebp], ebx
  0004a	80 bc 03 31 27
	00 00 00	 cmp	 BYTE PTR [ebx+eax+10033], 0
  00052	0f 85 7b 03 00
	00		 jne	 $LN3@DataSend

; 795  : 		return FALSE;
; 796  : 
; 797  : #endif
; 798  : 
; 799  : 	CCSLock cs(&g_SendLock);

  00058	68 00 00 00 00	 push	 OFFSET ?g_SendLock@@3VCCriticalSec@@A ; g_SendLock
  0005d	8d 4d e8	 lea	 ecx, DWORD PTR _cs$[ebp]
  00060	e8 00 00 00 00	 call	 ??0CCSLock@@QAE@PAVCCriticalSec@@@Z ; CCSLock::CCSLock

; 800  : 
; 801  : 
; 802  : 	DWORD SendBytes;
; 803  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext;	
; 804  : 
; 805  : 	if( gObj[aIndex].Connected < 1)

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00071	83 7c 03 04 01	 cmp	 DWORD PTR [ebx+eax+4], 1
  00076	0f 8c 24 01 00
	00		 jl	 $LN27@DataSend

; 806  : 	{
; 807  : 		return FALSE;
; 808  : 	}
; 809  : 
; 810  : 	if ( lpMsg[0] == 0xC3 || lpMsg[0] == 0xC4 )

  0007c	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0007f	8a 02		 mov	 al, BYTE PTR [edx]
  00081	3c c3		 cmp	 al, 195			; 000000c3H
  00083	74 79		 je	 SHORT $LN33@DataSend
  00085	3c c4		 cmp	 al, 196			; 000000c4H
  00087	74 08		 je	 SHORT $LN9@DataSend

; 840  : 		}
; 841  : 	}
; 842  : 	else
; 843  : 	{
; 844  : 		SendBuf = lpMsg;

  00089	8b 5d 10	 mov	 ebx, DWORD PTR _dwSize$[ebp]
  0008c	e9 c1 00 00 00	 jmp	 $LN10@DataSend
$LN9@DataSend:

; 827  : 		}
; 828  : 		else
; 829  : 		{
; 830  : 			btsize = lpMsg[2];

  00091	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00094	8d 72 02	 lea	 esi, DWORD PTR [edx+2]

; 831  : 			lpMsg[2] = gNSerialCheck[aIndex].GetSendSerial();

  00097	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[edi*8]
  0009e	88 45 0b	 mov	 BYTE PTR _btsize$1$[ebp], al
  000a1	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial
  000a6	88 06		 mov	 BYTE PTR [esi], al

; 832  : 
; 833  : 			ret = g_SimpleModulus.Encrypt(&ExSendBuf[3], &lpMsg[2], dwSize-2);

  000a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulus@@3VCSimpleModulus@@A ; g_SimpleModulus
  000ad	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  000b0	83 c0 fe	 add	 eax, -2			; fffffffeH
  000b3	50		 push	 eax
  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000b9	56		 push	 esi
  000ba	83 c0 03	 add	 eax, 3
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt

; 834  : 			ExSendBuf[0] = 0xC4;

  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000c9	8b d8		 mov	 ebx, eax
  000cb	c6 01 c4	 mov	 BYTE PTR [ecx], 196	; 000000c4H

; 835  : 			ExSendBuf[1] = SET_NUMBERH(ret+3);

  000ce	8d 53 03	 lea	 edx, DWORD PTR [ebx+3]
  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000d7	89 55 f0	 mov	 DWORD PTR _dwSize$1$[ebp], edx
  000da	c1 ea 08	 shr	 edx, 8

; 836  : 			ExSendBuf[2] = SET_NUMBERL(ret+3);

  000dd	80 c3 03	 add	 bl, 3
  000e0	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  000e3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000e8	88 58 02	 mov	 BYTE PTR [eax+2], bl

; 837  : 			SendBuf = ExSendBuf;

  000eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf

; 838  : 			dwSize = ret + 3;
; 839  : 			lpMsg[2] = btsize;

  000f1	8a 45 0b	 mov	 al, BYTE PTR _btsize$1$[ebp]
  000f4	8b 5d f0	 mov	 ebx, DWORD PTR _dwSize$1$[ebp]
  000f7	89 55 0c	 mov	 DWORD PTR _lpMsg$[ebp], edx
  000fa	88 06		 mov	 BYTE PTR [esi], al
  000fc	eb 54		 jmp	 SHORT $LN10@DataSend
$LN33@DataSend:

; 811  : 	{
; 812  : 		int ret;
; 813  : 		BYTE btsize;
; 814  : 
; 815  : 		if ( lpMsg[0] == 0xC3 )
; 816  : 		{
; 817  : 			btsize = lpMsg[1];

  000fe	8a 5a 01	 mov	 bl, BYTE PTR [edx+1]
  00101	8d 72 01	 lea	 esi, DWORD PTR [edx+1]

; 818  : 			lpMsg[1]=gNSerialCheck[aIndex].GetSendSerial();

  00104	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[edi*8]
  0010b	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial
  00110	88 06		 mov	 BYTE PTR [esi], al

; 819  : 
; 820  : 			ret = g_SimpleModulus.Encrypt(&ExSendBuf[2], &lpMsg[1], dwSize-1);

  00112	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulus@@3VCSimpleModulus@@A ; g_SimpleModulus
  00117	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  0011a	48		 dec	 eax
  0011b	50		 push	 eax
  0011c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00121	56		 push	 esi
  00122	83 c0 02	 add	 eax, 2
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt

; 821  : 			ExSendBuf[0] = 0xC3;

  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf

; 822  : 			ExSendBuf[1] = ret + 2;

  00131	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00134	c6 01 c3	 mov	 BYTE PTR [ecx], 195	; 000000c3H
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  0013d	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 823  : 			SendBuf = ExSendBuf;
; 824  : 
; 825  : 			dwSize = ret + 2;

  00140	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf

; 826  : 			lpMsg[1] = btsize;

  00149	88 1e		 mov	 BYTE PTR [esi], bl
  0014b	8b da		 mov	 ebx, edx
  0014d	89 4d 0c	 mov	 DWORD PTR _lpMsg$[ebp], ecx
  00150	8b d1		 mov	 edx, ecx
$LN10@DataSend:

; 845  : 	}
; 846  : 
; 847  : 	lpPerSocketContext = gObj[aIndex].PerSocketContext;

  00152	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00157	8b 4d ec	 mov	 ecx, DWORD PTR tv522[ebp]
  0015a	03 c1		 add	 eax, ecx
  0015c	89 45 08	 mov	 DWORD PTR tv521[ebp], eax
  0015f	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00162	89 75 f0	 mov	 DWORD PTR _lpPerSocketContext$1$[ebp], esi

; 848  : 	
; 849  : 	if( dwSize > MAX_BUFF_SIZE )

  00165	81 fb 20 4e 00
	00		 cmp	 ebx, 20000		; 00004e20H
  0016b	76 51		 jbe	 SHORT $LN11@DataSend

; 850  : 	{
; 851  : 		////g_CS.Lock();		
; 852  : 		LogAdd("Error : Max msg(%d) %s %d", dwSize, __FILE__, __LINE__);

  0016d	68 54 03 00 00	 push	 852			; 00000354H
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  00177	53		 push	 ebx
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 853  : 		LogAddHeadHexFunc(1,(char*)lpPerSocketContext->IOContext[1].BufferSecond[0],MAX_BUFF_SIZE);

  00183	0f be 86 b4 ea
	00 00		 movsx	 eax, BYTE PTR [esi+60084]
  0018a	68 20 4e 00 00	 push	 20000			; 00004e20H
  0018f	50		 push	 eax
  00190	6a 01		 push	 1
  00192	e8 00 00 00 00	 call	 ?LogAddHeadHexFunc@@YAXHPADH@Z ; LogAddHeadHexFunc

; 854  : 		////g_CS.UnLock();
; 855  : 		CloseClient( aIndex );

  00197	57		 push	 edi
  00198	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0019d	83 c4 20	 add	 esp, 32			; 00000020H
$LN27@DataSend:
  001a0	33 f6		 xor	 esi, esi
$LN32@DataSend:

; 942  : 	return TRUE;

  001a2	8d 4d e8	 lea	 ecx, DWORD PTR _cs$[ebp]
  001a5	e8 00 00 00 00	 call	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
  001aa	8b c6		 mov	 eax, esi

; 943  : }

  001ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b6	59		 pop	 ecx
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c3		 ret	 0
$LN11@DataSend:

; 856  : 		return FALSE;
; 857  : 	}
; 858  : 
; 859  : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];	

  001be	81 c6 78 9c 00
	00		 add	 esi, 40056		; 00009c78H

; 860  : 
; 861  : 	if( lpIoCtxt->nWaitIO > 0 )

  001c4	83 be 6c 9c 00
	00 00		 cmp	 DWORD PTR [esi+40044], 0
  001cb	7e 6c		 jle	 SHORT $LN12@DataSend

; 862  : 	{	
; 863  : 		if( (lpIoCtxt->nSecondOfs+dwSize) > MAX_BUFF_SIZE-1)

  001cd	8b 8e 5c 9c 00
	00		 mov	 ecx, DWORD PTR [esi+40028]
  001d3	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001d6	3d 1f 4e 00 00	 cmp	 eax, 19999		; 00004e1fH
  001db	76 39		 jbe	 SHORT $LN14@DataSend

; 864  : 		{
; 865  : 			////g_CS.Lock();			
; 866  : 			//LogAddHeadHexFunc(1,(char*)&lpIoCtxt->BufferSecond[0],MAX_BUFF_SIZE);
; 867  : 			LogAdd("(%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]", aIndex, lpIoCtxt->nTotalBytes, lpIoCtxt->nSecondOfs, dwSize, gObj[aIndex].AccountID, gObj[aIndex].Name);

  001dd	8b 55 08	 mov	 edx, DWORD PTR tv521[ebp]
  001e0	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  001e3	50		 push	 eax
  001e4	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  001e7	50		 push	 eax
  001e8	53		 push	 ebx
  001e9	51		 push	 ecx
  001ea	ff b6 60 9c 00
	00		 push	 DWORD PTR [esi+40032]
  001f0	57		 push	 edi
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 868  : 			////g_CS.UnLock();
; 869  : 			lpIoCtxt->nWaitIO = 0;
; 870  : 			CloseClient( aIndex );			

  001fc	57		 push	 edi
  001fd	c7 86 6c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40044], 0
  00207	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0020c	83 c4 20	 add	 esp, 32			; 00000020H

; 871  : 			return TRUE;

  0020f	be 01 00 00 00	 mov	 esi, 1
  00214	eb 8c		 jmp	 SHORT $LN32@DataSend
$LN14@DataSend:

; 872  : 		}
; 873  : 		else
; 874  : 		{
; 875  : 			memcpy(lpIoCtxt->BufferSecond+lpIoCtxt->nSecondOfs, SendBuf, dwSize);

  00216	53		 push	 ebx
  00217	8d 86 3c 4e 00
	00		 lea	 eax, DWORD PTR [esi+20028]
  0021d	52		 push	 edx
  0021e	03 c1		 add	 eax, ecx
  00220	50		 push	 eax
  00221	e8 00 00 00 00	 call	 _memcpy
  00226	83 c4 0c	 add	 esp, 12			; 0000000cH

; 876  : 			lpIoCtxt->nSecondOfs+=dwSize;

  00229	01 9e 5c 9c 00
	00		 add	 DWORD PTR [esi+40028], ebx

; 877  : 			return TRUE;

  0022f	be 01 00 00 00	 mov	 esi, 1
  00234	e9 69 ff ff ff	 jmp	 $LN32@DataSend
$LN12@DataSend:

; 878  : 		}
; 879  : 	}
; 880  : 	else
; 881  : 	{
; 882  : 		lpIoCtxt->nTotalBytes = 0;
; 883  : 
; 884  : 		if( lpIoCtxt->nSecondOfs > 0 )

  00239	8b 86 5c 9c 00
	00		 mov	 eax, DWORD PTR [esi+40028]
  0023f	c7 86 60 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40032], 0
  00249	85 c0		 test	 eax, eax
  0024b	7e 2d		 jle	 SHORT $LN16@DataSend

; 885  : 		{
; 886  : 			memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  0024d	50		 push	 eax
  0024e	8d 86 3c 4e 00
	00		 lea	 eax, DWORD PTR [esi+20028]
  00254	50		 push	 eax
  00255	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 _memcpy

; 887  : 			lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  0025e	8b 86 5c 9c 00
	00		 mov	 eax, DWORD PTR [esi+40028]
  00264	83 c4 0c	 add	 esp, 12			; 0000000cH
  00267	8b 4d ec	 mov	 ecx, DWORD PTR tv522[ebp]
  0026a	89 86 60 9c 00
	00		 mov	 DWORD PTR [esi+40032], eax

; 888  : 			lpIoCtxt->nSecondOfs = 0;

  00270	c7 86 5c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40028], 0
$LN16@DataSend:

; 889  : 		}
; 890  : 
; 891  : 		if( (lpIoCtxt->nTotalBytes+dwSize) > MAX_BUFF_SIZE-1)

  0027a	8b 96 60 9c 00
	00		 mov	 edx, DWORD PTR [esi+40032]
  00280	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00283	3d 1f 4e 00 00	 cmp	 eax, 19999		; 00004e1fH
  00288	76 34		 jbe	 SHORT $LN17@DataSend

; 892  : 		{
; 893  : 			////g_CS.Lock();			
; 894  : 			//LogAddHeadHexFunc(1,&lpIoCtxt->Buffer[0],MAX_BUFF_SIZE);
; 895  : 			LogAdd("(%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]", aIndex, lpIoCtxt->nTotalBytes, dwSize, gObj[aIndex].AccountID, gObj[aIndex].Name);

  0028a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00290	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00293	50		 push	 eax
  00294	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00297	50		 push	 eax
  00298	53		 push	 ebx
  00299	52		 push	 edx
  0029a	57		 push	 edi
  0029b	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
  002a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 896  : 			////g_CS.UnLock();
; 897  : 			lpIoCtxt->nWaitIO = 0;
; 898  : 			CloseClient( aIndex );			

  002a6	57		 push	 edi
  002a7	c7 86 6c 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40044], 0
  002b1	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002b6	83 c4 1c	 add	 esp, 28			; 0000001cH

; 899  : 			return FALSE;

  002b9	e9 e2 fe ff ff	 jmp	 $LN27@DataSend
$LN17@DataSend:

; 900  : 		}
; 901  : 		else
; 902  : 		{
; 903  : 			memcpy(lpIoCtxt->Buffer+lpIoCtxt->nTotalBytes, SendBuf, dwSize);

  002be	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002c1	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  002c4	53		 push	 ebx
  002c5	51		 push	 ecx
  002c6	03 c2		 add	 eax, edx
  002c8	50		 push	 eax
  002c9	e8 00 00 00 00	 call	 _memcpy

; 904  : 			lpIoCtxt->nTotalBytes += dwSize;

  002ce	01 9e 60 9c 00
	00		 add	 DWORD PTR [esi+40032], ebx

; 905  : 		}
; 906  : 	}
; 907  : 
; 908  : 	lpIoCtxt->wsabuf.buf	= (char*)lpIoCtxt->Buffer;

  002d4	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  002d7	8b 8e 60 9c 00
	00		 mov	 ecx, DWORD PTR [esi+40032]
  002dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 909  : 	lpIoCtxt->wsabuf.len	= lpIoCtxt->nTotalBytes;
; 910  : 	lpIoCtxt->nSentBytes	= 0;
; 911  : 	lpIoCtxt->IOOperation	= SEND_IO;
; 912  : 
; 913  : 	if (WSASend(gObj[aIndex].m_socket, &(lpIoCtxt->wsabuf), 1, &SendBytes, 0,
; 914  : 		&(lpIoCtxt->Overlapped), NULL) == SOCKET_ERROR)

  002e0	8b 5d ec	 mov	 ebx, DWORD PTR tv522[ebp]
  002e3	89 46 18	 mov	 DWORD PTR [esi+24], eax
  002e6	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  002e9	89 08		 mov	 DWORD PTR [eax], ecx
  002eb	8d 4d e4	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  002ee	6a 00		 push	 0
  002f0	56		 push	 esi
  002f1	6a 00		 push	 0
  002f3	51		 push	 ecx
  002f4	6a 01		 push	 1
  002f6	c7 86 64 9c 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+40036], 0
  00300	c7 86 68 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+40040], 1
  0030a	50		 push	 eax
  0030b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00310	ff 74 03 18	 push	 DWORD PTR [ebx+eax+24]
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  0031a	83 f8 ff	 cmp	 eax, -1
  0031d	0f 85 92 00 00
	00		 jne	 $LN19@DataSend

; 915  : 	{
; 916  : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  00323	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00329	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  0032e	0f 84 8b 00 00
	00		 je	 $LN20@DataSend

; 917  : 		{
; 918  : 			////g_CS.Lock();			
; 919  : 			GetLastErrorMsg();

  00334	e8 00 00 00 00	 call	 ?GetLastErrorMsg@@YAXXZ	; GetLastErrorMsg

; 920  : 			
; 921  : 			if ( lpIoCtxt->wsabuf.buf[0] == 0xC1 )

  00339	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0033c	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0033f	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  00344	75 27		 jne	 SHORT $LN22@DataSend

; 922  : 			{
; 923  : 				LogAdd("(%d)WSASend(%d) failed with error [%x][%x] %d %s ", __LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0],

  00346	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0034b	8b 76 18	 mov	 esi, DWORD PTR [esi+24]
  0034e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00351	03 c3		 add	 eax, ebx
  00353	50		 push	 eax
  00354	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__WSAGetLastError@0
  00359	ff d0		 call	 eax
  0035b	50		 push	 eax
  0035c	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00360	50		 push	 eax
  00361	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00364	50		 push	 eax
  00365	57		 push	 edi
  00366	68 9b 03 00 00	 push	 923			; 0000039bH
  0036b	eb 2c		 jmp	 SHORT $LN35@DataSend
$LN22@DataSend:

; 924  : 					(BYTE)lpIoCtxt->wsabuf.buf[2], WSAGetLastError(), gObj[aIndex].Ip_addr);
; 925  : 			}
; 926  : 			else if ( lpIoCtxt->wsabuf.buf[0] == 0xC2 )

  0036d	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  00372	75 33		 jne	 SHORT $LN24@DataSend

; 927  : 			{
; 928  : 				LogAdd("(%d)WSASend(%d) failed with error [%x][%x] %d %s ", __LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0],

  00374	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00379	8b 76 18	 mov	 esi, DWORD PTR [esi+24]
  0037c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0037f	03 c3		 add	 eax, ebx
  00381	50		 push	 eax
  00382	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__WSAGetLastError@0
  00387	ff d0		 call	 eax
  00389	50		 push	 eax
  0038a	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0038e	50		 push	 eax
  0038f	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00392	50		 push	 eax
  00393	57		 push	 edi
  00394	68 a0 03 00 00	 push	 928			; 000003a0H
$LN35@DataSend:
  00399	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@
  0039e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003a4	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN24@DataSend:

; 929  : 					(BYTE)lpIoCtxt->wsabuf.buf[3], WSAGetLastError(), gObj[aIndex].Ip_addr);
; 930  : 			}
; 931  : 
; 932  : 			////g_CS.UnLock();
; 933  : 			CloseClient( aIndex );			

  003a7	57		 push	 edi
  003a8	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  003ad	83 c4 04	 add	 esp, 4

; 934  : 			return FALSE;

  003b0	e9 eb fd ff ff	 jmp	 $LN27@DataSend
$LN19@DataSend:

; 935  : 		}
; 936  : 	}
; 937  : 	else 
; 938  : 	{
; 939  : 		InterlockedIncrement(&lpPerSocketContext->dwIOCount);		

  003b5	8b 45 f0	 mov	 eax, DWORD PTR _lpPerSocketContext$1$[ebp]
  003b8	f0 ff 80 e8 38
	01 00		 lock	  inc	 DWORD PTR [eax+80104]
$LN20@DataSend:

; 940  : 	}
; 941  : 	lpIoCtxt->nWaitIO = 1;	

  003bf	c7 86 6c 9c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+40044], 1

; 942  : 	return TRUE;

  003c9	be 01 00 00 00	 mov	 esi, 1
  003ce	e9 cf fd ff ff	 jmp	 $LN32@DataSend
$LN3@DataSend:

; 788  : 	unsigned char * SendBuf;
; 789  : 
; 790  : 	if( aIndex < OBJ_STARTUSERINDEX || aIndex >= OBJMAX ) return FALSE;

  003d3	33 c0		 xor	 eax, eax

; 943  : }

  003d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003df	59		 pop	 ecx
  003e0	5f		 pop	 edi
  003e1	5e		 pop	 esi
  003e2	5b		 pop	 ebx
  003e3	8b e5		 mov	 esp, ebp
  003e5	5d		 pop	 ebp
  003e6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DataSend@@YAHHPAEK@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _cs$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CCSLock@@QAE@XZ	; CCSLock::~CCSLock
__ehhandler$?DataSend@@YAHHPAEK@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DataSend@@YAHHPAEK@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DataSend@@YAHHPAEK@Z ENDP				; DataSend
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?CreateGIocp@@YAHH@Z
_TEXT	SEGMENT
_ThreadID$ = 8						; size = 4
_server_port$ = 8					; size = 4
?CreateGIocp@@YAHH@Z PROC				; CreateGIocp, COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  : VM_START
; 114  : 	g_ServerPort = server_port;

  00003	8b 45 08	 mov	 eax, DWORD PTR _server_port$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?g_ServerPort@@3HA, eax ; g_ServerPort

; 115  : 
; 116  : 	DWORD ThreadID;
; 117  : 
; 118  : 	g_IocpThreadHandle = CreateThread( NULL, 0,(LPTHREAD_START_ROUTINE)IocpServerWorker,0, 0, &ThreadID);

  0000b	8d 45 08	 lea	 eax, DWORD PTR _ThreadID$[ebp]
  0000e	50		 push	 eax
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	68 00 00 00 00	 push	 OFFSET ?IocpServerWorker@@YAKXZ ; IocpServerWorker
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00022	a3 00 00 00 00	 mov	 DWORD PTR ?g_IocpThreadHandle@@3PAXA, eax ; g_IocpThreadHandle

; 119  : 	
; 120  : VM_END
; 121  : 	
; 122  : 	if ( g_IocpThreadHandle == NULL )

  00027	85 c0		 test	 eax, eax
  00029	75 19		 jne	 SHORT $LN2@CreateGIoc

; 123  : 	{
; 124  : 		LogAdd("CreateThread() failed with error %d", GetLastError());

  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003d	83 c4 08	 add	 esp, 8

; 125  : 		return FALSE;

  00040	33 c0		 xor	 eax, eax

; 129  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN2@CreateGIoc:

; 126  : 	}
; 127  : 
; 128  : 	return TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1

; 129  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?CreateGIocp@@YAHH@Z ENDP				; CreateGIocp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?IocpServerStart@@YAHXZ
_TEXT	SEGMENT
_wsaData$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
?IocpServerStart@@YAHXZ PROC				; IocpServerStart, COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 106  : 	WSADATA wsaData;
; 107  : 	WSAStartup(MAKEWORD(2,2), &wsaData);

  00013	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _wsaData$[ebp]
  00019	50		 push	 eax
  0001a	68 02 02 00 00	 push	 514			; 00000202H
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8

; 108  : 	return TRUE;
; 109  : }

  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	33 cd		 xor	 ecx, ebp
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?IocpServerStart@@YAHXZ ENDP				; IocpServerStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?GiocpInit@@YAXXZ
_TEXT	SEGMENT
?GiocpInit@@YAXXZ PROC					; GiocpInit, COMDAT

; 96   : 	ExSendBuf=new unsigned char[MAX_EXSENDBUF_SIZE];

  00000	68 20 4e 00 00	 push	 20000			; 00004e20H
  00005	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0000a	83 c4 04	 add	 esp, 4
  0000d	a3 00 00 00 00	 mov	 DWORD PTR ?ExSendBuf@@3PAEA, eax ; ExSendBuf

; 97   : }

  00012	c3		 ret	 0
?GiocpInit@@YAXXZ ENDP					; GiocpInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
;	COMDAT ??_GCStreamPacketEngine_Server@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z PROC		; CStreamPacketEngine_Server::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 21   : 	{

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CStreamPacketEngine_Server@@6B@
  00010	74 0e		 je	 SHORT $LN7@scalar
  00012	68 08 08 00 00	 push	 2056			; 00000808H
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001d	83 c4 08	 add	 esp, 8
$LN7@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z ENDP		; CStreamPacketEngine_Server::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
;	COMDAT ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z
_TEXT	SEGMENT
_pTar$GSCopy$1$ = -2056					; size = 4
_byTemp$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pTar$ = 8						; size = 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z PROC ; CStreamPacketEngine_Server::ExtractPacket, COMDAT
; _this$ = ecx

; 98   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 08 00
	00		 sub	 esp, 2056		; 00000808H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _pTar$[ebp]
  00016	53		 push	 ebx
  00017	8b d9		 mov	 ebx, ecx
  00019	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _pTar$GSCopy$1$[ebp], eax
  0001f	56		 push	 esi

; 99   : 		WORD wSize;
; 100  : 		BYTE byXorFilter[32];
; 101  : 
; 102  : 		BYTE byTemp[2048];
; 103  : 
; 104  : 		
; 105  : 
; 106  : 		switch ( this->m_byBuffer[0] )

  00020	8a 53 06	 mov	 dl, BYTE PTR [ebx+6]
  00023	0f b6 c2	 movzx	 eax, dl
  00026	2d c1 00 00 00	 sub	 eax, 193		; 000000c1H
  0002b	74 34		 je	 SHORT $LN4@ExtractPac
  0002d	83 e8 01	 sub	 eax, 1
  00030	74 17		 je	 SHORT $LN5@ExtractPac

; 115  : 
; 116  : 			default:
; 117  : 				return true;

  00032	5e		 pop	 esi
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	5b		 pop	 ebx

; 165  : 		return false;
; 166  : 	}

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	33 cd		 xor	 ecx, ebp
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN5@ExtractPac:

; 110  : 				break;
; 111  : 
; 112  : 			case 0xC2:
; 113  : 				wSize = this->m_byBuffer[1] * 256 + this->m_byBuffer[2];

  00049	0f b6 4b 07	 movzx	 ecx, BYTE PTR [ebx+7]
  0004d	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00052	0f af c8	 imul	 ecx, eax
  00055	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  00059	66 03 c8	 add	 cx, ax
  0005c	0f b7 f1	 movzx	 esi, cx

; 114  : 				break;

  0005f	eb 04		 jmp	 SHORT $LN2@ExtractPac
$LN4@ExtractPac:

; 107  : 		{
; 108  : 			case 0xC1:
; 109  : 				wSize = this->m_byBuffer[1];

  00061	0f b6 73 07	 movzx	 esi, BYTE PTR [ebx+7]
$LN2@ExtractPac:

; 118  : 				break;
; 119  : 		}
; 120  : 
; 121  : 		if ( this->m_wSize < wSize )

  00065	66 39 73 04	 cmp	 WORD PTR [ebx+4], si
  00069	73 17		 jae	 SHORT $LN7@ExtractPac

; 122  : 		{
; 123  : 			return 2;

  0006b	5e		 pop	 esi
  0006c	b8 02 00 00 00	 mov	 eax, 2
  00071	5b		 pop	 ebx

; 165  : 		return false;
; 166  : 	}

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	33 cd		 xor	 ecx, ebp
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN7@ExtractPac:

; 124  : 		}
; 125  : 
; 126  : 		byXorFilter[0] = 0xAB;
; 127  : 		byXorFilter[1] = 0x11;
; 128  : 		byXorFilter[2] = 0xCD;
; 129  : 		byXorFilter[3] = 0xFE;
; 130  : 		byXorFilter[4] = 0x18;
; 131  : 		byXorFilter[5] = 0x23;
; 132  : 		byXorFilter[6] = 0xC5;
; 133  : 		byXorFilter[7] = 0xA3;
; 134  : 		byXorFilter[8] = 0xCA;
; 135  : 		byXorFilter[9] = 0x33;
; 136  : 		byXorFilter[10] = 0xC1;
; 137  : 		byXorFilter[11] = 0xCC;
; 138  : 		byXorFilter[12] = 0x66;
; 139  : 		byXorFilter[13] = 0x67;
; 140  : 		byXorFilter[14] = 0x21;
; 141  : 		byXorFilter[15] = 0xF3;
; 142  : 		byXorFilter[16] = 0x32;
; 143  : 		byXorFilter[17] = 0x12;
; 144  : 		byXorFilter[18] = 0x15;
; 145  : 		byXorFilter[19] = 0x35;
; 146  : 		byXorFilter[20] = 0x29;
; 147  : 		byXorFilter[21] = 0xFF;
; 148  : 		byXorFilter[22] = 0xFE;
; 149  : 		byXorFilter[23] = 0x1D;
; 150  : 		byXorFilter[24] = 0x44;
; 151  : 		byXorFilter[25] = 0xEF;
; 152  : 		byXorFilter[26] = 0xCD;
; 153  : 		byXorFilter[27] = 0x41;
; 154  : 		byXorFilter[28] = 0x26;
; 155  : 		byXorFilter[29] = 0x3C;
; 156  : 		byXorFilter[30] = 0x4E;
; 157  : 		byXorFilter[31] = 0x4D;
; 158  : 
; 159  : 
; 160  : 		this->XorData(wSize-1, (this->m_byBuffer[0] == 0xC1 ? 2 : 3), -1);

  00082	33 c0		 xor	 eax, eax
  00084	8b cb		 mov	 ecx, ebx
  00086	57		 push	 edi
  00087	80 fa c1	 cmp	 dl, 193			; 000000c1H
  0008a	0f b7 fe	 movzx	 edi, si
  0008d	6a ff		 push	 -1
  0008f	0f 95 c0	 setne	 al
  00092	83 c0 02	 add	 eax, 2
  00095	50		 push	 eax
  00096	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ; CStreamPacketEngine_Server::XorData

; 161  : 		memcpy(pTar, this->m_byBuffer, wSize);

  0009f	57		 push	 edi
  000a0	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  000a3	50		 push	 eax
  000a4	ff b5 f8 f7 ff
	ff		 push	 DWORD PTR _pTar$GSCopy$1$[ebp]
  000aa	e8 00 00 00 00	 call	 _memcpy

; 162  : 		this->m_wSize-=wSize;

  000af	66 29 73 04	 sub	 WORD PTR [ebx+4], si

; 163  : 		memcpy(byTemp, &this->m_byBuffer[wSize], this->m_wSize);

  000b3	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  000b6	0f b7 73 04	 movzx	 esi, WORD PTR [ebx+4]
  000ba	03 c7		 add	 eax, edi
  000bc	56		 push	 esi
  000bd	50		 push	 eax
  000be	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _byTemp$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _memcpy

; 164  : 		memcpy(this->m_byBuffer, byTemp, this->m_wSize);

  000ca	56		 push	 esi
  000cb	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _byTemp$[ebp]
  000d1	50		 push	 eax
  000d2	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _memcpy

; 165  : 		return false;
; 166  : 	}

  000db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	83 c4 24	 add	 esp, 36			; 00000024H
  000e1	33 cd		 xor	 ecx, ebp
  000e3	33 c0		 xor	 eax, eax
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ENDP ; CStreamPacketEngine_Server::ExtractPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
;	COMDAT ?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_wSize$ = 12						; size = 2
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z PROC	; CStreamPacketEngine_Server::AddData, COMDAT
; _this$ = ecx

; 84   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 85   : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  00007	66 8b 7d 0c	 mov	 di, WORD PTR _wSize$[ebp]
  0000b	0f b7 d7	 movzx	 edx, di
  0000e	0f b7 4e 04	 movzx	 ecx, WORD PTR [esi+4]
  00012	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00015	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0001a	7d 26		 jge	 SHORT $LN3@AddData
  0001c	66 85 ff	 test	 di, di
  0001f	74 21		 je	 SHORT $LN3@AddData

; 90   : 		}
; 91   : 
; 92   : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  00021	52		 push	 edx
  00022	ff 75 08	 push	 DWORD PTR _pSrc$[ebp]
  00025	8d 46 06	 lea	 eax, DWORD PTR [esi+6]
  00028	03 c1		 add	 eax, ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _memcpy
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : 		this->m_wSize += wSize;
; 94   : 		return TRUE;

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	66 01 7e 04	 add	 WORD PTR [esi+4], di
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 95   : 	}

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN3@AddData:

; 86   : 		{
; 87   : 			LogAddC(2,"CStreamPacketEngine Adding Buffer Size Error %d", this->m_wSize + wSize);

  00042	50		 push	 eax
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  00048	6a 02		 push	 2
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 88   : 			int iSize = 2048;
; 89   : 			return FALSE;

  00053	33 c0		 xor	 eax, eax
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 95   : 	}

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z ENDP	; CStreamPacketEngine_Server::AddData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
;	COMDAT ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z
_TEXT	SEGMENT
_byXorFilter$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_iStart$ = 8						; size = 4
_iEnd$ = 12						; size = 4
_iDir$ = 16						; size = 4
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z PROC	; CStreamPacketEngine_Server::XorData, COMDAT
; _this$ = ecx

; 33   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 34   : 		if ( iStart < iEnd  )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iStart$[ebp]
  00013	8b 55 0c	 mov	 edx, DWORD PTR _iEnd$[ebp]
  00016	57		 push	 edi
  00017	8b f9		 mov	 edi, ecx
  00019	3b c2		 cmp	 eax, edx
  0001b	7d 23		 jge	 SHORT $LN5@XorData

; 35   : 		{
; 36   : 			LogAddC(2, "CStreamPacketEngine XorData Error %d,%d", iStart, iEnd);

  0001d	52		 push	 edx
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5f		 pop	 edi

; 78   : 		}
; 79   : 	}

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00033	33 cd		 xor	 ecx, ebp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@XorData:

; 37   : 			return;
; 38   : 		}
; 39   : 
; 40   : 		unsigned char byXorFilter[32];
; 41   : 
; 42   : 		byXorFilter[0] = 0xAB;

  00040	c7 45 dc ab 11
	cd fe		 mov	 DWORD PTR _byXorFilter$[ebp], -20115029 ; fecd11abH

; 43   : 		byXorFilter[1] = 0x11;
; 44   : 		byXorFilter[2] = 0xCD;
; 45   : 		byXorFilter[3] = 0xFE;
; 46   : 		byXorFilter[4] = 0x18;

  00047	c7 45 e0 18 23
	c5 a3		 mov	 DWORD PTR _byXorFilter$[ebp+4], -1547361512 ; a3c52318H

; 47   : 		byXorFilter[5] = 0x23;
; 48   : 		byXorFilter[6] = 0xC5;
; 49   : 		byXorFilter[7] = 0xA3;
; 50   : 		byXorFilter[8] = 0xCA;

  0004e	c7 45 e4 ca 33
	c1 cc		 mov	 DWORD PTR _byXorFilter$[ebp+8], -859753526 ; ccc133caH

; 51   : 		byXorFilter[9] = 0x33;
; 52   : 		byXorFilter[10] = 0xC1;
; 53   : 		byXorFilter[11] = 0xCC;
; 54   : 		byXorFilter[12] = 0x66;

  00055	c7 45 e8 66 67
	21 f3		 mov	 DWORD PTR _byXorFilter$[ebp+12], -215914650 ; f3216766H

; 55   : 		byXorFilter[13] = 0x67;
; 56   : 		byXorFilter[14] = 0x21;
; 57   : 		byXorFilter[15] = 0xF3;
; 58   : 		byXorFilter[16] = 0x32;

  0005c	c7 45 ec 32 12
	15 35		 mov	 DWORD PTR _byXorFilter$[ebp+16], 890573362 ; 35151232H

; 59   : 		byXorFilter[17] = 0x12;
; 60   : 		byXorFilter[18] = 0x15;
; 61   : 		byXorFilter[19] = 0x35;
; 62   : 		byXorFilter[20] = 0x29;

  00063	c7 45 f0 29 ff
	fe 1d		 mov	 DWORD PTR _byXorFilter$[ebp+20], 503250729 ; 1dfeff29H

; 63   : 		byXorFilter[21] = 0xFF;
; 64   : 		byXorFilter[22] = 0xFE;
; 65   : 		byXorFilter[23] = 0x1D;
; 66   : 		byXorFilter[24] = 0x44;

  0006a	c7 45 f4 44 ef
	cd 41		 mov	 DWORD PTR _byXorFilter$[ebp+24], 1104015172 ; 41cdef44H

; 67   : 		byXorFilter[25] = 0xEF;
; 68   : 		byXorFilter[26] = 0xCD;
; 69   : 		byXorFilter[27] = 0x41;
; 70   : 		byXorFilter[28] = 0x26;

  00071	c7 45 f8 26 3c
	4e 4d		 mov	 DWORD PTR _byXorFilter$[ebp+28], 1296972838 ; 4d4e3c26H

; 71   : 		byXorFilter[29] = 0x3C;
; 72   : 		byXorFilter[30] = 0x4E;
; 73   : 		byXorFilter[31] = 0x4D;
; 74   : 
; 75   : 		for ( int i = iStart ; i != iEnd ; i+=iDir )

  00078	3b c2		 cmp	 eax, edx
  0007a	74 36		 je	 SHORT $LN3@XorData

; 37   : 			return;
; 38   : 		}
; 39   : 
; 40   : 		unsigned char byXorFilter[32];
; 41   : 
; 42   : 		byXorFilter[0] = 0xAB;

  0007c	56		 push	 esi
  0007d	8d 48 06	 lea	 ecx, DWORD PTR [eax+6]

; 71   : 		byXorFilter[29] = 0x3C;
; 72   : 		byXorFilter[30] = 0x4E;
; 73   : 		byXorFilter[31] = 0x4D;
; 74   : 
; 75   : 		for ( int i = iStart ; i != iEnd ; i+=iDir )

  00080	be fa ff ff ff	 mov	 esi, -6			; fffffffaH
  00085	03 cf		 add	 ecx, edi
  00087	2b f7		 sub	 esi, edi
  00089	8b 7d 10	 mov	 edi, DWORD PTR _iDir$[ebp]
  0008c	0f 1f 40 00	 npad	 4
$LL4@XorData:

; 76   : 		{
; 77   : 			this->m_byBuffer[i] ^= this->m_byBuffer[i-1] ^ byXorFilter[ i%32 ];

  00090	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00093	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00098	79 05		 jns	 SHORT $LN11@XorData
  0009a	48		 dec	 eax
  0009b	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0009e	40		 inc	 eax
$LN11@XorData:
  0009f	8a 44 05 dc	 mov	 al, BYTE PTR _byXorFilter$[ebp+eax]
  000a3	32 41 ff	 xor	 al, BYTE PTR [ecx-1]
  000a6	30 01		 xor	 BYTE PTR [ecx], al
  000a8	03 cf		 add	 ecx, edi
  000aa	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  000ad	3b c2		 cmp	 eax, edx
  000af	75 df		 jne	 SHORT $LL4@XorData
  000b1	5e		 pop	 esi
$LN3@XorData:

; 78   : 		}
; 79   : 	}

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	5f		 pop	 edi
  000b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 0c 00	 ret	 12			; 0000000cH
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ENDP	; CStreamPacketEngine_Server::XorData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
;	COMDAT ?Clear@CStreamPacketEngine_Server@@QAEXXZ
_TEXT	SEGMENT
?Clear@CStreamPacketEngine_Server@@QAEXXZ PROC		; CStreamPacketEngine_Server::Clear, COMDAT
; _this$ = ecx

; 27   : 		this->m_wSize = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 28   : 	};

  00006	c3		 ret	 0
?Clear@CStreamPacketEngine_Server@@QAEXXZ ENDP		; CStreamPacketEngine_Server::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
;	COMDAT ??1CStreamPacketEngine_Server@@UAE@XZ
_TEXT	SEGMENT
??1CStreamPacketEngine_Server@@UAE@XZ PROC		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 21   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 22   : 		return;
; 23   : 	};

  00006	c3		 ret	 0
??1CStreamPacketEngine_Server@@UAE@XZ ENDP		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\spe.h
;	COMDAT ??0CStreamPacketEngine_Server@@QAE@XZ
_TEXT	SEGMENT
??0CStreamPacketEngine_Server@@QAE@XZ PROC		; CStreamPacketEngine_Server::CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 19   : 
; 20   : 	virtual ~CStreamPacketEngine_Server()	// Good
; 21   : 	{
; 22   : 		return;
; 23   : 	};
; 24   : 
; 25   : 	void Clear()	// Good 
; 26   : 	{
; 27   : 		this->m_wSize = 0;

  00000	33 c0		 xor	 eax, eax

; 16   : 	{

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 19   : 
; 20   : 	virtual ~CStreamPacketEngine_Server()	// Good
; 21   : 	{
; 22   : 		return;
; 23   : 	};
; 24   : 
; 25   : 	void Clear()	// Good 
; 26   : 	{
; 27   : 		this->m_wSize = 0;

  00008	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 17   : 		this->Clear();
; 18   : 	};

  0000c	8b c1		 mov	 eax, ecx
  0000e	c3		 ret	 0
??0CStreamPacketEngine_Server@@QAE@XZ ENDP		; CStreamPacketEngine_Server::CStreamPacketEngine_Server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);
; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000e	83 c4 04	 add	 esp, 4

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00014	51		 push	 ecx
  00015	6a 00		 push	 0
  00017	56		 push	 esi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	5e		 pop	 esi

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 640  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\giocp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
