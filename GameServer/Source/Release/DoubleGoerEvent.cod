; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\DoubleGoerEvent.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_DoubleGoerEvent_Gates@@3PAHA			; g_DoubleGoerEvent_Gates
PUBLIC	?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A ; g_DoubleGoerEvent_DefPts
PUBLIC	?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A ; g_DoubleGoerEvent_BlockPts
_DATA	SEGMENT
?g_DoubleGoerEvent_Gates@@3PAHA DD 0149H		; g_DoubleGoerEvent_Gates
	DD	014aH
	DD	014bH
	DD	014cH
?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A DB 0c5H ; g_DoubleGoerEvent_DefPts
	DB	01bH
	DB	0e0H
	DB	065H
	DD	04062e148r			; 3.545
	DB	04eH
	ORG $+3
	DB	089H
	DB	043H
	DB	072H
	DB	0b4H
	DD	040a170a4r			; 5.045
	DB	06fH
	ORG $+3
	DB	06eH
	DB	038H
	DB	06eH
	DB	096H
	DD	04082e8a7r			; 4.0909
	DB	05aH
	ORG $+3
	DB	05fH
	DB	0bH
	DB	02cH
	DB	06cH
	DD	0409a2d0er			; 4.818
	DB	06aH
	ORG $+3
?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A DB 0bfH ; g_DoubleGoerEvent_BlockPts
	DB	021H
	DB	0c8H
	DB	024H
	DB	086H
	DB	04cH
	DB	08dH
	DB	04fH
	DB	065H
	DB	041H
	DB	071H
	DB	044H
	DB	05cH
	DB	017H
	DB	062H
	DB	01aH
_DATA	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??0CDoubleGoerEvent@@QAE@XZ			; CDoubleGoerEvent::CDoubleGoerEvent
PUBLIC	??1CDoubleGoerEvent@@UAE@XZ			; CDoubleGoerEvent::~CDoubleGoerEvent
PUBLIC	?Init@CDoubleGoerEvent@@QAEXXZ			; CDoubleGoerEvent::Init
PUBLIC	?LoadData@CDoubleGoerEvent@@QAEXPAD@Z		; CDoubleGoerEvent::LoadData
PUBLIC	?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z ; CDoubleGoerEvent::EnterRequest
PUBLIC	?Run@CDoubleGoerEvent@@QAEXXZ			; CDoubleGoerEvent::Run
PUBLIC	?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::ProcState_WAITING
PUBLIC	?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::ProcState_PLAYING
PUBLIC	?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::ProcState_PLAYEND
PUBLIC	?SetState@CDoubleGoerEvent@@QAEXH@Z		; CDoubleGoerEvent::SetState
PUBLIC	?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_CLOSED
PUBLIC	?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_WAITING
PUBLIC	?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_PLAYING
PUBLIC	?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_PLAYEND
PUBLIC	?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ; CDoubleGoerEvent::CompensationBox
PUBLIC	?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ; CDoubleGoerEvent::GoldCompensationBox
PUBLIC	?SendStart@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SendStart
PUBLIC	?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SendMonsterCount
PUBLIC	?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SendWaveInfo
PUBLIC	?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SendPlayInfo
PUBLIC	?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z		; CDoubleGoerEvent::SendBossInfo
PUBLIC	?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z	; CDoubleGoerEvent::SendBlockInfo
PUBLIC	?SendData@CDoubleGoerEvent@@QAEXPAEH@Z		; CDoubleGoerEvent::SendData
PUBLIC	?SummonMonster@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SummonMonster
PUBLIC	?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z	; CDoubleGoerEvent::SummonMonster
PUBLIC	?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z	; CDoubleGoerEvent::SetMonster
PUBLIC	?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::GetRewardBox
PUBLIC	?RemoveMonster@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::RemoveMonster
PUBLIC	?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::MonsterDieHandle
PUBLIC	?AddUser@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::AddUser
PUBLIC	?DelUser@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::DelUser
PUBLIC	?CheckUser@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::CheckUser
PUBLIC	?AddMonster@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::AddMonster
PUBLIC	?DelMonster@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::DelMonster
PUBLIC	?AddBox@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::AddBox
PUBLIC	?DelBox@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::DelBox
PUBLIC	?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::gObjMonsterMove
PUBLIC	?GetOpenTime@CDoubleGoerEvent@@QAEEXZ		; CDoubleGoerEvent::GetOpenTime
PUBLIC	?CalcDistance@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::CalcDistance
PUBLIC	?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z	; CDoubleGoerEvent::CalcDistance
PUBLIC	?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
PUBLIC	?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate
PUBLIC	?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back
PUBLIC	?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reallocate
PUBLIC	?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
PUBLIC	??_GCDoubleGoerEvent@@UAEPAXI@Z			; CDoubleGoerEvent::`scalar deleting destructor'
PUBLIC	??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7CDoubleGoerEvent@@6B@			; CDoubleGoerEvent::`vftable'
PUBLIC	?gDoubleGoer@@3VCDoubleGoerEvent@@A		; gDoubleGoer
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@ ; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@ ; `string'
PUBLIC	??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@ ; `string'
PUBLIC	??_R0K@8					; unsigned long `RTTI Type Descriptor'
PUBLIC	??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@ ; `string'
PUBLIC	??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@ ; `string'
PUBLIC	??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@	; `string'
PUBLIC	??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@	; `string'
PUBLIC	??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@ ; `string'
PUBLIC	??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ ; `string'
PUBLIC	??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ ; `string'
PUBLIC	??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ ; `string'
PUBLIC	??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ ; `string'
PUBLIC	??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ ; `string'
PUBLIC	??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ ; `string'
PUBLIC	??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@ ; `string'
PUBLIC	??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@ ; `string'
PUBLIC	??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@ ; `string'
PUBLIC	??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@ ; `string'
PUBLIC	??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@ ; `string'
PUBLIC	??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@ ; `string'
PUBLIC	??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ ; `string'
PUBLIC	??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@ ; `string'
PUBLIC	??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ ; `string'
PUBLIC	??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@	; `string'
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CDoubleGoerEvent@@6B@			; CDoubleGoerEvent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDoubleGoerEvent@@@8			; CDoubleGoerEvent `RTTI Type Descriptor'
PUBLIC	??_R3CDoubleGoerEvent@@8			; CDoubleGoerEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDoubleGoerEvent@@8			; CDoubleGoerEvent::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDoubleGoerEvent@@8		; CDoubleGoerEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjSetInventory1Pointer
EXTRN	?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z:PROC ; gObjLifeCheck
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@GE@Z:PROC ; gObjMonsterMagicAdd
EXTRN	?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z:PROC ; gObjGetRandomItemDropLocation
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z:PROC	; GCStateInfoSend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	??0EventItemBag@@QAE@XZ:PROC			; EventItemBag::EventItemBag
EXTRN	?Read@EventItemBag@@QAEXPAD@Z:PROC		; EventItemBag::Read
EXTRN	?Open@EventItemBag@@QAE_NHHEE@Z:PROC		; EventItemBag::Open
EXTRN	??_ECDoubleGoerEvent@@UAEPAXI@Z:PROC		; CDoubleGoerEvent::`vector deleting destructor'
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageInit
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
EXTRN	?ConvertMonsterStat@CMonsterStatCalc@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; CMonsterStatCalc::ConvertMonsterStat
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__except_handler4:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?s_MonsterAIMovePath@TMonsterAIElement@@2PAVTMonsterAIMovePath@@A:BYTE ; TMonsterAIElement::s_MonsterAIMovePath
EXTRN	?g_MonsterStatCalc@@3VCMonsterStatCalc@@A:BYTE	; g_MonsterStatCalc
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?gDoubleGoer@@3VCDoubleGoerEvent@@A DB 0270H DUP (?)	; gDoubleGoer
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
CRT$XCU	SEGMENT
?gDoubleGoer$initializer$@@3P6AXXZA DD FLAT:??__EgDoubleGoer@@YAXXZ ; gDoubleGoer$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CDoubleGoerEvent@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDoubleGoerEvent@@8 DD FLAT:??_R0?AVCDoubleGoerEvent@@@8 ; CDoubleGoerEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDoubleGoerEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2CDoubleGoerEvent@@8
rdata$r	SEGMENT
??_R2CDoubleGoerEvent@@8 DD FLAT:??_R1A@?0A@EA@CDoubleGoerEvent@@8 ; CDoubleGoerEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDoubleGoerEvent@@8
rdata$r	SEGMENT
??_R3CDoubleGoerEvent@@8 DD 00H				; CDoubleGoerEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDoubleGoerEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDoubleGoerEvent@@@8
data$r	SEGMENT
??_R0?AVCDoubleGoerEvent@@@8 DD FLAT:??_7type_info@@6B@	; CDoubleGoerEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDoubleGoerEvent@@', 00H
data$r	ENDS
;	COMDAT ??_R4CDoubleGoerEvent@@6B@
rdata$r	SEGMENT
??_R4CDoubleGoerEvent@@6B@ DD 00H			; CDoubleGoerEvent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDoubleGoerEvent@@@8
	DD	FLAT:??_R3CDoubleGoerEvent@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@
CONST	SEGMENT
??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@ DB '[D'
	DB	'oppelganger] Boss Killed -> EVENT_END', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@ DB 'error : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@
CONST	SEGMENT
??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@ DB 'DoubleGoerEvent.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
CONST	SEGMENT
??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ DB '[Doppe'
	DB	'lganger] Failed to summon monster ID: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@
CONST	SEGMENT
??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@ DB '[D'
	DB	'oppelganger] SummonMonster [%d](%s) Map: %d, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
CONST	SEGMENT
??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ DB '[Doppe'
	DB	'lganger] Failed to summon silver box ID: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@
CONST	SEGMENT
??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@ DB '[Doppe'
	DB	'lganger] Failed to set monster info ID: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@
CONST	SEGMENT
??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@ DB '['
	DB	'Doppelganger] Event - Fail -> MonsterPassed: %d, PlayerCount:'
	DB	' %d, LeaderIndex: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@
CONST	SEGMENT
??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@ DB '[Dop'
	DB	'pelganger] Event - Success -> MonsterPassed: %d, PlayerCount:'
	DB	' %d, LeaderIndex: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@
CONST	SEGMENT
??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@ DB '[Doppel'
	DB	'ganger] SetState_PLAYEND()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@
CONST	SEGMENT
??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@ DB '[Doppe'
	DB	'lganger] SetState_PLAYING()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@
CONST	SEGMENT
??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@ DB '[Doppe'
	DB	'lganger] SetState_WAITING()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
CONST	SEGMENT
??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ DB '['
	DB	'Doppelganger] [USER REMOVE] User not on map [%d](%s)(%s) CurM'
	DB	'ap:[%d]-UserMap:[%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
CONST	SEGMENT
??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ DB '['
	DB	'Doppelganger] [USER REMOVE] User not connected [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
CONST	SEGMENT
??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ DB '['
	DB	'Doppelganger][%d](%s)(%s) Enter request failed - pk status', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
CONST	SEGMENT
??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ DB '['
	DB	'Doppelganger][%d](%s)(%s) Enter request failed - event on goi'
	DB	'ng', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@
CONST	SEGMENT
??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ DB '[D'
	DB	'oppelganger][ERROR] Inventory item error - [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@
CONST	SEGMENT
??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ DB '[D'
	DB	'oppelganger][ERROR] Inventory range error - [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@
CONST	SEGMENT
??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@ DB '[D'
	DB	'oppelganger][ERROR] Not talked with Lugard [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@ DB '['
	DB	'Doppelganger] File loaded! (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@
CONST	SEGMENT
??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@ DB 'MirrorMarkDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@
CONST	SEGMENT
??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@ DB 'DoubleGoerEventRun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@ DB 'CommonServer.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@
CONST	SEGMENT
??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@ DB '[Doppel'
	DB	'ganger] LevelInfo loaded [%d] levels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@
CONST	SEGMENT
??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@ DB '[Doppe'
	DB	'lganger] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0K@8
data$r	SEGMENT
??_R0K@8 DD	FLAT:??_7type_info@@6B@			; unsigned long `RTTI Type Descriptor'
	DD	00H
	DB	'.K', 00H
data$r	ENDS
;	COMDAT ??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@
CONST	SEGMENT
??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@ DB '[Doppe'
	DB	'lganger] Failed to init golden box!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@
CONST	SEGMENT
??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@ DB '[Doppe'
	DB	'lganger] Failed to init silver box!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@
CONST	SEGMENT
??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@ DB 'EventItemBag\Dop'
	DB	'pelganger\', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@
CONST	SEGMENT
??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@ DB '[Dop'
	DB	'pelganger] Load File failed(%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDoubleGoerEvent@@6B@
CONST	SEGMENT
??_7CDoubleGoerEvent@@6B@ DD FLAT:??_R4CDoubleGoerEvent@@6B@ ; CDoubleGoerEvent::`vftable'
	DD	FLAT:??_ECDoubleGoerEvent@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z$50 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z$50
__ehfuncinfo$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffa0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN47@gObjMonste
	DD	FLAT:$LN21@gObjMonste
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$44 DD 00H
	DD	FLAT:??_R0K@8
	DD	00H
	DD	FLAT:__catch$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$0
__tryblocktable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z DD 00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$44
__unwindtable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$3
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN3@construct:

; 656  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@$$QAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z PROC ; std::forward<CDoubleGoerEvent::_st_reward>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ENDP ; std::forward<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U_st_reward@CDoubleGoerEvent@@U12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_st_reward@CDoubleGoerEvent@@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_st_reward@CDoubleGoerEvent@@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::destroy<CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_st_reward@CDoubleGoerEvent@@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::destroy<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 1e		 je	 SHORT $LN3@Uninit_mov
$LL4@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00010	85 c0		 test	 eax, eax
  00012	74 10		 je	 SHORT $LN2@Uninit_mov
  00014	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00017	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0001a	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  0001f	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
$LN2@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 442  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00024	83 c1 18	 add	 ecx, 24			; 00000018H
  00027	83 c0 18	 add	 eax, 24			; 00000018H
  0002a	3b ca		 cmp	 ecx, edx
  0002c	75 e2		 jne	 SHORT $LL4@Uninit_mov
$LN3@Uninit_mov:

; 443  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 444  : 	_CATCH_ALL
; 445  : 	for (; _Next != _Dest; ++_Next)
; 446  : 		_Al.destroy(_Next);
; 447  : 	_RERAISE;
; 448  : 	_CATCH_END
; 449  : 	return (_Dest);
; 450  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z PROC ; std::_Val_type<CDoubleGoerEvent::_st_reward *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z ENDP ; std::_Val_type<CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_st_reward@CDoubleGoerEvent@@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_st_reward@CDoubleGoerEvent@@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::destroy<CDoubleGoerEvent::_st_reward>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@U_st_reward@CDoubleGoerEvent@@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::destroy<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAAAPAU_st_reward@CDoubleGoerEvent@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAAAPAU_st_reward@CDoubleGoerEvent@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAAAPAU_st_reward@CDoubleGoerEvent@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z PROC ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >, COMDAT

; 480  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 482  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 483  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z ENDP ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z PROC ; std::_Unchecked<CDoubleGoerEvent::_st_reward *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z ENDP ; std::_Unchecked<CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_st_reward@CDoubleGoerEvent@@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_st_reward@CDoubleGoerEvent@@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::destroy<CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_st_reward@CDoubleGoerEvent@@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::destroy<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU23@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN3@construct:

; 656  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU23@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN3@construct:

; 656  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >, COMDAT

; 490  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 491  : 	return (_Rechecked(_Dest,
; 492  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 493  : 			_Unchecked(_Dest), _Al)));
; 494  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@U_st_reward@CDoubleGoerEvent@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_st_reward@CDoubleGoerEvent@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U_st_reward@CDoubleGoerEvent@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_st_reward@CDoubleGoerEvent@@0@Z PROC ; std::_Ptr_cat<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@U_st_reward@CDoubleGoerEvent@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_st_reward@CDoubleGoerEvent@@0@Z ENDP ; std::_Ptr_cat<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAABV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAABV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@ABV10@@Z PROC ; std::forward<std::allocator<CDoubleGoerEvent::_st_reward> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAABV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<CDoubleGoerEvent::_st_reward> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@AAU12@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@AAU12@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<CDoubleGoerEvent::_st_reward>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@AAU12@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@ABU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABU_st_reward@CDoubleGoerEvent@@@std@@YAABU_st_reward@CDoubleGoerEvent@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU_st_reward@CDoubleGoerEvent@@@std@@YAABU_st_reward@CDoubleGoerEvent@@ABU12@@Z PROC ; std::forward<CDoubleGoerEvent::_st_reward const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABU_st_reward@CDoubleGoerEvent@@@std@@YAABU_st_reward@CDoubleGoerEvent@@ABU12@@Z ENDP ; std::forward<CDoubleGoerEvent::_st_reward const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@AAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@AAU34@@Z PROC ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@PAU_st_reward@CDoubleGoerEvent@@AAU34@@Z ENDP ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU_st_reward@CDoubleGoerEvent@@@std@@YAAAU_st_reward@CDoubleGoerEvent@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_st_reward@CDoubleGoerEvent@@@std@@YAAAU_st_reward@CDoubleGoerEvent@@AAU12@@Z PROC ; std::forward<CDoubleGoerEvent::_st_reward &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU_st_reward@CDoubleGoerEvent@@@std@@YAAAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ENDP ; std::forward<CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<CDoubleGoerEvent::_st_reward const >, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<CDoubleGoerEvent::_st_reward const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAU_st_reward@CDoubleGoerEvent@@@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEPAU_st_reward@CDoubleGoerEvent@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAU_st_reward@CDoubleGoerEvent@@@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEPAU_st_reward@CDoubleGoerEvent@@PAU23@00@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Umove<CDoubleGoerEvent::_st_reward *>, COMDAT
; _this$ = ecx

; 1677 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
  00017	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1680 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAU_st_reward@CDoubleGoerEvent@@@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEPAU_st_reward@CDoubleGoerEvent@@PAU23@00@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Umove<CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1><std::allocator<CDoubleGoerEvent::_st_reward> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1><std::allocator<CDoubleGoerEvent::_st_reward> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@AAU12@@Z PROC ; std::addressof<CDoubleGoerEvent::_st_reward>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ENDP ; std::addressof<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U_st_reward@CDoubleGoerEvent@@ABU12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00013	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00018	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U_st_reward@CDoubleGoerEvent@@AAU12@@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@@Z PROC ; std::addressof<CDoubleGoerEvent::_st_reward const >, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@@Z ENDP ; std::addressof<CDoubleGoerEvent::_st_reward const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU_st_reward@CDoubleGoerEvent@@@std@@SAPAU_st_reward@CDoubleGoerEvent@@AAU34@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU_st_reward@CDoubleGoerEvent@@@std@@SAPAU_st_reward@CDoubleGoerEvent@@AAU34@@Z PROC ; std::pointer_traits<CDoubleGoerEvent::_st_reward *>::pointer_to, COMDAT

; 316  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 318  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU_st_reward@CDoubleGoerEvent@@@std@@SAPAU_st_reward@CDoubleGoerEvent@@AAU34@@Z ENDP ; std::pointer_traits<CDoubleGoerEvent::_st_reward *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator++, COMDAT
; _this$ = ecx

; 340  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 341  : 		_Myiter _Tmp = *this;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 112  : 		++this->_Ptr;

  0000a	83 c2 18	 add	 edx, 24			; 00000018H
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 342  : 		++*this;
; 343  : 		return (_Tmp);
; 344  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 18	 add	 DWORD PTR [ecx], 24	; 00000018H

; 335  : 		++*(_Mybase *)this;
; 336  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 337  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEPAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEPAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator->, COMDAT
; _this$ = ecx

; 330  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 331  : 		}

  00002	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEPAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEAAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEAAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator*, COMDAT
; _this$ = ecx

; 325  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 326  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEAAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >, COMDAT
; _this$ = ecx

; 307  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 308  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::_Compat, COMDAT
; _this$ = ecx

; 256  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator!=, COMDAT
; _this$ = ecx

; 210  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 206  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 211  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 206  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 211  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 212  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		if (this->_Getcont() != _Right._Getcont())
; 205  : 			_Compat(_Right);
; 206  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 207  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 18	 add	 DWORD PTR [ecx], 24	; 00000018H

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FgDoubleGoer@@YAXXZ
text$yd	SEGMENT
??__FgDoubleGoer@@YAXXZ PROC				; `dynamic atexit destructor for 'gDoubleGoer'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  00005	e9 00 00 00 00	 jmp	 ??1CDoubleGoerEvent@@UAE@XZ ; CDoubleGoerEvent::~CDoubleGoerEvent
??__FgDoubleGoer@@YAXXZ ENDP				; `dynamic atexit destructor for 'gDoubleGoer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ??__EgDoubleGoer@@YAXXZ
text$di	SEGMENT
??__EgDoubleGoer@@YAXXZ PROC				; `dynamic initializer for 'gDoubleGoer'', COMDAT

; 58   : CDoubleGoerEvent gDoubleGoer;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  00005	e8 00 00 00 00	 call	 ??0CDoubleGoerEvent@@QAE@XZ ; CDoubleGoerEvent::CDoubleGoerEvent
  0000a	68 00 00 00 00	 push	 OFFSET ??__FgDoubleGoer@@YAXXZ ; `dynamic atexit destructor for 'gDoubleGoer''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EgDoubleGoer@@YAXXZ ENDP				; `dynamic initializer for 'gDoubleGoer''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	int ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA, 0
  00017	53		 push	 ebx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8b d8		 mov	 ebx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	83 fb ff	 cmp	 ebx, -1
  00033	74 5d		 je	 SHORT $LN43@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)
; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  00038	75 30		 jne	 SHORT $LN2@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00040	e8 00 00 00 00	 call	 _fgetc
  00045	8b d8		 mov	 ebx, eax
  00047	83 c4 04	 add	 esp, 4
  0004a	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  0004d	75 1b		 jne	 SHORT $LN2@GetToken
  0004f	90		 npad	 1
$LL5@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	83 fb ff	 cmp	 ebx, -1
  00053	74 3d		 je	 SHORT $LN43@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0005b	e8 00 00 00 00	 call	 _fgetc
  00060	8b d8		 mov	 ebx, eax
  00062	83 c4 04	 add	 esp, 4
  00065	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00068	75 e6		 jne	 SHORT $LL5@GetToken
$LN2@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _isspace
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	75 a9		 jne	 SHORT $LL4@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00077	8d 43 de	 lea	 eax, DWORD PTR [ebx-34]
  0007a	56		 push	 esi
  0007b	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  0007e	0f 87 89 01 00
	00		 ja	 $LN29@GetToken
  00084	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN58@GetToken[eax]
  0008b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@GetToken[eax*4]
$LN43@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE

  00092	b8 02 00 00 00	 mov	 eax, 2
  00097	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN20@GetToken:
  000a6	5e		 pop	 esi

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000a7	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  000b1	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b6	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN21@GetToken:
  000c5	5e		 pop	 esi

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000c6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  000d0	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000d5	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN22@GetToken:
  000e4	5e		 pop	 esi

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000e5	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  000ef	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000f4	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN23@GetToken:
  00103	5e		 pop	 esi

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00104	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0010e	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  00113	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN24@GetToken:
  00122	5e		 pop	 esi

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00123	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  0012d	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  00132	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
$LN25@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00141	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00147	53		 push	 ebx
  00148	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  0014d	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00153	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  00156	e8 00 00 00 00	 call	 _getc
  0015b	8b d8		 mov	 ebx, eax
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	83 fb ff	 cmp	 ebx, -1
  00163	74 2f		 je	 SHORT $LN59@GetToken
$LL9@GetToken:
  00165	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00168	74 12		 je	 SHORT $LN26@GetToken
  0016a	53		 push	 ebx
  0016b	e8 00 00 00 00	 call	 _isdigit
  00170	83 c4 04	 add	 esp, 4
  00173	85 c0		 test	 eax, eax
  00175	75 05		 jne	 SHORT $LN26@GetToken
  00177	83 fb 2d	 cmp	 ebx, 45			; 0000002dH
  0017a	75 18		 jne	 SHORT $LN59@GetToken
$LN26@GetToken:
  0017c	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00182	88 1e		 mov	 BYTE PTR [esi], bl

; 102  : 			p++;

  00184	46		 inc	 esi
  00185	e8 00 00 00 00	 call	 _getc
  0018a	8b d8		 mov	 ebx, eax
  0018c	83 c4 04	 add	 esp, 4
  0018f	83 fb ff	 cmp	 ebx, -1
  00192	75 d1		 jne	 SHORT $LL9@GetToken
$LN59@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = (float)atof( TempString);	// Select the first Byte as Main ID

  00194	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  00197	c6 06 00	 mov	 BYTE PTR [esi], 0
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _atof
  001a0	83 c4 04	 add	 esp, 4

; 106  : 		return CurrentToken  = NUMBER ;

  001a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  001ad	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA
  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN27@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  001c8	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  001ce	be 00 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA
  001d3	e8 00 00 00 00	 call	 _getc
  001d8	83 c4 04	 add	 esp, 4
  001db	83 f8 ff	 cmp	 eax, -1
  001de	74 1f		 je	 SHORT $LN12@GetToken
$LL11@GetToken:
  001e0	83 f8 22	 cmp	 eax, 34			; 00000022H
  001e3	0f 84 95 00 00
	00		 je	 $LN28@GetToken
  001e9	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 113  : 		{
; 114  : 			*p = ch;

  001ef	88 06		 mov	 BYTE PTR [esi], al

; 115  : 			p++;

  001f1	46		 inc	 esi
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	75 e1		 jne	 SHORT $LL11@GetToken
$LN12@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001ff	83 f8 22	 cmp	 eax, 34			; 00000022H
  00202	74 7a		 je	 SHORT $LN28@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00204	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0020a	50		 push	 eax

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  0020b	eb 69		 jmp	 SHORT $LN62@GetToken
$LN29@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0020d	53		 push	 ebx
  0020e	e8 00 00 00 00	 call	 _isalpha
  00213	83 c4 04	 add	 esp, 4
  00216	85 c0		 test	 eax, eax
  00218	0f 84 7f 00 00
	00		 je	 $LN30@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  0021e	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00224	88 1d 00 00 00
	00		 mov	 BYTE PTR ?TokenString@@3PADA, bl
  0022a	be 01 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA+1
  0022f	e8 00 00 00 00	 call	 _getc
  00234	8b d8		 mov	 ebx, eax
  00236	83 c4 04	 add	 esp, 4
  00239	83 fb ff	 cmp	 ebx, -1
  0023c	74 31		 je	 SHORT $LN60@GetToken
  0023e	66 90		 npad	 2
$LL13@GetToken:
  00240	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00243	74 12		 je	 SHORT $LN32@GetToken
  00245	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00248	74 0d		 je	 SHORT $LN32@GetToken
  0024a	53		 push	 ebx
  0024b	e8 00 00 00 00	 call	 _isalnum
  00250	83 c4 04	 add	 esp, 4
  00253	85 c0		 test	 eax, eax
  00255	74 18		 je	 SHORT $LN60@GetToken
$LN32@GetToken:
  00257	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 133  : 			{
; 134  : 				*p=ch;

  0025d	88 1e		 mov	 BYTE PTR [esi], bl

; 135  : 				p++;

  0025f	46		 inc	 esi
  00260	e8 00 00 00 00	 call	 _getc
  00265	8b d8		 mov	 ebx, eax
  00267	83 c4 04	 add	 esp, 4
  0026a	83 fb ff	 cmp	 ebx, -1
  0026d	75 d1		 jne	 SHORT $LL13@GetToken
$LN60@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0026f	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00275	53		 push	 ebx
$LN62@GetToken:
  00276	e8 00 00 00 00	 call	 _ungetc
  0027b	83 c4 08	 add	 esp, 8
$LN28@GetToken:

; 140  : 			*p=0;

  0027e	c6 06 00	 mov	 BYTE PTR [esi], 0

; 141  : 			CurrentToken=NAME;
; 142  : 			return CurrentToken;

  00281	33 c0		 xor	 eax, eax
  00283	5e		 pop	 esi
  00284	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0028e	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0028f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00292	33 cd		 xor	 ecx, ebp
  00294	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00299	8b e5		 mov	 esp, ebp
  0029b	5d		 pop	 ebp
  0029c	c3		 ret	 0
$LN30@GetToken:
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a0	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  002a5	5e		 pop	 esi
  002a6	33 cd		 xor	 ecx, ebp
  002a8	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  002b2	5b		 pop	 ebx
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
$LN64@GetToken:
  002bc	00 00 00 00	 DD	 $LN27@GetToken
  002c0	00 00 00 00	 DD	 $LN20@GetToken
  002c4	00 00 00 00	 DD	 $LN22@GetToken
  002c8	00 00 00 00	 DD	 $LN25@GetToken
  002cc	00 00 00 00	 DD	 $LN21@GetToken
  002d0	00 00 00 00	 DD	 $LN23@GetToken
  002d4	00 00 00 00	 DD	 $LN24@GetToken
  002d8	00 00 00 00	 DD	 $LN29@GetToken
$LN58@GetToken:
  002dc	00		 DB	 0
  002dd	01		 DB	 1
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	02		 DB	 2
  002e7	03		 DB	 3
  002e8	03		 DB	 3
  002e9	07		 DB	 7
  002ea	03		 DB	 3
  002eb	03		 DB	 3
  002ec	03		 DB	 3
  002ed	03		 DB	 3
  002ee	03		 DB	 3
  002ef	03		 DB	 3
  002f0	03		 DB	 3
  002f1	03		 DB	 3
  002f2	03		 DB	 3
  002f3	03		 DB	 3
  002f4	07		 DB	 7
  002f5	04		 DB	 4
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	07		 DB	 7
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	07		 DB	 7
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	07		 DB	 7
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	07		 DB	 7
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	07		 DB	 7
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	07		 DB	 7
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	07		 DB	 7
  00331	07		 DB	 7
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	05		 DB	 5
  00336	07		 DB	 7
  00337	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDoubleGoerEvent@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDoubleGoerEvent@@UAEPAXI@Z PROC			; CDoubleGoerEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDoubleGoerEvent@@UAE@XZ ; CDoubleGoerEvent::~CDoubleGoerEvent
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 70 02 00 00	 push	 624			; 00000270H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCDoubleGoerEvent@@UAEPAXI@Z ENDP			; CDoubleGoerEvent::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXPAU_st_reward@CDoubleGoerEvent@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXPAU_st_reward@CDoubleGoerEvent@@0@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1813 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXPAU_st_reward@CDoubleGoerEvent@@0@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Xlen, COMDAT
; _this$ = ecx

; 1784 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 33		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	c1 fa 02	 sar	 edx, 2
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00035	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0003c	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0003d	c3		 ret	 0
?_Tidy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv202 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve, COMDAT
; _this$ = ecx

; 1645 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 1646 : 		if (_Unused_capacity() < _Count)

  0000d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());

  00010	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00013	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	c1 fa 02	 sar	 edx, 2
  0001d	8b c2		 mov	 eax, edx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx

; 1646 : 		if (_Unused_capacity() < _Count)

  00024	3b c7		 cmp	 eax, edi
  00026	73 61		 jae	 SHORT $LN2@Reserve

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00028	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002a	2b f0		 sub	 esi, eax
  0002c	89 45 08	 mov	 DWORD PTR tv202[ebp], eax
  0002f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00034	f7 ee		 imul	 esi

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00036	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0003b	c1 fa 02	 sar	 edx, 2
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00043	03 ca		 add	 ecx, edx

; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)

  00045	2b c1		 sub	 eax, ecx
  00047	3b c7		 cmp	 eax, edi
  00049	72 45		 jb	 SHORT $LN134@Reserve

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	03 f9		 add	 edi, ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  0004d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00052	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00055	2b 4d 08	 sub	 ecx, DWORD PTR tv202[ebp]
  00058	f7 e9		 imul	 ecx
  0005a	c1 fa 02	 sar	 edx, 2
  0005d	8b f2		 mov	 esi, edx
  0005f	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00062	03 f2		 add	 esi, edx

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00064	ba aa aa aa 0a	 mov	 edx, 178956970		; 0aaaaaaaH
  00069	8b c6		 mov	 eax, esi
  0006b	d1 e8		 shr	 eax, 1
  0006d	2b d0		 sub	 edx, eax
  0006f	3b d6		 cmp	 edx, esi
  00071	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00074	b8 00 00 00 00	 mov	 eax, 0
  00079	0f 42 c8	 cmovb	 ecx, eax

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  0007c	3b cf		 cmp	 ecx, edi
  0007e	0f 42 cf	 cmovb	 ecx, edi

; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));

  00081	51		 push	 ecx
  00082	8b cb		 mov	 ecx, ebx
  00084	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reallocate
$LN2@Reserve:
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1651 : 			}
; 1652 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN134@Reserve:

; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  0009a	cc		 int	 3
?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reallocate, COMDAT
; _this$ = ecx

; 1620 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00038	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0003b	8b f8		 mov	 edi, eax

; 1622 : 
; 1623 : 		_TRY_BEGIN

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  00044	6a 00		 push	 0
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	ff 76 04	 push	 DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0004b	89 7d ec	 mov	 DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0004e	ff 36		 push	 DWORD PTR [esi]
  00050	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00055	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00058	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005d	2b 0e		 sub	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,

  0005f	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00062	f7 e9		 imul	 ecx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00064	8b 06		 mov	 eax, DWORD PTR [esi]

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00066	c1 fa 02	 sar	 edx, 2
  00069	8b da		 mov	 ebx, edx
  0006b	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0006e	03 da		 add	 ebx, edx

; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())

  00070	85 c0		 test	 eax, eax
  00072	74 20		 je	 SHORT $LN3@Reallocate

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00074	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00077	2b c8		 sub	 ecx, eax
  00079	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0007e	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00080	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),

  00082	c1 fa 02	 sar	 edx, 2
  00085	8b c2		 mov	 eax, edx
  00087	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008a	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0008c	50		 push	 eax
  0008d	ff 36		 push	 DWORD PTR [esi]
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1639 : 		this->_Myend() = _Ptr + _Count;

  00094	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00097	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0009a	8d 04 c7	 lea	 eax, DWORD PTR [edi+eax*8]
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1640 : 		this->_Mylast() = _Ptr + _Size;

  000a0	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  000a3	8d 04 c7	 lea	 eax, DWORD PTR [edi+eax*8]
  000a6	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1641 : 		this->_Myfirst() = _Ptr;

  000a9	89 3e		 mov	 DWORD PTR [esi], edi

; 1642 : 		}

  000ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b5	59		 pop	 ecx
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  000bf	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000c2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  000c8	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1627 : 		_RERAISE;

  000cd	6a 00		 push	 0
  000cf	6a 00		 push	 0
  000d1	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN179@Reallocate:
$LN178@Reallocate:
  000d6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBE_NPBU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBE_NPBU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Inside, COMDAT
; _this$ = ecx

; 1615 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1617 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1617 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBE_NPBU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEII@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Grow_to, COMDAT
; _this$ = ecx

; 1604 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0000d	b9 aa aa aa 0a	 mov	 ecx, 178956970		; 0aaaaaaaH

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00012	f7 ea		 imul	 edx
  00014	56		 push	 esi
  00015	c1 fa 02	 sar	 edx, 2
  00018	8b f2		 mov	 esi, edx
  0001a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001d	03 f2		 add	 esi, edx

; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001f	8b c6		 mov	 eax, esi
  00021	d1 e8		 shr	 eax, 1
  00023	57		 push	 edi
  00024	2b c8		 sub	 ecx, eax
  00026	33 ff		 xor	 edi, edi
  00028	3b ce		 cmp	 ecx, esi
  0002a	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0002d	0f 42 d7	 cmovb	 edx, edi

; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)

  00030	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00033	5f		 pop	 edi
  00034	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);

  00038	8b c2		 mov	 eax, edx
  0003a	5e		 pop	 esi

; 1612 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Grow_to@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEII@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXPAU_st_reward@CDoubleGoerEvent@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXPAU_st_reward@CDoubleGoerEvent@@0@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXPAU_st_reward@CDoubleGoerEvent@@0@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1543 : 		}

  00005	c3		 ret	 0
?clear@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back, COMDAT
; _this$ = ecx

; 1274 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4f		 jae	 SHORT $LN2@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 49		 ja	 SHORT $LN2@push_back

; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	c1 fa 02	 sar	 edx, 2
  00023	8b fa		 mov	 edi, edx
  00025	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00028	03 fa		 add	 edi, edx

; 1278 : 			if (this->_Mylast() == this->_Myend())

  0002a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002d	75 09		 jne	 SHORT $LN4@push_back

; 1279 : 				_Reserve(1);

  0002f	6a 01		 push	 1
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00038	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003b	85 d2		 test	 edx, edx
  0003d	74 46		 je	 SHORT $LN205@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1281 : 			this->_Getal().construct(this->_Mylast(),

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00044	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00045	0f 10 04 c8	 movups	 xmm0, XMMWORD PTR [eax+ecx*8]
  00049	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0004c	f3 0f 7e 44 c8
	10		 movq	 xmm0, QWORD PTR [eax+ecx*8+16]
  00052	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00057	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  0005b	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN2@push_back:

; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())

  00060	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00063	75 09		 jne	 SHORT $LN5@push_back

; 1288 : 				_Reserve(1);

  00065	6a 01		 push	 1
  00067	8b ce		 mov	 ecx, esi
  00069	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0006e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00071	85 c0		 test	 eax, eax
  00073	74 10		 je	 SHORT $LN205@push_back
  00075	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00078	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0007b	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  00080	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
$LN205@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1292 : 			++this->_Mylast();

  00085	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi

; 1293 : 			}
; 1294 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE_NXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		return (this->_Myfirst() == this->_Mylast());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1190 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		return (this->_Getal().max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1185 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1180 : 		}

  00016	c3		 ret	 0
?size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::end, COMDAT
; _this$ = ecx

; 1066 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::begin, COMDAT
; _this$ = ecx

; 1056 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 02	 sar	 edx, 2
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx

; 1048 : 		}

  00017	c3		 ret	 0
?_Unused_capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1043 : 		}

  00016	c3		 ret	 0
?capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 33		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	2b d1		 sub	 edx, ecx
  00013	f7 ea		 imul	 edx
  00015	c1 fa 02	 sar	 edx, 2
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00035	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0003c	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0003d	c3		 ret	 0
??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 707  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 707  : 		}

  00016	c3		 ret	 0
??0?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >,std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 479  : 		{	// initialize values
; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 481  : 		_Mylast = pointer();
; 482  : 		_Myend = pointer();
; 483  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >::_Vector_val<std::_Simple_types<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 668  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABQAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAPAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 628  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >, COMDAT
; _this$ = ecx

; 480  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 515  : 		}

  00006	8b c1		 mov	 eax, ecx

; 481  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 482  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 515  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@U?$_Vec_base_types@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_alloc<std::_Vec_base_types<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@ABV?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >::_Wrap_alloc<std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAIABV?$allocator@U_st_reward@CDoubleGoerEvent@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAIABV?$allocator@U_st_reward@CDoubleGoerEvent@@@2@@Z PROC ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@SAIABV?$allocator@U_st_reward@CDoubleGoerEvent@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CDoubleGoerEvent::_st_reward> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QBEIXZ PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QBEIXZ ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00013	77 3f		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00018	c1 e0 03	 shl	 eax, 3

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0000e	77 34		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00013	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 639  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@XZ PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@XZ ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z PROC		; CDoubleGoerEvent::CalcDistance, COMDAT
; _this$ = ecx

; 864  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 865  : 	float tx = (float)(x1 - x2);

  00006	8b 45 08	 mov	 eax, DWORD PTR _x1$[ebp]
  00009	2b 45 10	 sub	 eax, DWORD PTR _x2$[ebp]
  0000c	66 0f 6e c8	 movd	 xmm1, eax

; 866  : 	float ty = (float)(y1 - y2);

  00010	8b 45 0c	 mov	 eax, DWORD PTR _y1$[ebp]
  00013	2b 45 14	 sub	 eax, DWORD PTR _y2$[ebp]
  00016	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00019	66 0f 6e c0	 movd	 xmm0, eax
  0001d	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 868  : return (int)sqrt( (tx*tx)+(ty*ty) );

  00020	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00024	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00028	f3 0f 58 c1	 addss	 xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  0002c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002f	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00034	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 868  : return (int)sqrt( (tx*tx)+(ty*ty) );

  00038	f3 0f 2c c0	 cvttss2si eax, xmm0

; 869  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 10 00	 ret	 16			; 00000010H
?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ENDP		; CDoubleGoerEvent::CalcDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?CalcDistance@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_Dist$1$ = -12						; size = 4
tv500 = -8						; size = 4
tv504 = -4						; size = 4
tv502 = -4						; size = 4
?CalcDistance@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::CalcDistance, COMDAT
; _this$ = ecx

; 872  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 873  : 	int i;
; 874  : 	for(i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  0000b	b9 05 00 00 00	 mov	 ecx, 5
  00010	89 4d fc	 mov	 DWORD PTR tv502[ebp], ecx
  00013	8d 9f 8c 00 00
	00		 lea	 ebx, DWORD PTR [edi+140]
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@CalcDistan:

; 875  : 	{
; 876  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00020	8b 53 fc	 mov	 edx, DWORD PTR [ebx-4]

; 877  : 
; 878  : 		if( OBJMAX_RANGE(aIndex) )

  00023	85 d2		 test	 edx, edx
  00025	78 54		 js	 SHORT $LN2@CalcDistan
  00027	33 c0		 xor	 eax, eax
  00029	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0002f	0f 9e c0	 setle	 al
  00032	85 c0		 test	 eax, eax
  00034	74 45		 je	 SHORT $LN2@CalcDistan

; 879  : 		{
; 880  : 			m_PlayerInfo[i].Dist = CalcDistance(gObj[aIndex].X,gObj[aIndex].Y,

  00036	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00039	83 e8 41	 sub	 eax, 65			; 00000041H
  0003c	69 f2 40 27 00
	00		 imul	 esi, edx, 10048
  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0004b	0f b6 04 8d 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4+3]
  00053	50		 push	 eax
  00054	0f b6 04 8d 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4+2]
  0005c	8b cf		 mov	 ecx, edi
  0005e	50		 push	 eax
  0005f	0f b6 84 16 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+289]
  00067	50		 push	 eax
  00068	0f b6 84 16 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+288]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::CalcDistance
  00076	8b 4d fc	 mov	 ecx, DWORD PTR tv502[ebp]
  00079	89 03		 mov	 DWORD PTR [ebx], eax
$LN2@CalcDistan:

; 873  : 	int i;
; 874  : 	for(i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  0007b	83 c3 08	 add	 ebx, 8
  0007e	83 e9 01	 sub	 ecx, 1
  00081	89 4d fc	 mov	 DWORD PTR tv502[ebp], ecx
  00084	75 9a		 jne	 SHORT $LL4@CalcDistan

; 881  : 				g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY);
; 882  : 		}
; 883  : 	}
; 884  : 
; 885  : 	m_iWaveDist = 0;

  00086	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
  0008d	8d 9f b0 00 00
	00		 lea	 ebx, DWORD PTR [edi+176]
  00093	c7 45 fc 64 00
	00 00		 mov	 DWORD PTR tv504[ebp], 100 ; 00000064H
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL7@CalcDistan:

; 888  : 	{
; 889  : 		if( OBJMAX_RANGE(m_MonsterInfo[i]) )

  000a0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000a2	85 c9		 test	 ecx, ecx
  000a4	0f 88 dd 00 00
	00		 js	 $LN5@CalcDistan
  000aa	33 c0		 xor	 eax, eax
  000ac	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  000b2	0f 9e c0	 setle	 al
  000b5	85 c0		 test	 eax, eax
  000b7	0f 84 ca 00 00
	00		 je	 $LN5@CalcDistan

; 890  : 		{
; 891  : 			LPOBJ monObj = &gObj[m_MonsterInfo[i]];
; 892  : 
; 893  : 			int Dist = CalcDistance(monObj->X,monObj->Y,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,

  000bd	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000c0	83 e8 41	 sub	 eax, 65			; 00000041H
  000c3	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048
  000c9	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000cc	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	c1 e1 02	 shl	 ecx, 2
  000d5	89 4d f8	 mov	 DWORD PTR tv500[ebp], ecx
  000d8	0f b6 81 03 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx+3]
  000df	50		 push	 eax
  000e0	0f b6 81 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx+2]
  000e7	8b cf		 mov	 ecx, edi
  000e9	50		 push	 eax
  000ea	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000f1	50		 push	 eax
  000f2	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::CalcDistance
  000ff	8b c8		 mov	 ecx, eax

; 894  : 				g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY);
; 895  : 
; 896  : 			if( (Dist+1) >= g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].EndDist )

  00101	8b 45 f8	 mov	 eax, DWORD PTR tv500[ebp]
  00104	89 4d f4	 mov	 DWORD PTR _Dist$1$[ebp], ecx
  00107	41		 inc	 ecx
  00108	0f b6 90 08 00
	00 00		 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+8]
  0010f	3b ca		 cmp	 ecx, edx
  00111	7c 50		 jl	 SHORT $LN10@CalcDistan

; 897  : 			{
; 898  : 				GCStateInfoSend(monObj,1,105);

  00113	6a 69		 push	 105			; 00000069H
  00115	6a 01		 push	 1
  00117	56		 push	 esi
  00118	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend

; 899  : 
; 900  : 				if( monObj->Class == 529 ||
; 901  : 					monObj->Class == 530 ||

  0011d	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  00124	b9 11 02 00 00	 mov	 ecx, 529		; 00000211H
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012c	66 3b c1	 cmp	 ax, cx
  0012f	74 19		 je	 SHORT $LN13@CalcDistan
  00131	b9 12 02 00 00	 mov	 ecx, 530		; 00000212H
  00136	66 3b c1	 cmp	 ax, cx
  00139	74 0f		 je	 SHORT $LN13@CalcDistan
  0013b	b9 13 02 00 00	 mov	 ecx, 531		; 00000213H
  00140	66 3b c1	 cmp	 ax, cx
  00143	74 05		 je	 SHORT $LN13@CalcDistan

; 905  : 				}
; 906  : 				else
; 907  : 				{
; 908  : 					m_iMonsterPassed++;

  00145	ff 47 38	 inc	 DWORD PTR [edi+56]
  00148	eb 07		 jmp	 SHORT $LN12@CalcDistan
$LN13@CalcDistan:

; 902  : 					monObj->Class == 531 )
; 903  : 				{
; 904  : 					m_iMonsterPassed = 3;

  0014a	c7 47 38 03 00
	00 00		 mov	 DWORD PTR [edi+56], 3
$LN12@CalcDistan:

; 909  : 				}
; 910  : 
; 911  : 				DelMonster(monObj->m_Index);

  00151	ff 36		 push	 DWORD PTR [esi]
  00153	8b cf		 mov	 ecx, edi
  00155	e8 00 00 00 00	 call	 ?DelMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelMonster

; 912  : 				SendMonsterCount();

  0015a	8b cf		 mov	 ecx, edi
  0015c	e8 00 00 00 00	 call	 ?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendMonsterCount

; 913  : 				continue;

  00161	eb 24		 jmp	 SHORT $LN5@CalcDistan
$LN10@CalcDistan:
  00163	66 0f 6e 4d f4	 movd	 xmm1, DWORD PTR _Dist$1$[ebp]

; 914  : 			}
; 915  : 
; 916  : 			if( (Dist/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv) > m_iWaveDist )

  00168	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0016b	66 0f 6e 47 3c	 movd	 xmm0, DWORD PTR [edi+60]
  00170	f3 0f 5e 88 04
	00 00 00	 divss	 xmm1, DWORD PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+4]
  00178	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0017b	0f 2f c8	 comiss	 xmm1, xmm0
  0017e	76 07		 jbe	 SHORT $LN5@CalcDistan

; 917  : 			{
; 918  : 				m_iWaveDist = (int)(Dist/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv);

  00180	f3 0f 2c c1	 cvttss2si eax, xmm1
  00184	89 47 3c	 mov	 DWORD PTR [edi+60], eax
$LN5@CalcDistan:

; 886  : 
; 887  : 	for(i = 0;i < DOUBLEGOER_MAXMONSTER; i++)

  00187	83 c3 04	 add	 ebx, 4
  0018a	83 6d fc 01	 sub	 DWORD PTR tv504[ebp], 1
  0018e	0f 85 0c ff ff
	ff		 jne	 $LL7@CalcDistan
  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	5b		 pop	 ebx

; 919  : 			}
; 920  : 		}
; 921  : 	}
; 922  : }

  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c3		 ret	 0
?CalcDistance@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::CalcDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?GetOpenTime@CDoubleGoerEvent@@QAEEXZ
_TEXT	SEGMENT
?GetOpenTime@CDoubleGoerEvent@@QAEEXZ PROC		; CDoubleGoerEvent::GetOpenTime, COMDAT
; _this$ = ecx

; 672  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 673  : 	if( m_iState == DOUBLEGOER_STATE_PLAYING )

  00003	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00006	83 f8 02	 cmp	 eax, 2
  00009	75 1a		 jne	 SHORT $LN2@GetOpenTim

; 674  : 	{
; 675  : 		return m_iREMAIN_TIME/60000 + m_iEVENT_PLAYEND+1;

  0000b	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  00010	f7 6e 28	 imul	 DWORD PTR [esi+40]
  00013	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00016	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00019	40		 inc	 eax
  0001a	8b ca		 mov	 ecx, edx
  0001c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0001f	03 ca		 add	 ecx, edx
  00021	03 c1		 add	 eax, ecx
  00023	5e		 pop	 esi

; 683  : }

  00024	c3		 ret	 0
$LN2@GetOpenTim:

; 676  : 	}
; 677  : 	else if( m_iState == DOUBLEGOER_STATE_PLAYEND )

  00025	83 f8 03	 cmp	 eax, 3
  00028	75 15		 jne	 SHORT $LN4@GetOpenTim

; 678  : 	{
; 679  : 		return m_iREMAIN_TIME/60000+1;

  0002a	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0002f	f7 6e 28	 imul	 DWORD PTR [esi+40]
  00032	5e		 pop	 esi
  00033	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00036	8b c2		 mov	 eax, edx
  00038	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003b	40		 inc	 eax
  0003c	03 c2		 add	 eax, edx

; 683  : }

  0003e	c3		 ret	 0
$LN4@GetOpenTim:

; 680  : 	}
; 681  : 
; 682  : return 0;

  0003f	32 c0		 xor	 al, al
  00041	5e		 pop	 esi

; 683  : }

  00042	c3		 ret	 0
?GetOpenTime@CDoubleGoerEvent@@QAEEXZ ENDP		; CDoubleGoerEvent::GetOpenTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv600 = -80						; size = 4
tv572 = -80						; size = 4
_searchc$ = -80						; size = 4
tv570 = -76						; size = 4
tv607 = -72						; size = 4
tv580 = -68						; size = 4
tv578 = -64						; size = 4
_iTargetX$ = -60					; size = 4
tv618 = -56						; size = 4
tv583 = -56						; size = 4
_maxmoverange$ = -52					; size = 4
_iMidY$1$ = -48						; size = 4
_iMidX$1$ = -44						; size = 4
_bFindXY$ = -40						; size = 4
_iMinCost$1$ = -36					; size = 4
_iTargetY$ = -32					; size = 4
_tpx$ = -26						; size = 1
_tpy$ = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoubleGoerEvent::gObjMonsterMove, COMDAT
; _this$ = ecx

; 1111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 40	 sub	 esp, 64			; 00000040H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	8b d9		 mov	 ebx, ecx

; 1112 : 	if( gObjCheckUsedBuffEffect(lpObj,BUFF_ICEARROW) == TRUE ||
; 1113 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_STUN) == TRUE || 
; 1114 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_SLEEP) == TRUE ||
; 1115 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_FREEZE) == TRUE ||

  00035	6a 39		 push	 57			; 00000039H
  00037	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00040	83 c4 08	 add	 esp, 8
  00043	3c 01		 cmp	 al, 1
  00045	0f 84 ca 02 00
	00		 je	 $LN8@gObjMonste
  0004b	6a 3d		 push	 61			; 0000003dH
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00053	83 c4 08	 add	 esp, 8
  00056	3c 01		 cmp	 al, 1
  00058	0f 84 b7 02 00
	00		 je	 $LN8@gObjMonste
  0005e	6a 48		 push	 72			; 00000048H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00066	83 c4 08	 add	 esp, 8
  00069	3c 01		 cmp	 al, 1
  0006b	0f 84 a4 02 00
	00		 je	 $LN8@gObjMonste
  00071	68 92 00 00 00	 push	 146			; 00000092H
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0007c	83 c4 08	 add	 esp, 8
  0007f	3c 01		 cmp	 al, 1
  00081	0f 84 8e 02 00
	00		 je	 $LN8@gObjMonste
  00087	68 93 00 00 00	 push	 147			; 00000093H
  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00092	83 c4 08	 add	 esp, 8
  00095	3c 01		 cmp	 al, 1
  00097	0f 84 78 02 00
	00		 je	 $LN8@gObjMonste

; 1116 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_EARTHBINDS) == TRUE )
; 1117 : 	{
; 1118 : 		return;
; 1119 : 	}
; 1120 : 
; 1121 : 	int maxmoverange = lpObj->m_MoveRange*2+1;

  0009d	0f bf 86 8e 06
	00 00		 movsx	 eax, WORD PTR [esi+1678]
  000a4	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  000ab	89 45 cc	 mov	 DWORD PTR _maxmoverange$[ebp], eax

; 1122 : 	int searchc=10;

  000ae	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH

; 1123 : 	BYTE tpx;
; 1124 : 	BYTE tpy;
; 1125 : 
; 1126 : 	BOOL bFindXY = FALSE;

  000b3	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _bFindXY$[ebp], 0

; 1127 : 	int iTargetX = g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].stX;

  000ba	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000bd	83 e8 41	 sub	 eax, 65			; 00000041H
  000c0	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000c3	0f b6 1c 85 00
	00 00 00	 movzx	 ebx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax*4]
  000cb	89 5d c4	 mov	 DWORD PTR _iTargetX$[ebp], ebx

; 1128 : 	int iTargetY = g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].stY;

  000ce	0f b6 04 85 01
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax*4+1]
  000d6	89 45 e0	 mov	 DWORD PTR _iTargetY$[ebp], eax

; 1129 : 
; 1130 : 	int iTargetDistance = (int)(sqrt( float((lpObj->X - iTargetX)*(lpObj->X - iTargetX)+(lpObj->Y - iTargetY)*(lpObj->Y - iTargetY))));

  000d9	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  000e0	89 4d bc	 mov	 DWORD PTR tv580[ebp], ecx
  000e3	2b c8		 sub	 ecx, eax
  000e5	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  000ec	89 45 c0	 mov	 DWORD PTR tv578[ebp], eax
  000ef	2b c3		 sub	 eax, ebx
  000f1	0f af c0	 imul	 eax, eax
  000f4	0f af c9	 imul	 ecx, ecx
  000f7	03 c1		 add	 eax, ecx
  000f9	66 0f 6e c0	 movd	 xmm0, eax
  000fd	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00100	51		 push	 ecx
  00101	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00106	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  0010b	83 c4 04	 add	 esp, 4
  0010e	d9 5d c8	 fstp	 DWORD PTR tv618[ebp]
  00111	f3 0f 2c 4d c8	 cvttss2si ecx, DWORD PTR tv618[ebp]

; 1131 : 	
; 1132 : 	if ( TMonsterAIElement::s_MonsterAIMovePath[lpObj->MapNumber].m_bDataLoad )

  00116	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0011d	69 c0 cc 12 00
	00		 imul	 eax, eax, 4812
  00123	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR ?s_MonsterAIMovePath@TMonsterAIElement@@2PAVTMonsterAIMovePath@@A[eax+4], 0
  0012a	0f 84 08 01 00
	00		 je	 $LN38@gObjMonste

; 1133 : 	{
; 1134 : 		if ( iTargetDistance > 4 )

  00130	83 f9 04	 cmp	 ecx, 4
  00133	0f 8e ff 00 00
	00		 jle	 $LN38@gObjMonste

; 1135 : 		{
; 1136 : 			int iMinCost = 1000000;

  00139	c7 45 dc 40 42
	0f 00		 mov	 DWORD PTR _iMinCost$1$[ebp], 1000000 ; 000f4240H

; 1137 : 			int iMidX = -1;

  00140	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR _iMidX$1$[ebp], -1

; 1138 : 			int iMidY = -1;

  00147	c7 45 d0 ff ff
	ff ff		 mov	 DWORD PTR _iMidY$1$[ebp], -1

; 1135 : 		{
; 1136 : 			int iMinCost = 1000000;

  0014e	8d b8 14 00 00
	00		 lea	 edi, DWORD PTR ?s_MonsterAIMovePath@TMonsterAIElement@@2PAVTMonsterAIMovePath@@A[eax+20]
  00154	c7 45 c8 2c 01
	00 00		 mov	 DWORD PTR tv583[ebp], 300 ; 0000012cH
  0015b	8b 75 e0	 mov	 esi, DWORD PTR _iTargetY$[ebp]
  0015e	66 90		 npad	 2
$LL4@gObjMonste:

; 1142 : 			{
; 1143 : 				TMonsterAIMovePathInfo & PathInfo = TMonsterAIElement::s_MonsterAIMovePath[lpObj->MapNumber].m_MovePathInfo[i];
; 1144 : 				float fDistX = (float)(lpObj->X - PathInfo.m_iPathX);

  00160	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  00163	f7 d8		 neg	 eax
  00165	89 45 b4	 mov	 DWORD PTR tv570[ebp], eax
  00168	03 45 c0	 add	 eax, DWORD PTR tv578[ebp]
  0016b	66 0f 6e c8	 movd	 xmm1, eax
  0016f	0f 5b c9	 cvtdq2ps xmm1, xmm1

; 1145 : 				float fDistY = (float)(lpObj->Y - PathInfo.m_iPathY);

  00172	8b 07		 mov	 eax, DWORD PTR [edi]
  00174	f7 d8		 neg	 eax
  00176	89 45 b0	 mov	 DWORD PTR tv572[ebp], eax
  00179	8b 4d bc	 mov	 ecx, DWORD PTR tv580[ebp]
  0017c	03 c1		 add	 eax, ecx
  0017e	66 0f 6e c0	 movd	 xmm0, eax
  00182	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 1146 : 				int iPathSpotDist =  (int)sqrt( (fDistX*fDistX) + (fDistY*fDistY) );

  00185	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00189	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0018d	f3 0f 58 c1	 addss	 xmm0, xmm1
  00191	51		 push	 ecx
  00192	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00197	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  0019c	83 c4 04	 add	 esp, 4
  0019f	d9 5d b8	 fstp	 DWORD PTR tv607[ebp]
  001a2	f3 0f 2c 45 b8	 cvttss2si eax, DWORD PTR tv607[ebp]

; 1147 : 
; 1148 : 				if ( iPathSpotDist < 5 )

  001a7	83 f8 05	 cmp	 eax, 5
  001aa	7d 53		 jge	 SHORT $LN41@gObjMonste

; 1149 : 				{
; 1150 : 					fDistX = (float)(iTargetX - PathInfo.m_iPathX);

  001ac	8b 45 b4	 mov	 eax, DWORD PTR tv570[ebp]
  001af	03 c3		 add	 eax, ebx
  001b1	66 0f 6e c8	 movd	 xmm1, eax
  001b5	0f 5b c9	 cvtdq2ps xmm1, xmm1

; 1151 : 					fDistY = (float)(iTargetY - PathInfo.m_iPathY);

  001b8	8b 45 b0	 mov	 eax, DWORD PTR tv572[ebp]
  001bb	03 c6		 add	 eax, esi
  001bd	66 0f 6e c0	 movd	 xmm0, eax
  001c1	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 1152 : 					int iMidDist = (int)sqrt( (fDistX*fDistX) + (fDistY*fDistY) );

  001c4	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001c8	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001cc	f3 0f 58 c1	 addss	 xmm0, xmm1
  001d0	51		 push	 ecx
  001d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d6	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  001db	83 c4 04	 add	 esp, 4
  001de	d9 5d b0	 fstp	 DWORD PTR tv600[ebp]
  001e1	f3 0f 2c 45 b0	 cvttss2si eax, DWORD PTR tv600[ebp]

; 1153 : 
; 1154 : 					if ( iMinCost > iMidDist )

  001e6	39 45 dc	 cmp	 DWORD PTR _iMinCost$1$[ebp], eax
  001e9	7e 14		 jle	 SHORT $LN41@gObjMonste

; 1155 : 					{
; 1156 : 						if ( iMidDist )

  001eb	85 c0		 test	 eax, eax
  001ed	74 10		 je	 SHORT $LN41@gObjMonste

; 1157 : 						{
; 1158 : 							iMinCost = iMidDist;

  001ef	89 45 dc	 mov	 DWORD PTR _iMinCost$1$[ebp], eax

; 1159 : 							iMidX = PathInfo.m_iPathX;

  001f2	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  001f5	89 4d d4	 mov	 DWORD PTR _iMidX$1$[ebp], ecx

; 1160 : 							iMidY = PathInfo.m_iPathY;

  001f8	8b 17		 mov	 edx, DWORD PTR [edi]
  001fa	89 55 d0	 mov	 DWORD PTR _iMidY$1$[ebp], edx
  001fd	eb 09		 jmp	 SHORT $LN2@gObjMonste
$LN41@gObjMonste:
  001ff	8b 45 dc	 mov	 eax, DWORD PTR _iMinCost$1$[ebp]
  00202	8b 4d d4	 mov	 ecx, DWORD PTR _iMidX$1$[ebp]
  00205	8b 55 d0	 mov	 edx, DWORD PTR _iMidY$1$[ebp]
$LN2@gObjMonste:

; 1139 : 			int iSpotNum = -1;
; 1140 : 
; 1141 : 			for ( int i=0;i<MAX_MONSTER_AI_MOVE_PATH;i++)

  00208	83 c7 10	 add	 edi, 16			; 00000010H
  0020b	83 6d c8 01	 sub	 DWORD PTR tv583[ebp], 1
  0020f	0f 85 4b ff ff
	ff		 jne	 $LL4@gObjMonste

; 1161 : 							iSpotNum = i;
; 1162 : 						}
; 1163 : 					}
; 1164 : 				}
; 1165 : 			}
; 1166 : 
; 1167 : 			if ( iMinCost != 1000000 )

  00215	3d 40 42 0f 00	 cmp	 eax, 1000000		; 000f4240H
  0021a	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0021d	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00222	74 14		 je	 SHORT $LN38@gObjMonste

; 1168 : 			{
; 1169 : 				iTargetX = iMidX;

  00224	8b d9		 mov	 ebx, ecx
  00226	89 5d c4	 mov	 DWORD PTR _iTargetX$[ebp], ebx

; 1170 : 				iTargetY = iMidY;

  00229	8b ca		 mov	 ecx, edx
  0022b	89 4d e0	 mov	 DWORD PTR _iTargetY$[ebp], ecx

; 1171 : 				bFindXY = TRUE;

  0022e	ba 01 00 00 00	 mov	 edx, 1
  00233	89 55 d8	 mov	 DWORD PTR _bFindXY$[ebp], edx
  00236	eb 08		 jmp	 SHORT $LL5@gObjMonste
$LN38@gObjMonste:
  00238	8b 55 d8	 mov	 edx, DWORD PTR _bFindXY$[ebp]
  0023b	8b 4d e0	 mov	 ecx, DWORD PTR _iTargetY$[ebp]
  0023e	66 90		 npad	 2
$LL5@gObjMonste:

; 1172 : 			}
; 1173 : 		}
; 1174 : 	}
; 1175 : 
; 1176 : 	while ( searchc-- != 0 )

  00240	8b c7		 mov	 eax, edi
  00242	4f		 dec	 edi
  00243	89 7d b0	 mov	 DWORD PTR _searchc$[ebp], edi
  00246	85 c0		 test	 eax, eax
  00248	0f 84 c7 00 00
	00		 je	 $LN8@gObjMonste

; 1177 : 	{
; 1178 : 		__try

  0024e	9b		 fwait
  0024f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 1179 : 		{
; 1180 : 			if( bFindXY == FALSE )

  00256	85 d2		 test	 edx, edx
  00258	75 4a		 jne	 SHORT $LN16@gObjMonste

; 1181 : 			{
; 1182 : 				tpx = (lpObj->X - lpObj->m_MoveRange) + (rand()%maxmoverange);

  0025a	e8 00 00 00 00	 call	 _rand
  0025f	8b 4d cc	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  00262	99		 cdq
  00263	f7 f9		 idiv	 ecx
  00265	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0026c	03 d0		 add	 edx, eax
  0026e	0f bf 86 8e 06
	00 00		 movsx	 eax, WORD PTR [esi+1678]
  00275	2b d0		 sub	 edx, eax
  00277	88 55 e6	 mov	 BYTE PTR _tpx$[ebp], dl

; 1183 : 				tpy = (lpObj->Y - lpObj->m_MoveRange) + (rand()%maxmoverange);

  0027a	e8 00 00 00 00	 call	 _rand
  0027f	8b 4d cc	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  00282	99		 cdq
  00283	f7 f9		 idiv	 ecx
  00285	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0028c	03 d0		 add	 edx, eax
  0028e	0f bf 86 8e 06
	00 00		 movsx	 eax, WORD PTR [esi+1678]
  00295	2b d0		 sub	 edx, eax

; 1188 : 				tpy = iTargetY;

  00297	88 55 e7	 mov	 BYTE PTR _tpy$[ebp], dl

; 1189 : 			}
; 1190 : 		}

  0029a	9b		 fwait
  0029b	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  002a2	eb 35		 jmp	 SHORT $LN46@gObjMonste
$LN16@gObjMonste:

; 1184 : 			}
; 1185 : 			else
; 1186 : 			{
; 1187 : 				tpx = iTargetX;

  002a4	88 5d e6	 mov	 BYTE PTR _tpx$[ebp], bl

; 1188 : 				tpy = iTargetY;

  002a7	8a d1		 mov	 dl, cl
  002a9	88 55 e7	 mov	 BYTE PTR _tpy$[ebp], dl

; 1189 : 			}
; 1190 : 		}

  002ac	9b		 fwait
  002ad	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  002b4	eb 23		 jmp	 SHORT $LN46@gObjMonste
$LN20@gObjMonste:
$LN47@gObjMonste:

; 1191 : 		__except(maxmoverange=1, 1)

  002b6	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _maxmoverange$[ebp], 1
  002bd	b8 01 00 00 00	 mov	 eax, 1
$LN42@gObjMonste:
$LN22@gObjMonste:
  002c2	c3		 ret	 0
$LN21@gObjMonste:
  002c3	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 1189 : 			}
; 1190 : 		}

  002c6	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  002cd	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  002d0	8b 7d b0	 mov	 edi, DWORD PTR _searchc$[ebp]
  002d3	8b 5d c4	 mov	 ebx, DWORD PTR _iTargetX$[ebp]
  002d6	8a 55 e7	 mov	 dl, BYTE PTR _tpy$[ebp]
$LN46@gObjMonste:
  002d9	83 c8 ff	 or	 eax, -1

; 1192 : 		{
; 1193 : 
; 1194 : 		}
; 1195 : 
; 1196 : 
; 1197 : 		lpObj->TargetNumber = -1;

  002dc	66 89 86 38 06
	00 00		 mov	 WORD PTR [esi+1592], ax

; 1198 : 		lpObj->m_ActState.Attack = 0;
; 1199 : 		lpObj->NextActionTime = 1500;

  002e3	c7 86 a0 05 00
	00 dc 05 00 00	 mov	 DWORD PTR [esi+1440], 1500 ; 000005dcH

; 1201 : 		lpObj->MTX = tpx;

  002ed	8a 45 e6	 mov	 al, BYTE PTR _tpx$[ebp]
  002f0	88 86 54 01 00
	00		 mov	 BYTE PTR [esi+340], al

; 1202 : 		lpObj->MTY = tpy;

  002f6	88 96 55 01 00
	00		 mov	 BYTE PTR [esi+341], dl

; 1200 : 		lpObj->m_ActState.Emotion = 0;

  002fc	8b 86 c8 01 00
	00		 mov	 eax, DWORD PTR [esi+456]
  00302	25 0d ff ff ff	 and	 eax, -243		; ffffff0dH

; 1203 : 		lpObj->m_ActState.Move = 1;

  00307	83 c8 04	 or	 eax, 4
  0030a	89 86 c8 01 00
	00		 mov	 DWORD PTR [esi+456], eax

; 1204 : 	}

  00310	e9 23 ff ff ff	 jmp	 $LN38@gObjMonste
$LN8@gObjMonste:

; 1205 : }

  00315	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00318	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0031f	59		 pop	 ecx
  00320	5f		 pop	 edi
  00321	5e		 pop	 esi
  00322	5b		 pop	 ebx
  00323	8b e5		 mov	 esp, ebp
  00325	5d		 pop	 ebp
  00326	c2 04 00	 ret	 4
?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoubleGoerEvent::gObjMonsterMove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?DelBox@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?DelBox@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::DelBox, COMDAT
; _this$ = ecx

; 759  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 760  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	8d 91 40 02 00
	00		 lea	 edx, DWORD PTR [ecx+576]
  0000d	33 c0		 xor	 eax, eax
  0000f	90		 npad	 1
$LL4@DelBox:

; 761  : 	{
; 762  : 		if( m_BoxInfo[i] == aIndex )

  00010	39 32		 cmp	 DWORD PTR [edx], esi
  00012	74 10		 je	 SHORT $LN8@DelBox

; 760  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00014	40		 inc	 eax
  00015	83 c2 04	 add	 edx, 4
  00018	83 f8 06	 cmp	 eax, 6
  0001b	7c f3		 jl	 SHORT $LL4@DelBox

; 766  : 		}
; 767  : 	}
; 768  : return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 769  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@DelBox:

; 763  : 		{
; 764  : 			m_BoxInfo[i] = -1;

  00024	c7 84 81 40 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+576], -1

; 765  : 			return true;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	5e		 pop	 esi

; 769  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?DelBox@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::DelBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?AddBox@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?AddBox@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::AddBox, COMDAT
; _this$ = ecx

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 733  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00006	33 c0		 xor	 eax, eax
  00008	8d 96 40 02 00
	00		 lea	 edx, DWORD PTR [esi+576]
  0000e	66 90		 npad	 2
$LL4@AddBox:

; 734  : 	{
; 735  : 		if( m_BoxInfo[i] == -1 )

  00010	83 3a ff	 cmp	 DWORD PTR [edx], -1
  00013	74 10		 je	 SHORT $LN8@AddBox

; 733  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00015	40		 inc	 eax
  00016	83 c2 04	 add	 edx, 4
  00019	83 f8 06	 cmp	 eax, 6
  0001c	7c f2		 jl	 SHORT $LL4@AddBox

; 739  : 		}
; 740  : 	}
; 741  : return false;

  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 742  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN8@AddBox:

; 736  : 		{
; 737  : 			m_BoxInfo[i] = aIndex;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00028	89 8c 86 40 02
	00 00		 mov	 DWORD PTR [esi+eax*4+576], ecx

; 738  : 			return true;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	5e		 pop	 esi

; 742  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?AddBox@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::AddBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?DelMonster@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?DelMonster@CDoubleGoerEvent@@QAEHH@Z PROC		; CDoubleGoerEvent::DelMonster, COMDAT
; _this$ = ecx

; 745  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 746  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	8d 91 b0 00 00
	00		 lea	 edx, DWORD PTR [ecx+176]
  0000d	33 c0		 xor	 eax, eax
  0000f	90		 npad	 1
$LL4@DelMonster:

; 747  : 	{
; 748  : 		if( m_MonsterInfo[i] == aIndex )

  00010	39 32		 cmp	 DWORD PTR [edx], esi
  00012	74 10		 je	 SHORT $LN8@DelMonster

; 746  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00014	40		 inc	 eax
  00015	83 c2 04	 add	 edx, 4
  00018	83 f8 64	 cmp	 eax, 100		; 00000064H
  0001b	7c f3		 jl	 SHORT $LL4@DelMonster

; 753  : 		}
; 754  : 	}
; 755  : return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 756  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@DelMonster:

; 749  : 		{
; 750  : 			m_MonsterInfo[i] = -1;
; 751  : 			gObjDel(aIndex);

  00024	56		 push	 esi
  00025	c7 84 81 b0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+176], -1
  00030	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00035	83 c4 04	 add	 esp, 4

; 752  : 			return true;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	5e		 pop	 esi

; 756  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?DelMonster@CDoubleGoerEvent@@QAEHH@Z ENDP		; CDoubleGoerEvent::DelMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?AddMonster@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?AddMonster@CDoubleGoerEvent@@QAEHH@Z PROC		; CDoubleGoerEvent::AddMonster, COMDAT
; _this$ = ecx

; 719  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 720  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00006	33 c0		 xor	 eax, eax
  00008	8d 96 b0 00 00
	00		 lea	 edx, DWORD PTR [esi+176]
  0000e	66 90		 npad	 2
$LL4@AddMonster:

; 721  : 	{
; 722  : 		if( m_MonsterInfo[i] == -1 )

  00010	83 3a ff	 cmp	 DWORD PTR [edx], -1
  00013	74 10		 je	 SHORT $LN8@AddMonster

; 720  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00015	40		 inc	 eax
  00016	83 c2 04	 add	 edx, 4
  00019	83 f8 64	 cmp	 eax, 100		; 00000064H
  0001c	7c f2		 jl	 SHORT $LL4@AddMonster

; 726  : 		}
; 727  : 	}
; 728  : return false;

  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 729  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN8@AddMonster:

; 723  : 		{
; 724  : 			m_MonsterInfo[i] = aIndex;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00028	89 8c 86 b0 00
	00 00		 mov	 DWORD PTR [esi+eax*4+176], ecx

; 725  : 			return true;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	5e		 pop	 esi

; 729  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?AddMonster@CDoubleGoerEvent@@QAEHH@Z ENDP		; CDoubleGoerEvent::AddMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?CheckUser@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$1 = -16						; size = 5
tv297 = -8						; size = 4
tv298 = -4						; size = 4
?CheckUser@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::CheckUser, COMDAT
; _this$ = ecx

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 376  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  0000b	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR tv298[ebp], 5
  00012	8d 9f 88 00 00
	00		 lea	 ebx, DWORD PTR [edi+136]
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@CheckUser:

; 377  : 	{
; 378  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00020	8b 33		 mov	 esi, DWORD PTR [ebx]

; 379  : 
; 380  : 		if( OBJMAX_RANGE(aIndex) )

  00022	85 f6		 test	 esi, esi
  00024	0f 88 c6 00 00
	00		 js	 $LN2@CheckUser
  0002a	33 c0		 xor	 eax, eax
  0002c	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00032	0f 9e c0	 setle	 al
  00035	85 c0		 test	 eax, eax
  00037	0f 84 b3 00 00
	00		 je	 $LN2@CheckUser

; 381  : 		{
; 382  : 			if( !gObjIsConnected(aIndex) )

  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00043	83 c4 04	 add	 esp, 4
  00046	85 c0		 test	 eax, eax
  00048	75 2d		 jne	 SHORT $LN6@CheckUser

; 383  : 			{
; 384  : 				DelUser(aIndex);

  0004a	56		 push	 esi
  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?DelUser@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelUser

; 385  : 				LogAddTD("[Doppelganger] [USER REMOVE] User not connected [%d](%s)(%s)",aIndex,

  00052	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00058	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005e	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00061	50		 push	 eax
  00062	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	eb 79		 jmp	 SHORT $LN2@CheckUser
$LN6@CheckUser:

; 386  : 					gObj[aIndex].AccountID,gObj[aIndex].Name);
; 387  : 			}
; 388  : 			else if( gObj[aIndex].MapNumber != m_iCurentMap )

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00082	89 4d f8	 mov	 DWORD PTR tv297[ebp], ecx
  00085	0f b6 84 01 23
	01 00 00	 movzx	 eax, BYTE PTR [ecx+eax+291]
  0008d	3b 47 30	 cmp	 eax, DWORD PTR [edi+48]
  00090	74 5e		 je	 SHORT $LN2@CheckUser

; 389  : 			{
; 390  : 				if( m_iState == DOUBLEGOER_STATE_PLAYING )

  00092	83 7f 24 02	 cmp	 DWORD PTR [edi+36], 2
  00096	75 25		 jne	 SHORT $LN9@CheckUser

; 391  : 				{
; 392  : 					PMSG_DOUBLEGOER_EVENTEND pMsg;
; 393  : 					PHeadSubSetB((LPBYTE)&pMsg,0xBF,19,sizeof(pMsg));

  00098	6a 05		 push	 5
  0009a	6a 13		 push	 19			; 00000013H
  0009c	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0009f	68 bf 00 00 00	 push	 191			; 000000bfH
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 394  : 					pMsg.btResult = 1;
; 395  : 
; 396  : 					DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  000aa	6a 05		 push	 5
  000ac	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000af	c6 45 f4 01	 mov	 BYTE PTR _pMsg$1[ebp+4], 1
  000b3	50		 push	 eax
  000b4	56		 push	 esi
  000b5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ba	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN9@CheckUser:

; 397  : 				}
; 398  : 
; 399  : 				DelUser(aIndex);

  000bd	56		 push	 esi
  000be	8b cf		 mov	 ecx, edi
  000c0	e8 00 00 00 00	 call	 ?DelUser@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelUser

; 400  : 				LogAddTD("[Doppelganger] [USER REMOVE] User not on map [%d](%s)(%s) CurMap:[%d]-UserMap:[%d]",aIndex,

  000c5	8b 4d f8	 mov	 ecx, DWORD PTR tv297[ebp]
  000c8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ce	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  000d5	50		 push	 eax
  000d6	ff 77 30	 push	 DWORD PTR [edi+48]
  000d9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000dc	50		 push	 eax
  000dd	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000e0	50		 push	 eax
  000e1	56		 push	 esi
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ed	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@CheckUser:

; 376  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  000f0	83 c3 08	 add	 ebx, 8
  000f3	83 6d fc 01	 sub	 DWORD PTR tv298[ebp], 1
  000f7	0f 85 23 ff ff
	ff		 jne	 $LL4@CheckUser

; 401  : 					gObj[aIndex].AccountID,gObj[aIndex].Name,m_iCurentMap,gObj[aIndex].MapNumber);
; 402  : 			}
; 403  : 		}
; 404  : 	}
; 405  : 
; 406  : 	if( !OBJMAX_RANGE(m_iLeaderIndex) || !gObjIsConnected(m_iLeaderIndex) || gObj[m_iLeaderIndex].MapNumber != m_iCurentMap )

  000fd	8b 8f 80 00 00
	00		 mov	 ecx, DWORD PTR [edi+128]
  00103	85 c9		 test	 ecx, ecx
  00105	78 38		 js	 SHORT $LN11@CheckUser
  00107	33 c0		 xor	 eax, eax
  00109	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0010f	0f 9e c0	 setle	 al
  00112	85 c0		 test	 eax, eax
  00114	74 29		 je	 SHORT $LN11@CheckUser
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0011c	83 c4 04	 add	 esp, 4
  0011f	85 c0		 test	 eax, eax
  00121	74 1c		 je	 SHORT $LN11@CheckUser
  00123	69 8f 80 00 00
	00 40 27 00 00	 imul	 ecx, DWORD PTR [edi+128], 10048
  0012d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00132	0f b6 84 01 23
	01 00 00	 movzx	 eax, BYTE PTR [ecx+eax+291]
  0013a	3b 47 30	 cmp	 eax, DWORD PTR [edi+48]
  0013d	74 0a		 je	 SHORT $LN10@CheckUser
$LN11@CheckUser:

; 407  : 	{
; 408  : 		m_iLeaderIndex = -1;

  0013f	c7 87 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+128], -1
$LN10@CheckUser:
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx

; 409  : 	}
; 410  : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
?CheckUser@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::CheckUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?DelUser@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?DelUser@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::DelUser, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 706  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	8d 91 88 00 00
	00		 lea	 edx, DWORD PTR [ecx+136]
  0000d	33 c0		 xor	 eax, eax
  0000f	90		 npad	 1
$LL4@DelUser:

; 707  : 	{
; 708  : 		if( m_PlayerInfo[i].aIndex == aIndex )

  00010	39 32		 cmp	 DWORD PTR [edx], esi
  00012	74 10		 je	 SHORT $LN8@DelUser

; 706  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00014	40		 inc	 eax
  00015	83 c2 08	 add	 edx, 8
  00018	83 f8 05	 cmp	 eax, 5
  0001b	7c f3		 jl	 SHORT $LL4@DelUser

; 713  : 		}
; 714  : 	}
; 715  : return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 716  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@DelUser:

; 709  : 		{
; 710  : 			m_PlayerInfo[i].aIndex = -1;

  00024	c7 84 c1 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*8+136], -1

; 711  : 			m_iPlayerCount--;
; 712  : 			return true;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	ff 49 34	 dec	 DWORD PTR [ecx+52]
  00037	5e		 pop	 esi

; 716  : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?DelUser@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::DelUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?AddUser@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?AddUser@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::AddUser, COMDAT
; _this$ = ecx

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 687  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00008	8d 81 88 00 00
	00		 lea	 eax, DWORD PTR [ecx+136]
  0000e	33 f6		 xor	 esi, esi
$LL4@AddUser:

; 688  : 	{
; 689  : 		if( m_PlayerInfo[i].aIndex == -1 )

  00010	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00013	74 12		 je	 SHORT $LN8@AddUser

; 687  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00015	46		 inc	 esi
  00016	83 c0 08	 add	 eax, 8
  00019	83 fe 05	 cmp	 esi, 5
  0001c	7c f2		 jl	 SHORT $LL4@AddUser

; 699  : 		}
; 700  : 	}
; 701  : return false;

  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 702  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN8@AddUser:
  00027	53		 push	 ebx

; 690  : 		{
; 691  : 			int MapIndex = m_iCurentMap-MAP_INDEX_DOUBLEGOER1;

  00028	8b 59 30	 mov	 ebx, DWORD PTR [ecx+48]
  0002b	83 eb 41	 sub	 ebx, 65			; 00000041H
  0002e	57		 push	 edi

; 692  : 			gObjMoveGate(aIndex,g_DoubleGoerEvent_Gates[MapIndex]);

  0002f	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00032	ff 34 9d 00 00
	00 00		 push	 DWORD PTR ?g_DoubleGoerEvent_Gates@@3PAHA[ebx*4]
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0003f	83 c4 08	 add	 esp, 8

; 693  : 
; 694  : 			SendBlockInfo(aIndex,MapIndex,0);

  00042	6a 00		 push	 0
  00044	53		 push	 ebx
  00045	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00048	8b cb		 mov	 ecx, ebx
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 ?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z ; CDoubleGoerEvent::SendBlockInfo

; 695  : 
; 696  : 			m_PlayerInfo[i].aIndex = aIndex;

  00050	89 bc f3 88 00
	00 00		 mov	 DWORD PTR [ebx+esi*8+136], edi

; 697  : 			m_iPlayerCount++;
; 698  : 			return true;

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	ff 43 34	 inc	 DWORD PTR [ebx+52]
  0005f	5f		 pop	 edi
  00060	5b		 pop	 ebx
  00061	5e		 pop	 esi

; 702  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?AddUser@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::AddUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoubleGoerEvent::MonsterDieHandle, COMDAT
; _this$ = ecx

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1210 : 	if( lpObj->Class == 529 || lpObj->Class == 530 )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	b9 11 02 00 00	 mov	 ecx, 529		; 00000211H
  0000f	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  00016	66 3b c1	 cmp	 ax, cx
  00019	74 3e		 je	 SHORT $LN4@MonsterDie
  0001b	b9 12 02 00 00	 mov	 ecx, 530		; 00000212H
  00020	66 3b c1	 cmp	 ax, cx
  00023	74 34		 je	 SHORT $LN4@MonsterDie

; 1215 : 	}
; 1216 : 	else if( lpObj->Class == 531 )

  00025	b9 13 02 00 00	 mov	 ecx, 531		; 00000213H
  0002a	66 3b c1	 cmp	 ax, cx
  0002d	0f 85 c6 00 00
	00		 jne	 $LN5@MonsterDie

; 1217 : 	{
; 1218 : 		SetState(DOUBLEGOER_STATE_PLAYEND);

  00033	6a 03		 push	 3
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState

; 1219 : 		LogAddTD("[Doppelganger] Boss Killed -> EVENT_END");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00047	83 c4 04	 add	 esp, 4

; 1220 : 	}
; 1221 : 
; 1222 : 	DelMonster(lpObj->m_Index);

  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 37		 push	 DWORD PTR [edi]
  0004e	e8 00 00 00 00	 call	 ?DelMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelMonster
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 1223 : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN4@MonsterDie:
  00059	53		 push	 ebx

; 1211 : 	{
; 1212 : 		SummonMonster(541,m_iCurentMap,lpObj->X-1,lpObj->Y+(-1+rand()%3),m_EventLevel, m_EventReset);

  0005a	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  00060	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  00066	e8 00 00 00 00	 call	 _rand
  0006b	99		 cdq
  0006c	bb 03 00 00 00	 mov	 ebx, 3
  00071	f7 fb		 idiv	 ebx
  00073	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  0007a	8b ce		 mov	 ecx, esi
  0007c	48		 dec	 eax
  0007d	03 c2		 add	 eax, edx
  0007f	50		 push	 eax
  00080	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  00087	48		 dec	 eax
  00088	50		 push	 eax
  00089	ff 76 30	 push	 DWORD PTR [esi+48]
  0008c	68 1d 02 00 00	 push	 541			; 0000021dH
  00091	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 1213 : 		SummonMonster(541,m_iCurentMap,lpObj->X,lpObj->Y,m_EventLevel, m_EventReset);

  00096	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  0009c	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  000a3	8b ce		 mov	 ecx, esi
  000a5	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  000ab	50		 push	 eax
  000ac	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  000b3	50		 push	 eax
  000b4	ff 76 30	 push	 DWORD PTR [esi+48]
  000b7	68 1d 02 00 00	 push	 541			; 0000021dH
  000bc	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 1214 : 		SummonMonster(541,m_iCurentMap,lpObj->X+(-1+rand()%3),lpObj->Y+1,m_EventLevel, m_EventReset);

  000c1	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000c7	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  000ce	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  000d4	40		 inc	 eax
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _rand
  000db	99		 cdq
  000dc	8b ce		 mov	 ecx, esi
  000de	f7 fb		 idiv	 ebx
  000e0	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  000e7	48		 dec	 eax
  000e8	03 c2		 add	 eax, edx
  000ea	50		 push	 eax
  000eb	ff 76 30	 push	 DWORD PTR [esi+48]
  000ee	68 1d 02 00 00	 push	 541			; 0000021dH
  000f3	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
  000f8	5b		 pop	 ebx
$LN5@MonsterDie:

; 1220 : 	}
; 1221 : 
; 1222 : 	DelMonster(lpObj->m_Index);

  000f9	ff 37		 push	 DWORD PTR [edi]
  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?DelMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelMonster
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi

; 1223 : }

  00104	5d		 pop	 ebp
  00105	c2 04 00	 ret	 4
?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoubleGoerEvent::MonsterDieHandle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?RemoveMonster@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?RemoveMonster@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::RemoveMonster, COMDAT
; _this$ = ecx

; 1081 : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1082 : 	/*for(int i = 0; i < OBJ_MAXMONSTER; i++)
; 1083 : 	{
; 1084 : 		if( DG_MAP_RANGE(gObj[i].MapNumber) )
; 1085 : 		{
; 1086 : 			gObjDel(i);
; 1087 : 		}
; 1088 : 	}*/
; 1089 : 
; 1090 : 	int i;
; 1091 : 	for(i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00005	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
  0000a	8d b3 b0 00 00
	00		 lea	 esi, DWORD PTR [ebx+176]
$LL4@RemoveMons:

; 1092 : 	{
; 1093 : 		if( m_MonsterInfo[i] != -1 )

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 0f		 je	 SHORT $LN2@RemoveMons

; 1094 : 		{
; 1095 : 			gObjDel(m_MonsterInfo[i]);

  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0001d	83 c4 04	 add	 esp, 4

; 1096 : 			m_MonsterInfo[i] = -1;

  00020	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN2@RemoveMons:

; 1082 : 	/*for(int i = 0; i < OBJ_MAXMONSTER; i++)
; 1083 : 	{
; 1084 : 		if( DG_MAP_RANGE(gObj[i].MapNumber) )
; 1085 : 		{
; 1086 : 			gObjDel(i);
; 1087 : 		}
; 1088 : 	}*/
; 1089 : 
; 1090 : 	int i;
; 1091 : 	for(i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00026	83 c6 04	 add	 esi, 4
  00029	83 ef 01	 sub	 edi, 1
  0002c	75 e2		 jne	 SHORT $LL4@RemoveMons

; 1097 : 		}
; 1098 : 	}
; 1099 : 
; 1100 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  0002e	8d b3 40 02 00
	00		 lea	 esi, DWORD PTR [ebx+576]
  00034	bf 06 00 00 00	 mov	 edi, 6
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@RemoveMons:

; 1101 : 	{
; 1102 : 		if( m_BoxInfo[i] != -1 )

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 0f		 je	 SHORT $LN5@RemoveMons

; 1103 : 		{
; 1104 : 			gObjDel(m_BoxInfo[i]);

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0004d	83 c4 04	 add	 esp, 4

; 1105 : 			m_BoxInfo[i] = -1;

  00050	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN5@RemoveMons:

; 1097 : 		}
; 1098 : 	}
; 1099 : 
; 1100 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00056	83 c6 04	 add	 esi, 4
  00059	83 ef 01	 sub	 edi, 1
  0005c	75 e2		 jne	 SHORT $LL7@RemoveMons

; 1106 : 		}
; 1107 : 	}
; 1108 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	c3		 ret	 0
?RemoveMonster@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::RemoveMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_lpUser$ = 12						; size = 4
?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z PROC ; CDoubleGoerEvent::GetRewardBox, COMDAT
; _this$ = ecx

; 1319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1189 : 		return (this->_Myfirst() == this->_Mylast());

  00006	8b 86 64 02 00
	00		 mov	 eax, DWORD PTR [esi+612]
  0000c	3b 86 68 02 00
	00		 cmp	 eax, DWORD PTR [esi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 1320 : 	if( this->m_vtReward.empty() )

  00012	75 07		 jne	 SHORT $LN5@GetRewardB

; 1321 : 		return NULL;

  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 1343 : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN5@GetRewardB:
  0001b	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 206  : 		return (this->_Ptr == _Right._Ptr);

  0001c	3b 86 68 02 00
	00		 cmp	 eax, DWORD PTR [esi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 1325 : 	for( ; _It != m_vtReward.end(); _It++)

  00022	74 31		 je	 SHORT $LN186@GetRewardB

; 1326 : 	{
; 1327 : 		if( lpUser->Level >= _It->m_LevelMin &&

  00024	8b 7d 0c	 mov	 edi, DWORD PTR _lpUser$[ebp]
  00027	0f b7 8f 96 00
	00 00		 movzx	 ecx, WORD PTR [edi+150]
  0002e	0f bf d1	 movsx	 edx, cx
$LL4@GetRewardB:
  00031	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00034	7c 14		 jl	 SHORT $LN2@GetRewardB
  00036	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  00039	7f 0f		 jg	 SHORT $LN2@GetRewardB

; 1328 : 			lpUser->Level <= _It->m_LevelMax )
; 1329 : 		{
; 1330 : 			if( lpUser->iResetCount >= _It->m_ResetMin &&

  0003b	8b 8f 20 27 00
	00		 mov	 ecx, DWORD PTR [edi+10016]
  00041	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00043	7c 05		 jl	 SHORT $LN2@GetRewardB
  00045	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00048	7e 13		 jle	 SHORT $LN182@GetRewardB
$LN2@GetRewardB:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 112  : 		++this->_Ptr;

  0004a	83 c0 18	 add	 eax, 24			; 00000018H

; 206  : 		return (this->_Ptr == _Right._Ptr);

  0004d	3b 86 68 02 00
	00		 cmp	 eax, DWORD PTR [esi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 1325 : 	for( ; _It != m_vtReward.end(); _It++)

  00053	75 dc		 jne	 SHORT $LL4@GetRewardB
$LN186@GetRewardB:
  00055	5f		 pop	 edi

; 1337 : 
; 1338 : 				break;
; 1339 : 			}
; 1340 : 		}
; 1341 : 	}
; 1342 : 	return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	5e		 pop	 esi

; 1343 : }

  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
$LN182@GetRewardB:

; 1331 : 				lpUser->iResetCount <= _It->m_ResetMax )
; 1332 : 			{
; 1333 : 				if( type == 0 )

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  00060	85 c9		 test	 ecx, ecx
  00062	75 09		 jne	 SHORT $LN8@GetRewardB

; 1334 : 					return _It->m_SilverBox;

  00064	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 1343 : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN8@GetRewardB:

; 1335 : 				if( type == 1 )

  0006d	83 f9 01	 cmp	 ecx, 1
  00070	75 e3		 jne	 SHORT $LN186@GetRewardB

; 1336 : 					return _It->m_GoldenBox;

  00072	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 1343 : }

  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ENDP ; CDoubleGoerEvent::GetRewardBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_MonsterClass$ = 12					; size = 4
_nMaxLevel$ = 16					; size = 4
_nMaxReset$ = 20					; size = 4
?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z PROC		; CDoubleGoerEvent::SetMonster, COMDAT
; _this$ = ecx

; 1040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1041 : 	if( !OBJMAX_RANGE(nIndex) )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _nIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 88 14 01 00
	00		 js	 $LN7@SetMonster
  0000f	33 c0		 xor	 eax, eax
  00011	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 01 01 00
	00		 je	 $LN7@SetMonster

; 1045 : 	}
; 1046 : 
; 1047 : 	LPOBJ lpObj = &gObj[nIndex];

  00022	56		 push	 esi
  00023	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00029	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1048 : 	lpObj->ConnectCheckTime = GetTickCount();

  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1049 : 	lpObj->ShopNumber = -1;
; 1050 : 	lpObj->TargetNumber = -1;
; 1051 : 	lpObj->m_RecallMon = -1;
; 1052 : 	lpObj->Connected = PLAYER_PLAYING;
; 1053 : 	lpObj->Live = TRUE;
; 1054 : 	lpObj->m_State = 1;
; 1055 : 	lpObj->DieRegen = 0;
; 1056 : 	lpObj->Type = OBJ_MONSTER;
; 1057 : 	lpObj->Class = MonsterClass;
; 1058 : 	lpObj->LastAttackerID = -1;
; 1059 : 
; 1060 : 	g_MonsterStatCalc.ConvertMonsterStat(lpObj, nMaxLevel, nMaxReset);

  00035	ff 75 14	 push	 DWORD PTR _nMaxReset$[ebp]
  00038	83 c9 ff	 or	 ecx, -1
  0003b	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0003e	ff 75 10	 push	 DWORD PTR _nMaxLevel$[ebp]
  00041	66 8b 45 0c	 mov	 ax, WORD PTR _MonsterClass$[ebp]
  00045	66 89 8e 3c 06
	00 00		 mov	 WORD PTR [esi+1596], cx
  0004c	66 89 8e 38 06
	00 00		 mov	 WORD PTR [esi+1592], cx
  00053	89 8e 30 06 00
	00		 mov	 DWORD PTR [esi+1584], ecx
  00059	66 89 8e 3e 06
	00 00		 mov	 WORD PTR [esi+1598], cx
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterStatCalc@@3VCMonsterStatCalc@@A ; g_MonsterStatCalc
  00065	56		 push	 esi
  00066	c7 46 04 03 00
	00 00		 mov	 DWORD PTR [esi+4], 3
  0006d	66 c7 46 50 02
	01		 mov	 WORD PTR [esi+80], 258	; 00000102H
  00073	c7 86 d0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+464], 1
  0007d	c6 86 8a 05 00
	00 00		 mov	 BYTE PTR [esi+1418], 0
  00084	66 89 86 90 00
	00 00		 mov	 WORD PTR [esi+144], ax
  0008b	e8 00 00 00 00	 call	 ?ConvertMonsterStat@CMonsterStatCalc@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CMonsterStatCalc::ConvertMonsterStat

; 1061 : 
; 1062 : 	*lpObj->pInventoryCount = 0;

  00090	8b 86 c4 11 00
	00		 mov	 eax, DWORD PTR [esi+4548]
  00096	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1063 : 
; 1064 : 	if( lpObj->m_AttackType )

  00099	0f b7 86 92 06
	00 00		 movzx	 eax, WORD PTR [esi+1682]
  000a0	66 85 c0	 test	 ax, ax
  000a3	74 0c		 je	 SHORT $LN3@SetMonster

; 1065 : 	{
; 1066 : 		gObjMonsterMagicAdd(lpObj,lpObj->m_AttackType,1);

  000a5	6a 01		 push	 1
  000a7	50		 push	 eax
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@GE@Z ; gObjMonsterMagicAdd
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SetMonster:

; 1067 : 	}
; 1068 : 
; 1069 : 	gObjMonsterHitDamageInit(lpObj);

  000b1	56		 push	 esi
  000b2	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit

; 1070 : 	gObjSetInventory1Pointer(lpObj);

  000b7	56		 push	 esi
  000b8	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer

; 1071 : 	CreateFrustrum(lpObj->X,lpObj->Y,nIndex);

  000bd	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000c4	57		 push	 edi
  000c5	50		 push	 eax
  000c6	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 1072 : 
; 1073 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->X,lpObj->Y);

  000d3	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000da	83 c4 14	 add	 esp, 20			; 00000014H
  000dd	50		 push	 eax
  000de	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  000e5	50		 push	 eax
  000e6	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  000ed	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  000f3	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000f9	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 1074 : 
; 1075 : 	lpObj->m_OldX = lpObj->X;

  000fe	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00105	88 86 50 01 00
	00		 mov	 BYTE PTR [esi+336], al

; 1076 : 	lpObj->m_OldY = lpObj->Y;

  0010b	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00112	88 86 51 01 00
	00		 mov	 BYTE PTR [esi+337], al

; 1077 : 	return true;

  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	5e		 pop	 esi
  0011e	5f		 pop	 edi

; 1078 : }

  0011f	5d		 pop	 ebp
  00120	c2 10 00	 ret	 16			; 00000010H
$LN7@SetMonster:

; 1042 : 	{
; 1043 : 		LogAdd("error : %s %d",__FILE__,__LINE__);

  00123	68 13 04 00 00	 push	 1043			; 00000413H
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1044 : 		return false;

  0013b	33 c0		 xor	 eax, eax
  0013d	5f		 pop	 edi

; 1078 : }

  0013e	5d		 pop	 ebp
  0013f	c2 10 00	 ret	 16			; 00000010H
?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z ENDP		; CDoubleGoerEvent::SetMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_Id$ = 8						; size = 4
tv225 = 12						; size = 4
_map$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_MaxLevel$ = 24						; size = 4
_MaxReset$ = 28						; size = 4
?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z PROC	; CDoubleGoerEvent::SummonMonster, COMDAT
; _this$ = ecx

; 985  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 986  : 	int result = gObjAddMonster(map);

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _map$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	53		 push	 ebx
  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00013	0f bf f8	 movsx	 edi, ax
  00016	83 c4 04	 add	 esp, 4

; 987  : 
; 988  : 	if ( result >= 0 )

  00019	85 ff		 test	 edi, edi
  0001b	0f 88 6d 01 00
	00		 js	 $LN2@SummonMons

; 989  : 	{
; 990  : 		LPOBJ lpObj = &gObj[result];

  00021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 991  : 
; 992  : 		lpObj->m_PosNum = -1;

  00027	83 c8 ff	 or	 eax, -1

; 993  : 		lpObj->X = x;
; 994  : 		lpObj->Y = y;
; 995  : 		lpObj->MapNumber = map;
; 996  : 		lpObj->TX = x;
; 997  : 		lpObj->TY = y;
; 998  : 		lpObj->m_OldX = x;
; 999  : 		lpObj->m_OldY = y;
; 1000 : 		lpObj->StartX = x;
; 1001 : 		lpObj->StartY = y;
; 1002 : 
; 1003 : 		//if( gObjSetMonster(result, Id) == FALSE )
; 1004 : 
; 1005 : 		if( !this->SetMonster(result, Id, MaxLevel, MaxReset) )

  0002a	ff 75 1c	 push	 DWORD PTR _MaxReset$[ebp]
  0002d	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00033	ff 75 18	 push	 DWORD PTR _MaxLevel$[ebp]
  00036	03 f1		 add	 esi, ecx
  00038	89 4d 0c	 mov	 DWORD PTR tv225[ebp], ecx
  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _x$[ebp]
  0003e	88 9e 23 01 00
	00		 mov	 BYTE PTR [esi+291], bl
  00044	8b 5d 08	 mov	 ebx, DWORD PTR _Id$[ebp]
  00047	53		 push	 ebx
  00048	66 89 86 98 05
	00 00		 mov	 WORD PTR [esi+1432], ax
  0004f	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00052	88 8e 20 01 00
	00		 mov	 BYTE PTR [esi+288], cl
  00058	88 8e 52 01 00
	00		 mov	 BYTE PTR [esi+338], cl
  0005e	88 8e 50 01 00
	00		 mov	 BYTE PTR [esi+336], cl
  00064	88 8e 4e 01 00
	00		 mov	 BYTE PTR [esi+334], cl
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0006d	57		 push	 edi
  0006e	88 86 21 01 00
	00		 mov	 BYTE PTR [esi+289], al
  00074	88 86 53 01 00
	00		 mov	 BYTE PTR [esi+339], al
  0007a	88 86 51 01 00
	00		 mov	 BYTE PTR [esi+337], al
  00080	88 86 4f 01 00
	00		 mov	 BYTE PTR [esi+335], al
  00086	e8 00 00 00 00	 call	 ?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::SetMonster
  0008b	85 c0		 test	 eax, eax
  0008d	75 20		 jne	 SHORT $LN3@SummonMons

; 1006 : 		{
; 1007 : 			gObjDel(result);

  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 1008 : 			LogAddTD("[Doppelganger] Failed to set monster info ID: %d",Id);

  00095	53		 push	 ebx
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1009 : 			return false;

  000a4	33 c0		 xor	 eax, eax
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx

; 1037 : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 18 00	 ret	 24			; 00000018H
$LN3@SummonMons:

; 1010 : 		}
; 1011 : 
; 1012 : 		if( Id == 541 || Id == 542 )

  000af	81 fb 1d 02 00
	00		 cmp	 ebx, 541		; 0000021dH
  000b5	74 39		 je	 SHORT $LN6@SummonMons
  000b7	81 fb 1e 02 00
	00		 cmp	 ebx, 542		; 0000021eH
  000bd	74 31		 je	 SHORT $LN6@SummonMons

; 1024 : 				lpObj->Class,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y);
; 1025 : 		}
; 1026 : 		else if( AddMonster(result) == FALSE )

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000c2	57		 push	 edi
  000c3	e8 00 00 00 00	 call	 ?AddMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::AddMonster
  000c8	85 c0		 test	 eax, eax
  000ca	0f 85 8c 00 00
	00		 jne	 $LN8@SummonMons

; 1027 : 		{
; 1028 : 			gObjDel(result);

  000d0	57		 push	 edi
  000d1	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 1029 : 			LogAddTD("[Doppelganger] Failed to summon monster ID: %d",Id);

  000d6	53		 push	 ebx
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1030 : 			return false;

  000e5	33 c0		 xor	 eax, eax
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1037 : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 18 00	 ret	 24			; 00000018H
$LN6@SummonMons:

; 1013 : 		{
; 1014 : 			if( AddBox(result) == FALSE )

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000f3	57		 push	 edi
  000f4	e8 00 00 00 00	 call	 ?AddBox@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::AddBox
  000f9	85 c0		 test	 eax, eax
  000fb	75 20		 jne	 SHORT $LN7@SummonMons

; 1015 : 			{
; 1016 : 				gObjDel(result);

  000fd	57		 push	 edi
  000fe	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 1017 : 				LogAddTD("[Doppelganger] Failed to summon silver box ID: %d",Id);

  00103	53		 push	 ebx
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1018 : 				return false;

  00112	33 c0		 xor	 eax, eax
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx

; 1037 : }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 18 00	 ret	 24			; 00000018H
$LN7@SummonMons:

; 1019 : 			}
; 1020 : 
; 1021 : 			gObj[result].Type = OBJ_NPC;

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00122	8b 4d 0c	 mov	 ecx, DWORD PTR tv225[ebp]
  00125	c6 44 01 50 03	 mov	 BYTE PTR [ecx+eax+80], 3

; 1022 : 
; 1023 : 			LogAddTD("[Doppelganger] SummonMonster [%d](%s) Map: %d, X: %d, Y: %d",

  0012a	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00131	50		 push	 eax
  00132	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00139	50		 push	 eax
  0013a	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00141	50		 push	 eax
  00142	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00145	50		 push	 eax
  00146	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  0014d	50		 push	 eax
  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00159	83 c4 18	 add	 esp, 24			; 00000018H
$LN8@SummonMons:

; 1031 : 		}
; 1032 : 
; 1033 : 		LogAddTD("[Doppelganger] SummonMonster [%d](%s) Map: %d, X: %d, Y: %d",

  0015c	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00163	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00166	50		 push	 eax
  00167	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0016e	50		 push	 eax
  0016f	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00176	50		 push	 eax
  00177	51		 push	 ecx
  00178	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  0017f	51		 push	 ecx
  00180	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0018b	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@SummonMons:

; 1034 : 			lpObj->Class,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y);
; 1035 : 	}
; 1036 : return result;

  0018e	8b c7		 mov	 eax, edi
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx

; 1037 : }

  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 18 00	 ret	 24			; 00000018H
?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ENDP	; CDoubleGoerEvent::SummonMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SummonMonster@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
tv655 = -8						; size = 4
tv654 = -8						; size = 4
tv653 = -8						; size = 4
tv652 = -8						; size = 4
_this$1$ = -4						; size = 4
?SummonMonster@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SummonMonster, COMDAT
; _this$ = ecx

; 925  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi

; 926  : 	int result = -1;
; 927  : 
; 928  : 	if( !OBJMAX_RANGE(m_iLeaderIndex) )

  0000c	8b 8f 80 00 00
	00		 mov	 ecx, DWORD PTR [edi+128]
  00012	85 c9		 test	 ecx, ecx
  00014	0f 88 1c 02 00
	00		 js	 $LN6@SummonMons
  0001a	33 c0		 xor	 eax, eax
  0001c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00022	0f 9e c0	 setle	 al
  00025	85 c0		 test	 eax, eax
  00027	0f 84 09 02 00
	00		 je	 $LN6@SummonMons

; 929  : 	{
; 930  : 		return;
; 931  : 	}
; 932  : 
; 933  : 	LPOBJ lpObj = &gObj[m_iLeaderIndex];

  0002d	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048

; 934  : 	m_iPartyCount = 1;
; 935  : 
; 936  : 	int MaxLevel = 0;
; 937  : 	int MaxReset = 0;

  00033	33 c0		 xor	 eax, eax
  00035	53		 push	 ebx
  00036	56		 push	 esi
  00037	33 f6		 xor	 esi, esi
  00039	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	c7 87 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+132], 1

; 938  : 
; 939  : 	if( lpObj->PartyNumber >= 0 )

  00049	8b 91 0c 06 00
	00		 mov	 edx, DWORD PTR [ecx+1548]
  0004f	85 d2		 test	 edx, edx
  00051	0f 88 69 01 00
	00		 js	 $LN9@SummonMons

; 940  : 	{
; 941  : 		int PartyNum = lpObj->PartyNumber;
; 942  : 		m_iPartyCount = 0;
; 943  : 
; 944  : 		for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 945  : 		{
; 946  : 			int number = gParty.m_PartyS[PartyNum].Number[i];

  00057	8b da		 mov	 ebx, edx
  00059	89 87 84 00 00
	00		 mov	 DWORD PTR [edi+132], eax
  0005f	c1 e3 04	 shl	 ebx, 4
  00062	2b da		 sub	 ebx, edx
  00064	8b 0c 9d 0c 00
	00 00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[ebx*4+12]

; 947  : 
; 948  : 			if( number >= 0 )

  0006b	85 c9		 test	 ecx, ecx
  0006d	78 3e		 js	 SHORT $LN2@SummonMons

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  0006f	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007b	0f bf 84 0a 96
	00 00 00	 movsx	 eax, WORD PTR [edx+ecx+150]
  00083	89 45 f8	 mov	 DWORD PTR tv655[ebp], eax
  00086	85 c0		 test	 eax, eax
  00088	8b c6		 mov	 eax, esi
  0008a	7e 0b		 jle	 SHORT $LN12@SummonMons

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  0008c	0f bf b4 0a a8
	00 00 00	 movsx	 esi, WORD PTR [edx+ecx+168]
  00094	03 75 f8	 add	 esi, DWORD PTR tv655[ebp]
$LN12@SummonMons:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  00097	8b 8c 0a 20 27
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+10016]
  0009e	85 c9		 test	 ecx, ecx

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;
; 958  : 				}
; 959  : 				m_iPartyCount++;

  000a0	c7 87 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+132], 1
  000aa	0f 4f c1	 cmovg	 eax, ecx
$LN2@SummonMons:

; 947  : 
; 948  : 			if( number >= 0 )

  000ad	8b 0c 9d 10 00
	00 00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[ebx*4+16]
  000b4	85 c9		 test	 ecx, ecx
  000b6	78 3b		 js	 SHORT $LN31@SummonMons

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  000b8	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	0f bf bc 0a 96
	00 00 00	 movsx	 edi, WORD PTR [edx+ecx+150]
  000cc	89 7d f8	 mov	 DWORD PTR tv654[ebp], edi
  000cf	3b fe		 cmp	 edi, esi
  000d1	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  000d4	7e 0b		 jle	 SHORT $LN29@SummonMons

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  000d6	0f bf b4 0a a8
	00 00 00	 movsx	 esi, WORD PTR [edx+ecx+168]
  000de	03 75 f8	 add	 esi, DWORD PTR tv654[ebp]
$LN29@SummonMons:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  000e1	8b 8c 0a 20 27
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+10016]
  000e8	3b c8		 cmp	 ecx, eax
  000ea	0f 4f c1	 cmovg	 eax, ecx

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;
; 958  : 				}
; 959  : 				m_iPartyCount++;

  000ed	ff 87 84 00 00
	00		 inc	 DWORD PTR [edi+132]
$LN31@SummonMons:

; 947  : 
; 948  : 			if( number >= 0 )

  000f3	8b 0c 9d 14 00
	00 00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[ebx*4+20]
  000fa	85 c9		 test	 ecx, ecx
  000fc	78 3b		 js	 SHORT $LN35@SummonMons

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  000fe	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010a	0f bf bc 0a 96
	00 00 00	 movsx	 edi, WORD PTR [edx+ecx+150]
  00112	89 7d f8	 mov	 DWORD PTR tv653[ebp], edi
  00115	3b fe		 cmp	 edi, esi
  00117	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  0011a	7e 0b		 jle	 SHORT $LN33@SummonMons

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  0011c	0f bf b4 0a a8
	00 00 00	 movsx	 esi, WORD PTR [edx+ecx+168]
  00124	03 75 f8	 add	 esi, DWORD PTR tv653[ebp]
$LN33@SummonMons:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  00127	8b 8c 0a 20 27
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+10016]
  0012e	3b c8		 cmp	 ecx, eax
  00130	0f 4f c1	 cmovg	 eax, ecx

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;
; 958  : 				}
; 959  : 				m_iPartyCount++;

  00133	ff 87 84 00 00
	00		 inc	 DWORD PTR [edi+132]
$LN35@SummonMons:

; 947  : 
; 948  : 			if( number >= 0 )

  00139	8b 0c 9d 18 00
	00 00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[ebx*4+24]
  00140	85 c9		 test	 ecx, ecx
  00142	78 3b		 js	 SHORT $LN39@SummonMons

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  00144	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00150	0f bf bc 0a 96
	00 00 00	 movsx	 edi, WORD PTR [edx+ecx+150]
  00158	89 7d f8	 mov	 DWORD PTR tv652[ebp], edi
  0015b	3b fe		 cmp	 edi, esi
  0015d	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  00160	7e 0b		 jle	 SHORT $LN37@SummonMons

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  00162	0f bf b4 0a a8
	00 00 00	 movsx	 esi, WORD PTR [edx+ecx+168]
  0016a	03 75 f8	 add	 esi, DWORD PTR tv652[ebp]
$LN37@SummonMons:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  0016d	8b 8c 0a 20 27
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+10016]
  00174	3b c8		 cmp	 ecx, eax
  00176	0f 4f c1	 cmovg	 eax, ecx

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;
; 958  : 				}
; 959  : 				m_iPartyCount++;

  00179	ff 87 84 00 00
	00		 inc	 DWORD PTR [edi+132]
$LN39@SummonMons:

; 947  : 
; 948  : 			if( number >= 0 )

  0017f	8b 0c 9d 1c 00
	00 00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[ebx*4+28]
  00186	85 c9		 test	 ecx, ecx
  00188	78 4c		 js	 SHORT $LN10@SummonMons

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  0018a	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00196	0f bf 9c 0a 96
	00 00 00	 movsx	 ebx, WORD PTR [edx+ecx+150]
  0019e	3b de		 cmp	 ebx, esi
  001a0	7e 0a		 jle	 SHORT $LN41@SummonMons

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  001a2	0f bf b4 0a a8
	00 00 00	 movsx	 esi, WORD PTR [edx+ecx+168]
  001aa	03 f3		 add	 esi, ebx
$LN41@SummonMons:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  001ac	8b 8c 0a 20 27
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+10016]
  001b3	3b c8		 cmp	 ecx, eax
  001b5	0f 4f c1	 cmovg	 eax, ecx

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;
; 958  : 				}
; 959  : 				m_iPartyCount++;

  001b8	ff 87 84 00 00
	00		 inc	 DWORD PTR [edi+132]

; 960  : 			}
; 961  : 		}
; 962  : 	}
; 963  : 	else

  001be	eb 16		 jmp	 SHORT $LN10@SummonMons
$LN9@SummonMons:

; 964  : 	{
; 965  : 		MaxLevel = lpObj->Level + lpObj->MasterLevel;

  001c0	0f bf 81 96 00
	00 00		 movsx	 eax, WORD PTR [ecx+150]
  001c7	0f bf b1 a8 00
	00 00		 movsx	 esi, WORD PTR [ecx+168]
  001ce	03 f0		 add	 esi, eax

; 966  : 		MaxReset = lpObj->iResetCount;

  001d0	8b 81 20 27 00
	00		 mov	 eax, DWORD PTR [ecx+10016]
$LN10@SummonMons:

; 967  : 	}
; 968  : 
; 969  : 	m_EventLevel = MaxLevel;
; 970  : 	m_EventReset = MaxReset;

  001d6	89 87 58 02 00
	00		 mov	 DWORD PTR [edi+600], eax

; 971  : 
; 972  : 	int mapIndex = m_iCurentMap-MAP_INDEX_DOUBLEGOER1;
; 973  : 
; 974  : 	for(int i = 0; i < m_iMONSTER_COUNT; i++)

  001dc	33 db		 xor	 ebx, ebx
  001de	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  001e1	83 e8 41	 sub	 eax, 65			; 00000041H
  001e4	89 b7 5c 02 00
	00		 mov	 DWORD PTR [edi+604], esi
  001ea	39 5f 1c	 cmp	 DWORD PTR [edi+28], ebx
  001ed	7e 45		 jle	 SHORT $LN45@SummonMons
  001ef	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
$LL7@SummonMons:

; 975  : 	{
; 976  : 
; 977  : 		int sx = g_DoubleGoerEvent_DefPts[mapIndex].ptX;
; 978  : 		int sy = g_DoubleGoerEvent_DefPts[mapIndex].ptY;
; 979  : 
; 980  : 		SummonMonster(533+rand()%7,m_iCurentMap,sx,sy,m_EventLevel, m_EventReset);

  001f2	ff b7 58 02 00
	00		 push	 DWORD PTR [edi+600]
  001f8	0f b6 04 b5 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi*4+3]
  00200	ff b7 5c 02 00
	00		 push	 DWORD PTR [edi+604]
  00206	0f b6 0c b5 02
	00 00 00	 movzx	 ecx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi*4+2]
  0020e	50		 push	 eax
  0020f	51		 push	 ecx
  00210	ff 77 30	 push	 DWORD PTR [edi+48]
  00213	e8 00 00 00 00	 call	 _rand
  00218	99		 cdq
  00219	b9 07 00 00 00	 mov	 ecx, 7
  0021e	f7 f9		 idiv	 ecx
  00220	8b cf		 mov	 ecx, edi
  00222	81 c2 15 02 00
	00		 add	 edx, 533		; 00000215H
  00228	52		 push	 edx
  00229	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
  0022e	43		 inc	 ebx
  0022f	3b 5f 1c	 cmp	 ebx, DWORD PTR [edi+28]
  00232	7c be		 jl	 SHORT $LL7@SummonMons
$LN45@SummonMons:
  00234	5e		 pop	 esi
  00235	5b		 pop	 ebx
$LN6@SummonMons:
  00236	5f		 pop	 edi

; 981  : 	}
; 982  : }

  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	c3		 ret	 0
?SummonMonster@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SummonMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
_size$ = 12						; size = 4
?SendData@CDoubleGoerEvent@@QAEXPAEH@Z PROC		; CDoubleGoerEvent::SendData, COMDAT
; _this$ = ecx

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 773  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d b1 88 00 00
	00		 lea	 esi, DWORD PTR [ecx+136]
  0000f	bf 05 00 00 00	 mov	 edi, 5
$LL4@SendData:

; 774  : 	{
; 775  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]

; 776  : 		if(  OBJMAX_RANGE(aIndex) )

  00016	85 c0		 test	 eax, eax
  00018	78 1b		 js	 SHORT $LN2@SendData
  0001a	33 c9		 xor	 ecx, ecx
  0001c	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00021	0f 9e c1	 setle	 cl
  00024	85 c9		 test	 ecx, ecx
  00026	74 0d		 je	 SHORT $LN2@SendData

; 777  : 		{
; 778  : 			DataSend(aIndex,pMsg,size);

  00028	53		 push	 ebx
  00029	ff 75 08	 push	 DWORD PTR _pMsg$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendData:

; 773  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00035	83 c6 08	 add	 esi, 8
  00038	83 ef 01	 sub	 edi, 1
  0003b	75 d7		 jne	 SHORT $LL4@SendData
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx

; 779  : 		}
; 780  : 	}
; 781  : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ENDP		; CDoubleGoerEvent::SendData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_MapIndex$ = 12						; size = 4
_bType$ = 16						; size = 4
?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z PROC		; CDoubleGoerEvent::SendBlockInfo, COMDAT
; _this$ = ecx

; 1346 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 1347 : 	if( MapIndex < 0 || MapIndex >= 4 )

  00014	8b 75 0c	 mov	 esi, DWORD PTR _MapIndex$[ebp]
  00017	83 fe 03	 cmp	 esi, 3
  0001a	0f 87 8e 00 00
	00		 ja	 $LN3@SendBlockI

; 1348 : 		return;
; 1349 : 
; 1350 : 	char cTEMP_BUF[256] = {0};
; 1351 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 1352 : 
; 1353 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00020	68 00 01 00 00	 push	 256			; 00000100H
  00025	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0002b	6a 00		 push	 0
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _memset
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1354 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 1355 : 
; 1356 : 	lpMsg->btType = 0;
; 1357 : 	lpMsg->btCount = 1;
; 1358 : 	lpMsg->btMapAttr = 16;
; 1359 : 	lpMsg->btMapSetType=bType;

  00043	8a 45 10	 mov	 al, BYTE PTR _bType$[ebp]
  00046	88 85 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], al

; 1360 : 
; 1361 : 	lpMsgBody[0].btX = g_DoubleGoerEvent_BlockPts[MapIndex].stX;

  0004c	0f b6 04 b5 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4]
  00054	88 85 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], al

; 1362 : 	lpMsgBody[0].btY = g_DoubleGoerEvent_BlockPts[MapIndex].stY;

  0005a	0f b6 04 b5 01
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4+1]
  00062	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al

; 1363 : 	lpMsgBody[1].btX   = g_DoubleGoerEvent_BlockPts[MapIndex].ptX;

  00068	0f b6 04 b5 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4+2]
  00070	88 85 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], al

; 1364 : 	lpMsgBody[1].btY   = g_DoubleGoerEvent_BlockPts[MapIndex].ptY;

  00076	0f b6 04 b5 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4+3]
  0007e	88 85 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], al

; 1365 : 
; 1366 : 	DataSend(iIndex,(LPBYTE)lpMsg,lpMsg->h.size);

  00084	0f b6 85 fd fe
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+1]
  0008b	50		 push	 eax
  0008c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00092	66 c7 85 ff fe
	ff ff 00 10	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 4096 ; 00001000H
  0009b	50		 push	 eax
  0009c	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  0009f	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  000a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ab	83 c4 24	 add	 esp, 36			; 00000024H
$LN3@SendBlockI:

; 1367 : }

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b1	33 cd		 xor	 ecx, ebp
  000b3	5e		 pop	 esi
  000b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 0c 00	 ret	 12			; 0000000cH
?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z ENDP		; CDoubleGoerEvent::SendBlockInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iBossIndex$ = 8					; size = 4
?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z PROC		; CDoubleGoerEvent::SendBossInfo, COMDAT
; _this$ = ecx

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 848  : 	if( !OBJMAX_RANGE(iBossIndex) )

  00008	8b 7d 08	 mov	 edi, DWORD PTR _iBossIndex$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 95 00 00
	00		 js	 $LN1@SendBossIn
  00015	33 c0		 xor	 eax, eax
  00017	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001d	0f 9e c0	 setle	 al
  00020	85 c0		 test	 eax, eax
  00022	0f 84 82 00 00
	00		 je	 $LN1@SendBossIn

; 849  : 		return;
; 850  : 
; 851  : 	PMSG_DOUBLEGOER_BOSSINFO pMsg;
; 852  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,17,sizeof(pMsg));

  00028	56		 push	 esi
  00029	6a 06		 push	 6
  0002b	6a 11		 push	 17			; 00000011H
  0002d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00030	68 bf 00 00 00	 push	 191			; 000000bfH
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 853  : 
; 854  : 	if( !gObj[iBossIndex].Live )
; 855  : 		pMsg.btResult = 1;
; 856  : 
; 857  : 	pMsg.btResult = 0;
; 858  : 	pMsg.btPos = (BYTE)(CalcDistance(gObj[iBossIndex].X,gObj[iBossIndex].Y,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY)/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv);

  0003b	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00047	83 e8 41	 sub	 eax, 65			; 00000041H
  0004a	69 d7 40 27 00
	00		 imul	 edx, edi, 10048
  00050	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00054	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00057	0f b6 04 b5 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi*4+3]
  0005f	50		 push	 eax
  00060	0f b6 04 b5 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi*4+2]
  00068	50		 push	 eax
  00069	0f b6 84 0a 21
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+289]
  00071	50		 push	 eax
  00072	0f b6 84 0a 20
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+288]
  0007a	8b cb		 mov	 ecx, ebx
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::CalcDistance

; 859  : 
; 860  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  00082	8b cb		 mov	 ecx, ebx
  00084	66 0f 6e c0	 movd	 xmm0, eax
  00088	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0008b	f3 0f 5e 04 b5
	04 00 00 00	 divss	 xmm0, DWORD PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi*4+4]
  00094	f3 0f 2c c0	 cvttss2si eax, xmm0
  00098	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0009b	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009f	50		 push	 eax
  000a0	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
  000a9	5e		 pop	 esi
$LN1@SendBossIn:
  000aa	5f		 pop	 edi
  000ab	5b		 pop	 ebx

; 861  : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z ENDP		; CDoubleGoerEvent::SendBossInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendPlayInfo, COMDAT
; _this$ = ecx

; 803  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 804  : 	PMSG_DOUBLEGOER_PLAYINFO pMsg;
; 805  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,18,sizeof(pMsg));

  00013	6a 1c		 push	 28			; 0000001cH
  00015	6a 12		 push	 18			; 00000012H
  00017	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	8b f9		 mov	 edi, ecx
  0001c	68 bf 00 00 00	 push	 191			; 000000bfH
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 806  : 
; 807  : 	pMsg.EventTime = m_iREMAIN_TIME/1000;

  00027	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	f7 6f 28	 imul	 DWORD PTR [edi+40]
  00032	be 05 00 00 00	 mov	 esi, 5
  00037	c1 fa 06	 sar	 edx, 6
  0003a	8b c2		 mov	 eax, edx
  0003c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003f	03 c2		 add	 eax, edx

; 808  : 	pMsg.btCount = 0;

  00041	32 db		 xor	 bl, bl
  00043	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+4], ax
  00047	8d 97 8c 00 00
	00		 lea	 edx, DWORD PTR [edi+140]
  0004d	88 5d e6	 mov	 BYTE PTR _pMsg$[ebp+6], bl
$LL4@SendPlayIn:

; 811  : 	{
; 812  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00050	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]

; 813  : 
; 814  : 		if( OBJMAX_RANGE(aIndex) )

  00053	85 c9		 test	 ecx, ecx
  00055	78 44		 js	 SHORT $LN2@SendPlayIn
  00057	33 c0		 xor	 eax, eax
  00059	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0005f	0f 9e c0	 setle	 al
  00062	85 c0		 test	 eax, eax
  00064	74 35		 je	 SHORT $LN2@SendPlayIn

; 815  : 		{
; 816  : 			pMsg.m_Info[pMsg.btCount].aIndex = aIndex;

  00066	66 0f 6e 02	 movd	 xmm0, DWORD PTR [edx]
  0006a	0f b6 c3	 movzx	 eax, bl

; 817  : 			pMsg.m_Info[pMsg.btCount].Pos = (BYTE)(m_PlayerInfo[i].Dist/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv);

  0006d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00070	66 89 4c 85 e8	 mov	 WORD PTR _pMsg$[ebp+eax*4+8], cx
  00075	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00078	83 e8 41	 sub	 eax, 65			; 00000041H
  0007b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0007e	f3 0f 5e 04 85
	04 00 00 00	 divss	 xmm0, DWORD PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax*4+4]
  00087	0f b6 45 e6	 movzx	 eax, BYTE PTR _pMsg$[ebp+6]
  0008b	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0008f	88 4c 85 eb	 mov	 BYTE PTR _pMsg$[ebp+eax*4+11], cl

; 818  : 			pMsg.btCount++;

  00093	8a 5d e6	 mov	 bl, BYTE PTR _pMsg$[ebp+6]
  00096	fe c3		 inc	 bl
  00098	88 5d e6	 mov	 BYTE PTR _pMsg$[ebp+6], bl
$LN2@SendPlayIn:

; 809  : 
; 810  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  0009b	83 c2 08	 add	 edx, 8
  0009e	83 ee 01	 sub	 esi, 1
  000a1	75 ad		 jne	 SHORT $LL4@SendPlayIn

; 819  : 		}
; 820  : 	}
; 821  : 
; 822  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  000a3	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000a7	8b cf		 mov	 ecx, edi
  000a9	50		 push	 eax
  000aa	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData

; 823  : }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	33 cd		 xor	 ecx, ebp
  000ba	5b		 pop	 ebx
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendPlayInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendWaveInfo, COMDAT
; _this$ = ecx

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 838  : 	PMSG_DOUBLEGOER_WAVEINFO pMsg;
; 839  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,15,sizeof(pMsg));

  00007	6a 05		 push	 5
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	68 bf 00 00 00	 push	 191			; 000000bfH
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 840  : 
; 841  : 	pMsg.btDist = m_iWaveDist;

  0001b	8a 46 3c	 mov	 al, BYTE PTR [esi+60]
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
  00021	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 842  : 
; 843  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  00024	8b ce		 mov	 ecx, esi
  00026	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002a	50		 push	 eax
  0002b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
  00034	5e		 pop	 esi

; 844  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendWaveInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendMonsterCount, COMDAT
; _this$ = ecx

; 826  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 827  : 	PMSG_DOUBLEGOER_MONSTERSET pMsg;
; 828  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,20,sizeof(pMsg));

  00007	6a 06		 push	 6
  00009	6a 14		 push	 20			; 00000014H
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	68 bf 00 00 00	 push	 191			; 000000bfH
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 829  : 
; 830  : 	pMsg.btMaxMon = 3;
; 831  : 	pMsg.btCurMon = m_iMonsterPassed;

  0001b	8a 46 38	 mov	 al, BYTE PTR [esi+56]
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
  00021	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 832  : 
; 833  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  00024	8b ce		 mov	 ecx, esi
  00026	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002a	c6 45 fc 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3
  0002e	50		 push	 eax
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
  00038	5e		 pop	 esi

; 834  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendMonsterCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SendStart@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
?SendStart@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendStart, COMDAT
; _this$ = ecx

; 784  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 785  : 	m_bSEND_PLAY_START = TRUE;
; 786  : 	m_iREMAIN_TIME = m_iEVENT_TIME*60*1000;
; 787  : 
; 788  : 	PMSG_DOUBLEGOER_SET_START pMsg;
; 789  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,16,sizeof(pMsg));

  0000a	6a 05		 push	 5
  0000c	6a 10		 push	 16			; 00000010H
  0000e	69 46 14 60 ea
	00 00		 imul	 eax, DWORD PTR [esi+20], 60000
  00015	68 bf 00 00 00	 push	 191			; 000000bfH
  0001a	c7 46 54 01 00
	00 00		 mov	 DWORD PTR [esi+84], 1
  00021	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00024	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0002d	83 c4 10	 add	 esp, 16			; 00000010H

; 790  : 	pMsg.btResult = 2;

  00030	c6 45 fc 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  00034	81 c6 88 00 00
	00		 add	 esi, 136		; 00000088H
  0003a	bf 05 00 00 00	 mov	 edi, 5
  0003f	90		 npad	 1
$LL4@SendStart:

; 793  : 	{
; 794  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00040	8b 06		 mov	 eax, DWORD PTR [esi]

; 795  : 		if( OBJMAX_RANGE(aIndex) )

  00042	85 c0		 test	 eax, eax
  00044	78 20		 js	 SHORT $LN2@SendStart
  00046	33 c9		 xor	 ecx, ecx
  00048	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0004d	0f 9e c1	 setle	 cl
  00050	85 c9		 test	 ecx, ecx
  00052	74 12		 je	 SHORT $LN2@SendStart

; 796  : 		{
; 797  : 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00054	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00058	51		 push	 ecx
  00059	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005c	51		 push	 ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendStart:

; 791  : 
; 792  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00066	83 c6 08	 add	 esi, 8
  00069	83 ef 01	 sub	 edi, 1
  0006c	75 d2		 jne	 SHORT $LL4@SendStart
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 798  : 		}
; 799  : 	}
; 800  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?SendStart@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_pReward$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
_cDropX$1 = -4						; size = 1
_cDropY$2 = 8						; size = 1
_lpNpc$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z PROC ; CDoubleGoerEvent::GoldCompensationBox, COMDAT
; _this$ = ecx

; 1277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1278 : 	if( !lpNpc->Live )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpNpc$[ebp]
  0000a	8b c1		 mov	 eax, ecx
  0000c	89 45 f8	 mov	 DWORD PTR _this$1$[ebp], eax
  0000f	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  00013	0f 84 03 01 00
	00		 je	 $LN6@GoldCompen

; 1279 : 		return;
; 1280 : 
; 1281 : 	int i;
; 1282 : 
; 1283 : 	EventItemBag* pReward = GetRewardBox(1, lpObj);

  00019	53		 push	 ebx
  0001a	8b 5d 0c	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	6a 01		 push	 1
  00021	e8 00 00 00 00	 call	 ?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::GetRewardBox
  00026	89 45 f4	 mov	 DWORD PTR _pReward$1$[ebp], eax

; 1284 : 
; 1285 : 	if( pReward != NULL )

  00029	85 c0		 test	 eax, eax
  0002b	74 6c		 je	 SHORT $LN3@GoldCompen

; 1286 : 	{
; 1287 : 		for(i = 0; i < 10; i++)

  0002d	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL4@GoldCompen:

; 1288 : 		{
; 1289 : 			BYTE cDropX = lpNpc->X;

  00032	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00039	88 45 fc	 mov	 BYTE PTR _cDropX$1[ebp], al

; 1290 : 			BYTE cDropY = lpNpc->Y;

  0003c	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]

; 1291 : 
; 1292 : 			if ( !gObjGetRandomItemDropLocation(lpNpc->MapNumber, cDropX, cDropY, 3, 3, 10))

  00043	6a 0a		 push	 10			; 0000000aH
  00045	6a 03		 push	 3
  00047	88 45 08	 mov	 BYTE PTR _cDropY$2[ebp], al
  0004a	8d 45 08	 lea	 eax, DWORD PTR _cDropY$2[ebp]
  0004d	6a 03		 push	 3
  0004f	50		 push	 eax
  00050	8d 45 fc	 lea	 eax, DWORD PTR _cDropX$1[ebp]
  00053	50		 push	 eax
  00054	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  00061	83 c4 18	 add	 esp, 24			; 00000018H
  00064	85 c0		 test	 eax, eax
  00066	75 14		 jne	 SHORT $LN10@GoldCompen

; 1293 : 			{
; 1294 : 				cDropX = lpNpc->X;

  00068	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0006f	88 45 fc	 mov	 BYTE PTR _cDropX$1[ebp], al

; 1295 : 				cDropY = lpNpc->Y;

  00072	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00079	88 45 08	 mov	 BYTE PTR _cDropY$2[ebp], al
$LN10@GoldCompen:

; 1296 : 			}
; 1297 : 
; 1298 : 			pReward->Open(lpObj->m_Index,lpObj->MapNumber,cDropX,cDropY);

  0007c	ff 75 08	 push	 DWORD PTR _cDropY$2[ebp]
  0007f	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00086	ff 75 fc	 push	 DWORD PTR _cDropX$1[ebp]
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _pReward$1$[ebp]
  0008c	50		 push	 eax
  0008d	ff 33		 push	 DWORD PTR [ebx]
  0008f	e8 00 00 00 00	 call	 ?Open@EventItemBag@@QAE_NHHEE@Z ; EventItemBag::Open
  00094	83 ef 01	 sub	 edi, 1
  00097	75 99		 jne	 SHORT $LL4@GoldCompen
$LN3@GoldCompen:

; 1299 : 		}
; 1300 : 	}
; 1301 : 
; 1302 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00099	8b 7d f8	 mov	 edi, DWORD PTR _this$1$[ebp]
  0009c	bb 06 00 00 00	 mov	 ebx, 6
  000a1	81 c7 40 02 00
	00		 add	 edi, 576		; 00000240H
  000a7	ba 1e 02 00 00	 mov	 edx, 542		; 0000021eH
  000ac	0f 1f 40 00	 npad	 4
$LL7@GoldCompen:

; 1303 : 	{
; 1304 : 		int aIndex = m_BoxInfo[i];

  000b0	8b 37		 mov	 esi, DWORD PTR [edi]

; 1305 : 
; 1306 : 		if( OBJMAX_RANGE(aIndex) )

  000b2	85 f6		 test	 esi, esi
  000b4	78 5c		 js	 SHORT $LN5@GoldCompen
  000b6	33 c0		 xor	 eax, eax
  000b8	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000be	0f 9e c0	 setle	 al
  000c1	85 c0		 test	 eax, eax
  000c3	74 4d		 je	 SHORT $LN5@GoldCompen

; 1307 : 		{
; 1308 : 			if( gObj[aIndex].Class == 542 )

  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ca	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000d0	66 39 94 01 90
	00 00 00	 cmp	 WORD PTR [ecx+eax+144], dx
  000d8	75 38		 jne	 SHORT $LN5@GoldCompen

; 1309 : 			{
; 1310 : 				gObj[aIndex].Life = 0.0f;
; 1311 : 				gObjLifeCheck(&gObj[aIndex],lpObj,0,1,0,0,0,0);

  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	6a 00		 push	 0
  000e2	6a 01		 push	 1
  000e4	c7 84 01 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+216], 0
  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f4	6a 00		 push	 0
  000f6	ff 75 0c	 push	 DWORD PTR _lpObj$[ebp]
  000f9	03 c1		 add	 eax, ecx
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z ; gObjLifeCheck

; 1312 : 				DelBox(aIndex);

  00101	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00104	83 c4 20	 add	 esp, 32			; 00000020H
  00107	56		 push	 esi
  00108	e8 00 00 00 00	 call	 ?DelBox@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelBox
  0010d	ba 1e 02 00 00	 mov	 edx, 542		; 0000021eH
$LN5@GoldCompen:

; 1299 : 		}
; 1300 : 	}
; 1301 : 
; 1302 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00112	83 c7 04	 add	 edi, 4
  00115	83 eb 01	 sub	 ebx, 1
  00118	75 96		 jne	 SHORT $LL7@GoldCompen
  0011a	5f		 pop	 edi
  0011b	5b		 pop	 ebx
$LN6@GoldCompen:
  0011c	5e		 pop	 esi

; 1313 : 			}
; 1314 : 		}
; 1315 : 	}
; 1316 : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 08 00	 ret	 8
?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ENDP ; CDoubleGoerEvent::GoldCompensationBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_pReward$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
tv309 = -4						; size = 4
_cDropX$1 = -4						; size = 1
_bReward$1$ = 8						; size = 4
_cDropY$2 = 8						; size = 1
_lpNpc$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z PROC ; CDoubleGoerEvent::CompensationBox, COMDAT
; _this$ = ecx

; 1226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1227 : 	if( !lpNpc->Live )

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpNpc$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	89 5d f8	 mov	 DWORD PTR _this$1$[ebp], ebx
  00010	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  00014	0f 84 6c 01 00
	00		 je	 $LN6@Compensati

; 1228 : 		return;
; 1229 : 
; 1230 : 	int bReward = FALSE;
; 1231 : 
; 1232 : 	EventItemBag* pReward = GetRewardBox(0, lpObj);

  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001e	33 c0		 xor	 eax, eax
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	89 45 08	 mov	 DWORD PTR _bReward$1$[ebp], eax
  00025	e8 00 00 00 00	 call	 ?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::GetRewardBox
  0002a	89 45 f4	 mov	 DWORD PTR _pReward$1$[ebp], eax

; 1233 : 
; 1234 : 	if( pReward != NULL )

  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 8c 00 00
	00		 je	 $LN10@Compensati

; 1235 : 	{
; 1236 : 		if( rand()%3 == 0 )

  00035	e8 00 00 00 00	 call	 _rand
  0003a	99		 cdq
  0003b	b9 03 00 00 00	 mov	 ecx, 3
  00040	f7 f9		 idiv	 ecx
  00042	85 d2		 test	 edx, edx
  00044	75 7b		 jne	 SHORT $LN10@Compensati

; 1237 : 		{
; 1238 : 			for(int i = 0; i < 3; i++)

  00046	8b d9		 mov	 ebx, ecx
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@Compensati:

; 1239 : 			{
; 1240 : 				BYTE cDropX = lpNpc->X;

  00050	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00057	88 45 fc	 mov	 BYTE PTR _cDropX$1[ebp], al

; 1241 : 				BYTE cDropY = lpNpc->Y;

  0005a	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]

; 1242 : 
; 1243 : 				if ( !gObjGetRandomItemDropLocation(lpNpc->MapNumber, cDropX, cDropY, 3, 3, 10))

  00061	6a 0a		 push	 10			; 0000000aH
  00063	6a 03		 push	 3
  00065	88 45 08	 mov	 BYTE PTR _cDropY$2[ebp], al
  00068	8d 45 08	 lea	 eax, DWORD PTR _cDropY$2[ebp]
  0006b	6a 03		 push	 3
  0006d	50		 push	 eax
  0006e	8d 45 fc	 lea	 eax, DWORD PTR _cDropX$1[ebp]
  00071	50		 push	 eax
  00072	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	85 c0		 test	 eax, eax
  00084	75 14		 jne	 SHORT $LN11@Compensati

; 1244 : 				{
; 1245 : 					cDropX = lpNpc->X;

  00086	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0008d	88 45 fc	 mov	 BYTE PTR _cDropX$1[ebp], al

; 1246 : 					cDropY = lpNpc->Y;

  00090	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00097	88 45 08	 mov	 BYTE PTR _cDropY$2[ebp], al
$LN11@Compensati:

; 1247 : 				}
; 1248 : 
; 1249 : 				pReward->Open(lpObj->m_Index,lpObj->MapNumber,cDropX,cDropY);

  0009a	ff 75 08	 push	 DWORD PTR _cDropY$2[ebp]
  0009d	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  000a4	ff 75 fc	 push	 DWORD PTR _cDropX$1[ebp]
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _pReward$1$[ebp]
  000aa	50		 push	 eax
  000ab	ff 37		 push	 DWORD PTR [edi]
  000ad	e8 00 00 00 00	 call	 ?Open@EventItemBag@@QAE_NHHEE@Z ; EventItemBag::Open
  000b2	83 eb 01	 sub	 ebx, 1
  000b5	75 99		 jne	 SHORT $LL4@Compensati

; 1250 : 			}
; 1251 : 			bReward = TRUE;

  000b7	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000ba	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _bReward$1$[ebp], 1
$LN10@Compensati:

; 1252 : 		}
; 1253 : 	}
; 1254 : 
; 1255 : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  000c1	81 c3 40 02 00
	00		 add	 ebx, 576		; 00000240H
  000c7	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR tv309[ebp], 6
  000ce	b9 1d 02 00 00	 mov	 ecx, 541		; 0000021dH
$LL7@Compensati:

; 1256 : 	{
; 1257 : 		int aIndex = m_BoxInfo[i];

  000d3	8b 33		 mov	 esi, DWORD PTR [ebx]

; 1258 : 
; 1259 : 		if( OBJMAX_RANGE(aIndex) )

  000d5	85 f6		 test	 esi, esi
  000d7	0f 88 9b 00 00
	00		 js	 $LN5@Compensati
  000dd	33 c0		 xor	 eax, eax
  000df	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000e5	0f 9e c0	 setle	 al
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 88 00 00
	00		 je	 $LN5@Compensati

; 1260 : 		{
; 1261 : 			if( gObj[aIndex].Class == 541 )

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000fb	66 39 8c 07 90
	00 00 00	 cmp	 WORD PTR [edi+eax+144], cx
  00103	75 73		 jne	 SHORT $LN5@Compensati

; 1262 : 			{
; 1263 : 				gObj[aIndex].Life = 0.0f;
; 1264 : 				gObjLifeCheck(&gObj[aIndex],lpObj,0,1,0,0,0,0);

  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	6a 00		 push	 0
  0010d	6a 01		 push	 1
  0010f	c7 84 07 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+216], 0
  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	6a 00		 push	 0
  00121	ff 75 0c	 push	 DWORD PTR _lpObj$[ebp]
  00124	03 c7		 add	 eax, edi
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z ; gObjLifeCheck
  0012c	83 c4 20	 add	 esp, 32			; 00000020H

; 1265 : 				DelBox(aIndex);

  0012f	56		 push	 esi
  00130	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00133	8b ce		 mov	 ecx, esi
  00135	e8 00 00 00 00	 call	 ?DelBox@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelBox

; 1266 : 
; 1267 : 				if( bReward == FALSE )

  0013a	83 7d 08 00	 cmp	 DWORD PTR _bReward$1$[ebp], 0
  0013e	75 33		 jne	 SHORT $LN27@Compensati

; 1268 : 				{
; 1269 : 					SummonMonster(532,m_iCurentMap,gObj[aIndex].X,gObj[aIndex].Y,m_EventLevel, m_EventReset);

  00140	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  00146	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014c	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  00152	0f b6 84 0f 21
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+289]
  0015a	50		 push	 eax
  0015b	0f b6 84 0f 20
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+288]
  00163	8b ce		 mov	 ecx, esi
  00165	50		 push	 eax
  00166	ff 76 30	 push	 DWORD PTR [esi+48]
  00169	68 14 02 00 00	 push	 532			; 00000214H
  0016e	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
$LN27@Compensati:
  00173	b9 1d 02 00 00	 mov	 ecx, 541		; 0000021dH
$LN5@Compensati:

; 1252 : 		}
; 1253 : 	}
; 1254 : 
; 1255 : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00178	83 c3 04	 add	 ebx, 4
  0017b	83 6d fc 01	 sub	 DWORD PTR tv309[ebp], 1
  0017f	0f 85 4e ff ff
	ff		 jne	 $LL7@Compensati
  00185	5f		 pop	 edi
$LN6@Compensati:
  00186	5e		 pop	 esi
  00187	5b		 pop	 ebx

; 1270 : 				}
; 1271 : 			}
; 1272 : 		}
; 1273 : 	}
; 1274 : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c2 08 00	 ret	 8
?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ENDP ; CDoubleGoerEvent::CompensationBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_PLAYEND, COMDAT
; _this$ = ecx

; 631  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 632  : 	LogAddTD("[Doppelganger] SetState_PLAYEND()");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@
  0000c	8b f1		 mov	 esi, ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 633  : 	m_iREMAIN_TIME = m_iEVENT_PLAYEND*60*1000;

  00014	69 46 18 60 ea
	00 00		 imul	 eax, DWORD PTR [esi+24], 60000
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 634  : 	m_dwTICK_COUNT = GetTickCount();

  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 635  : 
; 636  : 	RemoveMonster();

  00027	8b ce		 mov	 ecx, esi
  00029	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002c	e8 00 00 00 00	 call	 ?RemoveMonster@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::RemoveMonster

; 637  : 
; 638  : 	PMSG_DOUBLEGOER_EVENTEND pMsg;
; 639  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,19,sizeof(pMsg));

  00031	6a 05		 push	 5
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00038	68 bf 00 00 00	 push	 191			; 000000bfH
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 640  : 
; 641  : 	if(  m_iMonsterPassed < 3 && m_iPlayerCount > 0  && m_iLeaderIndex != -1 )

  00043	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	83 f8 03	 cmp	 eax, 3
  0004c	0f 8d 9f 00 00
	00		 jge	 $LN2@SetState_P
  00052	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  00056	0f 8e 95 00 00
	00		 jle	 $LN2@SetState_P
  0005c	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  00063	0f 84 88 00 00
	00		 je	 $LN2@SetState_P

; 642  : 	{
; 643  : #ifdef POINTEX
; 644  : 		for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)
; 645  : 		{
; 646  : 			int aIndex = m_PlayerInfo[i].aIndex;
; 647  : 			if(  OBJMAX_RANGE(aIndex) )
; 648  : 			{
; 649  : 				g_ShopPointEx.AddEventBonus(aIndex, ShopPointExEvent::DG);
; 650  : 			}
; 651  : 		}
; 652  : #endif
; 653  : 		
; 654  : 
; 655  : 		SummonMonster(542,m_iCurentMap,gObj[m_iLeaderIndex].X+(-1+rand()%3),gObj[m_iLeaderIndex].Y+(-1+rand()%3),m_EventLevel, m_EventReset);

  00069	57		 push	 edi
  0006a	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  00070	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  00076	e8 00 00 00 00	 call	 _rand
  0007b	99		 cdq
  0007c	bf 03 00 00 00	 mov	 edi, 3
  00081	f7 ff		 idiv	 edi
  00083	69 8e 80 00 00
	00 40 27 00 00	 imul	 ecx, DWORD PTR [esi+128], 10048
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00092	0f b6 84 01 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+eax+289]
  0009a	48		 dec	 eax
  0009b	03 c2		 add	 eax, edx
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _rand
  000a3	99		 cdq
  000a4	f7 ff		 idiv	 edi
  000a6	69 8e 80 00 00
	00 40 27 00 00	 imul	 ecx, DWORD PTR [esi+128], 10048
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b5	0f b6 84 01 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+eax+288]
  000bd	8b ce		 mov	 ecx, esi
  000bf	48		 dec	 eax
  000c0	03 c2		 add	 eax, edx
  000c2	50		 push	 eax
  000c3	ff 76 30	 push	 DWORD PTR [esi+48]
  000c6	68 1e 02 00 00	 push	 542			; 0000021eH
  000cb	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 656  : 		pMsg.btResult = 0;
; 657  : 
; 658  : 		LogAddTD("[Doppelganger] Event - Success -> MonsterPassed: %d, PlayerCount: %d, LeaderIndex: %d",

  000d0	ff b6 80 00 00
	00		 push	 DWORD PTR [esi+128]
  000d6	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  000da	ff 76 34	 push	 DWORD PTR [esi+52]
  000dd	ff 76 38	 push	 DWORD PTR [esi+56]
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000eb	83 c4 10	 add	 esp, 16			; 00000010H
  000ee	5f		 pop	 edi

; 659  : 			m_iMonsterPassed,m_iPlayerCount,m_iLeaderIndex);
; 660  : 	}
; 661  : 	else

  000ef	eb 1c		 jmp	 SHORT $LN3@SetState_P
$LN2@SetState_P:

; 662  : 	{
; 663  : 		pMsg.btResult = 2;
; 664  : 		LogAddTD("[Doppelganger] Event - Fail -> MonsterPassed: %d, PlayerCount: %d, LeaderIndex: %d",

  000f1	ff b6 80 00 00
	00		 push	 DWORD PTR [esi+128]
  000f7	c6 45 fc 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  000fb	ff 76 34	 push	 DWORD PTR [esi+52]
  000fe	50		 push	 eax
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0010a	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@SetState_P:

; 665  : 			m_iMonsterPassed,m_iPlayerCount,m_iLeaderIndex);
; 666  : 	}
; 667  : 
; 668  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  0010d	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00111	8b ce		 mov	 ecx, esi
  00113	50		 push	 eax
  00114	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
  0011d	5e		 pop	 esi

; 669  : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_PLAYEND
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_PLAYING, COMDAT
; _this$ = ecx

; 624  : {

  00000	56		 push	 esi

; 625  : 	LogAddTD("[Doppelganger] SetState_PLAYING()");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 626  : 	m_iREMAIN_TIME = m_iEVENT_TIME*60*1000;

  0000e	69 46 14 60 ea
	00 00		 imul	 eax, DWORD PTR [esi+20], 60000
  00015	83 c4 04	 add	 esp, 4
  00018	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 627  : 	m_dwTICK_COUNT = GetTickCount();

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00021	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00024	5e		 pop	 esi

; 628  : }

  00025	c3		 ret	 0
?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_PLAYING
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_WAITING, COMDAT
; _this$ = ecx

; 615  : {

  00000	56		 push	 esi

; 616  : 	LogAddTD("[Doppelganger] SetState_WAITING()");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 617  : 	m_iREMAIN_TIME = m_iEVENT_WAIT*60*1000;

  0000e	69 46 10 60 ea
	00 00		 imul	 eax, DWORD PTR [esi+16], 60000
  00015	83 c4 04	 add	 esp, 4
  00018	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 618  : 	m_dwTICK_COUNT = GetTickCount();

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00021	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 619  : 
; 620  : 	m_iCurentMap = MAP_INDEX_DOUBLEGOER1 + rand()%DOUBLEGOER_MAXMAP;

  00024	e8 00 00 00 00	 call	 _rand
  00029	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0002e	79 05		 jns	 SHORT $LN3@SetState_W
  00030	48		 dec	 eax
  00031	83 c8 fc	 or	 eax, -4			; fffffffcH
  00034	40		 inc	 eax
$LN3@SetState_W:
  00035	83 c0 41	 add	 eax, 65			; 00000041H
  00038	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0003b	5e		 pop	 esi

; 621  : }

  0003c	c3		 ret	 0
?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_WAITING
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_CLOSED, COMDAT
; _this$ = ecx

; 601  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 602  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00005	bf 05 00 00 00	 mov	 edi, 5
  0000a	8d b3 88 00 00
	00		 lea	 esi, DWORD PTR [ebx+136]
$LL4@SetState_C:

; 603  : 	{
; 604  : 		if( m_PlayerInfo[i].aIndex != -1 )

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 0b		 je	 SHORT $LN2@SetState_C

; 605  : 		{
; 606  : 			gObjMoveGate(m_PlayerInfo[i].aIndex,17);

  00017	6a 11		 push	 17			; 00000011H
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0001f	83 c4 08	 add	 esp, 8
$LN2@SetState_C:

; 602  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00022	83 c6 08	 add	 esi, 8
  00025	83 ef 01	 sub	 edi, 1
  00028	75 e6		 jne	 SHORT $LL4@SetState_C

; 607  : 		}
; 608  : 	}
; 609  : 
; 610  : 	RemoveMonster();

  0002a	8b cb		 mov	 ecx, ebx
  0002c	e8 00 00 00 00	 call	 ?RemoveMonster@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::RemoveMonster
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 611  : 	Init();

  00033	8b cb		 mov	 ecx, ebx
  00035	5b		 pop	 ebx
  00036	e9 00 00 00 00	 jmp	 ?Init@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::Init
?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_CLOSED
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SetState@CDoubleGoerEvent@@QAEXH@Z
_TEXT	SEGMENT
_iState$ = 8						; size = 4
?SetState@CDoubleGoerEvent@@QAEXH@Z PROC		; CDoubleGoerEvent::SetState, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 579  : 	switch( iState )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iState$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff 03	 cmp	 edi, 3
  0000d	77 36		 ja	 SHORT $LN8@SetState
  0000f	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $LN11@SetState[edi*4]
$LN4@SetState:

; 580  : 	{
; 581  : 	case DOUBLEGOER_STATE_CLOSED:
; 582  : 		SetState_CLOSED();

  00016	e8 00 00 00 00	 call	 ?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_CLOSED

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  0001b	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 598  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN5@SetState:

; 583  : 		break;
; 584  : 	case DOUBLEGOER_STATE_WAITING:
; 585  : 		SetState_WAITING();

  00024	e8 00 00 00 00	 call	 ?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_WAITING

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  00029	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 598  : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN6@SetState:

; 586  : 		break;
; 587  : 	case DOUBLEGOER_STATE_PLAYING:
; 588  : 		SetState_PLAYING();

  00032	e8 00 00 00 00	 call	 ?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_PLAYING

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  00037	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 598  : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN7@SetState:

; 589  : 		break;
; 590  : 	case DOUBLEGOER_STATE_PLAYEND:
; 591  : 		SetState_PLAYEND();

  00040	e8 00 00 00 00	 call	 ?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_PLAYEND
$LN8@SetState:

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  00045	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi

; 598  : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
  0004e	66 90		 npad	 2
$LN11@SetState:
  00050	00 00 00 00	 DD	 $LN4@SetState
  00054	00 00 00 00	 DD	 $LN5@SetState
  00058	00 00 00 00	 DD	 $LN6@SetState
  0005c	00 00 00 00	 DD	 $LN7@SetState
?SetState@CDoubleGoerEvent@@QAEXH@Z ENDP		; CDoubleGoerEvent::SetState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$1 = -4						; size = 4
?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ PROC	; CDoubleGoerEvent::ProcState_PLAYEND, COMDAT
; _this$ = ecx

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 552  : 	DWORD dwTICK = GetTickCount() - m_dwTICK_COUNT;

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000e	8b f8		 mov	 edi, eax
  00010	2b 7e 2c	 sub	 edi, DWORD PTR [esi+44]

; 553  : 
; 554  : 	if( dwTICK >= 1000 )

  00013	81 ff e8 03 00
	00		 cmp	 edi, 1000		; 000003e8H
  00019	72 49		 jb	 SHORT $LN3@ProcState_

; 555  : 	{
; 556  : 		m_dwTICK_COUNT = GetTickCount();

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 557  : 		m_iREMAIN_TIME -= dwTICK;

  00021	29 7e 28	 sub	 DWORD PTR [esi+40], edi

; 558  : 
; 559  : 		if( m_bMSG_BEFORE_END == FALSE && m_iREMAIN_TIME <= 30000 )

  00024	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  00028	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002b	75 37		 jne	 SHORT $LN3@ProcState_
  0002d	81 7e 28 30 75
	00 00		 cmp	 DWORD PTR [esi+40], 30000 ; 00007530H
  00034	7f 2e		 jg	 SHORT $LN3@ProcState_

; 560  : 		{
; 561  : 			m_bMSG_BEFORE_END = TRUE;
; 562  : 
; 563  : 			PMSG_SET_DEVILSQUARE pMsg;
; 564  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00036	6a 04		 push	 4
  00038	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0003b	c7 46 50 01 00
	00 00		 mov	 DWORD PTR [esi+80], 1
  00042	68 92 00 00 00	 push	 146			; 00000092H
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 565  : 			pMsg.Type = 19;
; 566  : 
; 567  : 			SendData((LPBYTE)&pMsg,pMsg.h.size);

  0004d	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	8b ce		 mov	 ecx, esi
  00056	c6 45 ff 13	 mov	 BYTE PTR _pMsg$1[ebp+3], 19 ; 00000013H
  0005a	50		 push	 eax
  0005b	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
$LN3@ProcState_:

; 568  : 		}
; 569  : 	}
; 570  : 
; 571  : 	if( m_iREMAIN_TIME <= 0 )

  00064	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00068	7f 09		 jg	 SHORT $LN4@ProcState_

; 572  : 	{
; 573  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  0006a	6a 00		 push	 0
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN4@ProcState_:
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi

; 574  : 	}
; 575  : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ENDP	; CDoubleGoerEvent::ProcState_PLAYEND
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$1 = -4						; size = 4
?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ PROC	; CDoubleGoerEvent::ProcState_PLAYING, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 470  : 	DWORD dwTICK = GetTickCount() - m_dwTICK_COUNT;

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f1		 mov	 esi, ecx
  0000f	ff d3		 call	 ebx
  00011	8b f8		 mov	 edi, eax
  00013	2b 7e 2c	 sub	 edi, DWORD PTR [esi+44]

; 471  : 
; 472  : 	if( dwTICK >= 500 )

  00016	81 ff f4 01 00
	00		 cmp	 edi, 500		; 000001f4H
  0001c	0f 82 3c 02 00
	00		 jb	 $LN18@ProcState_

; 473  : 	{
; 474  : 		m_dwTICK_COUNT = GetTickCount();

  00022	ff d3		 call	 ebx

; 475  : 		m_iREMAIN_TIME -= dwTICK;

  00024	29 7e 28	 sub	 DWORD PTR [esi+40], edi

; 476  : 
; 477  : 		if( m_bSEND_PLAY_START == FALSE )

  00027	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  0002b	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002e	75 5e		 jne	 SHORT $LN3@ProcState_

; 478  : 		{
; 479  : 			m_iREMAIN_TIME = m_iEVENT_TIME*60*1000;

  00030	69 46 14 60 ea
	00 00		 imul	 eax, DWORD PTR [esi+20], 60000

; 480  : 
; 481  : 			SummonMonster();

  00037	8b ce		 mov	 ecx, esi
  00039	89 46 28	 mov	 DWORD PTR [esi+40], eax
  0003c	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SummonMonster

; 482  : 			SendStart();

  00041	8b ce		 mov	 ecx, esi
  00043	e8 00 00 00 00	 call	 ?SendStart@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendStart

; 483  : 			SendMonsterCount();

  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendMonsterCount
  0004f	8d be 88 00 00
	00		 lea	 edi, DWORD PTR [esi+136]
  00055	bb 05 00 00 00	 mov	 ebx, 5
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@ProcState_:

; 486  : 			{
; 487  : 				if( OBJMAX_RANGE(m_PlayerInfo[i].aIndex) )

  00060	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00062	85 c9		 test	 ecx, ecx
  00064	78 20		 js	 SHORT $LN2@ProcState_
  00066	33 c0		 xor	 eax, eax
  00068	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0006e	0f 9e c0	 setle	 al
  00071	85 c0		 test	 eax, eax
  00073	74 11		 je	 SHORT $LN2@ProcState_

; 488  : 				{
; 489  : 					SendBlockInfo(m_PlayerInfo[i].aIndex,m_iCurentMap - MAP_INDEX_DOUBLEGOER1,1);

  00075	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00078	6a 01		 push	 1
  0007a	83 e8 41	 sub	 eax, 65			; 00000041H
  0007d	50		 push	 eax
  0007e	51		 push	 ecx
  0007f	8b ce		 mov	 ecx, esi
  00081	e8 00 00 00 00	 call	 ?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z ; CDoubleGoerEvent::SendBlockInfo
$LN2@ProcState_:

; 484  : 
; 485  : 			for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00086	83 c7 08	 add	 edi, 8
  00089	83 eb 01	 sub	 ebx, 1
  0008c	75 d2		 jne	 SHORT $LL4@ProcState_
$LN3@ProcState_:

; 490  : 				}
; 491  : 			}
; 492  : 		}
; 493  : 
; 494  : 		if( m_bSEND_PLAY_START == TRUE )

  0008e	83 7e 54 01	 cmp	 DWORD PTR [esi+84], 1
  00092	0f 85 c6 01 00
	00		 jne	 $LN18@ProcState_

; 495  : 		{
; 496  : 			CalcDistance();

  00098	8b ce		 mov	 ecx, esi
  0009a	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::CalcDistance

; 497  : 			SendPlayInfo();

  0009f	8b ce		 mov	 ecx, esi
  000a1	e8 00 00 00 00	 call	 ?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendPlayInfo

; 498  : 			SendWaveInfo();

  000a6	8b ce		 mov	 ecx, esi
  000a8	e8 00 00 00 00	 call	 ?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendWaveInfo

; 499  : 			SendBossInfo(m_iBossIndex);

  000ad	ff 76 64	 push	 DWORD PTR [esi+100]
  000b0	8b ce		 mov	 ecx, esi
  000b2	e8 00 00 00 00	 call	 ?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SendBossInfo

; 500  : 
; 501  : 			if( m_bSUMMON_1ST_BOSS == FALSE && m_iREMAIN_TIME <= ((m_iEVENT_TIME*60*1000)-60000) )

  000b7	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000bb	75 4e		 jne	 SHORT $LN12@ProcState_
  000bd	69 46 14 60 ea
	00 00		 imul	 eax, DWORD PTR [esi+20], 60000
  000c4	2d 60 ea 00 00	 sub	 eax, 60000		; 0000ea60H
  000c9	39 46 28	 cmp	 DWORD PTR [esi+40], eax
  000cc	7f 3d		 jg	 SHORT $LN12@ProcState_

; 502  : 			{
; 503  : 				SummonMonster(529,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  000ce	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  000d1	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  000d7	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  000dd	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  000e0	0f b6 04 8d f7
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-777]
  000e8	50		 push	 eax
  000e9	0f b6 04 8d f6
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-778]
  000f1	8b ce		 mov	 ecx, esi
  000f3	50		 push	 eax
  000f4	52		 push	 edx
  000f5	68 11 02 00 00	 push	 529			; 00000211H
  000fa	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 504  : 				m_bSUMMON_1ST_BOSS = TRUE;

  000ff	c7 46 58 01 00
	00 00		 mov	 DWORD PTR [esi+88], 1
  00106	e9 a3 00 00 00	 jmp	 $LN16@ProcState_
$LN12@ProcState_:

; 505  : 			}
; 506  : 			else if( m_bSUMMON_2ND_BOSS == FALSE && m_iREMAIN_TIME <= ((m_iEVENT_TIME*60*1000)-3*60000) )

  0010b	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  0010f	75 4b		 jne	 SHORT $LN14@ProcState_
  00111	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00114	83 e8 03	 sub	 eax, 3
  00117	69 c0 60 ea 00
	00		 imul	 eax, eax, 60000
  0011d	39 46 28	 cmp	 DWORD PTR [esi+40], eax
  00120	7f 3a		 jg	 SHORT $LN14@ProcState_

; 507  : 			{
; 508  : 				SummonMonster(530,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  00122	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00125	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  0012b	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  00131	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00134	0f b6 04 8d f7
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-777]
  0013c	50		 push	 eax
  0013d	0f b6 04 8d f6
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-778]
  00145	8b ce		 mov	 ecx, esi
  00147	50		 push	 eax
  00148	52		 push	 edx
  00149	68 12 02 00 00	 push	 530			; 00000212H
  0014e	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 509  : 				m_bSUMMON_2ND_BOSS = TRUE;

  00153	c7 46 5c 01 00
	00 00		 mov	 DWORD PTR [esi+92], 1
  0015a	eb 52		 jmp	 SHORT $LN16@ProcState_
$LN14@ProcState_:

; 510  : 			}
; 511  : 			else if( m_bSUMMON_3RD_BOSS == FALSE && m_iREMAIN_TIME <= ((m_iEVENT_TIME*60*1000)-6*60000) )

  0015c	83 7e 60 00	 cmp	 DWORD PTR [esi+96], 0
  00160	75 4c		 jne	 SHORT $LN16@ProcState_
  00162	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00165	83 e8 06	 sub	 eax, 6
  00168	69 c0 60 ea 00
	00		 imul	 eax, eax, 60000
  0016e	39 46 28	 cmp	 DWORD PTR [esi+40], eax
  00171	7f 3b		 jg	 SHORT $LN16@ProcState_

; 512  : 			{
; 513  : 				m_iBossIndex = SummonMonster(531,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  00173	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00176	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  0017c	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  00182	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00185	0f b6 04 8d f7
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-777]
  0018d	50		 push	 eax
  0018e	0f b6 04 8d f6
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-778]
  00196	8b ce		 mov	 ecx, esi
  00198	50		 push	 eax
  00199	52		 push	 edx
  0019a	68 13 02 00 00	 push	 531			; 00000213H
  0019f	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
  001a4	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 514  : 				m_bSUMMON_3RD_BOSS = TRUE;

  001a7	c7 46 60 01 00
	00 00		 mov	 DWORD PTR [esi+96], 1
$LN16@ProcState_:

; 515  : 			}
; 516  : 
; 517  : 			if( m_iMONSTER_MINUTE_SPAWN != (m_iREMAIN_TIME/60000) )

  001ae	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  001b3	f7 6e 28	 imul	 DWORD PTR [esi+40]
  001b6	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  001b9	8b c2		 mov	 eax, edx
  001bb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001be	03 c2		 add	 eax, edx
  001c0	39 46 40	 cmp	 DWORD PTR [esi+64], eax
  001c3	74 5c		 je	 SHORT $LN6@ProcState_

; 518  : 			{
; 519  : 				m_iMONSTER_MINUTE_SPAWN = (m_iREMAIN_TIME/60000);
; 520  : 
; 521  : 				for(int i = 0; i < m_iMONSTER_PER_MINUTE; i++)

  001c5	33 ff		 xor	 edi, edi
  001c7	89 46 40	 mov	 DWORD PTR [esi+64], eax
  001ca	39 7e 20	 cmp	 DWORD PTR [esi+32], edi
  001cd	7e 52		 jle	 SHORT $LN6@ProcState_
  001cf	8d 5f 07	 lea	 ebx, DWORD PTR [edi+7]
  001d2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL7@ProcState_:

; 522  : 				{
; 523  : 					SummonMonster(533+rand()%7,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  001e0	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  001e3	ff b6 58 02 00
	00		 push	 DWORD PTR [esi+600]
  001e9	ff b6 5c 02 00
	00		 push	 DWORD PTR [esi+604]
  001ef	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  001f2	0f b6 04 8d f7
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-777]
  001fa	50		 push	 eax
  001fb	0f b6 04 8d f6
	fc ff ff	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4-778]
  00203	50		 push	 eax
  00204	52		 push	 edx
  00205	e8 00 00 00 00	 call	 _rand
  0020a	99		 cdq
  0020b	8b ce		 mov	 ecx, esi
  0020d	f7 fb		 idiv	 ebx
  0020f	81 c2 15 02 00
	00		 add	 edx, 533		; 00000215H
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
  0021b	47		 inc	 edi
  0021c	3b 7e 20	 cmp	 edi, DWORD PTR [esi+32]
  0021f	7c bf		 jl	 SHORT $LL7@ProcState_
$LN6@ProcState_:

; 524  : 				}
; 525  : 			}
; 526  : 
; 527  : 			if( m_bMSG_BEFORE_TIMEOUT == FALSE && m_iREMAIN_TIME <= 30000 )

  00221	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00225	75 37		 jne	 SHORT $LN18@ProcState_
  00227	81 7e 28 30 75
	00 00		 cmp	 DWORD PTR [esi+40], 30000 ; 00007530H
  0022e	7f 2e		 jg	 SHORT $LN18@ProcState_

; 528  : 			{
; 529  : 				m_bMSG_BEFORE_TIMEOUT = TRUE;
; 530  : 
; 531  : 				PMSG_SET_DEVILSQUARE pMsg;
; 532  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00230	6a 04		 push	 4
  00232	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00235	c7 46 4c 01 00
	00 00		 mov	 DWORD PTR [esi+76], 1
  0023c	68 92 00 00 00	 push	 146			; 00000092H
  00241	50		 push	 eax
  00242	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 533  : 				pMsg.Type = 18;
; 534  : 
; 535  : 				SendData((LPBYTE)&pMsg,pMsg.h.size);

  00247	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  0024b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024e	8b ce		 mov	 ecx, esi
  00250	c6 45 ff 12	 mov	 BYTE PTR _pMsg$1[ebp+3], 18 ; 00000012H
  00254	50		 push	 eax
  00255	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
$LN18@ProcState_:

; 536  : 			}
; 537  : 		}
; 538  : 	}
; 539  : 
; 540  : 	if( m_iREMAIN_TIME <= 0 || m_iMonsterPassed >= 3 )

  0025e	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00262	7e 25		 jle	 SHORT $LN21@ProcState_
  00264	83 7e 38 03	 cmp	 DWORD PTR [esi+56], 3
  00268	7d 1f		 jge	 SHORT $LN21@ProcState_

; 543  : 	}
; 544  : 	else if( m_iPlayerCount <= 0 || m_iLeaderIndex == -1 )

  0026a	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0026e	7e 09		 jle	 SHORT $LN23@ProcState_
  00270	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  00277	75 19		 jne	 SHORT $LN22@ProcState_
$LN23@ProcState_:

; 545  : 	{
; 546  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  00279	6a 00		 push	 0
  0027b	8b ce		 mov	 ecx, esi
  0027d	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
  00282	5f		 pop	 edi
  00283	5e		 pop	 esi
  00284	5b		 pop	 ebx

; 547  : 	}
; 548  : }

  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c3		 ret	 0
$LN21@ProcState_:

; 541  : 	{
; 542  : 		SetState(DOUBLEGOER_STATE_PLAYEND);

  00289	6a 03		 push	 3
  0028b	8b ce		 mov	 ecx, esi
  0028d	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN22@ProcState_:
  00292	5f		 pop	 edi
  00293	5e		 pop	 esi
  00294	5b		 pop	 ebx

; 547  : 	}
; 548  : }

  00295	8b e5		 mov	 esp, ebp
  00297	5d		 pop	 ebp
  00298	c3		 ret	 0
?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ ENDP	; CDoubleGoerEvent::ProcState_PLAYING
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$1 = -4						; size = 4
?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ PROC	; CDoubleGoerEvent::ProcState_WAITING, COMDAT
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 439  : 	DWORD dwTICK = GetTickCount() - m_dwTICK_COUNT;

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000e	8b f8		 mov	 edi, eax
  00010	2b 7e 2c	 sub	 edi, DWORD PTR [esi+44]

; 440  : 
; 441  : 	if( dwTICK >= 500 )

  00013	81 ff f4 01 00
	00		 cmp	 edi, 500		; 000001f4H
  00019	72 49		 jb	 SHORT $LN3@ProcState_

; 442  : 	{
; 443  : 		m_dwTICK_COUNT = GetTickCount();

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 444  : 		m_iREMAIN_TIME -= dwTICK;

  00021	29 7e 28	 sub	 DWORD PTR [esi+40], edi

; 445  : 
; 446  : 		if( m_bMSG_BEFORE_START == 0 && m_iREMAIN_TIME <= 30000 )

  00024	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00028	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002b	75 37		 jne	 SHORT $LN3@ProcState_
  0002d	81 7e 28 30 75
	00 00		 cmp	 DWORD PTR [esi+40], 30000 ; 00007530H
  00034	7f 2e		 jg	 SHORT $LN3@ProcState_

; 447  : 		{
; 448  : 			m_bMSG_BEFORE_START = TRUE;
; 449  : 
; 450  : 			PMSG_SET_DEVILSQUARE pMsg;
; 451  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00036	6a 04		 push	 4
  00038	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0003b	c7 46 44 01 00
	00 00		 mov	 DWORD PTR [esi+68], 1
  00042	68 92 00 00 00	 push	 146			; 00000092H
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 452  : 			pMsg.Type = 17;
; 453  : 
; 454  : 			SendData((LPBYTE)&pMsg,pMsg.h.size);

  0004d	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	8b ce		 mov	 ecx, esi
  00056	c6 45 ff 11	 mov	 BYTE PTR _pMsg$1[ebp+3], 17 ; 00000011H
  0005a	50		 push	 eax
  0005b	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
$LN3@ProcState_:

; 455  : 		}
; 456  : 	}
; 457  : 
; 458  : 	if( m_iREMAIN_TIME <= 0 )

  00064	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00068	7f 0f		 jg	 SHORT $LN4@ProcState_

; 459  : 	{
; 460  : 		SetState(DOUBLEGOER_STATE_PLAYING);

  0006a	6a 02		 push	 2

; 463  : 	{
; 464  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi

; 465  : 	}
; 466  : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN4@ProcState_:

; 461  : 	}
; 462  : 	else if( m_iPlayerCount <= 0 || m_iLeaderIndex == -1 )

  00079	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0007d	7e 09		 jle	 SHORT $LN7@ProcState_
  0007f	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  00086	75 09		 jne	 SHORT $LN6@ProcState_
$LN7@ProcState_:

; 463  : 	{
; 464  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  00088	6a 00		 push	 0
  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN6@ProcState_:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi

; 465  : 	}
; 466  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ ENDP	; CDoubleGoerEvent::ProcState_WAITING
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?Run@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?Run@CDoubleGoerEvent@@QAEXXZ PROC			; CDoubleGoerEvent::Run, COMDAT
; _this$ = ecx

; 413  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 414  : 	if( bEnabled == FALSE || bLoaded == FALSE || m_iState == DOUBLEGOER_STATE_CLOSED )

  00003	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00007	74 3b		 je	 SHORT $LN5@Run
  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0000d	74 35		 je	 SHORT $LN5@Run
  0000f	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00013	74 2f		 je	 SHORT $LN5@Run

; 415  : 	{
; 416  : 		return;
; 417  : 	}
; 418  : 
; 419  : 	CheckUser();

  00015	e8 00 00 00 00	 call	 ?CheckUser@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::CheckUser

; 420  : 
; 421  : 	switch( m_iState )

  0001a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0001d	83 e8 01	 sub	 eax, 1
  00020	74 1a		 je	 SHORT $LN6@Run
  00022	83 e8 01	 sub	 eax, 1
  00025	74 0d		 je	 SHORT $LN7@Run
  00027	83 e8 01	 sub	 eax, 1
  0002a	75 18		 jne	 SHORT $LN5@Run

; 428  : 		break;
; 429  : 	case DOUBLEGOER_STATE_PLAYEND:
; 430  : 		ProcState_PLAYEND();

  0002c	8b ce		 mov	 ecx, esi
  0002e	5e		 pop	 esi
  0002f	e9 00 00 00 00	 jmp	 ?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::ProcState_PLAYEND
$LN7@Run:

; 425  : 		break;
; 426  : 	case DOUBLEGOER_STATE_PLAYING:
; 427  : 		ProcState_PLAYING();

  00034	8b ce		 mov	 ecx, esi
  00036	5e		 pop	 esi
  00037	e9 00 00 00 00	 jmp	 ?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::ProcState_PLAYING
$LN6@Run:

; 422  : 	{
; 423  : 	case DOUBLEGOER_STATE_WAITING:
; 424  : 		ProcState_WAITING();

  0003c	8b ce		 mov	 ecx, esi
  0003e	5e		 pop	 esi
  0003f	e9 00 00 00 00	 jmp	 ?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::ProcState_WAITING
$LN5@Run:
  00044	5e		 pop	 esi

; 431  : 		break;
; 432  : 	default:
; 433  : 		break;
; 434  : 	}
; 435  : }

  00045	c3		 ret	 0
?Run@CDoubleGoerEvent@@QAEXXZ ENDP			; CDoubleGoerEvent::Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 5
tv352 = -8						; size = 4
_invPos$1$ = -4						; size = 4
tv348 = 8						; size = 4
_lpMsg$ = 8						; size = 4
tv347 = 12						; size = 4
_aIndex$ = 12						; size = 4
?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z PROC ; CDoubleGoerEvent::EnterRequest, COMDAT
; _this$ = ecx

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 266  : 	PMSG_DOUBLEGOER_ANS_ENTER pMsg;
; 267  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,14,sizeof(pMsg));

  00009	6a 05		 push	 5
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	8b d9		 mov	 ebx, ecx
  00012	68 bf 00 00 00	 push	 191			; 000000bfH
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 268  : 	pMsg.btResult = 1;
; 269  : 
; 270  : 	LPOBJ lpObj = &gObj[aIndex];

  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  0002f	03 f1		 add	 esi, ecx
  00031	c6 45 f4 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 271  : 
; 272  : 	if( lpObj->m_IfState.use == 0 || lpObj->m_IfState.type != 21 )

  00035	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0003b	89 4d f8	 mov	 DWORD PTR tv352[ebp], ecx
  0003e	a8 03		 test	 al, 3
  00040	0f 84 b8 01 00
	00		 je	 $LN3@EnterReque
  00046	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0004b	3d 40 05 00 00	 cmp	 eax, 1344		; 00000540H
  00050	0f 85 a8 01 00
	00		 jne	 $LN3@EnterReque

; 276  : 		return;
; 277  : 	}
; 278  : 
; 279  : 	int invPos = lpMsg->btPos+INVENTORY_BAG_START;

  00056	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00059	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0005d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00060	89 4d fc	 mov	 DWORD PTR _invPos$1$[ebp], ecx

; 280  : 
; 281  : 	if( !MAIN_INVENTORY_RANGE(invPos) )

  00063	0f 88 85 01 00
	00		 js	 $LN18@EnterReque
  00069	33 c0		 xor	 eax, eax
  0006b	81 f9 cb 00 00
	00		 cmp	 ecx, 203		; 000000cbH
  00071	0f 9e c0	 setle	 al
  00074	85 c0		 test	 eax, eax
  00076	0f 84 72 01 00
	00		 je	 $LN18@EnterReque

; 286  : 	}
; 287  : 
; 288  : 	if( lpObj->pInventory[invPos].IsItem() == FALSE || 

  0007c	69 c1 d4 00 00
	00		 imul	 eax, ecx, 212
  00082	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00088	03 c8		 add	 ecx, eax
  0008a	89 45 08	 mov	 DWORD PTR tv348[ebp], eax
  0008d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00092	85 c0		 test	 eax, eax
  00094	0f 84 44 01 00
	00		 je	 $LN6@EnterReque
  0009a	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  000a0	ba 6f 1c 00 00	 mov	 edx, 7279		; 00001c6fH
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR tv348[ebp]
  000a8	66 39 54 01 06	 cmp	 WORD PTR [ecx+eax+6], dx
  000ad	0f 85 2b 01 00
	00		 jne	 $LN6@EnterReque

; 294  : 	}
; 295  : 
; 296  : 	EnterCriticalSection(&m_sCrit);

  000b3	8d 43 68	 lea	 eax, DWORD PTR [ebx+104]
  000b6	50		 push	 eax
  000b7	89 45 0c	 mov	 DWORD PTR tv347[ebp], eax
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 297  : 
; 298  : 	if( m_iState != DOUBLEGOER_STATE_CLOSED )

  000c0	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  000c3	85 c0		 test	 eax, eax
  000c5	74 6c		 je	 SHORT $LN11@EnterReque

; 299  : 	{
; 300  : 		int bFail = TRUE;
; 301  : 
; 302  : 		if( m_iState == DOUBLEGOER_STATE_WAITING )

  000c7	83 f8 01	 cmp	 eax, 1
  000ca	75 2a		 jne	 SHORT $LN10@EnterReque

; 303  : 		{
; 304  : 			bFail = FALSE;
; 305  : 			int PartyNumber = lpObj->PartyNumber;

  000cc	8b 96 0c 06 00
	00		 mov	 edx, DWORD PTR [esi+1548]

; 306  : 
; 307  : 			if( PartyNumber == -1 || m_iLeaderIndex == -1 || gObj[m_iLeaderIndex].PartyNumber != PartyNumber )

  000d2	83 fa ff	 cmp	 edx, -1
  000d5	74 1f		 je	 SHORT $LN10@EnterReque
  000d7	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]
  000dd	83 f8 ff	 cmp	 eax, -1
  000e0	74 14		 je	 SHORT $LN10@EnterReque
  000e2	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  000e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ed	39 94 01 0c 06
	00 00		 cmp	 DWORD PTR [ecx+eax+1548], edx
  000f4	74 3d		 je	 SHORT $LN11@EnterReque
$LN10@EnterReque:

; 308  : 			{
; 309  : 				bFail = TRUE;
; 310  : 			}
; 311  : 		}
; 312  : 
; 313  : 		if( bFail == TRUE )
; 314  : 		{
; 315  : 			LogAddTD("[Doppelganger][%d](%s)(%s) Enter request failed - event on going",aIndex,lpObj->AccountID,lpObj->Name);

  000f6	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000f9	50		 push	 eax
  000fa	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000fd	50		 push	 eax
  000fe	57		 push	 edi
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 316  : 			pMsg.btResult = 2;

  0010a	c6 45 f4 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
$LN22@EnterReque:

; 317  : 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0010e	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00112	50		 push	 eax
  00113	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00116	50		 push	 eax
  00117	57		 push	 edi
  00118	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 318  : 			LeaveCriticalSection(&m_sCrit);

  0011d	8b 45 0c	 mov	 eax, DWORD PTR tv347[ebp]
  00120	83 c4 1c	 add	 esp, 28			; 0000001cH
  00123	50		 push	 eax
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx

; 372  : }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 08 00	 ret	 8
$LN11@EnterReque:

; 319  : 			return;
; 320  : 		}
; 321  : 	}
; 322  : 
; 323  : 
; 324  : 	int bFail = FALSE;
; 325  : 
; 326  : #if (ENABLE_FIX_PARTYPK == 1)
; 327  : 
; 328  : 	if( lpObj->m_PK_Level >= 4 )

  00133	80 be 19 01 00
	00 04		 cmp	 BYTE PTR [esi+281], 4
  0013a	7c 1a		 jl	 SHORT $LN13@EnterReque

; 329  : 	{
; 330  : 		bFail = TRUE;
; 331  : 	}
; 332  : 
; 333  : #else
; 334  : 	if ( lpObj->PartyNumber >= 0 )
; 335  : 	{
; 336  : 		if( gParty.GetPartyPkLevel(lpObj->PartyNumber) >= 5 )
; 337  : 		{
; 338  : 			bFail = TRUE;
; 339  : 		}
; 340  : 	}
; 341  : 	else if( lpObj->m_PK_Level >= 4 )
; 342  : 	{
; 343  : 		bFail = TRUE;
; 344  : 	}
; 345  : #endif
; 346  : 
; 347  : 	if( bFail == TRUE )
; 348  : 	{
; 349  : 		LogAddTD("[Doppelganger][%d](%s)(%s) Enter request failed - pk status",aIndex,lpObj->AccountID,lpObj->Name);

  0013c	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0013f	50		 push	 eax
  00140	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00143	50		 push	 eax
  00144	57		 push	 edi
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 350  : 		pMsg.btResult = 3;

  00150	c6 45 f4 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3

; 351  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 352  : 		LeaveCriticalSection(&m_sCrit);
; 353  : 		return;

  00154	eb b8		 jmp	 SHORT $LN22@EnterReque
$LN13@EnterReque:

; 354  : 	}
; 355  : 
; 356  : 	lpObj->m_IfState.use = 0;
; 357  : 	lpObj->m_IfState.type = 0;

  00156	81 a6 b8 11 00
	00 3c 00 ff ff	 and	 DWORD PTR [esi+4536], -65476 ; ffff003cH

; 358  : 
; 359  : 	gObjInventoryItemSet(aIndex, invPos, -1);

  00160	68 ff 00 00 00	 push	 255			; 000000ffH
  00165	ff 75 fc	 push	 DWORD PTR _invPos$1$[ebp]
  00168	57		 push	 edi
  00169	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 360  : 	gObj[aIndex].pInventory[invPos].Clear();

  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH
  00176	8b 4d f8	 mov	 ecx, DWORD PTR tv352[ebp]
  00179	8b 8c 01 c0 11
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+4544]
  00180	03 4d 08	 add	 ecx, DWORD PTR tv348[ebp]
  00183	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 361  : 	GCInventoryItemDeleteSend(aIndex, invPos, 1);

  00188	6a 01		 push	 1
  0018a	ff 75 fc	 push	 DWORD PTR _invPos$1$[ebp]
  0018d	57		 push	 edi
  0018e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH

; 362  : 
; 363  : 	if( m_iLeaderIndex == -1 )

  00196	83 bb 80 00 00
	00 ff		 cmp	 DWORD PTR [ebx+128], -1
  0019d	75 11		 jne	 SHORT $LN14@EnterReque

; 364  : 	{
; 365  : 		m_iLeaderIndex = lpObj->m_Index;

  0019f	8b 06		 mov	 eax, DWORD PTR [esi]

; 366  : 		SetState(DOUBLEGOER_STATE_WAITING);

  001a1	8b cb		 mov	 ecx, ebx
  001a3	6a 01		 push	 1
  001a5	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax
  001ab	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN14@EnterReque:

; 367  : 	}
; 368  : 
; 369  : 	AddUser(lpObj->m_Index);

  001b0	ff 36		 push	 DWORD PTR [esi]
  001b2	8b cb		 mov	 ecx, ebx
  001b4	e8 00 00 00 00	 call	 ?AddUser@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::AddUser

; 370  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  001b9	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001bd	50		 push	 eax
  001be	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001c1	50		 push	 eax
  001c2	57		 push	 edi
  001c3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 371  : 	LeaveCriticalSection(&m_sCrit);

  001cb	8d 43 68	 lea	 eax, DWORD PTR [ebx+104]
  001ce	50		 push	 eax
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5b		 pop	 ebx

; 372  : }

  001d8	8b e5		 mov	 esp, ebp
  001da	5d		 pop	 ebp
  001db	c2 08 00	 ret	 8
$LN6@EnterReque:

; 289  : 		lpObj->pInventory[invPos].m_Type != ITEMGET(14,111) )
; 290  : 	{
; 291  : 		LogAddTD("[Doppelganger][ERROR] Inventory item error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  001de	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001e1	50		 push	 eax
  001e2	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  001e5	50		 push	 eax
  001e6	57		 push	 edi
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@

; 292  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 293  : 		return;

  001ec	eb 1e		 jmp	 SHORT $LN21@EnterReque
$LN18@EnterReque:

; 282  : 	{
; 283  : 		LogAddTD("[Doppelganger][ERROR] Inventory range error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  001ee	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001f1	50		 push	 eax
  001f2	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  001f5	50		 push	 eax
  001f6	57		 push	 edi
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@

; 284  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 285  : 		return;

  001fc	eb 0e		 jmp	 SHORT $LN21@EnterReque
$LN3@EnterReque:

; 273  : 	{
; 274  : 		LogAddTD("[Doppelganger][ERROR] Not talked with Lugard [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  001fe	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00201	50		 push	 eax
  00202	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00205	50		 push	 eax
  00206	57		 push	 edi
  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@
$LN21@EnterReque:
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 275  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00212	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00216	50		 push	 eax
  00217	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0021a	50		 push	 eax
  0021b	57		 push	 edi
  0021c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00221	83 c4 1c	 add	 esp, 28			; 0000001cH
  00224	5f		 pop	 edi
  00225	5e		 pop	 esi
  00226	5b		 pop	 ebx

; 372  : }

  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	c2 08 00	 ret	 8
?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z ENDP ; CDoubleGoerEvent::EnterRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.h
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
_TEXT	SEGMENT
_pTmp$2 = -580						; size = 24
$T3 = -556						; size = 4
$T4 = -556						; size = 4
_this$GSCopy$ = -552					; size = 4
_lpszFileName$GSCopy$ = -548				; size = 4
_lpszFileName$GSCopy$1$ = -544				; size = 4
_Path$5 = -540						; size = 260
_Path$6 = -280						; size = 260
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@CDoubleGoerEvent@@QAEXPAD@Z PROC		; CDoubleGoerEvent::LoadData, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 38 02 00
	00		 sub	 esp, 568		; 00000238H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f9		 mov	 edi, ecx
  00033	8b 5d 08	 mov	 ebx, DWORD PTR _lpszFileName$[ebp]

; 127  : 	SMDFile = fopen(lpszFileName,"r");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0003b	53		 push	 ebx
  0003c	89 bd d8 fd ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00042	89 9d e0 fd ff
	ff		 mov	 DWORD PTR _lpszFileName$GSCopy$1$[ebp], ebx
  00048	89 9d dc fd ff
	ff		 mov	 DWORD PTR _lpszFileName$GSCopy$[ebp], ebx
  0004e	e8 00 00 00 00	 call	 _fopen
  00053	83 c4 08	 add	 esp, 8
  00056	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 128  : 
; 129  : 	if( SMDFile == NULL )

  0005b	85 c0		 test	 eax, eax
  0005d	75 10		 jne	 SHORT $LN9@LoadData

; 130  : 	{
; 131  : 		MsgBox("[Doppelganger] Load File failed(%s)",lpszFileName);

  0005f	53		 push	 ebx
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@
  00065	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 132  : 		return;

  0006a	e9 ed 03 00 00	 jmp	 $LN254@LoadData
$LN9@LoadData:

; 133  : 	}
; 134  : 
; 135  : 	m_iLoadedInfo = 0;

  0006f	c7 87 60 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+608], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1189 : 		return (this->_Myfirst() == this->_Mylast());

  00079	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  0007f	3b 87 68 02 00
	00		 cmp	 eax, DWORD PTR [edi+616]
  00085	0f 94 c0	 sete	 al
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 137  : 	if( !m_vtReward.empty() )

  00088	84 c0		 test	 al, al
  0008a	75 39		 jne	 SHORT $LN3@LoadData
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 46   : 		: _Ptr(_Parg)

  0008c	8b b7 64 02 00
	00		 mov	 esi, DWORD PTR [edi+612]

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		if (this->_Getcont() != _Right._Getcont())
; 205  : 			_Compat(_Right);
; 206  : 		return (this->_Ptr == _Right._Ptr);

  00092	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 141  : 		for( ; _It != m_vtReward.end(); _It++)

  00098	74 2b		 je	 SHORT $LN3@LoadData
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL4@LoadData:

; 142  : 		{
; 143  : 			if( _It->m_SilverBox != NULL )

  000a0	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000a3	85 c9		 test	 ecx, ecx
  000a5	74 06		 je	 SHORT $LN28@LoadData

; 144  : 				delete _It->m_SilverBox;

  000a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a9	6a 01		 push	 1
  000ab	ff 10		 call	 DWORD PTR [eax]
$LN28@LoadData:

; 145  : 
; 146  : 			if( _It->m_GoldenBox != NULL )

  000ad	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000b0	85 c9		 test	 ecx, ecx
  000b2	74 06		 je	 SHORT $LN2@LoadData

; 147  : 				delete _It->m_GoldenBox;

  000b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b6	6a 01		 push	 1
  000b8	ff 10		 call	 DWORD PTR [eax]
$LN2@LoadData:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 112  : 		++this->_Ptr;

  000ba	83 c6 18	 add	 esi, 24			; 00000018H

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		if (this->_Getcont() != _Right._Getcont())
; 205  : 			_Compat(_Right);
; 206  : 		return (this->_Ptr == _Right._Ptr);

  000bd	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 141  : 		for( ; _It != m_vtReward.end(); _It++)

  000c3	75 db		 jne	 SHORT $LL4@LoadData
$LN3@LoadData:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

  000c5	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  000cb	89 87 68 02 00
	00		 mov	 DWORD PTR [edi+616], eax
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 153  : 	try

  000d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000d8	eb 06		 jmp	 SHORT $LN5@LoadData
$LN251@LoadData:
  000da	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _lpszFileName$GSCopy$1$[ebp]
$LN5@LoadData:

; 154  : 	{
; 155  : 		int Token,Index;
; 156  : 
; 157  : 		while( TRUE )
; 158  : 		{
; 159  : 			Token = GetToken();

  000e0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 160  : 
; 161  : 			if( Token == END )

  000e5	83 f8 02	 cmp	 eax, 2
  000e8	0f 84 f8 02 00
	00		 je	 $LN253@LoadData

; 162  : 				break;
; 163  : 
; 164  : 			Index = (int)TokenNumber;

  000ee	f3 0f 2c 1d 00
	00 00 00	 cvttss2si ebx, DWORD PTR ?TokenNumber@@3MA
$LL7@LoadData:

; 165  : 
; 166  : 			while( TRUE )
; 167  : 			{
; 168  : 				if( Index == 0 )

  000f6	85 db		 test	 ebx, ebx
  000f8	75 72		 jne	 SHORT $LN15@LoadData

; 169  : 				{
; 170  : 					Token = GetToken();

  000fa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 171  : 
; 172  : 					if( strcmp("end",TokenString) == NULL )

  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  00104	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00109	0f 1f 80 00 00
	00 00		 npad	 7
$LL238@LoadData:
  00110	8a 10		 mov	 dl, BYTE PTR [eax]
  00112	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00114	75 1a		 jne	 SHORT $LN239@LoadData
  00116	84 d2		 test	 dl, dl
  00118	74 12		 je	 SHORT $LN240@LoadData
  0011a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0011d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00120	75 0e		 jne	 SHORT $LN239@LoadData
  00122	83 c0 02	 add	 eax, 2
  00125	83 c1 02	 add	 ecx, 2
  00128	84 d2		 test	 dl, dl
  0012a	75 e4		 jne	 SHORT $LL238@LoadData
$LN240@LoadData:
  0012c	33 c0		 xor	 eax, eax
  0012e	eb 05		 jmp	 SHORT $LN241@LoadData
$LN239@LoadData:
  00130	1b c0		 sbb	 eax, eax
  00132	83 c8 01	 or	 eax, 1
$LN241@LoadData:
  00135	85 c0		 test	 eax, eax
  00137	74 a1		 je	 SHORT $LN251@LoadData

; 173  : 						break;
; 174  : 
; 175  : 					m_iEVENT_WAIT = (int)TokenNumber;

  00139	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00141	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 176  : 
; 177  : 					Token = GetToken();

  00144	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 178  : 					m_iEVENT_TIME = (int)TokenNumber;

  00149	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00151	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 179  : 
; 180  : 					Token = GetToken();

  00154	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 181  : 					m_iEVENT_PLAYEND = (int)TokenNumber;

  00159	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00161	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 182  : 
; 183  : 					m_iMONSTER_MINUTE_SPAWN = m_iEVENT_TIME;

  00164	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00167	89 47 40	 mov	 DWORD PTR [edi+64], eax
  0016a	eb 8a		 jmp	 SHORT $LL7@LoadData
$LN15@LoadData:

; 184  : 				}
; 185  : 				else if( Index == 1 )

  0016c	83 fb 01	 cmp	 ebx, 1
  0016f	75 5c		 jne	 SHORT $LN18@LoadData

; 186  : 				{
; 187  : 					Token = GetToken();

  00171	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 188  : 
; 189  : 					if( strcmp("end",TokenString) == NULL )

  00176	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  0017b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL242@LoadData:
  00180	8a 10		 mov	 dl, BYTE PTR [eax]
  00182	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00184	75 1a		 jne	 SHORT $LN243@LoadData
  00186	84 d2		 test	 dl, dl
  00188	74 12		 je	 SHORT $LN244@LoadData
  0018a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0018d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00190	75 0e		 jne	 SHORT $LN243@LoadData
  00192	83 c0 02	 add	 eax, 2
  00195	83 c1 02	 add	 ecx, 2
  00198	84 d2		 test	 dl, dl
  0019a	75 e4		 jne	 SHORT $LL242@LoadData
$LN244@LoadData:
  0019c	33 c0		 xor	 eax, eax
  0019e	eb 05		 jmp	 SHORT $LN245@LoadData
$LN243@LoadData:
  001a0	1b c0		 sbb	 eax, eax
  001a2	83 c8 01	 or	 eax, 1
$LN245@LoadData:
  001a5	85 c0		 test	 eax, eax
  001a7	0f 84 2d ff ff
	ff		 je	 $LN251@LoadData

; 190  : 						break;
; 191  : 
; 192  : 					m_iMONSTER_COUNT = (int)TokenNumber;

  001ad	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001b5	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 193  : 
; 194  : 					Token = GetToken();

  001b8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 195  : 					m_iMONSTER_PER_MINUTE = (int)TokenNumber;

  001bd	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001c5	89 47 20	 mov	 DWORD PTR [edi+32], eax
  001c8	e9 29 ff ff ff	 jmp	 $LL7@LoadData
$LN18@LoadData:

; 196  : 				}
; 197  : 				else if( Index == 2 )

  001cd	83 fb 02	 cmp	 ebx, 2
  001d0	0f 85 20 ff ff
	ff		 jne	 $LL7@LoadData

; 198  : 				{
; 199  : 					Token = GetToken();

  001d6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 200  : 
; 201  : 					if( strcmp("end",TokenString) == NULL )

  001db	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  001e0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL246@LoadData:
  001e5	8a 10		 mov	 dl, BYTE PTR [eax]
  001e7	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001e9	75 1a		 jne	 SHORT $LN247@LoadData
  001eb	84 d2		 test	 dl, dl
  001ed	74 12		 je	 SHORT $LN248@LoadData
  001ef	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001f2	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001f5	75 0e		 jne	 SHORT $LN247@LoadData
  001f7	83 c0 02	 add	 eax, 2
  001fa	83 c1 02	 add	 ecx, 2
  001fd	84 d2		 test	 dl, dl
  001ff	75 e4		 jne	 SHORT $LL246@LoadData
$LN248@LoadData:
  00201	33 c0		 xor	 eax, eax
  00203	eb 05		 jmp	 SHORT $LN249@LoadData
$LN247@LoadData:
  00205	1b c0		 sbb	 eax, eax
  00207	83 c8 01	 or	 eax, 1
$LN249@LoadData:
  0020a	85 c0		 test	 eax, eax
  0020c	0f 84 c8 fe ff
	ff		 je	 $LN251@LoadData

; 206  : 					pTmp.m_ResetMin = TokenNumber;

  00212	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.h

; 113  : 			m_SilverBox = NULL;

  0021a	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _pTmp$2[ebp+16], 0

; 114  : 			m_GoldenBox = NULL;

  00224	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _pTmp$2[ebp+20], 0
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 206  : 					pTmp.m_ResetMin = TokenNumber;

  0022e	89 85 bc fd ff
	ff		 mov	 DWORD PTR _pTmp$2[ebp], eax

; 207  : 
; 208  : 					Token = GetToken();

  00234	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 209  : 					pTmp.m_ResetMax = TokenNumber;

  00239	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00241	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _pTmp$2[ebp+4], eax

; 210  : 
; 211  : 					Token = GetToken();

  00247	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 212  : 					pTmp.m_LevelMin = TokenNumber;

  0024c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00254	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _pTmp$2[ebp+8], eax

; 213  : 
; 214  : 					Token = GetToken();

  0025a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 215  : 					pTmp.m_LevelMax = TokenNumber;

  0025f	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00267	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _pTmp$2[ebp+12], eax

; 216  : 
; 217  : 					Token = GetToken();

  0026d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 218  : 					pTmp.m_SilverBox = new EventItemBag;

  00272	68 48 02 00 00	 push	 584			; 00000248H
  00277	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0027c	83 c4 04	 add	 esp, 4
  0027f	89 85 d4 fd ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  00285	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00289	85 c0		 test	 eax, eax
  0028b	74 0b		 je	 SHORT $LN32@LoadData
  0028d	8b c8		 mov	 ecx, eax
  0028f	e8 00 00 00 00	 call	 ??0EventItemBag@@QAE@XZ	; EventItemBag::EventItemBag
  00294	8b f0		 mov	 esi, eax
  00296	eb 02		 jmp	 SHORT $LN33@LoadData
$LN32@LoadData:
  00298	33 f6		 xor	 esi, esi
$LN33@LoadData:
  0029a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0029e	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _pTmp$2[ebp+16], esi

; 219  : 					if( pTmp.m_SilverBox != NULL )

  002a4	85 f6		 test	 esi, esi
  002a6	74 4c		 je	 SHORT $LN23@LoadData

; 220  : 					{
; 221  : 						char Path[MAX_PATH] = { 0 };
; 222  : 						sprintf(Path, "%s%s", PATH_EVENTBAG_DOPPELGANGER, TokenString);

  002a8	68 04 01 00 00	 push	 260			; 00000104H
  002ad	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _Path$6[ebp]
  002b3	6a 00		 push	 0
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 _memset
  002bb	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  002c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@
  002c5	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _Path$6[ebp]
  002cb	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  002d0	50		 push	 eax
  002d1	e8 00 00 00 00	 call	 _sprintf
  002d6	83 c4 1c	 add	 esp, 28			; 0000001cH

; 223  : 						pTmp.m_SilverBox->Read(gDirPath.GetNewPath(Path));

  002d9	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _Path$6[ebp]
  002df	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  002e4	50		 push	 eax
  002e5	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  002ea	50		 push	 eax
  002eb	8b ce		 mov	 ecx, esi
  002ed	e8 00 00 00 00	 call	 ?Read@EventItemBag@@QAEXPAD@Z ; EventItemBag::Read

; 224  : 					}
; 225  : 					else

  002f2	eb 0d		 jmp	 SHORT $LN24@LoadData
$LN23@LoadData:

; 226  : 					{
; 227  : 						MsgBox("[Doppelganger] Failed to init silver box!");

  002f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@
  002f9	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002fe	83 c4 04	 add	 esp, 4
$LN24@LoadData:

; 228  : 					}
; 229  : 
; 230  : 
; 231  : 					Token = GetToken();

  00301	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 232  : 					pTmp.m_GoldenBox = new EventItemBag;

  00306	68 48 02 00 00	 push	 584			; 00000248H
  0030b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00310	83 c4 04	 add	 esp, 4
  00313	89 85 d4 fd ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00319	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0031d	85 c0		 test	 eax, eax
  0031f	74 0b		 je	 SHORT $LN34@LoadData
  00321	8b c8		 mov	 ecx, eax
  00323	e8 00 00 00 00	 call	 ??0EventItemBag@@QAE@XZ	; EventItemBag::EventItemBag
  00328	8b f0		 mov	 esi, eax
  0032a	eb 02		 jmp	 SHORT $LN35@LoadData
$LN34@LoadData:
  0032c	33 f6		 xor	 esi, esi
$LN35@LoadData:
  0032e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00332	89 b5 d0 fd ff
	ff		 mov	 DWORD PTR _pTmp$2[ebp+20], esi

; 233  : 					if( pTmp.m_GoldenBox != NULL )

  00338	85 f6		 test	 esi, esi
  0033a	74 61		 je	 SHORT $LN25@LoadData

; 234  : 					{
; 235  : 						char Path[MAX_PATH] = { 0 };
; 236  : 						sprintf(Path, "%s%s", PATH_EVENTBAG_DOPPELGANGER, TokenString);

  0033c	68 04 01 00 00	 push	 260			; 00000104H
  00341	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _Path$5[ebp]
  00347	6a 00		 push	 0
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 _memset
  0034f	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00354	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@
  00359	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _Path$5[ebp]
  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00364	50		 push	 eax
  00365	e8 00 00 00 00	 call	 _sprintf
  0036a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 237  : 						pTmp.m_GoldenBox->Read(gDirPath.GetNewPath(Path));

  0036d	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _Path$5[ebp]
  00373	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00378	50		 push	 eax
  00379	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0037e	50		 push	 eax
  0037f	8b ce		 mov	 ecx, esi
  00381	e8 00 00 00 00	 call	 ?Read@EventItemBag@@QAEXPAD@Z ; EventItemBag::Read

; 242  : 					}
; 243  : 
; 244  : 					m_vtReward.push_back(pTmp);

  00386	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _pTmp$2[ebp]
  0038c	50		 push	 eax
  0038d	8d 8f 64 02 00
	00		 lea	 ecx, DWORD PTR [edi+612]
  00393	e8 00 00 00 00	 call	 ?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back
  00398	e9 59 fd ff ff	 jmp	 $LL7@LoadData
$LN25@LoadData:

; 238  : 					}
; 239  : 					else
; 240  : 					{
; 241  : 						MsgBox("[Doppelganger] Failed to init golden box!");

  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@
  003a2	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  003a7	83 c4 04	 add	 esp, 4

; 242  : 					}
; 243  : 
; 244  : 					m_vtReward.push_back(pTmp);

  003aa	8d 85 bc fd ff
	ff		 lea	 eax, DWORD PTR _pTmp$2[ebp]
  003b0	8d 8f 64 02 00
	00		 lea	 ecx, DWORD PTR [edi+612]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 ?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back
  003bc	e9 35 fd ff ff	 jmp	 $LL7@LoadData
__catch$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$0:

; 245  : 				}
; 246  : 			}
; 247  : 		}
; 248  : 
; 249  : 	}
; 250  : 	catch( DWORD )
; 251  : 	{
; 252  : 		MsgBox("[Doppelganger] - Loading Exception Error (%s) File. ", lpszFileName);

  003c1	ff b5 dc fd ff
	ff		 push	 DWORD PTR _lpszFileName$GSCopy$[ebp]
  003c7	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@
  003cc	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  003d1	83 c4 08	 add	 esp, 8

; 253  : 	}

  003d4	b8 00 00 00 00	 mov	 eax, $LN41@LoadData
  003d9	c3		 ret	 0
$LN41@LoadData:
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.h
  003da	8b bd d8 fd ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$[ebp]
  003e0	8b 9d dc fd ff
	ff		 mov	 ebx, DWORD PTR _lpszFileName$GSCopy$[ebp]
$LN253@LoadData:
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 254  : 
; 255  : 	LogAddTD("[Doppelganger] LevelInfo loaded [%d] levels",m_iLoadedInfo);

  003e6	ff b7 60 02 00
	00		 push	 DWORD PTR [edi+608]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.h
  003ec	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003f3	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@
  003f8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003fe	83 c4 08	 add	 esp, 8
  00401	c7 47 08 01 00
	00 00		 mov	 DWORD PTR [edi+8], 1
  00408	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0040d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00412	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00417	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  0041d	50		 push	 eax
  0041e	6a 00		 push	 0
  00420	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@
  00425	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0042a	ff d6		 call	 esi
  0042c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00431	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00436	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00439	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0043e	50		 push	 eax
  0043f	6a 64		 push	 100			; 00000064H
  00441	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@
  00446	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0044b	ff d6		 call	 esi
  0044d	53		 push	 ebx
  0044e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@
  00453	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00456	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
$LN254@LoadData:
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 256  : 
; 257  : 	bLoaded = TRUE;
; 258  : 	bEnabled = GetPrivateProfileInt("GameServerInfo","DoubleGoerEventRun",0, gDirPath.GetNewPath(FILE_SERVER_COMMON));
; 259  : 	m_iMirrorDropRate = GetPrivateProfileInt("GameServerInfo","MirrorMarkDropRate",100, gDirPath.GetNewPath(FILE_SERVER_COMMON));
; 260  : 
; 261  : 	LogAddTD("[Doppelganger] File loaded! (%s)",lpszFileName);

  0045c	83 c4 08	 add	 esp, 8

; 262  : }

  0045f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00462	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00469	59		 pop	 ecx
  0046a	5f		 pop	 edi
  0046b	5e		 pop	 esi
  0046c	5b		 pop	 ebx
  0046d	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00470	33 cd		 xor	 ecx, ebp
  00472	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00477	8b e5		 mov	 esp, ebp
  00479	5d		 pop	 ebp
  0047a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$2:
  00000	68 48 02 00 00	 push	 584			; 00000248H
  00005	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00011	83 c4 08	 add	 esp, 8
  00014	c3		 ret	 0
__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$3:
  00015	68 48 02 00 00	 push	 584			; 00000248H
  0001a	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
  00029	c3		 ret	 0
__ehhandler$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z:
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 8a b8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-584]
  00037	33 c8		 xor	 ecx, eax
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@CDoubleGoerEvent@@QAEXPAD@Z ENDP		; CDoubleGoerEvent::LoadData
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?Init@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?Init@CDoubleGoerEvent@@QAEXXZ PROC			; CDoubleGoerEvent::Init, COMDAT
; _this$ = ecx

; 89   : {

  00000	8b d1		 mov	 edx, ecx

; 90   : 	int i;
; 91   : 	for(i = 0; i < DOUBLEGOER_MAXPLAYER; i++)
; 92   : 	{
; 93   : 		m_PlayerInfo[i].aIndex = -1;
; 94   : 	}
; 95   : 
; 96   : 	m_iLeaderIndex = -1;
; 97   : 	m_iPlayerCount = 0;
; 98   : 
; 99   : 	for(i = 0; i < DOUBLEGOER_MAXMONSTER; i++)
; 100  : 	{
; 101  : 		m_MonsterInfo[i] = -1;

  00002	83 c8 ff	 or	 eax, -1
  00005	57		 push	 edi
  00006	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0000b	c7 82 88 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+136], -1
  00015	8d ba b0 00 00
	00		 lea	 edi, DWORD PTR [edx+176]
  0001b	c7 82 90 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+144], -1
  00025	c7 82 98 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+152], -1
  0002f	c7 82 a0 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+160], -1
  00039	c7 82 a8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+168], -1
  00043	c7 82 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+128], -1
  0004d	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
  00054	f3 ab		 rep stosd

; 102  : 	}
; 103  : 
; 104  : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)
; 105  : 	{
; 106  : 		m_BoxInfo[i] = -1;

  00056	89 82 40 02 00
	00		 mov	 DWORD PTR [edx+576], eax
  0005c	89 82 44 02 00
	00		 mov	 DWORD PTR [edx+580], eax
  00062	89 82 48 02 00
	00		 mov	 DWORD PTR [edx+584], eax
  00068	89 82 4c 02 00
	00		 mov	 DWORD PTR [edx+588], eax
  0006e	89 82 50 02 00
	00		 mov	 DWORD PTR [edx+592], eax
  00074	89 82 54 02 00
	00		 mov	 DWORD PTR [edx+596], eax

; 107  : 	}
; 108  : 
; 109  : 	m_iMonsterPassed = 0;
; 110  : 	m_bSEND_PLAY_START = FALSE;
; 111  : 	m_bMSG_BEFORE_START = FALSE;
; 112  : 
; 113  : 	m_bSUMMON_1ST_BOSS = FALSE;
; 114  : 	m_bSUMMON_2ND_BOSS = FALSE;
; 115  : 	m_bSUMMON_3RD_BOSS = FALSE;
; 116  : 
; 117  : 	m_iBossIndex = -1;

  0007a	89 42 64	 mov	 DWORD PTR [edx+100], eax

; 118  : 
; 119  : 	m_iWaveDist = 0;
; 120  : 	m_iCurentMap = -1;

  0007d	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 121  : 
; 122  : 	m_iMONSTER_MINUTE_SPAWN = m_iEVENT_TIME;

  00080	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00083	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
  0008a	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0
  00091	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0
  00098	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0
  0009f	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], 0
  000a6	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0
  000ad	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0
  000b4	89 42 40	 mov	 DWORD PTR [edx+64], eax
  000b7	5f		 pop	 edi

; 123  : }

  000b8	c3		 ret	 0
?Init@CDoubleGoerEvent@@QAEXXZ ENDP			; CDoubleGoerEvent::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ??1CDoubleGoerEvent@@UAE@XZ
_TEXT	SEGMENT
??1CDoubleGoerEvent@@UAE@XZ PROC			; CDoubleGoerEvent::~CDoubleGoerEvent, COMDAT
; _this$ = ecx

; 67   : {

  00000	53		 push	 ebx
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CDoubleGoerEvent@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1189 : 		return (this->_Myfirst() == this->_Mylast());

  0000a	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  00010	3b 87 68 02 00
	00		 cmp	 eax, DWORD PTR [edi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 69   : 	if( !m_vtReward.empty() )

  00016	74 31		 je	 SHORT $LN3@CDoubleGoe
  00018	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 46   : 		: _Ptr(_Parg)

  00019	8b f0		 mov	 esi, eax

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		if (this->_Getcont() != _Right._Getcont())
; 205  : 			_Compat(_Right);
; 206  : 		return (this->_Ptr == _Right._Ptr);

  0001b	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 73   : 		for( ; _It != m_vtReward.end(); _It++)

  00021	74 25		 je	 SHORT $LN269@CDoubleGoe
$LL4@CDoubleGoe:

; 74   : 		{
; 75   : 			if( _It->m_SilverBox != NULL )

  00023	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00026	85 c9		 test	 ecx, ecx
  00028	74 06		 je	 SHORT $LN9@CDoubleGoe

; 76   : 				delete _It->m_SilverBox;

  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	6a 01		 push	 1
  0002e	ff 10		 call	 DWORD PTR [eax]
$LN9@CDoubleGoe:

; 77   : 
; 78   : 			if( _It->m_GoldenBox != NULL )

  00030	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00033	85 c9		 test	 ecx, ecx
  00035	74 06		 je	 SHORT $LN2@CDoubleGoe

; 79   : 				delete _It->m_GoldenBox;

  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	6a 01		 push	 1
  0003b	ff 10		 call	 DWORD PTR [eax]
$LN2@CDoubleGoe:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 112  : 		++this->_Ptr;

  0003d	83 c6 18	 add	 esi, 24			; 00000018H

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		if (this->_Getcont() != _Right._Getcont())
; 205  : 			_Compat(_Right);
; 206  : 		return (this->_Ptr == _Right._Ptr);

  00040	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 73   : 		for( ; _It != m_vtReward.end(); _It++)

  00046	75 db		 jne	 SHORT $LL4@CDoubleGoe
$LN269@CDoubleGoe:
  00048	5e		 pop	 esi
$LN3@CDoubleGoe:

; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	DeleteCriticalSection(&m_sCrit);

  00049	8d 47 68	 lea	 eax, DWORD PTR [edi+104]
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1656 : 		if (this->_Myfirst() != pointer())

  00053	8b 9f 64 02 00
	00		 mov	 ebx, DWORD PTR [edi+612]
  00059	85 db		 test	 ebx, ebx
  0005b	74 6e		 je	 SHORT $LN159@CDoubleGoe

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0005d	8b 8f 6c 02 00
	00		 mov	 ecx, DWORD PTR [edi+620]
  00063	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00068	2b cb		 sub	 ecx, ebx
  0006a	f7 e9		 imul	 ecx
  0006c	c1 fa 02	 sar	 edx, 2
  0006f	8b c2		 mov	 eax, edx
  00071	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00074	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00076	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0007b	77 51		 ja	 SHORT $LN271@CDoubleGoe

; 101  : 	const size_t _User_size = _Count * _Sz;

  0007d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00080	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00083	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00088	72 1a		 jb	 SHORT $LN227@CDoubleGoe

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0008a	f6 c3 1f	 test	 bl, 31			; 0000001fH
  0008d	75 44		 jne	 SHORT $LN273@CDoubleGoe

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0008f	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00092	3b c3		 cmp	 eax, ebx
  00094	73 42		 jae	 SHORT $LN274@CDoubleGoe

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00096	2b d8		 sub	 ebx, eax
  00098	83 fb 04	 cmp	 ebx, 4
  0009b	72 40		 jb	 SHORT $LN275@CDoubleGoe

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0009d	83 fb 23	 cmp	 ebx, 35			; 00000023H
  000a0	77 40		 ja	 SHORT $LN276@CDoubleGoe

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000a2	8b d8		 mov	 ebx, eax
$LN227@CDoubleGoe:

; 138  : 	::operator delete(_Ptr);

  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1662 : 			this->_Myfirst() = pointer();

  000aa	c7 87 64 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+612], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  000b4	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1663 : 			this->_Mylast() = pointer();

  000b7	c7 87 68 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+616], 0

; 1664 : 			this->_Myend() = pointer();

  000c1	c7 87 6c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+620], 0
$LN159@CDoubleGoe:
  000cb	5f		 pop	 edi
  000cc	5b		 pop	 ebx
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 84   : }

  000cd	c3		 ret	 0
$LN271@CDoubleGoe:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  000ce	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN277@CDoubleGoe:
$LN273@CDoubleGoe:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  000d3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN278@CDoubleGoe:
$LN274@CDoubleGoe:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  000d8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN279@CDoubleGoe:
$LN275@CDoubleGoe:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  000dd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN280@CDoubleGoe:
$LN276@CDoubleGoe:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  000e2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN281@CDoubleGoe:
$LN270@CDoubleGoe:
  000e7	cc		 int	 3
??1CDoubleGoerEvent@@UAE@XZ ENDP			; CDoubleGoerEvent::~CDoubleGoerEvent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ??0CDoubleGoerEvent@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDoubleGoerEvent@@QAE@XZ PROC			; CDoubleGoerEvent::CDoubleGoerEvent, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDoubleGoerEvent@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 480  : 		_Myfirst = pointer();

  00010	c7 86 64 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+612], 0

; 481  : 		_Mylast = pointer();

  0001a	c7 86 68 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+616], 0

; 482  : 		_Myend = pointer();

  00024	c7 86 6c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+620], 0
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp

; 62   : 	Init();

  0002e	e8 00 00 00 00	 call	 ?Init@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::Init

; 63   : 	InitializeCriticalSection(&m_sCrit);

  00033	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 64   : }

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??0CDoubleGoerEvent@@QAE@XZ ENDP			; CDoubleGoerEvent::CDoubleGoerEvent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.h
;	COMDAT ??0_st_reward@CDoubleGoerEvent@@QAE@XZ
_TEXT	SEGMENT
??0_st_reward@CDoubleGoerEvent@@QAE@XZ PROC		; CDoubleGoerEvent::_st_reward::_st_reward, COMDAT
; _this$ = ecx

; 108  : 		{
; 109  : 			m_ResetMin = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 110  : 			m_ResetMax = 0;
; 111  : 			m_LevelMin = 0;
; 112  : 			m_LevelMax = 0;
; 113  : 			m_SilverBox = NULL;
; 114  : 			m_GoldenBox = NULL;
; 115  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0002b	c3		 ret	 0
??0_st_reward@CDoubleGoerEvent@@QAE@XZ ENDP		; CDoubleGoerEvent::_st_reward::_st_reward
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Xx$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 316  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 317  : 	return (_CSTD sqrtf(_Xx));

  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv65[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv65[esp+8]

; 318  : 	}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 59   : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 60   : 		}

  00002	c3		 ret	 0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 745  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 746  :         return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 747  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\doublegoerevent.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
