; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\ElementalSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?Clear@ERTEL_USER@@QAEXXZ			; ERTEL_USER::Clear
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??0CElementalSystem@@QAE@XZ			; CElementalSystem::CElementalSystem
PUBLIC	??1CElementalSystem@@UAE@XZ			; CElementalSystem::~CElementalSystem
PUBLIC	?LoadElementalInfo@CElementalSystem@@QAEXPAD@Z	; CElementalSystem::LoadElementalInfo
PUBLIC	?LoadPentagramOption@CElementalSystem@@QAEXPAD@Z ; CElementalSystem::LoadPentagramOption
PUBLIC	?LoadOptions@CElementalSystem@@QAEXXZ		; CElementalSystem::LoadOptions
PUBLIC	?IsElementalItem@CElementalSystem@@QAEHH@Z	; CElementalSystem::IsElementalItem
PUBLIC	?IsElementalItem@CElementalSystem@@QAEHPAVCItem@@@Z ; CElementalSystem::IsElementalItem
PUBLIC	?IsPentagram@CElementalSystem@@QAEHH@Z		; CElementalSystem::IsPentagram
PUBLIC	?IsPentagram@CElementalSystem@@QAEHPAVCItem@@@Z	; CElementalSystem::IsPentagram
PUBLIC	?IsErrtel@CElementalSystem@@QAEHH@Z		; CElementalSystem::IsErrtel
PUBLIC	?IsErrtel@CElementalSystem@@QAEHPAVCItem@@@Z	; CElementalSystem::IsErrtel
PUBLIC	?Drop@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ; CElementalSystem::Drop
PUBLIC	?InitElementOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::InitElementOptions
PUBLIC	?ApplyElementItem@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::ApplyElementItem
PUBLIC	?ApplyErtelOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::ApplyErtelOption
PUBLIC	?ApplyOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CElementalSystem::ApplyOption
PUBLIC	?ApplyBonusOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CElementalSystem::ApplyBonusOptions
PUBLIC	?MissCheck@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ; CElementalSystem::MissCheck
PUBLIC	?MissCheckPvP@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ; CElementalSystem::MissCheckPvP
PUBLIC	?Attack@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@@Z ; CElementalSystem::Attack
PUBLIC	?GetTargetDefense@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@E@Z ; CElementalSystem::GetTargetDefense
PUBLIC	?GetAttackDamage@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0HPAVCMagicInf@@EE@Z ; CElementalSystem::GetAttackDamage
PUBLIC	?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems
PUBLIC	?SendShopElementalItem@CElementalSystem@@QAEXHH@Z ; CElementalSystem::SendShopElementalItem
PUBLIC	?SendTradeElementalItem@CElementalSystem@@QAEXHH@Z ; CElementalSystem::SendTradeElementalItem
PUBLIC	?BuildErtelInfo@CElementalSystem@@QAEXPAUPMSG_ERTELINFO@@PAUERTEL_USER@@HH@Z ; CElementalSystem::BuildErtelInfo
PUBLIC	?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z ; CElementalSystem::CGInsertErtel
PUBLIC	?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z ; CElementalSystem::CGRemoveErtel
PUBLIC	?InsertErtel@CElementalSystem@@QAEEPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CElementalSystem::InsertErtel
PUBLIC	?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CElementalSystem::ClearErtel
PUBLIC	?MoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@EPAE@Z ; CElementalSystem::MoveErtel
PUBLIC	?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z ; CElementalSystem::PShopErtel
PUBLIC	?TradeErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z ; CElementalSystem::TradeErtel
PUBLIC	?RemoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CElementalSystem::RemoveErtel
PUBLIC	?GetSlotCount@CElementalSystem@@QAEEPAVCItem@@@Z ; CElementalSystem::GetSlotCount
PUBLIC	?GetErtelOption@CElementalSystem@@QAEEHE@Z	; CElementalSystem::GetErtelOption
PUBLIC	?GetErtelOption@CElementalSystem@@QAEPAUERTEL_OPTION@@H@Z ; CElementalSystem::GetErtelOption
PUBLIC	?GetErtel@CElementalSystem@@QAEPAUERTEL_USER@@PAUOBJECTSTRUCT@@HH@Z ; CElementalSystem::GetErtel
PUBLIC	?GetPentagram@CElementalSystem@@QAEPAUPENTAGRAM_OPTION@@H@Z ; CElementalSystem::GetPentagram
PUBLIC	?GetPentagramOption@CElementalSystem@@QAEPAUPENTAGRAM_OPTION_INFO@@H@Z ; CElementalSystem::GetPentagramOption
PUBLIC	?CheckBonusRequirement@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@PAVCItem@@PAUPENTAGRAM_OPTION_INFO@@@Z ; CElementalSystem::CheckBonusRequirement
PUBLIC	?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z ; CElementalSystem::CGCombineButtonClick
PUBLIC	?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z ; CElementalSystem::CGUpgradeButtonClick
PUBLIC	?MithrilMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::MithrilMix
PUBLIC	?ElixirMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::ElixirMix
PUBLIC	?ErrtelMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::ErrtelMix
PUBLIC	?ErrtelLevelUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::ErrtelLevelUp
PUBLIC	?ErrtelRankUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@E@Z ; CElementalSystem::ErrtelRankUp
PUBLIC	?PentagramMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::PentagramMix
PUBLIC	?GDReqErtelList@CElementalSystem@@QAEXH@Z	; CElementalSystem::GDReqErtelList
PUBLIC	?DGAnsErtelList@CElementalSystem@@QAEXPAUPMSG_ANS_ERTELLIST@@@Z ; CElementalSystem::DGAnsErtelList
PUBLIC	?GDSaveErtelList@CElementalSystem@@QAEXH@Z	; CElementalSystem::GDSaveErtelList
PUBLIC	??_GCElementalSystem@@UAEPAXI@Z			; CElementalSystem::`scalar deleting destructor'
PUBLIC	??_7CElementalSystem@@6B@			; CElementalSystem::`vftable'
PUBLIC	?g_ElementalSystem@@3VCElementalSystem@@A	; g_ElementalSystem
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CN@HOILEDFI@?$FLElemental?5System?$FN?5Ertel?5file?5lo@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0DG@PKADJNLH@?$FLElemental?5System?$FN?5Damage?5player@ ; `string'
PUBLIC	??_C@_0DI@GIDECHPE@?$FLElemental?5System?$FN?5Pentagram?5Opt@ ; `string'
PUBLIC	??_C@_0EB@NFJNMDPD@?$FLElemental?5System?$FN?5Pentagram?5Opt@ ; `string'
PUBLIC	??_C@_0ED@MDILOIPJ@?$FLElemental?5System?$FN?5Pentagram?5Opt@ ; `string'
PUBLIC	??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@	; `string'
PUBLIC	??_C@_0BM@BJLNEGJB@SpiritMapFragment_DropLevel?$AA@ ; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BL@MGECKHDP@SpiritMapFragment_DropRate?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NJKIAEP@MithrilFragment_DropRate?$AA@	; `string'
PUBLIC	??_C@_0BI@JLLDEOPN@ElixirFragment_DropRate?$AA@	; `string'
PUBLIC	??_C@_0BE@ICNAACD@MurenBook_DropLevel?$AA@	; `string'
PUBLIC	??_C@_0BD@FHAPEJOE@MurenBook_DropRate?$AA@	; `string'
PUBLIC	??_C@_0BH@DAENMFCN@EtramuScroll_DropLevel?$AA@	; `string'
PUBLIC	??_C@_0BJ@PBJHJCFF@m_iEtramuScroll_DropRate?$AA@ ; `string'
PUBLIC	??_C@_0BG@FGICCHGI@ElementSlotCountRate1?$AA@	; `string'
PUBLIC	??_C@_0BG@HNKPHEKL@ElementSlotCountRate2?$AA@	; `string'
PUBLIC	??_C@_0BG@GELEEFOK@ElementSlotCountRate3?$AA@	; `string'
PUBLIC	??_C@_0BG@CLPFNDCN@ElementSlotCountRate4?$AA@	; `string'
PUBLIC	??_C@_0BG@DCOOOCGM@ElementSlotCountRate5?$AA@	; `string'
PUBLIC	??_C@_0CF@JAMJMJON@?$FLShield?$FN?5ComboSkill?5Cancel?$CB?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0DL@JCIFHKLN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Inventory?5@ ; `string'
PUBLIC	??_C@_0DB@FBKJFJKK@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelID?5?$DN?$DN@ ; `string'
PUBLIC	??_C@_0DL@FIGMOAKP@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelSocke@ ; `string'
PUBLIC	??_C@_0EL@LLEHKIAN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5elem@ ; `string'
PUBLIC	??_C@_0DI@NHPFFHEF@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5list@ ; `string'
PUBLIC	??_C@_0DL@DICEMIHC@?$FLErtel?5Remove?$FN?$FLERROR?$FN?5Inventory?5@ ; `string'
PUBLIC	??_C@_0GM@MHCJODDO@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLSu@ ; `string'
PUBLIC	??_C@_0GJ@CBGBFNDC@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLFa@ ; `string'
PUBLIC	??_C@_0BE@KNKAACGF@ElementalSystem?4cpp?$AA@	; `string'
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ ; `string'
PUBLIC	??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ ; `string'
PUBLIC	??_C@_0DN@HJKEFHCH@?$FLElemental?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Unde@ ; `string'
PUBLIC	??_C@_0CB@FIEELGCG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5info?5error?5?$CB@ ; `string'
PUBLIC	??_C@_0CC@KJHJFHEO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5level?5info?5error?5@ ; `string'
PUBLIC	??_C@_0CE@ICIBLGAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5up?5info?5erro@ ; `string'
PUBLIC	??_C@_0M@JOFENNCC@Mithril?5Mix?$AA@		; `string'
PUBLIC	??_C@_0CF@KHNHOBHG@?$FLElemental?5System?$FN?5Mithril?5Mix?5S@ ; `string'
PUBLIC	??_C@_0EI@MHGFDFME@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@ ; `string'
PUBLIC	??_C@_0EG@PECHNODK@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@ ; `string'
PUBLIC	??_C@_0L@CHFCKLND@Elixir?5Mix?$AA@		; `string'
PUBLIC	??_C@_0CE@NNKLGBLG@?$FLElemental?5System?$FN?5Elixir?5Mix?5St@ ; `string'
PUBLIC	??_C@_0EH@CFOIEEJA@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@ ; `string'
PUBLIC	??_C@_0EF@EKMPONBC@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@ ; `string'
PUBLIC	??_C@_0BC@BFDOANCJ@Ertel?5LevelUp?5Mix?$AA@	; `string'
PUBLIC	??_C@_0CH@GJPCHLDL@?$FLElemental?5System?$FN?5Ertel?5LevelUp@ ; `string'
PUBLIC	??_C@_0EK@PHDHHJCA@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@ ; `string'
PUBLIC	??_C@_0EI@PPAHDGDE@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@ ; `string'
PUBLIC	??_C@_0BB@LKFPHNIC@Ertel?5RankUp?5Mix?$AA@	; `string'
PUBLIC	??_C@_0CG@CFLBJGOL@?$FLElemental?5System?$FN?5Ertel?5RankUp?5@ ; `string'
PUBLIC	??_C@_0EJ@BDBNMFDL@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@ ; `string'
PUBLIC	??_C@_0EH@DILEBMMH@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@ ; `string'
PUBLIC	??_C@_0BB@MGODOAMM@Pentagram?5Refine?$AA@	; `string'
PUBLIC	??_C@_0CK@GCKAIEKG@?$FLElemental?5System?$FN?5Pentagram?5Ref@ ; `string'
PUBLIC	??_C@_0EN@KOCLEMN@?$FLElemental?5System?$FN?$FLPentagram?5Ref@ ; `string'
PUBLIC	??_C@_0EL@HGMMBHEK@?$FLElemental?5System?$FN?$FLPentagram?5Ref@ ; `string'
PUBLIC	??_R4CElementalSystem@@6B@			; CElementalSystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCElementalSystem@@@8			; CElementalSystem `RTTI Type Descriptor'
PUBLIC	??_R3CElementalSystem@@8			; CElementalSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CElementalSystem@@8			; CElementalSystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CElementalSystem@@8		; CElementalSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CObjBaseAttack@@8			; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCObjBaseAttack@@@8			; CObjBaseAttack `RTTI Type Descriptor'
PUBLIC	??_R3CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Base Class Array'
PUBLIC	__real@3f800000
PUBLIC	__real@42c80000
PUBLIC	__real@461c4000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEE@Z:PROC		; CItem::Convert
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?GetSkillDistance@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillDistance
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?GensMap@CGensSystem@@QAEHH@Z:PROC		; CGensSystem::GensMap
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?IncAgro@TMonsterAIAgro@@QAEHHH@Z:PROC		; TMonsterAIAgro::IncAgro
EXTRN	??0TRandomPoolMgr@@QAE@XZ:PROC			; TRandomPoolMgr::TRandomPoolMgr
EXTRN	??1TRandomPoolMgr@@UAE@XZ:PROC			; TRandomPoolMgr::~TRandomPoolMgr
EXTRN	?InitPool@TRandomPoolMgr@@QAEXXZ:PROC		; TRandomPoolMgr::InitPool
EXTRN	?AddValue@TRandomPoolMgr@@QAE_NHH@Z:PROC	; TRandomPoolMgr::AddValue
EXTRN	?GetRandomValue@TRandomPoolMgr@@QAEHW4eRandomPoolSelectType@@@Z:PROC ; TRandomPoolMgr::GetRandomValue
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCInventoryItemOneSend@@YAXHH@Z:PROC		; GCInventoryItemOneSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?GCDamageSend@@YAXHHHE@Z:PROC			; GCDamageSend
EXTRN	?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z:PROC	; GCActionSend
EXTRN	?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCMagicCancelSend
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjAttackQ
EXTRN	?gObjSpriteDamage@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; gObjSpriteDamage
EXTRN	?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z:PROC ; gObjArmorRandomDurDown
EXTRN	?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckSelfDefense
EXTRN	?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z:PROC ; gObjLifeCheck
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; CheckInventoryEmptySpace
EXTRN	?gObjChaosItemSet@@YAXHHE@Z:PROC		; gObjChaosItemSet
EXTRN	?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjChaosBoxInsertItemPos
EXTRN	?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjTargetGuildWarCheck
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjDuelCheck
EXTRN	?gObjCheckAttackTypeMagic@@YAHHH@Z:PROC		; gObjCheckAttackTypeMagic
EXTRN	?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjGetRelationShip
EXTRN	?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z:PROC ; gObjWeaponDurDownInCastle
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?GetPartyPkLevel@PartyClass@@QAEDH@Z:PROC	; PartyClass::GetPartyPkLevel
EXTRN	??0CObjBaseAttack@@QAE@XZ:PROC			; CObjBaseAttack::CObjBaseAttack
EXTRN	??1CObjBaseAttack@@UAE@XZ:PROC			; CObjBaseAttack::~CObjBaseAttack
EXTRN	?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z:PROC ; CObjBaseAttack::CheckAttackArea
EXTRN	?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z:PROC ; CObjBaseAttack::PkCheck
EXTRN	?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAHE@Z:PROC ; CObjBaseAttack::MissCheck
EXTRN	??_ECElementalSystem@@UAEPAXI@Z:PROC		; CElementalSystem::`vector deleting destructor'
EXTRN	?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjAddBuffEffect
EXTRN	?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
EXTRN	?GetState@CIllusionTempleEvent@@QAEEE@Z:PROC	; CIllusionTempleEvent::GetState
EXTRN	?Is1stSkillActive@CIllusionTempleEvent@@QAEHHE@Z:PROC ; CIllusionTempleEvent::Is1stSkillActive
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ChaosBoxInit
EXTRN	?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CChaosBox::LogChaosItem
EXTRN	?ChaosBoxSpecialItemDown@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ChaosBoxSpecialItemDown
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z:PROC ; ItemSerialCreateSend
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
EXTRN	?gObjCallMonsterSetEnemy@@YAHPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCallMonsterSetEnemy
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
EXTRN	?PHeadSubSetW@@YAXPAEEEH@Z:PROC			; PHeadSubSetW
EXTRN	?GetBattleSoccerGoalMove@@YAHH@Z:PROC		; GetBattleSoccerGoalMove
EXTRN	?GetCastleState@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetCastleState
EXTRN	?IsAttackAbleMonster@CImperialGuardian@@QAE_NH@Z:PROC ; CImperialGuardian::IsAttackAbleMonster
EXTRN	?GetShieldDamage@CObjAttack@@QAEHPAUOBJECTSTRUCT@@0H@Z:PROC ; CObjAttack::GetShieldDamage
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gGensSystem@@3VCGensSystem@@A:BYTE		; gGensSystem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?g_fSuccessAttackRateOption@@3MA:DWORD		; g_fSuccessAttackRateOption
EXTRN	?g_bShieldComboMissOptionOn@@3HA:DWORD		; g_bShieldComboMissOptionOn
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?g_ChaosBox@@3VCChaosBox@@A:BYTE		; g_ChaosBox
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_ImperialGuardian@@3VCImperialGuardian@@A:BYTE ; g_ImperialGuardian
EXTRN	?gclassObjAttack@@3VCObjAttack@@A:DWORD		; gclassObjAttack
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_ElementalSystem@@3VCElementalSystem@@A DB 01a84H DUP (?) ; g_ElementalSystem
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
CRT$XCU	SEGMENT
?g_ElementalSystem$initializer$@@3P6AXXZA DD FLAT:??__Eg_ElementalSystem@@YAXXZ ; g_ElementalSystem$initializer$
CRT$XCU	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R2CObjBaseAttack@@8
rdata$r	SEGMENT
??_R2CObjBaseAttack@@8 DD FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8 ; CObjBaseAttack::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjBaseAttack@@8
rdata$r	SEGMENT
??_R3CObjBaseAttack@@8 DD 00H				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjBaseAttack@@@8
data$r	SEGMENT
??_R0?AVCObjBaseAttack@@@8 DD FLAT:??_7type_info@@6B@	; CObjBaseAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjBaseAttack@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObjBaseAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjBaseAttack@@8 DD FLAT:??_R0?AVCObjBaseAttack@@@8 ; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CElementalSystem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CElementalSystem@@8 DD FLAT:??_R0?AVCElementalSystem@@@8 ; CElementalSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CElementalSystem@@8
rdata$r	ENDS
;	COMDAT ??_R2CElementalSystem@@8
rdata$r	SEGMENT
??_R2CElementalSystem@@8 DD FLAT:??_R1A@?0A@EA@CElementalSystem@@8 ; CElementalSystem::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R3CElementalSystem@@8
rdata$r	SEGMENT
??_R3CElementalSystem@@8 DD 00H				; CElementalSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CElementalSystem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCElementalSystem@@@8
data$r	SEGMENT
??_R0?AVCElementalSystem@@@8 DD FLAT:??_7type_info@@6B@	; CElementalSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCElementalSystem@@', 00H
data$r	ENDS
;	COMDAT ??_R4CElementalSystem@@6B@
rdata$r	SEGMENT
??_R4CElementalSystem@@6B@ DD 00H			; CElementalSystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCElementalSystem@@@8
	DD	FLAT:??_R3CElementalSystem@@8
rdata$r	ENDS
;	COMDAT ??_C@_0EL@HGMMBHEK@?$FLElemental?5System?$FN?$FLPentagram?5Ref@
CONST	SEGMENT
??_C@_0EL@HGMMBHEK@?$FLElemental?5System?$FN?$FLPentagram?5Ref@ DB '[Elem'
	DB	'ental System][Pentagram Refine] [%s][%s] CBMix Fail %d Money '
	DB	': %d-%d ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@KOCLEMN@?$FLElemental?5System?$FN?$FLPentagram?5Ref@
CONST	SEGMENT
??_C@_0EN@KOCLEMN@?$FLElemental?5System?$FN?$FLPentagram?5Ref@ DB '[Eleme'
	DB	'ntal System][Pentagram Refine] [%s][%s] CBMix Success %d Mone'
	DB	'y : %d-%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GCKAIEKG@?$FLElemental?5System?$FN?5Pentagram?5Ref@
CONST	SEGMENT
??_C@_0CK@GCKAIEKG@?$FLElemental?5System?$FN?5Pentagram?5Ref@ DB '[Elemen'
	DB	'tal System] Pentagram Refine Start', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGODOAMM@Pentagram?5Refine?$AA@
CONST	SEGMENT
??_C@_0BB@MGODOAMM@Pentagram?5Refine?$AA@ DB 'Pentagram Refine', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@DILEBMMH@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@
CONST	SEGMENT
??_C@_0EH@DILEBMMH@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@ DB '[E'
	DB	'lemental System][Ertel RankUp] [%s][%s] CBMix Fail %d Money :'
	DB	' %d-%d ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@BDBNMFDL@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@
CONST	SEGMENT
??_C@_0EJ@BDBNMFDL@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@ DB '[E'
	DB	'lemental System][Ertel RankUp] [%s][%s] CBMix Success %d Mone'
	DB	'y : %d-%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CFLBJGOL@?$FLElemental?5System?$FN?5Ertel?5RankUp?5@
CONST	SEGMENT
??_C@_0CG@CFLBJGOL@?$FLElemental?5System?$FN?5Ertel?5RankUp?5@ DB '[Eleme'
	DB	'ntal System] Ertel RankUp Start', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LKFPHNIC@Ertel?5RankUp?5Mix?$AA@
CONST	SEGMENT
??_C@_0BB@LKFPHNIC@Ertel?5RankUp?5Mix?$AA@ DB 'Ertel RankUp Mix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@PPAHDGDE@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@
CONST	SEGMENT
??_C@_0EI@PPAHDGDE@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@ DB '[Elem'
	DB	'ental System][Ertel LevelUp] [%s][%s] CBMix Fail %d Money : %'
	DB	'd-%d ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@PHDHHJCA@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@
CONST	SEGMENT
??_C@_0EK@PHDHHJCA@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@ DB '[Elem'
	DB	'ental System][Ertel LevelUp] [%s][%s] CBMix Success %d Money '
	DB	': %d-%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GJPCHLDL@?$FLElemental?5System?$FN?5Ertel?5LevelUp@
CONST	SEGMENT
??_C@_0CH@GJPCHLDL@?$FLElemental?5System?$FN?5Ertel?5LevelUp@ DB '[Elemen'
	DB	'tal System] Ertel LevelUp Start', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BFDOANCJ@Ertel?5LevelUp?5Mix?$AA@
CONST	SEGMENT
??_C@_0BC@BFDOANCJ@Ertel?5LevelUp?5Mix?$AA@ DB 'Ertel LevelUp Mix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@EKMPONBC@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@
CONST	SEGMENT
??_C@_0EF@EKMPONBC@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@ DB '['
	DB	'Elemental System][Elixir Mix] [%s][%s] CBMix Fail %d Money : '
	DB	'%d-%d ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@CFOIEEJA@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@
CONST	SEGMENT
??_C@_0EH@CFOIEEJA@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@ DB '['
	DB	'Elemental System][Elixir Mix] [%s][%s] CBMix Success %d Money'
	DB	' : %d-%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNKLGBLG@?$FLElemental?5System?$FN?5Elixir?5Mix?5St@
CONST	SEGMENT
??_C@_0CE@NNKLGBLG@?$FLElemental?5System?$FN?5Elixir?5Mix?5St@ DB '[Eleme'
	DB	'ntal System] Elixir Mix Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CHFCKLND@Elixir?5Mix?$AA@
CONST	SEGMENT
??_C@_0L@CHFCKLND@Elixir?5Mix?$AA@ DB 'Elixir Mix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@PECHNODK@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@
CONST	SEGMENT
??_C@_0EG@PECHNODK@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@ DB '['
	DB	'Elemental System][Mithril Mix] [%s][%s] CBMix Fail %d Money :'
	DB	' %d-%d ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@MHGFDFME@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@
CONST	SEGMENT
??_C@_0EI@MHGFDFME@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@ DB '['
	DB	'Elemental System][Mithril Mix] [%s][%s] CBMix Success %d Mone'
	DB	'y : %d-%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KHNHOBHG@?$FLElemental?5System?$FN?5Mithril?5Mix?5S@
CONST	SEGMENT
??_C@_0CF@KHNHOBHG@?$FLElemental?5System?$FN?5Mithril?5Mix?5S@ DB '[Eleme'
	DB	'ntal System] Mithril Mix Start', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JOFENNCC@Mithril?5Mix?$AA@
CONST	SEGMENT
??_C@_0M@JOFENNCC@Mithril?5Mix?$AA@ DB 'Mithril Mix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ICIBLGAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5up?5info?5erro@
CONST	SEGMENT
??_C@_0CE@ICIBLGAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5up?5info?5erro@ DB '['
	DB	'%s][%s] Ertel rank up info error !', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KJHJFHEO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5level?5info?5error?5@
CONST	SEGMENT
??_C@_0CC@KJHJFHEO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5level?5info?5error?5@ DB '['
	DB	'%s][%s] Ertel level info error !', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FIEELGCG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5info?5error?5?$CB@
CONST	SEGMENT
??_C@_0CB@FIEELGCG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5info?5error?5?$CB@ DB '['
	DB	'%s][%s] Ertel rank info error !', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HJKEFHCH@?$FLElemental?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Unde@
CONST	SEGMENT
??_C@_0DN@HJKEFHCH@?$FLElemental?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Unde@ DB '['
	DB	'Elemental System] [%s][%s] Undefine chaosmix type detect %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
CONST	SEGMENT
??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ DB '['
	DB	'%s][%s] is Already Opening PShop, ChaosBox Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
CONST	SEGMENT
??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ DB '['
	DB	'%s][%s] Already Used Chaos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ DB 'error-L'
	DB	'3 [%s][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KNKAACGF@ElementalSystem?4cpp?$AA@
CONST	SEGMENT
??_C@_0BE@KNKAACGF@ElementalSystem?4cpp?$AA@ DB 'ElementalSystem.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@CBGBFNDC@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLFa@
CONST	SEGMENT
??_C@_0GJ@CBGBFNDC@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLFa@ DB '['
	DB	'Ertel Remove] [%d] (%s)(%s) [Fail] ErrtelID: %d, Op1[%d/%d],O'
	DB	'p2[%d/%d],Op3[%d/%d],Op4[%d/%d],Op5[%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@MHCJODDO@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLSu@
CONST	SEGMENT
??_C@_0GM@MHCJODDO@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLSu@ DB '['
	DB	'Ertel Remove] [%d] (%s)(%s) [Success] ErrtelID: %d, Op1[%d/%d'
	DB	'],Op2[%d/%d],Op3[%d/%d],Op4[%d/%d],Op5[%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@DICEMIHC@?$FLErtel?5Remove?$FN?$FLERROR?$FN?5Inventory?5@
CONST	SEGMENT
??_C@_0DL@DICEMIHC@?$FLErtel?5Remove?$FN?$FLERROR?$FN?5Inventory?5@ DB '['
	DB	'Ertel Remove][ERROR] Inventory range error - [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NHPFFHEF@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5list@
CONST	SEGMENT
??_C@_0DI@NHPFFHEF@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5list@ DB '['
	DB	'Ertel Insert][ERROR] Ertel list is full ! [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LLEHKIAN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5elem@
CONST	SEGMENT
??_C@_0EL@LLEHKIAN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5elem@ DB '['
	DB	'Ertel Insert][ERROR] Ertel element dont match book element ! '
	DB	'[%d](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FIGMOAKP@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelSocke@
CONST	SEGMENT
??_C@_0DL@FIGMOAKP@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelSocke@ DB '[E'
	DB	'rtel Insert][ERROR] ErtelSocket not empty ! [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FBKJFJKK@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelID?5?$DN?$DN@
CONST	SEGMENT
??_C@_0DB@FBKJFJKK@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelID?5?$DN?$DN@ DB '['
	DB	'Ertel Insert][ERROR] ErtelID == -1 [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JCIFHKLN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Inventory?5@
CONST	SEGMENT
??_C@_0DL@JCIFHKLN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Inventory?5@ DB '['
	DB	'Ertel Insert][ERROR] Inventory range error - [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JAMJMJON@?$FLShield?$FN?5ComboSkill?5Cancel?$CB?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CF@JAMJMJON@?$FLShield?$FN?5ComboSkill?5Cancel?$CB?5?$FL?$CFs?$FN@ DB '['
	DB	'Shield] ComboSkill Cancel! [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DCOOOCGM@ElementSlotCountRate5?$AA@
CONST	SEGMENT
??_C@_0BG@DCOOOCGM@ElementSlotCountRate5?$AA@ DB 'ElementSlotCountRate5', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CLPFNDCN@ElementSlotCountRate4?$AA@
CONST	SEGMENT
??_C@_0BG@CLPFNDCN@ElementSlotCountRate4?$AA@ DB 'ElementSlotCountRate4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GELEEFOK@ElementSlotCountRate3?$AA@
CONST	SEGMENT
??_C@_0BG@GELEEFOK@ElementSlotCountRate3?$AA@ DB 'ElementSlotCountRate3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HNKPHEKL@ElementSlotCountRate2?$AA@
CONST	SEGMENT
??_C@_0BG@HNKPHEKL@ElementSlotCountRate2?$AA@ DB 'ElementSlotCountRate2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FGICCHGI@ElementSlotCountRate1?$AA@
CONST	SEGMENT
??_C@_0BG@FGICCHGI@ElementSlotCountRate1?$AA@ DB 'ElementSlotCountRate1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBJHJCFF@m_iEtramuScroll_DropRate?$AA@
CONST	SEGMENT
??_C@_0BJ@PBJHJCFF@m_iEtramuScroll_DropRate?$AA@ DB 'm_iEtramuScroll_Drop'
	DB	'Rate', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DAENMFCN@EtramuScroll_DropLevel?$AA@
CONST	SEGMENT
??_C@_0BH@DAENMFCN@EtramuScroll_DropLevel?$AA@ DB 'EtramuScroll_DropLevel'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FHAPEJOE@MurenBook_DropRate?$AA@
CONST	SEGMENT
??_C@_0BD@FHAPEJOE@MurenBook_DropRate?$AA@ DB 'MurenBook_DropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ICNAACD@MurenBook_DropLevel?$AA@
CONST	SEGMENT
??_C@_0BE@ICNAACD@MurenBook_DropLevel?$AA@ DB 'MurenBook_DropLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLLDEOPN@ElixirFragment_DropRate?$AA@
CONST	SEGMENT
??_C@_0BI@JLLDEOPN@ElixirFragment_DropRate?$AA@ DB 'ElixirFragment_DropRa'
	DB	'te', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NJKIAEP@MithrilFragment_DropRate?$AA@
CONST	SEGMENT
??_C@_0BJ@NJKIAEP@MithrilFragment_DropRate?$AA@ DB 'MithrilFragment_DropR'
	DB	'ate', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MGECKHDP@SpiritMapFragment_DropRate?$AA@
CONST	SEGMENT
??_C@_0BL@MGECKHDP@SpiritMapFragment_DropRate?$AA@ DB 'SpiritMapFragment_'
	DB	'DropRate', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BJLNEGJB@SpiritMapFragment_DropLevel?$AA@
CONST	SEGMENT
??_C@_0BM@BJLNEGJB@SpiritMapFragment_DropLevel?$AA@ DB 'SpiritMapFragment'
	DB	'_DropLevel', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@ DB 'CommonServer.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MDILOIPJ@?$FLElemental?5System?$FN?5Pentagram?5Opt@
CONST	SEGMENT
??_C@_0ED@MDILOIPJ@?$FLElemental?5System?$FN?5Pentagram?5Opt@ DB '[Elemen'
	DB	'tal System] Pentagram Option Count >= MAX_PENTAGRAM_OPTIONS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NFJNMDPD@?$FLElemental?5System?$FN?5Pentagram?5Opt@
CONST	SEGMENT
??_C@_0EB@NFJNMDPD@?$FLElemental?5System?$FN?5Pentagram?5Opt@ DB '[Elemen'
	DB	'tal System] Pentagram Option Count >= MAX_PENTAGRAM_ITEMS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GIDECHPE@?$FLElemental?5System?$FN?5Pentagram?5Opt@
CONST	SEGMENT
??_C@_0DI@GIDECHPE@?$FLElemental?5System?$FN?5Pentagram?5Opt@ DB '[Elemen'
	DB	'tal System] Pentagram Option file load fail (%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PKADJNLH@?$FLElemental?5System?$FN?5Damage?5player@
CONST	SEGMENT
??_C@_0DG@PKADJNLH@?$FLElemental?5System?$FN?5Damage?5player@ DB '[Elemen'
	DB	'tal System] Damage player class out of bounds!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HOILEDFI@?$FLElemental?5System?$FN?5Ertel?5file?5lo@
CONST	SEGMENT
??_C@_0CN@HOILEDFI@?$FLElemental?5System?$FN?5Ertel?5file?5lo@ DB '[Eleme'
	DB	'ntal System] Ertel file load fail (%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CElementalSystem@@6B@
CONST	SEGMENT
??_7CElementalSystem@@6B@ DD FLAT:??_R4CElementalSystem@@6B@ ; CElementalSystem::`vftable'
	DD	FLAT:??_ECElementalSystem@@UAEPAXI@Z
	DD	FLAT:?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAHE@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetAttackDamage@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0HPAVCMagicInf@@EE@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN42@GetAttackD
	DD	FLAT:$LN30@GetAttackD
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?MissCheck@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffd0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN29@MissCheck
	DD	FLAT:$LN21@MissCheck
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CElementalSystem@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CElementalSystem@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CElementalSystem@@QAE@XZ$1
__ehfuncinfo$??0CElementalSystem@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CElementalSystem@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_ElementalSystem@@YAXXZ
text$yd	SEGMENT
??__Fg_ElementalSystem@@YAXXZ PROC			; `dynamic atexit destructor for 'g_ElementalSystem'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00005	e9 00 00 00 00	 jmp	 ??1CElementalSystem@@UAE@XZ ; CElementalSystem::~CElementalSystem
??__Fg_ElementalSystem@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_ElementalSystem''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ??__Eg_ElementalSystem@@YAXXZ
text$di	SEGMENT
??__Eg_ElementalSystem@@YAXXZ PROC			; `dynamic initializer for 'g_ElementalSystem'', COMDAT

; 26   : CElementalSystem g_ElementalSystem;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00005	e8 00 00 00 00	 call	 ??0CElementalSystem@@QAE@XZ ; CElementalSystem::CElementalSystem
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_ElementalSystem@@YAXXZ ; `dynamic atexit destructor for 'g_ElementalSystem''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_ElementalSystem@@YAXXZ ENDP			; `dynamic initializer for 'g_ElementalSystem''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\crywolf.h
;	COMDAT ?GetCrywolfState@CCrywolf@@QAEHXZ
_TEXT	SEGMENT
?GetCrywolfState@CCrywolf@@QAEHXZ PROC			; CCrywolf::GetCrywolfState, COMDAT
; _this$ = ecx

; 92   : 	int GetCrywolfState(){return this->m_iCrywolfState;}

  00000	8b 81 8c a8 0f
	00		 mov	 eax, DWORD PTR [ecx+1026188]
  00006	c3		 ret	 0
?GetCrywolfState@CCrywolf@@QAEHXZ ENDP			; CCrywolf::GetCrywolfState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\common\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	TokenString[0] = '\0';

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA, 0
  00017	53		 push	 ebx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetToken:

; 27   : 
; 28   : 	do
; 29   : 	{
; 30   : 		if( (ch = (char)fgetc(SMDFile)) == EOF )

  00020	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	0f 84 c0 02 00
	00		 je	 $LN41@GetToken

; 31   : 			return END;
; 32   : 			
; 33   : 		if( ch == '/' && ( ch = (char)fgetc(SMDFile) ) == '/' )	

  00039	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0003c	75 2a		 jne	 SHORT $LN2@GetToken
  0003e	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00044	e8 00 00 00 00	 call	 _fgetc
  00049	8a d8		 mov	 bl, al
  0004b	83 c4 04	 add	 esp, 4
  0004e	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00051	75 15		 jne	 SHORT $LN2@GetToken
$LL5@GetToken:

; 34   : 		{
; 35   : 			while( (ch = (char)fgetc(SMDFile)) != '\n' );

  00053	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00059	e8 00 00 00 00	 call	 _fgetc
  0005e	8a d8		 mov	 bl, al
  00060	83 c4 04	 add	 esp, 4
  00063	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00066	75 eb		 jne	 SHORT $LL5@GetToken
$LN2@GetToken:

; 36   : 		}
; 37   : 	} while( isspace(ch) );

  00068	0f be c3	 movsx	 eax, bl
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _isspace
  00071	83 c4 04	 add	 esp, 4
  00074	85 c0		 test	 eax, eax
  00076	75 a8		 jne	 SHORT $LL4@GetToken

; 38   : 	
; 39   : 	char *p, TempString[100];
; 40   : 
; 41   : 	switch(ch)

  00078	0f be cb	 movsx	 ecx, bl
  0007b	56		 push	 esi
  0007c	8d 41 de	 lea	 eax, DWORD PTR [ecx-34]
  0007f	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00082	0f 87 be 01 00
	00		 ja	 $LN29@GetToken
  00088	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN59@GetToken[eax]
  0008f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN66@GetToken[eax*4]
$LN19@GetToken:

; 42   : 	{	
; 43   : 	case '#':
; 44   : 		p = TokenString;
; 45   : 		while ( ( (ch = getc(SMDFile) ) != EOF) && (ch!='#'))// || isalnum(ch)) )

  00096	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0009c	be 00 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA
  000a1	e8 00 00 00 00	 call	 _getc
  000a6	83 c4 04	 add	 esp, 4
  000a9	3c ff		 cmp	 al, -1
  000ab	74 1c		 je	 SHORT $LN10@GetToken
  000ad	0f 1f 00	 npad	 3
$LL9@GetToken:
  000b0	3c 23		 cmp	 al, 35			; 00000023H
  000b2	74 2b		 je	 SHORT $LN20@GetToken
  000b4	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 46   : 			*p++ = ch;

  000ba	88 06		 mov	 BYTE PTR [esi], al
  000bc	46		 inc	 esi
  000bd	e8 00 00 00 00	 call	 _getc
  000c2	83 c4 04	 add	 esp, 4
  000c5	3c ff		 cmp	 al, -1
  000c7	75 e7		 jne	 SHORT $LL9@GetToken
$LN10@GetToken:

; 47   : 		if (ch!='#')

  000c9	3c 23		 cmp	 al, 35			; 00000023H
  000cb	74 12		 je	 SHORT $LN20@GetToken

; 48   : 			ungetc(ch,SMDFile);

  000cd	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000d3	0f be c0	 movsx	 eax, al
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _ungetc
  000dc	83 c4 08	 add	 esp, 8
$LN20@GetToken:

; 49   : 		*p = 0;

  000df	c6 06 00	 mov	 BYTE PTR [esi], 0

; 50   : 		return CurrentToken = COMMAND;

  000e2	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000e7	5e		 pop	 esi
  000e8	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  000f2	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f6	33 cd		 xor	 ecx, ebp
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN21@GetToken:
  00101	5e		 pop	 esi

; 51   : 	case ';':
; 52   : 		return CurrentToken = SEMICOLON;

  00102	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  0010c	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  00111	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN22@GetToken:
  00120	5e		 pop	 esi

; 53   : 	case ',':
; 54   : 		return CurrentToken = COMMA;

  00121	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  0012b	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  00130	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  00131	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00134	33 cd		 xor	 ecx, ebp
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
$LN23@GetToken:
  0013f	5e		 pop	 esi

; 55   : 	case '{':
; 56   : 		return CurrentToken = LP;

  00140	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0014a	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  0014f	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  00150	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
$LN24@GetToken:
  0015e	5e		 pop	 esi

; 57   : 	case '}':
; 58   : 		return CurrentToken = RP;

  0015f	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00169	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  0016e	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  0016f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00172	33 cd		 xor	 ecx, ebp
  00174	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
$LN25@GetToken:

; 59   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 60   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 61   : 	case '.':	case '-':
; 62   : 		ungetc(ch,SMDFile);

  0017d	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 _ungetc

; 63   : 		p = TempString;
; 64   : 		while ( (  (ch = getc(SMDFile) ) !=EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00189	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0018f	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  00192	e8 00 00 00 00	 call	 _getc
  00197	8a d8		 mov	 bl, al
  00199	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019c	80 fb ff	 cmp	 bl, -1
  0019f	74 32		 je	 SHORT $LN60@GetToken
$LL11@GetToken:
  001a1	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001a4	74 15		 je	 SHORT $LN26@GetToken
  001a6	0f be cb	 movsx	 ecx, bl
  001a9	51		 push	 ecx
  001aa	e8 00 00 00 00	 call	 _isdigit
  001af	83 c4 04	 add	 esp, 4
  001b2	85 c0		 test	 eax, eax
  001b4	75 05		 jne	 SHORT $LN26@GetToken
  001b6	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  001b9	75 18		 jne	 SHORT $LN60@GetToken
$LN26@GetToken:
  001bb	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 65   : 			*p++ = ch;

  001c1	88 1e		 mov	 BYTE PTR [esi], bl
  001c3	46		 inc	 esi
  001c4	e8 00 00 00 00	 call	 _getc
  001c9	8a d8		 mov	 bl, al
  001cb	83 c4 04	 add	 esp, 4
  001ce	80 fb ff	 cmp	 bl, -1
  001d1	75 ce		 jne	 SHORT $LL11@GetToken
$LN60@GetToken:

; 66   : 		*p = 0;
; 67   : 		TokenNumber = (float)atof(TempString);

  001d3	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  001d6	c6 06 00	 mov	 BYTE PTR [esi], 0
  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 _atof
  001df	83 c4 04	 add	 esp, 4

; 68   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 69   : 		return CurrentToken = NUMBER;

  001e2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  001ec	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA
  001f2	b8 01 00 00 00	 mov	 eax, 1
  001f7	5e		 pop	 esi
  001f8	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  001f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fc	33 cd		 xor	 ecx, ebp
  001fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
$LN27@GetToken:

; 70   : 	case '"':
; 71   : 		p = TokenString;
; 72   : 		while ( (  (ch = getc(SMDFile) ) !=EOF) && (ch!='"'))// || isalnum(ch)) )

  00207	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0020d	be 00 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA
  00212	e8 00 00 00 00	 call	 _getc
  00217	83 c4 04	 add	 esp, 4
  0021a	3c ff		 cmp	 al, -1
  0021c	74 1f		 je	 SHORT $LN14@GetToken
  0021e	66 90		 npad	 2
$LL13@GetToken:
  00220	3c 22		 cmp	 al, 34			; 00000022H
  00222	0f 84 93 00 00
	00		 je	 $LN28@GetToken
  00228	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 73   : 			*p++ = ch;

  0022e	88 06		 mov	 BYTE PTR [esi], al
  00230	46		 inc	 esi
  00231	e8 00 00 00 00	 call	 _getc
  00236	83 c4 04	 add	 esp, 4
  00239	3c ff		 cmp	 al, -1
  0023b	75 e3		 jne	 SHORT $LL13@GetToken
$LN14@GetToken:

; 74   : 		if (ch!='"')

  0023d	3c 22		 cmp	 al, 34			; 00000022H
  0023f	74 7a		 je	 SHORT $LN28@GetToken

; 75   : 			ungetc(ch,SMDFile);

  00241	0f be c0	 movsx	 eax, al

; 76   : 		*p = 0;
; 77   : 		return CurrentToken = NAME;

  00244	eb 66		 jmp	 SHORT $LN64@GetToken
$LN29@GetToken:

; 78   : 	default:
; 79   : 		if (isalpha(ch))	

  00246	51		 push	 ecx
  00247	e8 00 00 00 00	 call	 _isalpha
  0024c	83 c4 04	 add	 esp, 4
  0024f	85 c0		 test	 eax, eax
  00251	0f 84 83 00 00
	00		 je	 $LN30@GetToken

; 80   : 		{
; 81   : 			p = TokenString;
; 82   : 			*p++ = ch;
; 83   : 			while ( (  (ch = getc(SMDFile) ) !=EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  00257	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0025d	88 1d 00 00 00
	00		 mov	 BYTE PTR ?TokenString@@3PADA, bl
  00263	be 01 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA+1
  00268	e8 00 00 00 00	 call	 _getc
  0026d	8a d8		 mov	 bl, al
  0026f	83 c4 04	 add	 esp, 4
  00272	80 fb ff	 cmp	 bl, -1
  00275	74 32		 je	 SHORT $LN61@GetToken
$LL15@GetToken:
  00277	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  0027a	74 15		 je	 SHORT $LN31@GetToken
  0027c	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  0027f	74 10		 je	 SHORT $LN31@GetToken
  00281	0f be c3	 movsx	 eax, bl
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 _isalnum
  0028a	83 c4 04	 add	 esp, 4
  0028d	85 c0		 test	 eax, eax
  0028f	74 18		 je	 SHORT $LN61@GetToken
$LN31@GetToken:
  00291	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 84   : 				*p++ = ch;

  00297	88 1e		 mov	 BYTE PTR [esi], bl
  00299	46		 inc	 esi
  0029a	e8 00 00 00 00	 call	 _getc
  0029f	8a d8		 mov	 bl, al
  002a1	83 c4 04	 add	 esp, 4
  002a4	80 fb ff	 cmp	 bl, -1
  002a7	75 ce		 jne	 SHORT $LL15@GetToken
$LN61@GetToken:

; 85   : 			ungetc(ch,SMDFile);

  002a9	0f be c3	 movsx	 eax, bl
$LN64@GetToken:
  002ac	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 _ungetc
  002b8	83 c4 08	 add	 esp, 8
$LN28@GetToken:

; 86   : 			*p = 0;

  002bb	c6 06 00	 mov	 BYTE PTR [esi], 0

; 87   : 			return CurrentToken = NAME;

  002be	33 c0		 xor	 eax, eax
  002c0	5e		 pop	 esi
  002c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  002cb	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  002cc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cf	33 cd		 xor	 ecx, ebp
  002d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d6	8b e5		 mov	 esp, ebp
  002d8	5d		 pop	 ebp
  002d9	c3		 ret	 0
$LN30@GetToken:
  002da	5e		 pop	 esi

; 88   : 		}
; 89   : 		return CurrentToken = SMD_ERROR;

  002db	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  002e5	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  002ea	5b		 pop	 ebx

; 90   : 	}
; 91   : }

  002eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ee	33 cd		 xor	 ecx, ebp
  002f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f5	8b e5		 mov	 esp, ebp
  002f7	5d		 pop	 ebp
  002f8	c3		 ret	 0
$LN41@GetToken:
  002f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fc	b8 02 00 00 00	 mov	 eax, 2
  00301	33 cd		 xor	 ecx, ebp
  00303	5b		 pop	 ebx
  00304	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00309	8b e5		 mov	 esp, ebp
  0030b	5d		 pop	 ebp
  0030c	c3		 ret	 0
  0030d	0f 1f 00	 npad	 3
$LN66@GetToken:
  00310	00 00 00 00	 DD	 $LN27@GetToken
  00314	00 00 00 00	 DD	 $LN19@GetToken
  00318	00 00 00 00	 DD	 $LN22@GetToken
  0031c	00 00 00 00	 DD	 $LN25@GetToken
  00320	00 00 00 00	 DD	 $LN21@GetToken
  00324	00 00 00 00	 DD	 $LN23@GetToken
  00328	00 00 00 00	 DD	 $LN24@GetToken
  0032c	00 00 00 00	 DD	 $LN29@GetToken
$LN59@GetToken:
  00330	00		 DB	 0
  00331	01		 DB	 1
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	07		 DB	 7
  00336	07		 DB	 7
  00337	07		 DB	 7
  00338	07		 DB	 7
  00339	07		 DB	 7
  0033a	02		 DB	 2
  0033b	03		 DB	 3
  0033c	03		 DB	 3
  0033d	07		 DB	 7
  0033e	03		 DB	 3
  0033f	03		 DB	 3
  00340	03		 DB	 3
  00341	03		 DB	 3
  00342	03		 DB	 3
  00343	03		 DB	 3
  00344	03		 DB	 3
  00345	03		 DB	 3
  00346	03		 DB	 3
  00347	03		 DB	 3
  00348	07		 DB	 7
  00349	04		 DB	 4
  0034a	07		 DB	 7
  0034b	07		 DB	 7
  0034c	07		 DB	 7
  0034d	07		 DB	 7
  0034e	07		 DB	 7
  0034f	07		 DB	 7
  00350	07		 DB	 7
  00351	07		 DB	 7
  00352	07		 DB	 7
  00353	07		 DB	 7
  00354	07		 DB	 7
  00355	07		 DB	 7
  00356	07		 DB	 7
  00357	07		 DB	 7
  00358	07		 DB	 7
  00359	07		 DB	 7
  0035a	07		 DB	 7
  0035b	07		 DB	 7
  0035c	07		 DB	 7
  0035d	07		 DB	 7
  0035e	07		 DB	 7
  0035f	07		 DB	 7
  00360	07		 DB	 7
  00361	07		 DB	 7
  00362	07		 DB	 7
  00363	07		 DB	 7
  00364	07		 DB	 7
  00365	07		 DB	 7
  00366	07		 DB	 7
  00367	07		 DB	 7
  00368	07		 DB	 7
  00369	07		 DB	 7
  0036a	07		 DB	 7
  0036b	07		 DB	 7
  0036c	07		 DB	 7
  0036d	07		 DB	 7
  0036e	07		 DB	 7
  0036f	07		 DB	 7
  00370	07		 DB	 7
  00371	07		 DB	 7
  00372	07		 DB	 7
  00373	07		 DB	 7
  00374	07		 DB	 7
  00375	07		 DB	 7
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	07		 DB	 7
  0037f	07		 DB	 7
  00380	07		 DB	 7
  00381	07		 DB	 7
  00382	07		 DB	 7
  00383	07		 DB	 7
  00384	07		 DB	 7
  00385	07		 DB	 7
  00386	07		 DB	 7
  00387	07		 DB	 7
  00388	07		 DB	 7
  00389	05		 DB	 5
  0038a	07		 DB	 7
  0038b	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCElementalSystem@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCElementalSystem@@UAEPAXI@Z PROC			; CElementalSystem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CElementalSystem@@UAE@XZ ; CElementalSystem::~CElementalSystem
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 84 1a 00 00	 push	 6788			; 00001a84H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCElementalSystem@@UAEPAXI@Z ENDP			; CElementalSystem::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GDSaveErtelList@CElementalSystem@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -1428						; size = 1424
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDSaveErtelList@CElementalSystem@@QAEXH@Z PROC		; CElementalSystem::GDSaveErtelList, COMDAT
; _this$ = ecx

; 1948 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 05 00
	00		 sub	 esp, 1428		; 00000594H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 1949 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	69 f8 40 27 00
	00		 imul	 edi, eax, 10048

; 1950 : 	PMSG_SAVE_ERTELLIST pMsg;
; 1951 : 	PHeadSetW((LPBYTE)&pMsg,0xA5,sizeof(pMsg));

  0001e	8d 85 6c fa ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	68 90 05 00 00	 push	 1424			; 00000590H
  00029	68 a5 00 00 00	 push	 165			; 000000a5H
  0002e	50		 push	 eax
  0002f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 1952 : 
; 1953 : 	memcpy(pMsg.szAccount,lpObj->AccountID,10);

  0003a	f3 0f 7e 47 52	 movq	 xmm0, QWORD PTR [edi+82]
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	66 0f d6 85 70
	fa ff ff	 movq	 QWORD PTR _pMsg$[ebp+4], xmm0
  0004a	33 f6		 xor	 esi, esi
  0004c	0f b7 47 5a	 movzx	 eax, WORD PTR [edi+90]
  00050	66 89 85 78 fa
	ff ff		 mov	 WORD PTR _pMsg$[ebp+12], ax

; 1954 : 	memcpy(pMsg.szName,lpObj->Name,10);

  00057	f3 0f 7e 47 5d	 movq	 xmm0, QWORD PTR [edi+93]
  0005c	66 0f d6 85 7a
	fa ff ff	 movq	 QWORD PTR _pMsg$[ebp+14], xmm0
  00064	0f b7 47 65	 movzx	 eax, WORD PTR [edi+101]
  00068	66 89 85 82 fa
	ff ff		 mov	 WORD PTR _pMsg$[ebp+22], ax
  0006f	8d 85 85 fa ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+25]
  00075	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@GDSaveErte:

; 1958 : 
; 1959 : 		if( lpObj->pErtelList1[n].btType != (BYTE)-1 )

  00080	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  00086	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00089	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  0008c	74 7a		 je	 SHORT $LN5@GDSaveErte

; 1960 : 		{
; 1961 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELID] = lpObj->pErtelList1[n].btType;

  0008e	88 48 ff	 mov	 BYTE PTR [eax-1], cl

; 1962 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ATTRIBUTE] = lpObj->pErtelList1[n].btAttribute;

  00091	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  00097	8a 4c 31 01	 mov	 cl, BYTE PTR [ecx+esi+1]
  0009b	88 08		 mov	 BYTE PTR [eax], cl

; 1963 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1] = lpObj->pErtelList1[n].Level[0]*16 | lpObj->pErtelList1[n].Option[0];

  0009d	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000a3	0f b6 54 31 07	 movzx	 edx, BYTE PTR [ecx+esi+7]
  000a8	c0 e2 04	 shl	 dl, 4
  000ab	0a 54 31 02	 or	 dl, BYTE PTR [ecx+esi+2]
  000af	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 1964 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP2] = lpObj->pErtelList1[n].Level[1]*16 | lpObj->pErtelList1[n].Option[1];

  000b2	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000b8	0f b6 54 31 08	 movzx	 edx, BYTE PTR [ecx+esi+8]
  000bd	c0 e2 04	 shl	 dl, 4
  000c0	0a 54 31 03	 or	 dl, BYTE PTR [ecx+esi+3]
  000c4	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 1965 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP3] = lpObj->pErtelList1[n].Level[2]*16 | lpObj->pErtelList1[n].Option[2];

  000c7	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000cd	0f b6 54 31 09	 movzx	 edx, BYTE PTR [ecx+esi+9]
  000d2	c0 e2 04	 shl	 dl, 4
  000d5	0a 54 31 04	 or	 dl, BYTE PTR [ecx+esi+4]
  000d9	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 1966 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP4] = lpObj->pErtelList1[n].Level[3]*16 | lpObj->pErtelList1[n].Option[3];

  000dc	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000e2	0f b6 54 31 0a	 movzx	 edx, BYTE PTR [ecx+esi+10]
  000e7	c0 e2 04	 shl	 dl, 4
  000ea	0a 54 31 05	 or	 dl, BYTE PTR [ecx+esi+5]
  000ee	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 1967 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP5] = lpObj->pErtelList1[n].Level[4]*16 | lpObj->pErtelList1[n].Option[4];

  000f1	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000f7	0f b6 54 31 0b	 movzx	 edx, BYTE PTR [ecx+esi+11]
  000fc	c0 e2 04	 shl	 dl, 4
  000ff	0a 54 31 06	 or	 dl, BYTE PTR [ecx+esi+6]
  00103	88 50 05	 mov	 BYTE PTR [eax+5], dl

; 1968 : 		}
; 1969 : 		else

  00106	eb 11		 jmp	 SHORT $LN6@GDSaveErte
$LN5@GDSaveErte:

; 1970 : 		{
; 1971 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELID] = -1;

  00108	c7 40 ff ff ff
	ff ff		 mov	 DWORD PTR [eax-1], -1

; 1972 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ATTRIBUTE] = -1;
; 1973 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1] = -1;
; 1974 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP2] = -1;
; 1975 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP3] = -1;

  0010f	66 c7 40 03 ff
	ff		 mov	 WORD PTR [eax+3], 65535	; 0000ffffH

; 1976 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP4] = -1;
; 1977 : 			pMsg.ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP5] = -1;

  00115	c6 40 05 ff	 mov	 BYTE PTR [eax+5], 255	; 000000ffH
$LN6@GDSaveErte:

; 1978 : 		}
; 1979 : 
; 1980 : 		if( lpObj->pErtelList2[n].btType != (BYTE)-1 )

  00119	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  0011f	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00122	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00125	0f 84 90 00 00
	00		 je	 $LN7@GDSaveErte

; 1981 : 		{
; 1982 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELID] = lpObj->pErtelList2[n].btType;

  0012b	88 88 bb 02 00
	00		 mov	 BYTE PTR [eax+699], cl

; 1983 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ATTRIBUTE] = lpObj->pErtelList2[n].btAttribute;

  00131	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00137	8a 4c 0e 01	 mov	 cl, BYTE PTR [esi+ecx+1]
  0013b	88 88 bc 02 00
	00		 mov	 BYTE PTR [eax+700], cl

; 1984 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1] = lpObj->pErtelList2[n].Level[0]*16 | lpObj->pErtelList2[n].Option[0];

  00141	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00147	0f b6 54 0e 07	 movzx	 edx, BYTE PTR [esi+ecx+7]
  0014c	c0 e2 04	 shl	 dl, 4
  0014f	0a 54 0e 02	 or	 dl, BYTE PTR [esi+ecx+2]
  00153	88 90 bd 02 00
	00		 mov	 BYTE PTR [eax+701], dl

; 1985 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP2] = lpObj->pErtelList2[n].Level[1]*16 | lpObj->pErtelList2[n].Option[1];

  00159	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  0015f	0f b6 54 0e 08	 movzx	 edx, BYTE PTR [esi+ecx+8]
  00164	c0 e2 04	 shl	 dl, 4
  00167	0a 54 0e 03	 or	 dl, BYTE PTR [esi+ecx+3]
  0016b	88 90 be 02 00
	00		 mov	 BYTE PTR [eax+702], dl

; 1986 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP3] = lpObj->pErtelList2[n].Level[2]*16 | lpObj->pErtelList2[n].Option[2];

  00171	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00177	0f b6 54 0e 09	 movzx	 edx, BYTE PTR [esi+ecx+9]
  0017c	c0 e2 04	 shl	 dl, 4
  0017f	0a 54 0e 04	 or	 dl, BYTE PTR [esi+ecx+4]
  00183	88 90 bf 02 00
	00		 mov	 BYTE PTR [eax+703], dl

; 1987 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP4] = lpObj->pErtelList2[n].Level[3]*16 | lpObj->pErtelList2[n].Option[3];

  00189	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  0018f	0f b6 54 0e 0a	 movzx	 edx, BYTE PTR [esi+ecx+10]
  00194	c0 e2 04	 shl	 dl, 4
  00197	0a 54 0e 05	 or	 dl, BYTE PTR [esi+ecx+5]
  0019b	88 90 c0 02 00
	00		 mov	 BYTE PTR [eax+704], dl

; 1988 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP5] = lpObj->pErtelList2[n].Level[4]*16 | lpObj->pErtelList2[n].Option[4];

  001a1	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  001a7	0f b6 54 0e 0b	 movzx	 edx, BYTE PTR [esi+ecx+11]
  001ac	c0 e2 04	 shl	 dl, 4
  001af	0a 54 0e 06	 or	 dl, BYTE PTR [esi+ecx+6]
  001b3	88 90 c1 02 00
	00		 mov	 BYTE PTR [eax+705], dl

; 1989 : 		}
; 1990 : 		else

  001b9	eb 1a		 jmp	 SHORT $LN2@GDSaveErte
$LN7@GDSaveErte:

; 1991 : 		{
; 1992 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELID] = -1;

  001bb	c7 80 bb 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+699], -1

; 1993 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ATTRIBUTE] = -1;
; 1994 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1] = -1;
; 1995 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP2] = -1;
; 1996 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP3] = -1;

  001c5	66 c7 80 bf 02
	00 00 ff ff	 mov	 WORD PTR [eax+703], 65535 ; 0000ffffH

; 1997 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP4] = -1;
; 1998 : 			pMsg.ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP5] = -1;

  001ce	c6 80 c1 02 00
	00 ff		 mov	 BYTE PTR [eax+705], 255	; 000000ffH
$LN2@GDSaveErte:

; 1955 : 
; 1956 : 
; 1957 : 	for(int n = 0; n < MAX_ERTEL; n++)	{

  001d5	83 c6 0c	 add	 esi, 12			; 0000000cH
  001d8	83 c0 07	 add	 eax, 7
  001db	81 fe b0 04 00
	00		 cmp	 esi, 1200		; 000004b0H
  001e1	0f 8c 99 fe ff
	ff		 jl	 $LL4@GDSaveErte

; 1999 : 		}
; 2000 : 	}
; 2001 : 
; 2002 : 	cDBSMng.Send((PCHAR)&pMsg,sizeof(pMsg));

  001e7	68 90 05 00 00	 push	 1424			; 00000590H
  001ec	8d 85 6c fa ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  001f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2003 : }

  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	5f		 pop	 edi
  00201	33 cd		 xor	 ecx, ebp
  00203	5e		 pop	 esi
  00204	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 04 00	 ret	 4
?GDSaveErtelList@CElementalSystem@@QAEXH@Z ENDP		; CElementalSystem::GDSaveErtelList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?DGAnsErtelList@CElementalSystem@@QAEXPAUPMSG_ANS_ERTELLIST@@@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
_szName$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsErtelList@CElementalSystem@@QAEXPAUPMSG_ANS_ERTELLIST@@@Z PROC ; CElementalSystem::DGAnsErtelList, COMDAT
; _this$ = ecx

; 1900 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	89 4d ec	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1901 : 	if( lpMsg == NULL )

  00017	85 db		 test	 ebx, ebx
  00019	0f 84 c6 02 00
	00		 je	 $LN13@DGAnsErtel

; 1902 : 		return;
; 1903 : 
; 1904 : 	char szName[11];
; 1905 : 	int aIndex = lpMsg->aIndex;
; 1906 : 
; 1907 : 	memcpy(szName,lpMsg->szName,10);

  0001f	f3 0f 7e 43 08	 movq	 xmm0, QWORD PTR [ebx+8]
  00024	66 8b 43 10	 mov	 ax, WORD PTR [ebx+16]
  00028	56		 push	 esi
  00029	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]

; 1908 : 	szName[10] = '\0';
; 1909 : 	
; 1910 : 
; 1911 : 	if( !gObjIsConnected(aIndex) || strcmp(szName,gObj[aIndex].Name) )

  0002c	56		 push	 esi
  0002d	66 0f d6 45 f0	 movq	 QWORD PTR _szName$[ebp], xmm0
  00032	66 89 45 f8	 mov	 WORD PTR _szName$[ebp+8], ax
  00036	c6 45 fa 00	 mov	 BYTE PTR _szName$[ebp+10], 0
  0003a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003f	83 c4 04	 add	 esp, 4
  00042	85 c0		 test	 eax, eax
  00044	0f 84 9a 02 00
	00		 je	 $LN45@DGAnsErtel
  0004a	57		 push	 edi
  0004b	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00051	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00054	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  0005d	0f 1f 00	 npad	 3
$LL41@DGAnsErtel:
  00060	8a 10		 mov	 dl, BYTE PTR [eax]
  00062	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00064	75 1a		 jne	 SHORT $LN42@DGAnsErtel
  00066	84 d2		 test	 dl, dl
  00068	74 12		 je	 SHORT $LN43@DGAnsErtel
  0006a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00070	75 0e		 jne	 SHORT $LN42@DGAnsErtel
  00072	83 c0 02	 add	 eax, 2
  00075	83 c1 02	 add	 ecx, 2
  00078	84 d2		 test	 dl, dl
  0007a	75 e4		 jne	 SHORT $LL41@DGAnsErtel
$LN43@DGAnsErtel:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN44@DGAnsErtel
$LN42@DGAnsErtel:
  00080	1b c0		 sbb	 eax, eax
  00082	83 c8 01	 or	 eax, 1
$LN44@DGAnsErtel:
  00085	85 c0		 test	 eax, eax
  00087	0f 85 56 02 00
	00		 jne	 $LN46@DGAnsErtel

; 1912 : 		return;
; 1913 : 
; 1914 : 	LPOBJ lpObj = &gObj[aIndex];

  0008d	33 f6		 xor	 esi, esi
  0008f	8d 43 12	 lea	 eax, DWORD PTR [ebx+18]
$LL4@DGAnsErtel:

; 1917 : 
; 1918 : 		if( lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELID] != (BYTE)-1 )

  00092	8a 10		 mov	 dl, BYTE PTR [eax]
  00094	80 fa ff	 cmp	 dl, 255			; 000000ffH
  00097	0f 84 f2 00 00
	00		 je	 $LN28@DGAnsErtel

; 1919 : 		{
; 1920 : 			lpObj->pErtelList1[n].btType = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELID];

  0009d	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000a3	88 14 0e	 mov	 BYTE PTR [esi+ecx], dl

; 1921 : 			lpObj->pErtelList1[n].btAttribute = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ATTRIBUTE];

  000a6	8b 97 dc 26 00
	00		 mov	 edx, DWORD PTR [edi+9948]
  000ac	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000af	88 4c 16 01	 mov	 BYTE PTR [esi+edx+1], cl

; 1922 : 
; 1923 : 			for(int i = 0; i < 5; i++)	{
; 1924 : 				lpObj->pErtelList1[n].Option[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  000b3	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]
  000b7	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  000bd	79 05		 jns	 SHORT $LN47@DGAnsErtel
  000bf	4a		 dec	 edx
  000c0	83 ca f0	 or	 edx, -16		; fffffff0H
  000c3	42		 inc	 edx
$LN47@DGAnsErtel:
  000c4	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000ca	88 54 0e 02	 mov	 BYTE PTR [esi+ecx+2], dl

; 1925 : 				lpObj->pErtelList1[n].Level[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  000ce	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]
  000d2	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000d8	c0 ea 04	 shr	 dl, 4
  000db	88 54 0e 07	 mov	 BYTE PTR [esi+ecx+7], dl
  000df	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  000e3	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  000e9	79 05		 jns	 SHORT $LN48@DGAnsErtel

; 1922 : 
; 1923 : 			for(int i = 0; i < 5; i++)	{
; 1924 : 				lpObj->pErtelList1[n].Option[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  000eb	4a		 dec	 edx
  000ec	83 ca f0	 or	 edx, -16		; fffffff0H
  000ef	42		 inc	 edx
$LN48@DGAnsErtel:
  000f0	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  000f6	88 54 0e 03	 mov	 BYTE PTR [esi+ecx+3], dl

; 1925 : 				lpObj->pErtelList1[n].Level[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  000fa	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  000fe	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  00104	c0 ea 04	 shr	 dl, 4
  00107	88 54 0e 08	 mov	 BYTE PTR [esi+ecx+8], dl
  0010b	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0010f	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00115	79 05		 jns	 SHORT $LN49@DGAnsErtel

; 1922 : 
; 1923 : 			for(int i = 0; i < 5; i++)	{
; 1924 : 				lpObj->pErtelList1[n].Option[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  00117	4a		 dec	 edx
  00118	83 ca f0	 or	 edx, -16		; fffffff0H
  0011b	42		 inc	 edx
$LN49@DGAnsErtel:
  0011c	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  00122	88 54 0e 04	 mov	 BYTE PTR [esi+ecx+4], dl

; 1925 : 				lpObj->pErtelList1[n].Level[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  00126	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0012a	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  00130	c0 ea 04	 shr	 dl, 4
  00133	88 54 0e 09	 mov	 BYTE PTR [esi+ecx+9], dl
  00137	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  0013b	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00141	79 05		 jns	 SHORT $LN50@DGAnsErtel

; 1922 : 
; 1923 : 			for(int i = 0; i < 5; i++)	{
; 1924 : 				lpObj->pErtelList1[n].Option[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  00143	4a		 dec	 edx
  00144	83 ca f0	 or	 edx, -16		; fffffff0H
  00147	42		 inc	 edx
$LN50@DGAnsErtel:
  00148	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  0014e	88 54 0e 05	 mov	 BYTE PTR [esi+ecx+5], dl

; 1925 : 				lpObj->pErtelList1[n].Level[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  00152	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00156	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  0015c	c0 ea 04	 shr	 dl, 4
  0015f	88 54 0e 0a	 mov	 BYTE PTR [esi+ecx+10], dl
  00163	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00167	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0016d	79 05		 jns	 SHORT $LN51@DGAnsErtel

; 1922 : 
; 1923 : 			for(int i = 0; i < 5; i++)	{
; 1924 : 				lpObj->pErtelList1[n].Option[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  0016f	4a		 dec	 edx
  00170	83 ca f0	 or	 edx, -16		; fffffff0H
  00173	42		 inc	 edx
$LN51@DGAnsErtel:
  00174	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  0017a	88 54 0e 06	 mov	 BYTE PTR [esi+ecx+6], dl

; 1925 : 				lpObj->pErtelList1[n].Level[i] = lpMsg->ErtelList1[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  0017e	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00182	8b 8f dc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9948]
  00188	c0 ea 04	 shr	 dl, 4
  0018b	88 54 0e 0b	 mov	 BYTE PTR [esi+ecx+11], dl
$LN28@DGAnsErtel:

; 1926 : 			}
; 1927 : 		}
; 1928 : 
; 1929 : 		if( lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELID] != (BYTE)-1 )

  0018f	8a 90 bc 02 00
	00		 mov	 dl, BYTE PTR [eax+700]
  00195	80 fa ff	 cmp	 dl, 255			; 000000ffH
  00198	0f 84 13 01 00
	00		 je	 $LN2@DGAnsErtel

; 1930 : 		{
; 1931 : 			lpObj->pErtelList2[n].btType = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELID];

  0019e	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  001a4	88 14 0e	 mov	 BYTE PTR [esi+ecx], dl

; 1932 : 			lpObj->pErtelList2[n].btAttribute = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ATTRIBUTE];

  001a7	8b 97 e0 26 00
	00		 mov	 edx, DWORD PTR [edi+9952]
  001ad	8a 88 bd 02 00
	00		 mov	 cl, BYTE PTR [eax+701]
  001b3	88 4c 32 01	 mov	 BYTE PTR [edx+esi+1], cl

; 1933 : 
; 1934 : 			for(int i = 0; i < 5; i++)	{
; 1935 : 				lpObj->pErtelList2[n].Option[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  001b7	0f b6 90 be 02
	00 00		 movzx	 edx, BYTE PTR [eax+702]
  001be	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  001c4	79 05		 jns	 SHORT $LN52@DGAnsErtel
  001c6	4a		 dec	 edx
  001c7	83 ca f0	 or	 edx, -16		; fffffff0H
  001ca	42		 inc	 edx
$LN52@DGAnsErtel:
  001cb	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  001d1	88 54 31 02	 mov	 BYTE PTR [ecx+esi+2], dl

; 1936 : 				lpObj->pErtelList2[n].Level[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  001d5	0f b6 90 be 02
	00 00		 movzx	 edx, BYTE PTR [eax+702]
  001dc	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  001e2	c0 ea 04	 shr	 dl, 4
  001e5	88 54 31 07	 mov	 BYTE PTR [ecx+esi+7], dl
  001e9	0f b6 90 bf 02
	00 00		 movzx	 edx, BYTE PTR [eax+703]
  001f0	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  001f6	79 05		 jns	 SHORT $LN53@DGAnsErtel

; 1933 : 
; 1934 : 			for(int i = 0; i < 5; i++)	{
; 1935 : 				lpObj->pErtelList2[n].Option[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  001f8	4a		 dec	 edx
  001f9	83 ca f0	 or	 edx, -16		; fffffff0H
  001fc	42		 inc	 edx
$LN53@DGAnsErtel:
  001fd	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00203	88 54 31 03	 mov	 BYTE PTR [ecx+esi+3], dl

; 1936 : 				lpObj->pErtelList2[n].Level[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  00207	0f b6 90 bf 02
	00 00		 movzx	 edx, BYTE PTR [eax+703]
  0020e	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00214	c0 ea 04	 shr	 dl, 4
  00217	88 54 31 08	 mov	 BYTE PTR [ecx+esi+8], dl
  0021b	0f b6 90 c0 02
	00 00		 movzx	 edx, BYTE PTR [eax+704]
  00222	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00228	79 05		 jns	 SHORT $LN54@DGAnsErtel

; 1933 : 
; 1934 : 			for(int i = 0; i < 5; i++)	{
; 1935 : 				lpObj->pErtelList2[n].Option[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  0022a	4a		 dec	 edx
  0022b	83 ca f0	 or	 edx, -16		; fffffff0H
  0022e	42		 inc	 edx
$LN54@DGAnsErtel:
  0022f	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00235	88 54 31 04	 mov	 BYTE PTR [ecx+esi+4], dl

; 1936 : 				lpObj->pErtelList2[n].Level[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  00239	0f b6 90 c0 02
	00 00		 movzx	 edx, BYTE PTR [eax+704]
  00240	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00246	c0 ea 04	 shr	 dl, 4
  00249	88 54 31 09	 mov	 BYTE PTR [ecx+esi+9], dl
  0024d	0f b6 90 c1 02
	00 00		 movzx	 edx, BYTE PTR [eax+705]
  00254	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0025a	79 05		 jns	 SHORT $LN55@DGAnsErtel

; 1933 : 
; 1934 : 			for(int i = 0; i < 5; i++)	{
; 1935 : 				lpObj->pErtelList2[n].Option[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  0025c	4a		 dec	 edx
  0025d	83 ca f0	 or	 edx, -16		; fffffff0H
  00260	42		 inc	 edx
$LN55@DGAnsErtel:
  00261	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00267	88 54 31 05	 mov	 BYTE PTR [ecx+esi+5], dl

; 1936 : 				lpObj->pErtelList2[n].Level[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  0026b	0f b6 90 c1 02
	00 00		 movzx	 edx, BYTE PTR [eax+705]
  00272	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00278	c0 ea 04	 shr	 dl, 4
  0027b	88 54 31 0a	 mov	 BYTE PTR [ecx+esi+10], dl
  0027f	0f b6 90 c2 02
	00 00		 movzx	 edx, BYTE PTR [eax+706]
  00286	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0028c	79 05		 jns	 SHORT $LN56@DGAnsErtel

; 1933 : 
; 1934 : 			for(int i = 0; i < 5; i++)	{
; 1935 : 				lpObj->pErtelList2[n].Option[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]%16;

  0028e	4a		 dec	 edx
  0028f	83 ca f0	 or	 edx, -16		; fffffff0H
  00292	42		 inc	 edx
$LN56@DGAnsErtel:
  00293	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  00299	88 54 31 06	 mov	 BYTE PTR [ecx+esi+6], dl

; 1936 : 				lpObj->pErtelList2[n].Level[i] = lpMsg->ErtelList2[DB_ERTELSIZE*n+DB_ERTELOP1+i]/16;

  0029d	0f b6 90 c2 02
	00 00		 movzx	 edx, BYTE PTR [eax+706]
  002a4	8b 8f e0 26 00
	00		 mov	 ecx, DWORD PTR [edi+9952]
  002aa	c0 ea 04	 shr	 dl, 4
  002ad	88 54 31 0b	 mov	 BYTE PTR [ecx+esi+11], dl
$LN2@DGAnsErtel:

; 1915 : 
; 1916 : 	for(int n = 0; n < MAX_ERTEL; n++)	{

  002b1	83 c6 0c	 add	 esi, 12			; 0000000cH
  002b4	83 c0 07	 add	 eax, 7
  002b7	81 fe b0 04 00
	00		 cmp	 esi, 1200		; 000004b0H
  002bd	0f 8c cf fd ff
	ff		 jl	 $LL4@DGAnsErtel

; 1937 : 			}
; 1938 : 		}
; 1939 : 	}
; 1940 : 
; 1941 : 	gObjCalCharacter(lpObj->m_Index);

  002c3	ff 37		 push	 DWORD PTR [edi]
  002c5	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 1942 : 
; 1943 : 	SendElementalItems(lpObj,ERTEL_INVENTORY);

  002ca	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  002cd	83 c4 04	 add	 esp, 4
  002d0	6a 00		 push	 0
  002d2	57		 push	 edi
  002d3	e8 00 00 00 00	 call	 ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems

; 1944 : 	SendElementalItems(lpObj,ERTEL_WAREHOUSE);

  002d8	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  002db	6a 01		 push	 1
  002dd	57		 push	 edi
  002de	e8 00 00 00 00	 call	 ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems
$LN46@DGAnsErtel:
  002e3	5f		 pop	 edi
$LN45@DGAnsErtel:
  002e4	5e		 pop	 esi
$LN13@DGAnsErtel:

; 1945 : }

  002e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e8	33 cd		 xor	 ecx, ebp
  002ea	5b		 pop	 ebx
  002eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c2 04 00	 ret	 4
?DGAnsErtelList@CElementalSystem@@QAEXPAUPMSG_ANS_ERTELLIST@@@Z ENDP ; CElementalSystem::DGAnsErtelList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GDReqErtelList@CElementalSystem@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqErtelList@CElementalSystem@@QAEXH@Z PROC		; CElementalSystem::GDReqErtelList, COMDAT
; _this$ = ecx

; 1888 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 1889 : 	PMSG_REQ_ERTELLIST pMsg;
; 1890 : 	PHeadSetB((LPBYTE)&pMsg,0xA4,sizeof(pMsg));

  00014	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 1c		 push	 28			; 0000001cH
  00019	68 a4 00 00 00	 push	 164			; 000000a4H
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1891 : 
; 1892 : 	pMsg.aIndex = aIndex;
; 1893 : 	memcpy(pMsg.szAccount,gObj[aIndex].AccountID,10);

  00024	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	89 75 e4	 mov	 DWORD PTR _pMsg$[ebp+4], esi

; 1894 : 	memcpy(pMsg.szName,gObj[aIndex].Name,10);
; 1895 : 
; 1896 : 	cDBSMng.Send((PCHAR)&pMsg,sizeof(pMsg));

  00030	6a 1c		 push	 28			; 0000001cH
  00032	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  0003d	66 0f d6 45 e8	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  00042	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00046	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+16], ax
  0004a	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  0004f	66 0f d6 45 f2	 movq	 QWORD PTR _pMsg$[ebp+18], xmm0
  00054	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0005d	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+26], ax
  00061	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 1897 : }

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	5e		 pop	 esi
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?GDReqErtelList@CElementalSystem@@QAEXH@Z ENDP		; CElementalSystem::GDReqErtelList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?PentagramMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iHarmonyCount$1$ = -36					; size = 4
_iPentagramCount$1$ = -32				; size = 4
_SocketBonus$1 = -32					; size = 1
_pMsg$ = -28						; size = 16
_iPentagramLuckyCharmRate$1$ = -12			; size = 4
_Type$2 = -12						; size = 4
_SocketOption$3 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?PentagramMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CElementalSystem::PentagramMix, COMDAT
; _this$ = ecx

; 3458 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 3459 : 	lpObj->ChaosLock = TRUE;
; 3460 : 
; 3461 : 	PMSG_CHAOSMIXRESULT pMsg;
; 3462 : 
; 3463 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00015	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00018	57		 push	 edi
  00019	6a 10		 push	 16			; 00000010H
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	50		 push	 eax
  00021	c7 86 20 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4640], 1
  0002b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3464 : 	pMsg.Result = ELEMENTAL_IMPROPER;
; 3465 : 
; 3466 : 	int iPentagramCount = 0;
; 3467 : 	int iHarmonyCount = 0;
; 3468 : 	int iOtherItemCount = 0;
; 3469 : 	int iPentagramLuckyCharm = 0;
; 3470 : 	int iPentagramLuckyCharmRate = 0;

  00030	33 c0		 xor	 eax, eax
  00032	c6 45 e7 fb	 mov	 BYTE PTR _pMsg$[ebp+3], 251 ; 000000fbH
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iPentagramCount$1$[ebp], 0
  00040	33 db		 xor	 ebx, ebx
  00042	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iHarmonyCount$1$[ebp], 0
  00049	89 45 f4	 mov	 DWORD PTR _iPentagramLuckyCharmRate$1$[ebp], eax
  0004c	33 ff		 xor	 edi, edi
  0004e	66 90		 npad	 2
$LL4@PentagramM:

; 3473 : 	{
; 3474 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 5e		 jne	 SHORT $LN32@PentagramM

; 3475 : 		{
; 3476 : 			if ( lpObj->pChaosBox[n].m_Type >= ITEMGET(12,200) &&

  00062	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  00068	b9 c8 18 00 00	 mov	 ecx, 6344		; 000018c8H
  0006d	0f b7 44 38 06	 movzx	 eax, WORD PTR [eax+edi+6]
  00072	66 3b c1	 cmp	 ax, cx
  00075	7c 13		 jl	 SHORT $LN8@PentagramM
  00077	b9 d6 18 00 00	 mov	 ecx, 6358		; 000018d6H
  0007c	66 3b c1	 cmp	 ax, cx
  0007f	7f 09		 jg	 SHORT $LN8@PentagramM

; 3477 : 				 lpObj->pChaosBox[n].m_Type <= ITEMGET(12,214) )
; 3478 : 			{
; 3479 : 				iPentagramCount++;

  00081	8b 4d e0	 mov	 ecx, DWORD PTR _iPentagramCount$1$[ebp]
  00084	41		 inc	 ecx
  00085	89 4d e0	 mov	 DWORD PTR _iPentagramCount$1$[ebp], ecx
  00088	eb 39		 jmp	 SHORT $LN35@PentagramM
$LN8@PentagramM:

; 3480 : 			}
; 3481 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,42) )

  0008a	b9 2a 1c 00 00	 mov	 ecx, 7210		; 00001c2aH
  0008f	66 3b c1	 cmp	 ax, cx
  00092	75 0c		 jne	 SHORT $LN10@PentagramM

; 3482 : 			{
; 3483 : 				iHarmonyCount++;

  00094	8b 45 dc	 mov	 eax, DWORD PTR _iHarmonyCount$1$[ebp]
  00097	8b 4d e0	 mov	 ecx, DWORD PTR _iPentagramCount$1$[ebp]
  0009a	40		 inc	 eax
  0009b	89 45 dc	 mov	 DWORD PTR _iHarmonyCount$1$[ebp], eax
  0009e	eb 26		 jmp	 SHORT $LN2@PentagramM
$LN10@PentagramM:

; 3484 : 			}
; 3485 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14, 189) )

  000a0	b9 bd 1c 00 00	 mov	 ecx, 7357		; 00001cbdH
  000a5	66 3b c1	 cmp	 ax, cx

; 3489 : 			}
; 3490 : 			else

  000a8	8b 4d e0	 mov	 ecx, DWORD PTR _iPentagramCount$1$[ebp]
  000ab	75 10		 jne	 SHORT $LN12@PentagramM

; 3486 : 			{
; 3487 : 				iPentagramLuckyCharm++;
; 3488 : 				iPentagramLuckyCharmRate = ItemAttribute[lpObj->pChaosBox[n].m_Type].Level; 

  000ad	98		 cwde
  000ae	6b c0 70	 imul	 eax, eax, 112
  000b1	0f b6 80 22 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  000b8	89 45 f4	 mov	 DWORD PTR _iPentagramLuckyCharmRate$1$[ebp], eax

; 3489 : 			}
; 3490 : 			else

  000bb	eb 06		 jmp	 SHORT $LN35@PentagramM
$LN12@PentagramM:

; 3491 : 			{
; 3492 : 				iOtherItemCount++;

  000bd	43		 inc	 ebx
  000be	eb 03		 jmp	 SHORT $LN35@PentagramM
$LN32@PentagramM:
  000c0	8b 4d e0	 mov	 ecx, DWORD PTR _iPentagramCount$1$[ebp]
$LN35@PentagramM:
  000c3	8b 45 dc	 mov	 eax, DWORD PTR _iHarmonyCount$1$[ebp]
$LN2@PentagramM:

; 3471 : 
; 3472 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000c6	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000cc	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  000d2	0f 8c 78 ff ff
	ff		 jl	 $LL4@PentagramM

; 3493 : 			}
; 3494 : 		}
; 3495 : 	}
; 3496 : 
; 3497 : 	if( iPentagramCount != 1 ||
; 3498 : 		iHarmonyCount != 1 ||

  000d8	83 f9 01	 cmp	 ecx, 1
  000db	75 73		 jne	 SHORT $LN15@PentagramM
  000dd	3b c1		 cmp	 eax, ecx
  000df	75 6f		 jne	 SHORT $LN15@PentagramM
  000e1	85 db		 test	 ebx, ebx
  000e3	75 6b		 jne	 SHORT $LN15@PentagramM

; 3504 : 
; 3505 : 		return;
; 3506 : 	}
; 3507 : 
; 3508 : 	g_ChaosBox.LogChaosItem(lpObj, "Pentagram Refine");

  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MGODOAMM@Pentagram?5Refine?$AA@
  000ea	56		 push	 esi
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  000f0	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 3509 : 	LogAddTD("[Elemental System] Pentagram Refine Start");

  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GCKAIEKG@?$FLElemental?5System?$FN?5Pentagram?5Ref@
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3510 : 
; 3511 : 	lpObj->ChaosSuccessRate = 50;
; 3512 : 	lpObj->ChaosSuccessRate += iPentagramLuckyCharmRate;

  00100	8b 45 f4	 mov	 eax, DWORD PTR _iPentagramLuckyCharmRate$1$[ebp]
  00103	83 c4 04	 add	 esp, 4
  00106	83 c0 32	 add	 eax, 50			; 00000032H

; 3513 : //	LogAddC(2, "[DEBUG] Rate3: %d", iPentagramLuckyCharmRate);
; 3514 : 
; 3515 : 	int nChaosNeedMoney = 100000;
; 3516 : 
; 3517 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0010e	89 86 1c 12 00
	00		 mov	 DWORD PTR [esi+4636], eax
  00114	ff 36		 push	 DWORD PTR [esi]
  00116	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  0011b	8b c8		 mov	 ecx, eax
  0011d	b8 a0 86 01 00	 mov	 eax, 100000		; 000186a0H
  00122	f7 e9		 imul	 ecx
  00124	53		 push	 ebx
  00125	6a 64		 push	 100			; 00000064H
  00127	52		 push	 edx
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 __alldiv
  0012e	8b c8		 mov	 ecx, eax

; 3518 : 
; 3519 : 	if ( iChaosTaxMoney < 0 )

  00130	33 c0		 xor	 eax, eax
  00132	85 c9		 test	 ecx, ecx
  00134	0f 48 c8	 cmovs	 ecx, eax

; 3520 : 	{
; 3521 : 		iChaosTaxMoney = 0;
; 3522 : 	}
; 3523 : 
; 3524 : 	nChaosNeedMoney += iChaosTaxMoney;

  00137	8d 99 a0 86 01
	00		 lea	 ebx, DWORD PTR [ecx+100000]

; 3525 : 
; 3526 : 	if ( nChaosNeedMoney < 0 )

  0013d	85 db		 test	 ebx, ebx
  0013f	0f 48 d8	 cmovs	 ebx, eax

; 3527 : 	{
; 3528 : 		nChaosNeedMoney = 0;
; 3529 : 	}
; 3530 : 
; 3531 : 	if ( lpObj->Money < nChaosNeedMoney )

  00142	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00148	3b c3		 cmp	 eax, ebx
  0014a	7d 34		 jge	 SHORT $LN18@PentagramM

; 3532 : 	{
; 3533 : 		pMsg.Result = ELEMENTAL_NOZEN;

  0014c	c6 45 e7 f9	 mov	 BYTE PTR _pMsg$[ebp+3], 249 ; 000000f9H
$LN15@PentagramM:

; 3499 : 		iOtherItemCount != 0 )
; 3500 : 
; 3501 : 	{
; 3502 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00150	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00154	50		 push	 eax
  00155	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00158	50		 push	 eax
  00159	ff 36		 push	 DWORD PTR [esi]
  0015b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@PentagramM:

; 3503 : 		lpObj->ChaosLock = FALSE;

  00163	5f		 pop	 edi
  00164	c7 86 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4640], 0
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx

; 3597 : 	}
; 3598 : }

  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c2 04 00	 ret	 4
$LN18@PentagramM:

; 3534 : 		
; 3535 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 3536 : 		lpObj->ChaosLock = FALSE;
; 3537 : 		return;
; 3538 : 	}
; 3539 : 
; 3540 : 	lpObj->Money -= nChaosNeedMoney;

  00180	2b c3		 sub	 eax, ebx

; 3541 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  00182	51		 push	 ecx
  00183	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00188	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0018e	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 3542 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00193	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00199	ff 36		 push	 DWORD PTR [esi]
  0019b	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  001a0	83 c4 08	 add	 esp, 8

; 3543 : 
; 3544 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  001a3	e8 00 00 00 00	 call	 _rand
  001a8	99		 cdq
  001a9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001ae	f7 f9		 idiv	 ecx
  001b0	3b 96 1c 12 00
	00		 cmp	 edx, DWORD PTR [esi+4636]
  001b6	0f 8d e2 00 00
	00		 jge	 $LN19@PentagramM

; 3545 : 	{
; 3546 : 		BYTE SocketBonus = -1;

  001bc	c6 45 e0 ff	 mov	 BYTE PTR _SocketBonus$1[ebp], 255 ; 000000ffH

; 3547 : 		BYTE SocketOption[5] = {-1};

  001c0	c6 45 f4 ff	 mov	 BYTE PTR _SocketOption$3[ebp], 255 ; 000000ffH
  001c4	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _SocketOption$3[ebp+1], 0

; 3548 : 
; 3549 : 		int _r = rand()%5;

  001cb	e8 00 00 00 00	 call	 _rand
  001d0	99		 cdq
  001d1	b9 05 00 00 00	 mov	 ecx, 5
  001d6	f7 f9		 idiv	 ecx

; 3550 : 
; 3551 : 		int Type;
; 3552 : 
; 3553 : 		switch( _r )

  001d8	83 fa 04	 cmp	 edx, 4
  001db	77 56		 ja	 SHORT $LN31@PentagramM
  001dd	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN38@PentagramM[edx*4]
$LN21@PentagramM:

; 3554 : 		{
; 3555 : 		case 0:
; 3556 : 			Type = ITEMGET(12,144);

  001e4	bf 90 18 00 00	 mov	 edi, 6288		; 00001890H

; 3557 : 			SocketBonus = 1+rand()%4;

  001e9	e8 00 00 00 00	 call	 _rand
  001ee	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  001f3	79 05		 jns	 SHORT $LN33@PentagramM
  001f5	48		 dec	 eax
  001f6	83 c8 fc	 or	 eax, -4			; fffffffcH
  001f9	40		 inc	 eax
$LN33@PentagramM:
  001fa	fe c0		 inc	 al
  001fc	88 45 e0	 mov	 BYTE PTR _SocketBonus$1[ebp], al

; 3558 : 			break;

  001ff	eb 35		 jmp	 SHORT $LN5@PentagramM
$LN22@PentagramM:

; 3559 : 		case 1:
; 3560 : 			Type = ITEMGET(12,145);

  00201	bf 91 18 00 00	 mov	 edi, 6289		; 00001891H

; 3561 : 			SocketBonus = 1+rand()%4;

  00206	e8 00 00 00 00	 call	 _rand
  0020b	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00210	79 e8		 jns	 SHORT $LN33@PentagramM
  00212	48		 dec	 eax
  00213	83 c8 fc	 or	 eax, -4			; fffffffcH
  00216	40		 inc	 eax
  00217	fe c0		 inc	 al
  00219	88 45 e0	 mov	 BYTE PTR _SocketBonus$1[ebp], al

; 3562 : 			break;

  0021c	eb 18		 jmp	 SHORT $LN5@PentagramM
$LN23@PentagramM:

; 3563 : 		case 2:
; 3564 : 			Type = ITEMGET(12,146);

  0021e	bf 92 18 00 00	 mov	 edi, 6290		; 00001892H

; 3565 : 			break;

  00223	eb 11		 jmp	 SHORT $LN5@PentagramM
$LN24@PentagramM:

; 3566 : 		case 3:
; 3567 : 			Type = ITEMGET(12,147);

  00225	bf 93 18 00 00	 mov	 edi, 6291		; 00001893H

; 3568 : 			break;

  0022a	eb 0a		 jmp	 SHORT $LN5@PentagramM
$LN25@PentagramM:

; 3569 : 		case 4:
; 3570 : 			Type = ITEMGET(12,150);

  0022c	bf 96 18 00 00	 mov	 edi, 6294		; 00001896H
  00231	eb 03		 jmp	 SHORT $LN5@PentagramM
$LN31@PentagramM:
  00233	8b 7d f4	 mov	 edi, DWORD PTR _Type$2[ebp]
$LN5@PentagramM:

; 3571 : 			break;
; 3572 : 		}
; 3573 : 
; 3574 : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, Type , 0, 0, 0, 0, 0, -1, 0, 0,SocketBonus,SocketOption);

  00236	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$3[ebp]
  00239	50		 push	 eax
  0023a	ff 75 e0	 push	 DWORD PTR _SocketBonus$1[ebp]
  0023d	6a 00		 push	 0
  0023f	6a 00		 push	 0
  00241	6a ff		 push	 -1
  00243	6a 00		 push	 0
  00245	6a 00		 push	 0
  00247	6a 00		 push	 0
  00249	6a 00		 push	 0
  0024b	6a 00		 push	 0
  0024d	57		 push	 edi
  0024e	6a 00		 push	 0
  00250	6a 00		 push	 0
  00252	68 ff 00 00 00	 push	 255			; 000000ffH
  00257	ff 36		 push	 DWORD PTR [esi]
  00259	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3575 : 		::gObjInventoryCommit(lpObj->m_Index);

  0025e	ff 36		 push	 DWORD PTR [esi]
  00260	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00265	83 c4 40	 add	 esp, 64			; 00000040H

; 3576 : #if( __4GAMERS__ == 1 )
; 3577 : 			g_Achievements.GD_UpdateMixData(lpObj, true);
; 3578 : #endif
; 3579 : 		LogAddTD("[Elemental System][Pentagram Refine] [%s][%s] CBMix Success %d Money : %d-%d",

  00268	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0026b	53		 push	 ebx
  0026c	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00272	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  00278	50		 push	 eax
  00279	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0027c	50		 push	 eax
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@KOCLEMN@?$FLElemental?5System?$FN?$FLPentagram?5Ref@
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3597 : 	}
; 3598 : }

  00288	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028b	83 c4 18	 add	 esp, 24			; 00000018H
  0028e	33 cd		 xor	 ecx, ebp
  00290	5f		 pop	 edi
  00291	5e		 pop	 esi
  00292	5b		 pop	 ebx
  00293	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00298	8b e5		 mov	 esp, ebp
  0029a	5d		 pop	 ebp
  0029b	c2 04 00	 ret	 4
$LN19@PentagramM:

; 3580 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3581 : 	}
; 3582 : 	else
; 3583 : 	{
; 3584 : #if( __4GAMERS__ == 1 )
; 3585 : 			g_Achievements.GD_UpdateMixData(lpObj, false);
; 3586 : #endif
; 3587 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  0029e	56		 push	 esi
  0029f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002a4	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 3588 : 		::GCUserChaosBoxSend(lpObj, 0);

  002a9	6a 00		 push	 0
  002ab	56		 push	 esi
  002ac	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 3589 : 
; 3590 : 		pMsg.Result = ELEMENTAL_FAIL1;
; 3591 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  002b1	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002b5	50		 push	 eax
  002b6	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002b9	c6 45 e7 f7	 mov	 BYTE PTR _pMsg$[ebp+3], 247 ; 000000f7H
  002bd	50		 push	 eax
  002be	ff 36		 push	 DWORD PTR [esi]
  002c0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3592 : 
; 3593 : 		LogAddTD("[Elemental System][Pentagram Refine] [%s][%s] CBMix Fail %d Money : %d-%d ",

  002c5	53		 push	 ebx
  002c6	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  002cc	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  002cf	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  002d5	50		 push	 eax
  002d6	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  002d9	50		 push	 eax
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@HGMMBHEK@?$FLElemental?5System?$FN?$FLPentagram?5Ref@
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002e5	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3594 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3595 : 
; 3596 : 		lpObj->ChaosLock = FALSE;

  002e8	e9 76 fe ff ff	 jmp	 $LN36@PentagramM
  002ed	0f 1f 00	 npad	 3
$LN38@PentagramM:

; 3597 : 	}
; 3598 : }

  002f0	00 00 00 00	 DD	 $LN21@PentagramM
  002f4	00 00 00 00	 DD	 $LN22@PentagramM
  002f8	00 00 00 00	 DD	 $LN23@PentagramM
  002fc	00 00 00 00	 DD	 $LN24@PentagramM
  00300	00 00 00 00	 DD	 $LN25@PentagramM
?PentagramMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CElementalSystem::PentagramMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ErrtelRankUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_btRank$GSCopy$ = -308					; size = 1
tv828 = -304						; size = 4
_Ertel$1$ = -300					; size = 4
_iPentagramLuckyCharmRate$1$ = -296			; size = 4
_this$GSCopy$1$ = -292					; size = 4
_SocketBonus$1 = -292					; size = 1
_lpObj$GSCopy$1$ = -288					; size = 4
_iPentagramLuckyCharm$1$ = -284				; size = 4
_iOtherItemCount$1$ = -280				; size = 4
_iSoulCount$1$ = -276					; size = 4
_iErtelCount$1$ = -272					; size = 4
_iSetItemCount$1$ = -268				; size = 4
_iBlessCount$1$ = -264					; size = 4
_iSpiritPowderCount$1$ = -260				; size = 4
_Item$2 = -256						; size = 212
_pResult$3 = -44					; size = 16
_pMsg$ = -28						; size = 16
_iPentagramChaosCharm$1$ = -12				; size = 4
_SocketOptions$4 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_btRank$ = 12						; size = 1
?ErrtelRankUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@E@Z PROC ; CElementalSystem::ErrtelRankUp, COMDAT
; _this$ = ecx

; 3261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8a 5d 0c	 mov	 bl, BYTE PTR _btRank$[ebp]

; 3262 : 	lpObj->ChaosLock = TRUE;
; 3263 : 
; 3264 : 	PMSG_CHAOSMIXRESULT pMsg;
; 3265 : 
; 3266 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00017	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001e	57		 push	 edi
  0001f	6a 10		 push	 16			; 00000010H
  00021	68 86 00 00 00	 push	 134			; 00000086H
  00026	50		 push	 eax
  00027	89 8d dc fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$1$[ebp], esi
  00033	88 9d cc fe ff
	ff		 mov	 BYTE PTR _btRank$GSCopy$[ebp], bl
  00039	c7 86 20 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4640], 1
  00043	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3267 : 	pMsg.Result = ELEMENTAL_IMPROPER;
; 3268 : 
; 3269 : 	int iErtelCount = 0;
; 3270 : 	CItem* Ertel = NULL;
; 3271 : 	int iSpiritPowderCount = 0;
; 3272 : 	int iBlessCount = 0;
; 3273 : 	int iSoulCount = 0;

  00048	33 c0		 xor	 eax, eax
  0004a	c6 45 e7 fb	 mov	 BYTE PTR _pMsg$[ebp+3], 251 ; 000000fbH
  0004e	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iSoulCount$1$[ebp], eax
  00054	33 c9		 xor	 ecx, ecx

; 3274 : 	int iSetItemCount = 0;

  00056	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iSetItemCount$1$[ebp], eax
  0005c	33 ff		 xor	 edi, edi

; 3275 : 	int iReqCount = btRank-1;

  0005e	0f b6 c3	 movzx	 eax, bl
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv828[ebp], eax

; 3276 : 	int iOtherItemCount = 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	89 bd f0 fe ff
	ff		 mov	 DWORD PTR _iErtelCount$1$[ebp], edi

; 3277 : 	int iPentagramLuckyCharm = 0;
; 3278 : 	int iPentagramLuckyCharmRate = 0;
; 3279 : 	int iPentagramChaosCharm = 0;

  00072	33 db		 xor	 ebx, ebx
  00074	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _Ertel$1$[ebp], ecx
  0007a	89 8d fc fe ff
	ff		 mov	 DWORD PTR _iSpiritPowderCount$1$[ebp], ecx
  00080	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _iBlessCount$1$[ebp], ecx
  00086	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iOtherItemCount$1$[ebp], eax
  0008c	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iPentagramLuckyCharm$1$[ebp], eax
  00092	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _iPentagramLuckyCharmRate$1$[ebp], eax
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@ErrtelRank:

; 3282 : 	{
; 3283 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  000a0	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  000a6	03 cf		 add	 ecx, edi
  000a8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	0f 85 3c 01 00
	00		 jne	 $LN48@ErrtelRank

; 3284 : 		{
; 3285 : 			if( lpObj->pChaosBox[n].IsSetItem() &&
; 3286 : 				lpObj->pChaosBox[n].m_Level >= 7 &&

  000b6	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  000bc	03 cf		 add	 ecx, edi
  000be	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  000c3	85 c0		 test	 eax, eax
  000c5	74 2a		 je	 SHORT $LN9@ErrtelRank
  000c7	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  000cd	66 83 7c 07 08
	07		 cmp	 WORD PTR [edi+eax+8], 7
  000d3	7c 1c		 jl	 SHORT $LN9@ErrtelRank
  000d5	80 bc 07 92 00
	00 00 01	 cmp	 BYTE PTR [edi+eax+146], 1
  000dd	72 12		 jb	 SHORT $LN9@ErrtelRank

; 3287 : 				lpObj->pChaosBox[n].m_Option3 >= 1 )
; 3288 : 			{
; 3289 : 				iSetItemCount++;

  000df	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iSetItemCount$1$[ebp]
  000e5	42		 inc	 edx
  000e6	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _iSetItemCount$1$[ebp], edx

; 3290 : 			}
; 3291 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,221) ||

  000ec	e9 07 01 00 00	 jmp	 $LN49@ErrtelRank
$LN9@ErrtelRank:

; 3292 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,231) ||
; 3293 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,241) ||
; 3294 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,251) ||

  000f1	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  000f7	ba dd 18 00 00	 mov	 edx, 6365		; 000018ddH
  000fc	03 cf		 add	 ecx, edi
  000fe	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00102	66 3b c2	 cmp	 ax, dx
  00105	0f 84 db 00 00
	00		 je	 $LN13@ErrtelRank
  0010b	ba e7 18 00 00	 mov	 edx, 6375		; 000018e7H
  00110	66 3b c2	 cmp	 ax, dx
  00113	0f 84 cd 00 00
	00		 je	 $LN13@ErrtelRank
  00119	ba f1 18 00 00	 mov	 edx, 6385		; 000018f1H
  0011e	66 3b c2	 cmp	 ax, dx
  00121	0f 84 bf 00 00
	00		 je	 $LN13@ErrtelRank
  00127	ba fb 18 00 00	 mov	 edx, 6395		; 000018fbH
  0012c	66 3b c2	 cmp	 ax, dx
  0012f	0f 84 b1 00 00
	00		 je	 $LN13@ErrtelRank
  00135	ba 05 19 00 00	 mov	 edx, 6405		; 00001905H
  0013a	66 3b c2	 cmp	 ax, dx
  0013d	0f 84 a3 00 00
	00		 je	 $LN13@ErrtelRank

; 3299 : 			}
; 3300 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,151) )

  00143	b9 97 18 00 00	 mov	 ecx, 6295		; 00001897H
  00148	66 3b c1	 cmp	 ax, cx
  0014b	75 18		 jne	 SHORT $LN14@ErrtelRank

; 3301 : 			{
; 3302 : 				iSpiritPowderCount++;

  0014d	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iSpiritPowderCount$1$[ebp]
  00153	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iSetItemCount$1$[ebp]
  00159	40		 inc	 eax
  0015a	89 85 fc fe ff
	ff		 mov	 DWORD PTR _iSpiritPowderCount$1$[ebp], eax
  00160	e9 99 00 00 00	 jmp	 $LN50@ErrtelRank
$LN14@ErrtelRank:

; 3303 : 			}
; 3304 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  00165	b9 0d 1c 00 00	 mov	 ecx, 7181		; 00001c0dH
  0016a	66 3b c1	 cmp	 ax, cx
  0016d	75 1b		 jne	 SHORT $LN16@ErrtelRank

; 3305 : 			{
; 3306 : 				iBlessCount++;

  0016f	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBlessCount$1$[ebp]
  00175	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iSpiritPowderCount$1$[ebp]
  0017b	41		 inc	 ecx
  0017c	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iSetItemCount$1$[ebp]
  00182	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _iBlessCount$1$[ebp], ecx
  00188	eb 7a		 jmp	 SHORT $LN2@ErrtelRank
$LN16@ErrtelRank:

; 3307 : 			}
; 3308 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,14) )

  0018a	b9 0e 1c 00 00	 mov	 ecx, 7182		; 00001c0eH
  0018f	66 3b c1	 cmp	 ax, cx
  00192	75 08		 jne	 SHORT $LN18@ErrtelRank

; 3309 : 			{
; 3310 : 				iSoulCount++;

  00194	ff 85 ec fe ff
	ff		 inc	 DWORD PTR _iSoulCount$1$[ebp]
  0019a	eb 56		 jmp	 SHORT $LN48@ErrtelRank
$LN18@ErrtelRank:

; 3311 : 			}
; 3312 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14, 189) )

  0019c	b9 bd 1c 00 00	 mov	 ecx, 7357		; 00001cbdH
  001a1	66 3b c1	 cmp	 ax, cx
  001a4	75 19		 jne	 SHORT $LN20@ErrtelRank

; 3313 : 			{
; 3314 : 				iPentagramLuckyCharm++;

  001a6	ff 85 e4 fe ff
	ff		 inc	 DWORD PTR _iPentagramLuckyCharm$1$[ebp]

; 3315 : 				iPentagramLuckyCharmRate = ItemAttribute[lpObj->pChaosBox[n].m_Type].Level; 

  001ac	98		 cwde
  001ad	6b c0 70	 imul	 eax, eax, 112
  001b0	0f b6 80 22 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  001b7	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _iPentagramLuckyCharmRate$1$[ebp], eax
  001bd	eb 33		 jmp	 SHORT $LN48@ErrtelRank
$LN20@ErrtelRank:

; 3320 : 			}
; 3321 : 			else

  001bf	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iSetItemCount$1$[ebp]
  001c5	b9 be 1c 00 00	 mov	 ecx, 7358		; 00001cbeH
  001ca	66 3b c1	 cmp	 ax, cx
  001cd	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iSpiritPowderCount$1$[ebp]
  001d3	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBlessCount$1$[ebp]
  001d9	75 03		 jne	 SHORT $LN22@ErrtelRank

; 3316 : 			}
; 3317 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14, 190) )
; 3318 : 			{
; 3319 : 				iPentagramChaosCharm++;

  001db	43		 inc	 ebx

; 3320 : 			}
; 3321 : 			else

  001dc	eb 26		 jmp	 SHORT $LN2@ErrtelRank
$LN22@ErrtelRank:

; 3322 : 			{
; 3323 : 				iOtherItemCount++;

  001de	ff 85 e8 fe ff
	ff		 inc	 DWORD PTR _iOtherItemCount$1$[ebp]
  001e4	eb 1e		 jmp	 SHORT $LN2@ErrtelRank
$LN13@ErrtelRank:

; 3295 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,261) )
; 3296 : 			{
; 3297 : 				Ertel = &lpObj->pChaosBox[n];
; 3298 : 				iErtelCount++;

  001e6	ff 85 f0 fe ff
	ff		 inc	 DWORD PTR _iErtelCount$1$[ebp]
  001ec	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _Ertel$1$[ebp], ecx
$LN48@ErrtelRank:
  001f2	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iSetItemCount$1$[ebp]
$LN49@ErrtelRank:
  001f8	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iSpiritPowderCount$1$[ebp]
$LN50@ErrtelRank:
  001fe	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBlessCount$1$[ebp]
$LN2@ErrtelRank:

; 3280 : 
; 3281 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00204	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0020a	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  00210	0f 8c 8a fe ff
	ff		 jl	 $LL4@ErrtelRank

; 3324 : 			}
; 3325 : 		}
; 3326 : 	}
; 3327 : 
; 3328 : 	if( iErtelCount != 1 ||
; 3329 : 		iSpiritPowderCount != iReqCount ||
; 3330 : 		iBlessCount != iReqCount ||
; 3331 : 		iSoulCount != iReqCount ||
; 3332 : 		iSetItemCount != 1 ||

  00216	83 bd f0 fe ff
	ff 01		 cmp	 DWORD PTR _iErtelCount$1$[ebp], 1
  0021d	89 5d f4	 mov	 DWORD PTR _iPentagramChaosCharm$1$[ebp], ebx
  00220	0f 85 e0 00 00
	00		 jne	 $LN25@ErrtelRank
  00226	8b bd d0 fe ff
	ff		 mov	 edi, DWORD PTR tv828[ebp]
  0022c	4f		 dec	 edi
  0022d	3b c7		 cmp	 eax, edi
  0022f	0f 85 d1 00 00
	00		 jne	 $LN25@ErrtelRank
  00235	3b cf		 cmp	 ecx, edi
  00237	0f 85 c9 00 00
	00		 jne	 $LN25@ErrtelRank
  0023d	39 bd ec fe ff
	ff		 cmp	 DWORD PTR _iSoulCount$1$[ebp], edi
  00243	0f 85 bd 00 00
	00		 jne	 $LN25@ErrtelRank
  00249	83 fa 01	 cmp	 edx, 1
  0024c	0f 85 b4 00 00
	00		 jne	 $LN25@ErrtelRank
  00252	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iOtherItemCount$1$[ebp]
  00258	85 c0		 test	 eax, eax
  0025a	0f 85 a6 00 00
	00		 jne	 $LN25@ErrtelRank

; 3337 : 		lpObj->ChaosLock = FALSE;
; 3338 : 		return;
; 3339 : 	}
; 3340 : 
; 3341 : 	if ( iPentagramChaosCharm > 1 )

  00260	3b da		 cmp	 ebx, edx
  00262	7e 2c		 jle	 SHORT $LN26@ErrtelRank
$LN52@ErrtelRank:

; 3342 : 	{
; 3343 : 		PMSG_CHAOSMIXRESULT pResult;
; 3344 : 		PHeadSetB((LPBYTE)&pResult, 0x86, sizeof(pResult));

  00264	6a 10		 push	 16			; 00000010H
  00266	8d 45 d4	 lea	 eax, DWORD PTR _pResult$3[ebp]
  00269	68 86 00 00 00	 push	 134			; 00000086H
  0026e	50		 push	 eax
  0026f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3345 : 		pResult.Result = 7;
; 3346 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  00274	0f b6 45 d5	 movzx	 eax, BYTE PTR _pResult$3[ebp+1]
  00278	50		 push	 eax
  00279	8d 45 d4	 lea	 eax, DWORD PTR _pResult$3[ebp]
  0027c	c6 45 d7 07	 mov	 BYTE PTR _pResult$3[ebp+3], 7
  00280	50		 push	 eax
  00281	ff 36		 push	 DWORD PTR [esi]
  00283	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00288	83 c4 18	 add	 esp, 24			; 00000018H

; 3347 : 		lpObj->ChaosLock = FALSE;
; 3348 : 		return;

  0028b	e9 89 00 00 00	 jmp	 $LN51@ErrtelRank
$LN26@ErrtelRank:

; 3349 : 	}
; 3350 : 
; 3351 : 	if ( iPentagramLuckyCharm > 0 && iPentagramChaosCharm > 0 )

  00290	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iPentagramLuckyCharm$1$[ebp]
  00296	85 c0		 test	 eax, eax
  00298	7e 04		 jle	 SHORT $LN27@ErrtelRank
  0029a	85 db		 test	 ebx, ebx
  0029c	7f c6		 jg	 SHORT $LN52@ErrtelRank
$LN27@ErrtelRank:

; 3352 : 	{
; 3353 : 		PMSG_CHAOSMIXRESULT pResult;
; 3354 : 		PHeadSetB((LPBYTE)&pResult, 0x86, sizeof(pResult));
; 3355 : 		pResult.Result = 7;
; 3356 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 3357 : 		lpObj->ChaosLock = FALSE;
; 3358 : 		return;
; 3359 : 	}
; 3360 : 
; 3361 : 	g_ChaosBox.LogChaosItem(lpObj, "Ertel RankUp Mix");

  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LKFPHNIC@Ertel?5RankUp?5Mix?$AA@
  002a3	56		 push	 esi
  002a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002a9	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 3362 : 	LogAddTD("[Elemental System] Ertel RankUp Start");

  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CFLBJGOL@?$FLElemental?5System?$FN?5Ertel?5RankUp?5@
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002b9	83 c4 04	 add	 esp, 4

; 3363 : 
; 3364 : 	lpObj->ChaosSuccessRate = 50;

  002bc	c7 86 1c 12 00
	00 32 00 00 00	 mov	 DWORD PTR [esi+4636], 50 ; 00000032H

; 3365 : 	int nChaosNeedMoney = 400000;
; 3366 : 
; 3367 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  002c6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  002cb	ff 36		 push	 DWORD PTR [esi]
  002cd	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  002d2	8b c8		 mov	 ecx, eax
  002d4	b8 80 1a 06 00	 mov	 eax, 400000		; 00061a80H
  002d9	f7 e9		 imul	 ecx
  002db	6a 00		 push	 0
  002dd	6a 64		 push	 100			; 00000064H
  002df	52		 push	 edx
  002e0	50		 push	 eax
  002e1	e8 00 00 00 00	 call	 __alldiv

; 3368 : 
; 3369 : 	if ( iChaosTaxMoney < 0 )

  002e6	33 c9		 xor	 ecx, ecx
  002e8	85 c0		 test	 eax, eax
  002ea	0f 48 c1	 cmovs	 eax, ecx

; 3370 : 	{
; 3371 : 		iChaosTaxMoney = 0;
; 3372 : 	}
; 3373 : 
; 3374 : 	nChaosNeedMoney += iChaosTaxMoney;

  002ed	8d 98 80 1a 06
	00		 lea	 ebx, DWORD PTR [eax+400000]

; 3375 : 
; 3376 : 	if ( nChaosNeedMoney < 0 )

  002f3	85 db		 test	 ebx, ebx
  002f5	0f 48 d9	 cmovs	 ebx, ecx

; 3377 : 	{
; 3378 : 		nChaosNeedMoney = 0;
; 3379 : 	}
; 3380 : 
; 3381 : 	if ( lpObj->Money < nChaosNeedMoney )

  002f8	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  002fe	3b cb		 cmp	 ecx, ebx
  00300	7d 34		 jge	 SHORT $LN30@ErrtelRank

; 3382 : 	{
; 3383 : 		pMsg.Result = ELEMENTAL_NOZEN;

  00302	c6 45 e7 f9	 mov	 BYTE PTR _pMsg$[ebp+3], 249 ; 000000f9H
$LN25@ErrtelRank:

; 3333 : 		iOtherItemCount != 0 )
; 3334 : 
; 3335 : 	{
; 3336 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00306	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0030a	50		 push	 eax
  0030b	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0030e	50		 push	 eax
  0030f	ff 36		 push	 DWORD PTR [esi]
  00311	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00316	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN51@ErrtelRank:

; 3455 : }

  00319	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031c	5f		 pop	 edi
  0031d	c7 86 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4640], 0
  00327	33 cd		 xor	 ecx, ebp
  00329	5e		 pop	 esi
  0032a	5b		 pop	 ebx
  0032b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c2 08 00	 ret	 8
$LN30@ErrtelRank:

; 3384 : 		
; 3385 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 3386 : 		lpObj->ChaosLock = FALSE;
; 3387 : 		return;
; 3388 : 	}
; 3389 : 
; 3390 : 	lpObj->Money -= nChaosNeedMoney;

  00336	2b cb		 sub	 ecx, ebx
  00338	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx

; 3391 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  0033e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00343	50		 push	 eax
  00344	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 3392 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00349	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0034f	ff 36		 push	 DWORD PTR [esi]
  00351	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 3393 : 	lpObj->ChaosSuccessRate += iPentagramLuckyCharmRate;

  00356	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _iPentagramLuckyCharmRate$1$[ebp]
  0035c	83 c4 08	 add	 esp, 8
  0035f	01 86 1c 12 00
	00		 add	 DWORD PTR [esi+4636], eax

; 3394 : //	LogAddC(2, "[DEBUG] Rate2: %d", iPentagramLuckyCharmRate);
; 3395 : 
; 3396 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00365	e8 00 00 00 00	 call	 _rand
  0036a	99		 cdq
  0036b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00370	f7 f9		 idiv	 ecx
  00372	3b 96 1c 12 00
	00		 cmp	 edx, DWORD PTR [esi+4636]
  00378	0f 8d be 01 00
	00		 jge	 $LN31@ErrtelRank

; 3397 : 	{
; 3398 : 		if( iPentagramChaosCharm > 0 )

  0037e	83 7d f4 00	 cmp	 DWORD PTR _iPentagramChaosCharm$1$[ebp], 0
  00382	7e 26		 jle	 SHORT $LN33@ErrtelRank

; 3399 : 		{
; 3400 : 			g_ChaosBox.ChaosBoxSpecialItemDown(lpObj);

  00384	56		 push	 esi
  00385	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0038a	e8 00 00 00 00	 call	 ?ChaosBoxSpecialItemDown@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxSpecialItemDown

; 3401 : 			GCUserChaosBoxSend(lpObj, 0);

  0038f	6a 00		 push	 0
  00391	56		 push	 esi
  00392	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 3402 : 			DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00397	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0039b	50		 push	 eax
  0039c	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0039f	50		 push	 eax
  003a0	ff 36		 push	 DWORD PTR [esi]
  003a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003a7	83 c4 14	 add	 esp, 20			; 00000014H
$LN33@ErrtelRank:

; 3403 : 		}
; 3404 : 
; 3405 : 		pMsg.Result = CB_SUCCESS;
; 3406 : 
; 3407 : 		Ertel->m_SocketOption[btRank-1] = GetErtelOption(Ertel->m_Type,btRank);

  003aa	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _Ertel$1$[ebp]
  003b0	ff b5 cc fe ff
	ff		 push	 DWORD PTR _btRank$GSCopy$[ebp]
  003b6	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003bc	c6 45 e7 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  003c0	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  003c4	50		 push	 eax
  003c5	e8 00 00 00 00	 call	 ?GetErtelOption@CElementalSystem@@QAEEHE@Z ; CElementalSystem::GetErtelOption
  003ca	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv828[ebp]
  003d0	88 84 31 c7 00
	00 00		 mov	 BYTE PTR [ecx+esi+199], al

; 3408 : 
; 3409 : 		CItem Item;

  003d7	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$2[ebp]
  003dd	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3410 : 
; 3411 : 		Item.m_Level = Ertel->m_Level;

  003e2	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]

; 3412 : 		Item.m_Durability = Ertel->m_Durability;
; 3413 : 		Item.m_JewelOfHarmonyOption = Ertel->m_JewelOfHarmonyOption;
; 3414 : 		Item.m_bLOCKED = Ertel->m_bLOCKED;
; 3415 : 
; 3416 : 		BYTE SocketBonus = Ertel->m_SocketBonus;
; 3417 : 		BYTE SocketOptions[MAX_SOCKET_COUNT];
; 3418 : 
; 3419 : 		for(int i = 0; i < 5; i++)	{
; 3420 : 			SocketOptions[i] = Ertel->m_SocketOption[i];
; 3421 : 		}
; 3422 : 
; 3423 : 		Item.Convert(Ertel->m_Type, Ertel->m_Option1, Ertel->m_Option2,

  003e6	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$2[ebp]
  003ec	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _Item$2[ebp+8], ax
  003f3	8a 86 c0 00 00
	00		 mov	 al, BYTE PTR [esi+192]
  003f9	88 45 c0	 mov	 BYTE PTR _Item$2[ebp+192], al
  003fc	8a 86 d1 00 00
	00		 mov	 al, BYTE PTR [esi+209]
  00402	88 45 d1	 mov	 BYTE PTR _Item$2[ebp+209], al
  00405	8a 86 c7 00 00
	00		 mov	 al, BYTE PTR [esi+199]
  0040b	88 85 dc fe ff
	ff		 mov	 BYTE PTR _SocketBonus$1[ebp], al
  00411	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  00417	88 45 f4	 mov	 BYTE PTR _SocketOptions$4[ebp], al
  0041a	8a 86 c9 00 00
	00		 mov	 al, BYTE PTR [esi+201]
  00420	88 45 f5	 mov	 BYTE PTR _SocketOptions$4[ebp+1], al
  00423	8a 86 ca 00 00
	00		 mov	 al, BYTE PTR [esi+202]
  00429	88 45 f6	 mov	 BYTE PTR _SocketOptions$4[ebp+2], al
  0042c	8a 86 cb 00 00
	00		 mov	 al, BYTE PTR [esi+203]
  00432	88 45 f7	 mov	 BYTE PTR _SocketOptions$4[ebp+3], al
  00435	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  0043b	6a 03		 push	 3
  0043d	ff b5 dc fe ff
	ff		 push	 DWORD PTR _SocketBonus$1[ebp]
  00443	f3 0f 10 46 24	 movss	 xmm0, DWORD PTR [esi+36]
  00448	88 45 f8	 mov	 BYTE PTR _SocketOptions$4[ebp+4], al
  0044b	8d 45 f4	 lea	 eax, DWORD PTR _SocketOptions$4[ebp]
  0044e	50		 push	 eax
  0044f	0f b6 86 c6 00
	00 00		 movzx	 eax, BYTE PTR [esi+198]
  00456	50		 push	 eax
  00457	0f b6 86 aa 00
	00 00		 movzx	 eax, BYTE PTR [esi+170]
  0045e	50		 push	 eax
  0045f	0f b6 86 93 00
	00 00		 movzx	 eax, BYTE PTR [esi+147]
  00466	50		 push	 eax
  00467	0f b6 86 92 00
	00 00		 movzx	 eax, BYTE PTR [esi+146]
  0046e	50		 push	 eax
  0046f	0f b6 86 91 00
	00 00		 movzx	 eax, BYTE PTR [esi+145]
  00476	50		 push	 eax
  00477	0f b6 86 90 00
	00 00		 movzx	 eax, BYTE PTR [esi+144]
  0047e	50		 push	 eax
  0047f	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  00483	50		 push	 eax
  00484	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _Item$2[ebp+36], xmm0
  0048c	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 3424 : 			Ertel->m_Option3, Ertel->m_NewOption, Ertel->m_SetOption, Ertel->m_ItemOptionEx, SocketOptions, SocketBonus, CURRENT_DB_VERSION);
; 3425 : 
; 3426 : 		Item.m_Number = Ertel->m_Number;

  00491	8b 06		 mov	 eax, DWORD PTR [esi]

; 3427 : 
; 3428 : 		ItemByteConvert(pMsg.ItemInfo, Item);

  00493	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00499	89 85 00 ff ff
	ff		 mov	 DWORD PTR _Item$2[ebp], eax
  0049f	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _Item$2[ebp]
  004a5	8b fc		 mov	 edi, esp
  004a7	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  004aa	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  004af	f3 a5		 rep movsd
  004b1	50		 push	 eax
  004b2	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  004b7	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3429 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  004bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004c2	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _lpObj$GSCopy$1$[ebp]
  004c8	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 3430 : 		::gObjChaosBoxInsertItemPos(lpObj->m_Index, Item, 0, -1);

  004cd	6a ff		 push	 -1
  004cf	6a 00		 push	 0
  004d1	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  004d7	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _Item$2[ebp]
  004dd	8b fc		 mov	 edi, esp
  004df	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  004e4	f3 a5		 rep movsd
  004e6	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$1$[ebp]
  004ec	ff 36		 push	 DWORD PTR [esi]
  004ee	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos

; 3431 : 		gObjChaosItemSet(lpObj->m_Index, 0, 1);

  004f3	6a 01		 push	 1
  004f5	6a 00		 push	 0
  004f7	ff 36		 push	 DWORD PTR [esi]
  004f9	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet

; 3432 : 
; 3433 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  004fe	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00502	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00508	50		 push	 eax
  00509	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0050c	50		 push	 eax
  0050d	ff 36		 push	 DWORD PTR [esi]
  0050f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3434 : #if( __4GAMERS__ == 1 )
; 3435 : 			g_Achievements.GD_UpdateMixData(lpObj, true);
; 3436 : #endif
; 3437 : 		LogAddTD("[Elemental System][Ertel RankUp] [%s][%s] CBMix Success %d Money : %d-%d",

  00514	53		 push	 ebx
  00515	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0051b	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0051e	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  00524	50		 push	 eax
  00525	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00528	50		 push	 eax
  00529	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@BDBNMFDL@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@
  0052e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00534	83 c4 24	 add	 esp, 36			; 00000024H

; 3438 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3439 : 	}
; 3440 : 	else

  00537	e9 dd fd ff ff	 jmp	 $LN51@ErrtelRank
$LN31@ErrtelRank:

; 3441 : 	{
; 3442 : #if( __4GAMERS__ == 1 )
; 3443 : 			g_Achievements.GD_UpdateMixData(lpObj, false);
; 3444 : #endif
; 3445 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  0053c	56		 push	 esi
  0053d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00542	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 3446 : 		::GCUserChaosBoxSend(lpObj, 0);

  00547	6a 00		 push	 0
  00549	56		 push	 esi
  0054a	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 3447 : 
; 3448 : 		pMsg.Result = ELEMENTAL_FAIL2;
; 3449 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0054f	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00553	50		 push	 eax
  00554	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00557	c6 45 e7 e1	 mov	 BYTE PTR _pMsg$[ebp+3], 225 ; 000000e1H
  0055b	50		 push	 eax
  0055c	ff 36		 push	 DWORD PTR [esi]
  0055e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3450 : 
; 3451 : 		LogAddTD("[Elemental System][Ertel RankUp] [%s][%s] CBMix Fail %d Money : %d-%d ",

  00563	53		 push	 ebx
  00564	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0056a	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0056d	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  00573	50		 push	 eax
  00574	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00577	50		 push	 eax
  00578	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@DILEBMMH@?$FLElemental?5System?$FN?$FLErtel?5RankUp?$FN@
  0057d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00583	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3452 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3453 : 	}
; 3454 : 	lpObj->ChaosLock = FALSE;

  00586	e9 8e fd ff ff	 jmp	 $LN51@ErrtelRank
?ErrtelRankUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@E@Z ENDP ; CElementalSystem::ErrtelRankUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ErrtelLevelUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iErtelCount$1$ = -280					; size = 4
_Ertel$1$ = -276					; size = 4
_SocketBonus$1 = -276					; size = 1
_nChaosNeedMoney$2$ = -272				; size = 4
_iPentagramLuckyCharm$1$ = -272				; size = 4
_iOtherItemCount$1$ = -268				; size = 4
_iBlessCount$1$ = -264					; size = 4
_iJewelCombineFrameCount$1$ = -260			; size = 4
_Item$2 = -256						; size = 212
_pResult$3 = -44					; size = 16
_pMsg$ = -28						; size = 16
_iPentagramLuckyCharmRate$1$ = -12			; size = 4
_SocketOptions$4 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?ErrtelLevelUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CElementalSystem::ErrtelLevelUp, COMDAT
; _this$ = ecx

; 3070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]

; 3071 : 	lpObj->ChaosLock = TRUE;
; 3072 : 
; 3073 : 	PMSG_CHAOSMIXRESULT pMsg;
; 3074 : 
; 3075 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00017	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	6a 10		 push	 16			; 00000010H
  0001e	68 86 00 00 00	 push	 134			; 00000086H
  00023	50		 push	 eax
  00024	c7 83 20 12 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+4640], 1
  0002e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3076 : 	pMsg.Result = ELEMENTAL_IMPROPER;
; 3077 : 
; 3078 : 	int iErtelCount = 0;
; 3079 : 	CItem* Ertel = NULL;

  00033	33 c9		 xor	 ecx, ecx
  00035	c6 45 e7 fb	 mov	 BYTE PTR _pMsg$[ebp+3], 251 ; 000000fbH

; 3080 : 	int iJewelCombineFrameCount = 0;
; 3081 : 	int iBlessCount = 0;
; 3082 : 	int iOtherItemCount = 0;
; 3083 : 	int iPentagramLuckyCharm = 0;

  00039	33 c0		 xor	 eax, eax
  0003b	89 8d ec fe ff
	ff		 mov	 DWORD PTR _Ertel$1$[ebp], ecx
  00041	33 f6		 xor	 esi, esi
  00043	89 8d fc fe ff
	ff		 mov	 DWORD PTR _iJewelCombineFrameCount$1$[ebp], ecx
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	89 b5 e8 fe ff
	ff		 mov	 DWORD PTR _iErtelCount$1$[ebp], esi
  00052	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _iBlessCount$1$[ebp], ecx

; 3084 : 	int iPentagramLuckyCharmRate = 0;
; 3085 : 	int iPentagramChaosCharm = 0;

  00058	33 ff		 xor	 edi, edi
  0005a	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _iOtherItemCount$1$[ebp], ecx
  00060	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iPentagramLuckyCharm$1$[ebp], eax
  00066	89 45 f4	 mov	 DWORD PTR _iPentagramLuckyCharmRate$1$[ebp], eax
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ErrtelLeve:

; 3088 : 	{
; 3089 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00070	8b 8b 10 12 00
	00		 mov	 ecx, DWORD PTR [ebx+4624]
  00076	03 ce		 add	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0007d	83 f8 01	 cmp	 eax, 1
  00080	0f 85 de 00 00
	00		 jne	 $LN45@ErrtelLeve

; 3090 : 		{
; 3091 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,221) ||
; 3092 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,231) ||
; 3093 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,241) ||
; 3094 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,251) ||

  00086	8b 8b 10 12 00
	00		 mov	 ecx, DWORD PTR [ebx+4624]
  0008c	ba dd 18 00 00	 mov	 edx, 6365		; 000018ddH
  00091	03 ce		 add	 ecx, esi
  00093	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00097	66 3b c2	 cmp	 ax, dx
  0009a	0f 84 b8 00 00
	00		 je	 $LN11@ErrtelLeve
  000a0	ba e7 18 00 00	 mov	 edx, 6375		; 000018e7H
  000a5	66 3b c2	 cmp	 ax, dx
  000a8	0f 84 aa 00 00
	00		 je	 $LN11@ErrtelLeve
  000ae	ba f1 18 00 00	 mov	 edx, 6385		; 000018f1H
  000b3	66 3b c2	 cmp	 ax, dx
  000b6	0f 84 9c 00 00
	00		 je	 $LN11@ErrtelLeve
  000bc	ba fb 18 00 00	 mov	 edx, 6395		; 000018fbH
  000c1	66 3b c2	 cmp	 ax, dx
  000c4	0f 84 8e 00 00
	00		 je	 $LN11@ErrtelLeve
  000ca	ba 05 19 00 00	 mov	 edx, 6405		; 00001905H
  000cf	66 3b c2	 cmp	 ax, dx
  000d2	0f 84 80 00 00
	00		 je	 $LN11@ErrtelLeve

; 3099 : 			}
; 3100 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,150) )

  000d8	b9 96 18 00 00	 mov	 ecx, 6294		; 00001896H
  000dd	66 3b c1	 cmp	 ax, cx
  000e0	75 0f		 jne	 SHORT $LN12@ErrtelLeve

; 3101 : 			{
; 3102 : 				iJewelCombineFrameCount++;

  000e2	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iJewelCombineFrameCount$1$[ebp]
  000e8	40		 inc	 eax
  000e9	89 85 fc fe ff
	ff		 mov	 DWORD PTR _iJewelCombineFrameCount$1$[ebp], eax
  000ef	eb 79		 jmp	 SHORT $LN46@ErrtelLeve
$LN12@ErrtelLeve:

; 3103 : 			}
; 3104 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  000f1	b9 0d 1c 00 00	 mov	 ecx, 7181		; 00001c0dH
  000f6	66 3b c1	 cmp	 ax, cx
  000f9	75 15		 jne	 SHORT $LN14@ErrtelLeve

; 3105 : 			{
; 3106 : 				iBlessCount++;

  000fb	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBlessCount$1$[ebp]
  00101	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iJewelCombineFrameCount$1$[ebp]
  00107	41		 inc	 ecx
  00108	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _iBlessCount$1$[ebp], ecx
  0010e	eb 60		 jmp	 SHORT $LN47@ErrtelLeve
$LN14@ErrtelLeve:

; 3107 : 			}
; 3108 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14, 189) )

  00110	b9 bd 1c 00 00	 mov	 ecx, 7357		; 00001cbdH
  00115	66 3b c1	 cmp	 ax, cx
  00118	75 16		 jne	 SHORT $LN16@ErrtelLeve

; 3109 : 			{
; 3110 : 				iPentagramLuckyCharm++;

  0011a	ff 85 f0 fe ff
	ff		 inc	 DWORD PTR _iPentagramLuckyCharm$1$[ebp]

; 3111 : 				iPentagramLuckyCharmRate = ItemAttribute[lpObj->pChaosBox[n].m_Type].Level; 

  00120	98		 cwde
  00121	6b c0 70	 imul	 eax, eax, 112
  00124	0f b6 80 22 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  0012b	89 45 f4	 mov	 DWORD PTR _iPentagramLuckyCharmRate$1$[ebp], eax
  0012e	eb 34		 jmp	 SHORT $LN45@ErrtelLeve
$LN16@ErrtelLeve:

; 3116 : 			}
; 3117 : 			else

  00130	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iOtherItemCount$1$[ebp]
  00136	b9 be 1c 00 00	 mov	 ecx, 7358		; 00001cbeH
  0013b	66 3b c1	 cmp	 ax, cx
  0013e	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iJewelCombineFrameCount$1$[ebp]
  00144	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBlessCount$1$[ebp]
  0014a	75 03		 jne	 SHORT $LN18@ErrtelLeve

; 3112 : 			}
; 3113 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14, 190) )
; 3114 : 			{
; 3115 : 				iPentagramChaosCharm++;

  0014c	47		 inc	 edi

; 3116 : 			}
; 3117 : 			else

  0014d	eb 27		 jmp	 SHORT $LN2@ErrtelLeve
$LN18@ErrtelLeve:

; 3118 : 			{
; 3119 : 				iOtherItemCount++;

  0014f	42		 inc	 edx
  00150	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _iOtherItemCount$1$[ebp], edx
  00156	eb 1e		 jmp	 SHORT $LN2@ErrtelLeve
$LN11@ErrtelLeve:

; 3095 : 				 lpObj->pChaosBox[n].m_Type == ITEMGET(12,261) )
; 3096 : 			{
; 3097 : 				Ertel = &lpObj->pChaosBox[n];
; 3098 : 				iErtelCount++;

  00158	ff 85 e8 fe ff
	ff		 inc	 DWORD PTR _iErtelCount$1$[ebp]
  0015e	89 8d ec fe ff
	ff		 mov	 DWORD PTR _Ertel$1$[ebp], ecx
$LN45@ErrtelLeve:
  00164	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _iJewelCombineFrameCount$1$[ebp]
$LN46@ErrtelLeve:
  0016a	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBlessCount$1$[ebp]
$LN47@ErrtelLeve:
  00170	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iOtherItemCount$1$[ebp]
$LN2@ErrtelLeve:

; 3086 : 
; 3087 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00176	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  0017c	81 fe 80 1a 00
	00		 cmp	 esi, 6784		; 00001a80H
  00182	0f 8c e8 fe ff
	ff		 jl	 $LL4@ErrtelLeve

; 3120 : 			}
; 3121 : 		}
; 3122 : 	}
; 3123 : 
; 3124 : 	if( iErtelCount != 1 ||
; 3125 : 		iJewelCombineFrameCount != 1 ||
; 3126 : 		iBlessCount != 1 ||

  00188	83 bd e8 fe ff
	ff 01		 cmp	 DWORD PTR _iErtelCount$1$[ebp], 1
  0018f	0f 85 c5 00 00
	00		 jne	 $LN21@ErrtelLeve
  00195	83 f8 01	 cmp	 eax, 1
  00198	0f 85 bc 00 00
	00		 jne	 $LN21@ErrtelLeve
  0019e	3b c8		 cmp	 ecx, eax
  001a0	0f 85 b4 00 00
	00		 jne	 $LN21@ErrtelLeve
  001a6	85 d2		 test	 edx, edx
  001a8	0f 85 ac 00 00
	00		 jne	 $LN21@ErrtelLeve

; 3131 : 		lpObj->ChaosLock = FALSE;
; 3132 : 
; 3133 : 		return;
; 3134 : 	}
; 3135 : 
; 3136 : 	if ( iPentagramChaosCharm > 1 )

  001ae	3b f8		 cmp	 edi, eax
  001b0	7e 2c		 jle	 SHORT $LN22@ErrtelLeve
$LN49@ErrtelLeve:

; 3137 : 	{
; 3138 : 		PMSG_CHAOSMIXRESULT pResult;
; 3139 : 		PHeadSetB((LPBYTE)&pResult, 0x86, sizeof(pResult));

  001b2	6a 10		 push	 16			; 00000010H
  001b4	8d 45 d4	 lea	 eax, DWORD PTR _pResult$3[ebp]
  001b7	68 86 00 00 00	 push	 134			; 00000086H
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3140 : 		pResult.Result = 7;
; 3141 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  001c2	0f b6 45 d5	 movzx	 eax, BYTE PTR _pResult$3[ebp+1]
  001c6	50		 push	 eax
  001c7	8d 45 d4	 lea	 eax, DWORD PTR _pResult$3[ebp]
  001ca	c6 45 d7 07	 mov	 BYTE PTR _pResult$3[ebp+3], 7
  001ce	50		 push	 eax
  001cf	ff 33		 push	 DWORD PTR [ebx]
  001d1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d6	83 c4 18	 add	 esp, 24			; 00000018H

; 3142 : 		lpObj->ChaosLock = FALSE;
; 3143 : 		return;

  001d9	e9 8f 00 00 00	 jmp	 $LN48@ErrtelLeve
$LN22@ErrtelLeve:

; 3144 : 	}
; 3145 : 
; 3146 : 	if ( iPentagramLuckyCharm > 0 && iPentagramChaosCharm > 0 )

  001de	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iPentagramLuckyCharm$1$[ebp]
  001e4	85 c0		 test	 eax, eax
  001e6	7e 04		 jle	 SHORT $LN23@ErrtelLeve
  001e8	85 ff		 test	 edi, edi
  001ea	7f c6		 jg	 SHORT $LN49@ErrtelLeve
$LN23@ErrtelLeve:

; 3147 : 	{
; 3148 : 		PMSG_CHAOSMIXRESULT pResult;
; 3149 : 		PHeadSetB((LPBYTE)&pResult, 0x86, sizeof(pResult));
; 3150 : 		pResult.Result = 7;
; 3151 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 3152 : 		lpObj->ChaosLock = FALSE;
; 3153 : 		return;
; 3154 : 	}
; 3155 : 
; 3156 : 	g_ChaosBox.LogChaosItem(lpObj, "Ertel LevelUp Mix");

  001ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BFDOANCJ@Ertel?5LevelUp?5Mix?$AA@
  001f1	53		 push	 ebx
  001f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  001f7	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 3157 : 	LogAddTD("[Elemental System] Ertel LevelUp Start");

  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GJPCHLDL@?$FLElemental?5System?$FN?5Ertel?5LevelUp@
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00207	83 c4 04	 add	 esp, 4

; 3158 : 
; 3159 : 	lpObj->ChaosSuccessRate = 50;

  0020a	c7 83 1c 12 00
	00 32 00 00 00	 mov	 DWORD PTR [ebx+4636], 50 ; 00000032H

; 3160 : 	int nChaosNeedMoney = 400000;
; 3161 : 
; 3162 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00214	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00219	ff 33		 push	 DWORD PTR [ebx]
  0021b	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00220	8b c8		 mov	 ecx, eax
  00222	b8 80 1a 06 00	 mov	 eax, 400000		; 00061a80H
  00227	f7 e9		 imul	 ecx
  00229	6a 00		 push	 0
  0022b	6a 64		 push	 100			; 00000064H
  0022d	52		 push	 edx
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 __alldiv

; 3163 : 
; 3164 : 	if ( iChaosTaxMoney < 0 )

  00234	33 c9		 xor	 ecx, ecx
  00236	85 c0		 test	 eax, eax
  00238	0f 48 c1	 cmovs	 eax, ecx

; 3165 : 	{
; 3166 : 		iChaosTaxMoney = 0;
; 3167 : 	}
; 3168 : 
; 3169 : 	nChaosNeedMoney += iChaosTaxMoney;

  0023b	8d b0 80 1a 06
	00		 lea	 esi, DWORD PTR [eax+400000]

; 3170 : 
; 3171 : 	if ( nChaosNeedMoney < 0 )

  00241	85 f6		 test	 esi, esi
  00243	0f 48 f1	 cmovs	 esi, ecx

; 3172 : 	{
; 3173 : 		nChaosNeedMoney = 0;
; 3174 : 	}
; 3175 : 
; 3176 : 	if ( lpObj->Money < nChaosNeedMoney )

  00246	8b 8b cc 00 00
	00		 mov	 ecx, DWORD PTR [ebx+204]
  0024c	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _nChaosNeedMoney$2$[ebp], esi
  00252	3b ce		 cmp	 ecx, esi
  00254	7d 34		 jge	 SHORT $LN26@ErrtelLeve

; 3177 : 	{
; 3178 : 		pMsg.Result = ELEMENTAL_NOZEN;

  00256	c6 45 e7 f9	 mov	 BYTE PTR _pMsg$[ebp+3], 249 ; 000000f9H
$LN21@ErrtelLeve:

; 3127 : 		iOtherItemCount != 0 )
; 3128 : 
; 3129 : 	{
; 3130 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0025a	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0025e	50		 push	 eax
  0025f	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00262	50		 push	 eax
  00263	ff 33		 push	 DWORD PTR [ebx]
  00265	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0026a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN48@ErrtelLeve:

; 3258 : }

  0026d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00270	5f		 pop	 edi
  00271	5e		 pop	 esi
  00272	c7 83 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+4640], 0
  0027c	33 cd		 xor	 ecx, ebp
  0027e	5b		 pop	 ebx
  0027f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00284	8b e5		 mov	 esp, ebp
  00286	5d		 pop	 ebp
  00287	c2 04 00	 ret	 4
$LN26@ErrtelLeve:

; 3179 : 		
; 3180 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 3181 : 		lpObj->ChaosLock = FALSE;
; 3182 : 		return;
; 3183 : 	}
; 3184 : 
; 3185 : 	lpObj->Money -= nChaosNeedMoney;

  0028a	2b ce		 sub	 ecx, esi
  0028c	89 8b cc 00 00
	00		 mov	 DWORD PTR [ebx+204], ecx

; 3186 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  00292	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 3187 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  0029d	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  002a3	ff 33		 push	 DWORD PTR [ebx]
  002a5	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 3188 : 	lpObj->ChaosSuccessRate += iPentagramLuckyCharmRate;

  002aa	8b 45 f4	 mov	 eax, DWORD PTR _iPentagramLuckyCharmRate$1$[ebp]
  002ad	83 c4 08	 add	 esp, 8
  002b0	01 83 1c 12 00
	00		 add	 DWORD PTR [ebx+4636], eax

; 3189 : 	
; 3190 : //	LogAddC(2, "[DEBUG] Rate1: %d", iPentagramLuckyCharmRate);
; 3191 : 
; 3192 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  002b6	e8 00 00 00 00	 call	 _rand
  002bb	99		 cdq
  002bc	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  002c1	f7 f9		 idiv	 ecx
  002c3	3b 93 1c 12 00
	00		 cmp	 edx, DWORD PTR [ebx+4636]
  002c9	0f 8d c5 01 00
	00		 jge	 $LN27@ErrtelLeve

; 3193 : 	{
; 3194 : 		if( iPentagramChaosCharm > 0 )

  002cf	85 ff		 test	 edi, edi
  002d1	7e 26		 jle	 SHORT $LN29@ErrtelLeve

; 3195 : 		{
; 3196 : 			g_ChaosBox.ChaosBoxSpecialItemDown(lpObj);

  002d3	53		 push	 ebx
  002d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002d9	e8 00 00 00 00	 call	 ?ChaosBoxSpecialItemDown@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxSpecialItemDown

; 3197 : 			GCUserChaosBoxSend(lpObj, 0);

  002de	6a 00		 push	 0
  002e0	53		 push	 ebx
  002e1	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 3198 : 			DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  002e6	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002ea	50		 push	 eax
  002eb	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002ee	50		 push	 eax
  002ef	ff 33		 push	 DWORD PTR [ebx]
  002f1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002f6	83 c4 14	 add	 esp, 20			; 00000014H
$LN29@ErrtelLeve:

; 3199 : 		}
; 3200 : 
; 3201 : 
; 3202 : 		pMsg.Result = CB_SUCCESS;
; 3203 : 
; 3204 : 		int iRank = Ertel->m_SocketBonus/16;

  002f9	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _Ertel$1$[ebp]
  002ff	c6 45 e7 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  00303	8a 8e c7 00 00
	00		 mov	 cl, BYTE PTR [esi+199]
  00309	0f b6 d1	 movzx	 edx, cl
  0030c	c1 ea 04	 shr	 edx, 4

; 3205 : 		int iLevel = Ertel->m_SocketOption[iRank-1]/16;
; 3206 : 
; 3207 : 		if( iLevel++ >= 10 )

  0030f	8a 84 32 c7 00
	00 00		 mov	 al, BYTE PTR [edx+esi+199]
  00316	24 f0		 and	 al, 240			; 000000f0H
  00318	3c a0		 cmp	 al, 160			; 000000a0H
  0031a	72 09		 jb	 SHORT $LN30@ErrtelLeve

; 3208 : 			Ertel->m_SocketBonus += 16;

  0031c	80 c1 10	 add	 cl, 16			; 00000010H
  0031f	88 8e c7 00 00
	00		 mov	 BYTE PTR [esi+199], cl
$LN30@ErrtelLeve:

; 3209 : 
; 3210 : 		Ertel->m_SocketOption[iRank-1] += 16;

  00325	80 84 32 c7 00
	00 00 10	 add	 BYTE PTR [edx+esi+199], 16 ; 00000010H

; 3211 : 
; 3212 : 		CItem Item;

  0032d	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$2[ebp]
  00333	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3213 : 
; 3214 : 		Item.m_Level = Ertel->m_Level;

  00338	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]

; 3215 : 		Item.m_Durability = Ertel->m_Durability;
; 3216 : 		Item.m_JewelOfHarmonyOption = Ertel->m_JewelOfHarmonyOption;
; 3217 : 		Item.m_bLOCKED = Ertel->m_bLOCKED;
; 3218 : 
; 3219 : 		BYTE SocketBonus = Ertel->m_SocketBonus;
; 3220 : 		BYTE SocketOptions[MAX_SOCKET_COUNT];
; 3221 : 
; 3222 : 		for(int i = 0; i < 5; i++)	{
; 3223 : 			SocketOptions[i] = Ertel->m_SocketOption[i];
; 3224 : 		}
; 3225 : 
; 3226 : 		Item.Convert(Ertel->m_Type, Ertel->m_Option1, Ertel->m_Option2,

  0033c	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$2[ebp]
  00342	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _Item$2[ebp+8], ax
  00349	0f b6 86 c0 00
	00 00		 movzx	 eax, BYTE PTR [esi+192]
  00350	88 45 c0	 mov	 BYTE PTR _Item$2[ebp+192], al
  00353	0f b6 86 d1 00
	00 00		 movzx	 eax, BYTE PTR [esi+209]
  0035a	88 45 d1	 mov	 BYTE PTR _Item$2[ebp+209], al
  0035d	0f b6 86 c7 00
	00 00		 movzx	 eax, BYTE PTR [esi+199]
  00364	88 85 ec fe ff
	ff		 mov	 BYTE PTR _SocketBonus$1[ebp], al
  0036a	0f b6 86 c8 00
	00 00		 movzx	 eax, BYTE PTR [esi+200]
  00371	88 45 f4	 mov	 BYTE PTR _SocketOptions$4[ebp], al
  00374	0f b6 86 c9 00
	00 00		 movzx	 eax, BYTE PTR [esi+201]
  0037b	88 45 f5	 mov	 BYTE PTR _SocketOptions$4[ebp+1], al
  0037e	0f b6 86 ca 00
	00 00		 movzx	 eax, BYTE PTR [esi+202]
  00385	88 45 f6	 mov	 BYTE PTR _SocketOptions$4[ebp+2], al
  00388	0f b6 86 cb 00
	00 00		 movzx	 eax, BYTE PTR [esi+203]
  0038f	88 45 f7	 mov	 BYTE PTR _SocketOptions$4[ebp+3], al
  00392	0f b6 86 cc 00
	00 00		 movzx	 eax, BYTE PTR [esi+204]
  00399	6a 03		 push	 3
  0039b	ff b5 ec fe ff
	ff		 push	 DWORD PTR _SocketBonus$1[ebp]
  003a1	f3 0f 10 46 24	 movss	 xmm0, DWORD PTR [esi+36]
  003a6	88 45 f8	 mov	 BYTE PTR _SocketOptions$4[ebp+4], al
  003a9	8d 45 f4	 lea	 eax, DWORD PTR _SocketOptions$4[ebp]
  003ac	50		 push	 eax
  003ad	0f b6 86 c6 00
	00 00		 movzx	 eax, BYTE PTR [esi+198]
  003b4	50		 push	 eax
  003b5	0f b6 86 aa 00
	00 00		 movzx	 eax, BYTE PTR [esi+170]
  003bc	50		 push	 eax
  003bd	0f b6 86 93 00
	00 00		 movzx	 eax, BYTE PTR [esi+147]
  003c4	50		 push	 eax
  003c5	0f b6 86 92 00
	00 00		 movzx	 eax, BYTE PTR [esi+146]
  003cc	50		 push	 eax
  003cd	0f b6 86 91 00
	00 00		 movzx	 eax, BYTE PTR [esi+145]
  003d4	50		 push	 eax
  003d5	0f b6 86 90 00
	00 00		 movzx	 eax, BYTE PTR [esi+144]
  003dc	50		 push	 eax
  003dd	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  003e1	50		 push	 eax
  003e2	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _Item$2[ebp+36], xmm0
  003ea	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 3227 : 			Ertel->m_Option3, Ertel->m_NewOption, Ertel->m_SetOption, Ertel->m_ItemOptionEx, SocketOptions, SocketBonus, CURRENT_DB_VERSION);
; 3228 : 
; 3229 : 		Item.m_Number = Ertel->m_Number;

  003ef	8b 06		 mov	 eax, DWORD PTR [esi]

; 3230 : 
; 3231 : 		ItemByteConvert(pMsg.ItemInfo, Item);

  003f1	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  003f7	89 85 00 ff ff
	ff		 mov	 DWORD PTR _Item$2[ebp], eax
  003fd	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _Item$2[ebp]
  00403	8b fc		 mov	 edi, esp
  00405	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00408	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0040d	f3 a5		 rep movsd
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00415	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3232 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  0041b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00420	53		 push	 ebx
  00421	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 3233 : 		::gObjChaosBoxInsertItemPos(lpObj->m_Index, Item, 0, -1);

  00426	6a ff		 push	 -1
  00428	6a 00		 push	 0
  0042a	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00430	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _Item$2[ebp]
  00436	8b fc		 mov	 edi, esp
  00438	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0043d	f3 a5		 rep movsd
  0043f	ff 33		 push	 DWORD PTR [ebx]
  00441	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos

; 3234 : 		gObjChaosItemSet(lpObj->m_Index, 0, 1);

  00446	6a 01		 push	 1
  00448	6a 00		 push	 0
  0044a	ff 33		 push	 DWORD PTR [ebx]
  0044c	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet

; 3235 : 
; 3236 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);

  00451	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00455	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  0045b	50		 push	 eax
  0045c	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0045f	50		 push	 eax
  00460	ff 33		 push	 DWORD PTR [ebx]
  00462	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3237 : #if( __4GAMERS__ == 1 )
; 3238 : 		g_Achievements.GD_UpdateMixData(lpObj, true);
; 3239 : #endif
; 3240 : 		LogAddTD("[Elemental System][Ertel LevelUp] [%s][%s] CBMix Success %d Money : %d-%d",

  00467	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _nChaosNeedMoney$2$[ebp]
  0046d	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00470	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  00476	ff b3 1c 12 00
	00		 push	 DWORD PTR [ebx+4636]
  0047c	50		 push	 eax
  0047d	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00480	50		 push	 eax
  00481	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@PHDHHJCA@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0048c	83 c4 24	 add	 esp, 36			; 00000024H

; 3241 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3242 : 	}
; 3243 : 	else

  0048f	e9 d9 fd ff ff	 jmp	 $LN48@ErrtelLeve
$LN27@ErrtelLeve:

; 3244 : 	{
; 3245 : #if( __4GAMERS__ == 1 )
; 3246 : 		g_Achievements.GD_UpdateMixData(lpObj, false);
; 3247 : #endif
; 3248 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  00494	53		 push	 ebx
  00495	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0049a	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 3249 : 		::GCUserChaosBoxSend(lpObj, 0);

  0049f	6a 00		 push	 0
  004a1	53		 push	 ebx
  004a2	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 3250 : 
; 3251 : 		pMsg.Result = ELEMENTAL_FAIL2;
; 3252 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  004a7	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  004ab	50		 push	 eax
  004ac	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  004af	c6 45 e7 e1	 mov	 BYTE PTR _pMsg$[ebp+3], 225 ; 000000e1H
  004b3	50		 push	 eax
  004b4	ff 33		 push	 DWORD PTR [ebx]
  004b6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3253 : 
; 3254 : 		LogAddTD("[Elemental System][Ertel LevelUp] [%s][%s] CBMix Fail %d Money : %d-%d ",

  004bb	56		 push	 esi
  004bc	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  004c2	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  004c5	ff b3 1c 12 00
	00		 push	 DWORD PTR [ebx+4636]
  004cb	50		 push	 eax
  004cc	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  004cf	50		 push	 eax
  004d0	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PPAHDGDE@?$FLElemental?5System?$FN?$FLErtel?5LevelUp@
  004d5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004db	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3255 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3256 : 	}
; 3257 : 	lpObj->ChaosLock = FALSE;

  004de	e9 8a fd ff ff	 jmp	 $LN48@ErrtelLeve
?ErrtelLevelUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CElementalSystem::ErrtelLevelUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ErrtelMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -44					; size = 4
_iMithrilType$1$ = -40					; size = 4
_iElixirCount$1$ = -36					; size = 4
_iBlessCount$1$ = -32					; size = 4
_pMsg$ = -28						; size = 16
_iMithrilCount$1$ = -12					; size = 4
_SocketOption$1 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?ErrtelMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CElementalSystem::ErrtelMix, COMDAT
; _this$ = ecx

; 2946 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 2947 : 	lpObj->ChaosLock = TRUE;
; 2948 : 
; 2949 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2950 : 
; 2951 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00016	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 10		 push	 16			; 00000010H
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	50		 push	 eax
  00021	89 4d d4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00024	c7 87 20 12 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+4640], 1
  0002e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2952 : 	pMsg.Result = ELEMENTAL_IMPROPER;
; 2953 : 
; 2954 : 	int iMithrilCount = 0;
; 2955 : 	int iMithrilType = -1;

  00033	83 c8 ff	 or	 eax, -1
  00036	c6 45 e7 fb	 mov	 BYTE PTR _pMsg$[ebp+3], 251 ; 000000fbH
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iMithrilCount$1$[ebp], 0

; 2956 : 	int iElixirCount = 0;
; 2957 : 	int iBlessCount = 0;
; 2958 : 	int iOtherItemCount = 0;

  00044	33 db		 xor	 ebx, ebx
  00046	89 45 d8	 mov	 DWORD PTR _iMithrilType$1$[ebp], eax
  00049	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iElixirCount$1$[ebp], 0
  00050	33 f6		 xor	 esi, esi
  00052	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iBlessCount$1$[ebp], 0
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ErrtelMix:

; 2961 : 	{
; 2962 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00060	8b 8f 10 12 00
	00		 mov	 ecx, DWORD PTR [edi+4624]
  00066	03 ce		 add	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	83 f8 01	 cmp	 eax, 1
  00070	75 55		 jne	 SHORT $LN24@ErrtelMix

; 2963 : 		{
; 2964 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,145) )

  00072	8b 8f 10 12 00
	00		 mov	 ecx, DWORD PTR [edi+4624]
  00078	ba 91 18 00 00	 mov	 edx, 6289		; 00001891H
  0007d	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  00082	66 3b c2	 cmp	 ax, dx

; 2965 : 			{
; 2966 : 				iMithrilType = lpObj->pChaosBox[n].m_SocketBonus;
; 2967 : 				iMithrilCount++;

  00085	8b 55 f4	 mov	 edx, DWORD PTR _iMithrilCount$1$[ebp]
  00088	75 11		 jne	 SHORT $LN6@ErrtelMix
  0008a	0f b6 84 31 c7
	00 00 00	 movzx	 eax, BYTE PTR [ecx+esi+199]
  00092	42		 inc	 edx
  00093	89 45 d8	 mov	 DWORD PTR _iMithrilType$1$[ebp], eax
  00096	89 55 f4	 mov	 DWORD PTR _iMithrilCount$1$[ebp], edx
  00099	eb 2f		 jmp	 SHORT $LN25@ErrtelMix
$LN6@ErrtelMix:

; 2968 : 			}
; 2969 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,147) )

  0009b	b9 93 18 00 00	 mov	 ecx, 6291		; 00001893H
  000a0	66 3b c1	 cmp	 ax, cx
  000a3	75 09		 jne	 SHORT $LN8@ErrtelMix

; 2970 : 			{
; 2971 : 				iElixirCount++;

  000a5	8b 4d dc	 mov	 ecx, DWORD PTR _iElixirCount$1$[ebp]
  000a8	41		 inc	 ecx
  000a9	89 4d dc	 mov	 DWORD PTR _iElixirCount$1$[ebp], ecx
  000ac	eb 1f		 jmp	 SHORT $LN26@ErrtelMix
$LN8@ErrtelMix:

; 2972 : 			}
; 2973 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,13) )

  000ae	b9 0d 1c 00 00	 mov	 ecx, 7181		; 00001c0dH
  000b3	66 3b c1	 cmp	 ax, cx

; 2974 : 			{
; 2975 : 				iBlessCount++;

  000b6	8b 45 e0	 mov	 eax, DWORD PTR _iBlessCount$1$[ebp]

; 2976 : 			}
; 2977 : 			else

  000b9	8b 4d dc	 mov	 ecx, DWORD PTR _iElixirCount$1$[ebp]
  000bc	75 06		 jne	 SHORT $LN10@ErrtelMix

; 2974 : 			{
; 2975 : 				iBlessCount++;

  000be	40		 inc	 eax
  000bf	89 45 e0	 mov	 DWORD PTR _iBlessCount$1$[ebp], eax

; 2976 : 			}
; 2977 : 			else

  000c2	eb 0c		 jmp	 SHORT $LN2@ErrtelMix
$LN10@ErrtelMix:

; 2978 : 			{
; 2979 : 				iOtherItemCount++;

  000c4	43		 inc	 ebx
  000c5	eb 09		 jmp	 SHORT $LN2@ErrtelMix
$LN24@ErrtelMix:
  000c7	8b 55 f4	 mov	 edx, DWORD PTR _iMithrilCount$1$[ebp]
$LN25@ErrtelMix:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR _iElixirCount$1$[ebp]
$LN26@ErrtelMix:
  000cd	8b 45 e0	 mov	 eax, DWORD PTR _iBlessCount$1$[ebp]
$LN2@ErrtelMix:

; 2959 : 
; 2960 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000d0	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  000d6	81 fe 80 1a 00
	00		 cmp	 esi, 6784		; 00001a80H
  000dc	7c 82		 jl	 SHORT $LL4@ErrtelMix

; 2980 : 			}
; 2981 : 		}
; 2982 : 	}
; 2983 : 
; 2984 : 	if( iMithrilCount != 1 ||
; 2985 : 		iElixirCount != 1 ||
; 2986 : 		iBlessCount != 1 ||

  000de	83 fa 01	 cmp	 edx, 1
  000e1	75 75		 jne	 SHORT $LN13@ErrtelMix
  000e3	3b ca		 cmp	 ecx, edx
  000e5	75 71		 jne	 SHORT $LN13@ErrtelMix
  000e7	3b c2		 cmp	 eax, edx
  000e9	75 6d		 jne	 SHORT $LN13@ErrtelMix
  000eb	85 db		 test	 ebx, ebx
  000ed	75 69		 jne	 SHORT $LN13@ErrtelMix

; 2992 : 
; 2993 : 		return;
; 2994 : 	}
; 2995 : 
; 2996 : 	g_ChaosBox.LogChaosItem(lpObj, "Elixir Mix");

  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CHFCKLND@Elixir?5Mix?$AA@
  000f4	57		 push	 edi
  000f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  000fa	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 2997 : 	LogAddTD("[Elemental System] Elixir Mix Start");

  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NNKLGBLG@?$FLElemental?5System?$FN?5Elixir?5Mix?5St@
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0010a	83 c4 04	 add	 esp, 4

; 2998 : 
; 2999 : 	lpObj->ChaosSuccessRate = 50;

  0010d	c7 87 1c 12 00
	00 32 00 00 00	 mov	 DWORD PTR [edi+4636], 50 ; 00000032H

; 3000 : 	int nChaosNeedMoney = 100000;
; 3001 : 
; 3002 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  00117	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0011c	ff 37		 push	 DWORD PTR [edi]
  0011e	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00123	8b c8		 mov	 ecx, eax
  00125	b8 a0 86 01 00	 mov	 eax, 100000		; 000186a0H
  0012a	f7 e9		 imul	 ecx
  0012c	53		 push	 ebx
  0012d	6a 64		 push	 100			; 00000064H
  0012f	52		 push	 edx
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 __alldiv
  00136	8b c8		 mov	 ecx, eax

; 3003 : 
; 3004 : 	if ( iChaosTaxMoney < 0 )

  00138	33 c0		 xor	 eax, eax
  0013a	85 c9		 test	 ecx, ecx
  0013c	0f 48 c8	 cmovs	 ecx, eax

; 3005 : 	{
; 3006 : 		iChaosTaxMoney = 0;
; 3007 : 	}
; 3008 : 
; 3009 : 	nChaosNeedMoney += iChaosTaxMoney;

  0013f	8d 99 a0 86 01
	00		 lea	 ebx, DWORD PTR [ecx+100000]

; 3010 : 
; 3011 : 	if ( nChaosNeedMoney < 0 )

  00145	85 db		 test	 ebx, ebx
  00147	0f 48 d8	 cmovs	 ebx, eax

; 3012 : 	{
; 3013 : 		nChaosNeedMoney = 0;
; 3014 : 	}
; 3015 : 
; 3016 : 	if ( lpObj->Money < nChaosNeedMoney )

  0014a	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00150	3b c3		 cmp	 eax, ebx
  00152	7d 34		 jge	 SHORT $LN16@ErrtelMix

; 3017 : 	{
; 3018 : 		pMsg.Result = ELEMENTAL_NOZEN;

  00154	c6 45 e7 f9	 mov	 BYTE PTR _pMsg$[ebp+3], 249 ; 000000f9H
$LN13@ErrtelMix:

; 2987 : 		iOtherItemCount != 0 )
; 2988 : 
; 2989 : 	{
; 2990 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00158	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0015c	50		 push	 eax
  0015d	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00160	50		 push	 eax
  00161	ff 37		 push	 DWORD PTR [edi]
  00163	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@ErrtelMix:

; 2991 : 		lpObj->ChaosLock = FALSE;

  0016b	c7 87 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+4640], 0
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx

; 3065 : 	}
; 3066 : }

  00178	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017b	33 cd		 xor	 ecx, ebp
  0017d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 04 00	 ret	 4
$LN16@ErrtelMix:

; 3019 : 		
; 3020 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 3021 : 		lpObj->ChaosLock = FALSE;
; 3022 : 		return;
; 3023 : 	}
; 3024 : 
; 3025 : 	lpObj->Money -= nChaosNeedMoney;

  00188	2b c3		 sub	 eax, ebx

; 3026 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  0018a	51		 push	 ecx
  0018b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00190	89 87 cc 00 00
	00		 mov	 DWORD PTR [edi+204], eax
  00196	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 3027 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  0019b	ff b7 cc 00 00
	00		 push	 DWORD PTR [edi+204]
  001a1	ff 37		 push	 DWORD PTR [edi]
  001a3	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  001a8	83 c4 08	 add	 esp, 8

; 3028 : 
; 3029 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  001ab	e8 00 00 00 00	 call	 _rand
  001b0	99		 cdq
  001b1	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001b6	f7 f9		 idiv	 ecx
  001b8	3b 97 1c 12 00
	00		 cmp	 edx, DWORD PTR [edi+4636]
  001be	0f 8d 9a 00 00
	00		 jge	 $LN17@ErrtelMix

; 3030 : 	{
; 3031 : 		int type = ITEMGET(12,221+(rand()%5*10));

  001c4	e8 00 00 00 00	 call	 _rand
  001c9	99		 cdq
  001ca	b9 05 00 00 00	 mov	 ecx, 5
  001cf	f7 f9		 idiv	 ecx

; 3032 : 
; 3033 : 		BYTE SocketBonus = iMithrilType | 0x10;
; 3034 : 		BYTE SocketOption[5];
; 3035 : 
; 3036 : 		SocketOption[0] = GetErtelOption(type,1);

  001d1	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001d4	6a 01		 push	 1
  001d6	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  001d9	8d 34 45 dd 18
	00 00		 lea	 esi, DWORD PTR [eax*2+6365]
  001e0	56		 push	 esi
  001e1	e8 00 00 00 00	 call	 ?GetErtelOption@CElementalSystem@@QAEEHE@Z ; CElementalSystem::GetErtelOption
  001e6	88 45 f4	 mov	 BYTE PTR _SocketOption$1[ebp], al

; 3037 : 		SocketOption[1] = (BYTE)-1;
; 3038 : 		SocketOption[2] = (BYTE)-1;
; 3039 : 		SocketOption[3] = (BYTE)-1;
; 3040 : 		SocketOption[4] = (BYTE)-1;
; 3041 : 
; 3042 : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, type , 0, 0, 0, 0, 0, -1, 0, 0,SocketBonus,SocketOption);

  001e9	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$1[ebp]
  001ec	50		 push	 eax
  001ed	8b 45 d8	 mov	 eax, DWORD PTR _iMithrilType$1$[ebp]
  001f0	0c 10		 or	 al, 16			; 00000010H
  001f2	c7 45 f5 ff ff
	ff ff		 mov	 DWORD PTR _SocketOption$1[ebp+1], -1
  001f9	0f b6 c0	 movzx	 eax, al
  001fc	50		 push	 eax
  001fd	6a 00		 push	 0
  001ff	6a 00		 push	 0
  00201	6a ff		 push	 -1
  00203	6a 00		 push	 0
  00205	6a 00		 push	 0
  00207	6a 00		 push	 0
  00209	6a 00		 push	 0
  0020b	6a 00		 push	 0
  0020d	56		 push	 esi
  0020e	6a 00		 push	 0
  00210	6a 00		 push	 0
  00212	68 ff 00 00 00	 push	 255			; 000000ffH
  00217	ff 37		 push	 DWORD PTR [edi]
  00219	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3043 : 		::gObjInventoryCommit(lpObj->m_Index);

  0021e	ff 37		 push	 DWORD PTR [edi]
  00220	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00225	83 c4 40	 add	 esp, 64			; 00000040H

; 3044 : #if( __4GAMERS__ == 1 )
; 3045 : 			g_Achievements.GD_UpdateMixData(lpObj, true);
; 3046 : #endif
; 3047 : 		LogAddTD("[Elemental System][Elixir Mix] [%s][%s] CBMix Success %d Money : %d-%d",

  00228	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0022b	53		 push	 ebx
  0022c	ff b7 cc 00 00
	00		 push	 DWORD PTR [edi+204]
  00232	ff b7 1c 12 00
	00		 push	 DWORD PTR [edi+4636]
  00238	50		 push	 eax
  00239	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0023c	50		 push	 eax
  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@CFOIEEJA@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@
  00242	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3065 : 	}
; 3066 : }

  00248	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024b	83 c4 18	 add	 esp, 24			; 00000018H
  0024e	33 cd		 xor	 ecx, ebp
  00250	5f		 pop	 edi
  00251	5e		 pop	 esi
  00252	5b		 pop	 ebx
  00253	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 04 00	 ret	 4
$LN17@ErrtelMix:

; 3048 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3049 : 	}
; 3050 : 	else
; 3051 : 	{
; 3052 : #if( __4GAMERS__ == 1 )
; 3053 : 			g_Achievements.GD_UpdateMixData(lpObj, false);
; 3054 : #endif
; 3055 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  0025e	57		 push	 edi
  0025f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00264	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 3056 : 		::GCUserChaosBoxSend(lpObj, 0);

  00269	6a 00		 push	 0
  0026b	57		 push	 edi
  0026c	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 3057 : 
; 3058 : 		pMsg.Result = ELEMENTAL_FAIL1;
; 3059 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00271	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00275	50		 push	 eax
  00276	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00279	c6 45 e7 f7	 mov	 BYTE PTR _pMsg$[ebp+3], 247 ; 000000f7H
  0027d	50		 push	 eax
  0027e	ff 37		 push	 DWORD PTR [edi]
  00280	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3060 : 
; 3061 : 		LogAddTD("[Elemental System][Elixir Mix] [%s][%s] CBMix Fail %d Money : %d-%d ",

  00285	53		 push	 ebx
  00286	ff b7 cc 00 00
	00		 push	 DWORD PTR [edi+204]
  0028c	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0028f	ff b7 1c 12 00
	00		 push	 DWORD PTR [edi+4636]
  00295	50		 push	 eax
  00296	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00299	50		 push	 eax
  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@EKMPONBC@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a5	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3062 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 3063 : 
; 3064 : 		lpObj->ChaosLock = FALSE;

  002a8	e9 be fe ff ff	 jmp	 $LN27@ErrtelMix
?ErrtelMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CElementalSystem::ErrtelMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ElixirMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iBounchOfElixirCount$1$ = -28				; size = 4
_iChaosCount$1$ = -24					; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?ElixirMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CElementalSystem::ElixirMix, COMDAT
; _this$ = ecx

; 2837 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 2838 : 	lpObj->ChaosLock = TRUE;
; 2839 : 
; 2840 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2841 : 
; 2842 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00015	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00018	57		 push	 edi
  00019	6a 10		 push	 16			; 00000010H
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	50		 push	 eax
  00021	c7 86 20 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4640], 1
  0002b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2843 : 	pMsg.Result = ELEMENTAL_IMPROPER;

  00033	c6 45 ef fb	 mov	 BYTE PTR _pMsg$[ebp+3], 251 ; 000000fbH

; 2844 : 
; 2845 : 	int iBounchOfElixirCount = 0;
; 2846 : 	int iChaosCount = 0;
; 2847 : 	int iOtherItemCount = 0;

  00037	33 db		 xor	 ebx, ebx
  00039	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iBounchOfElixirCount$1$[ebp], 0
  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iChaosCount$1$[ebp], 0
  00047	33 ff		 xor	 edi, edi
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ElixirMix:

; 2851 : 	{
; 2852 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 37		 jne	 SHORT $LN22@ElixirMix

; 2853 : 		{
; 2854 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,149) )

  00062	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  00068	b9 95 18 00 00	 mov	 ecx, 6293		; 00001895H
  0006d	0f b7 44 38 06	 movzx	 eax, WORD PTR [eax+edi+6]
  00072	66 3b c1	 cmp	 ax, cx
  00075	75 09		 jne	 SHORT $LN6@ElixirMix

; 2855 : 			{
; 2856 : 				iBounchOfElixirCount++;

  00077	8b 4d e4	 mov	 ecx, DWORD PTR _iBounchOfElixirCount$1$[ebp]
  0007a	41		 inc	 ecx
  0007b	89 4d e4	 mov	 DWORD PTR _iBounchOfElixirCount$1$[ebp], ecx
  0007e	eb 1c		 jmp	 SHORT $LN23@ElixirMix
$LN6@ElixirMix:

; 2857 : 			}
; 2858 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )

  00080	b9 0f 18 00 00	 mov	 ecx, 6159		; 0000180fH
  00085	66 3b c1	 cmp	 ax, cx

; 2859 : 			{
; 2860 : 				iChaosCount++;

  00088	8b 45 e8	 mov	 eax, DWORD PTR _iChaosCount$1$[ebp]

; 2861 : 			}
; 2862 : 			else

  0008b	8b 4d e4	 mov	 ecx, DWORD PTR _iBounchOfElixirCount$1$[ebp]
  0008e	75 06		 jne	 SHORT $LN8@ElixirMix

; 2859 : 			{
; 2860 : 				iChaosCount++;

  00090	40		 inc	 eax
  00091	89 45 e8	 mov	 DWORD PTR _iChaosCount$1$[ebp], eax

; 2861 : 			}
; 2862 : 			else

  00094	eb 09		 jmp	 SHORT $LN2@ElixirMix
$LN8@ElixirMix:

; 2863 : 			{
; 2864 : 				iOtherItemCount++;

  00096	43		 inc	 ebx
  00097	eb 06		 jmp	 SHORT $LN2@ElixirMix
$LN22@ElixirMix:
  00099	8b 4d e4	 mov	 ecx, DWORD PTR _iBounchOfElixirCount$1$[ebp]
$LN23@ElixirMix:
  0009c	8b 45 e8	 mov	 eax, DWORD PTR _iChaosCount$1$[ebp]
$LN2@ElixirMix:

; 2848 : 
; 2849 : 
; 2850 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0009f	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000a5	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  000ab	7c a3		 jl	 SHORT $LL4@ElixirMix

; 2865 : 			}
; 2866 : 		}
; 2867 : 	}
; 2868 : 
; 2869 : 	if( iBounchOfElixirCount != 1 ||
; 2870 : 		iChaosCount != 1 ||

  000ad	83 f9 01	 cmp	 ecx, 1
  000b0	75 71		 jne	 SHORT $LN11@ElixirMix
  000b2	3b c1		 cmp	 eax, ecx
  000b4	75 6d		 jne	 SHORT $LN11@ElixirMix
  000b6	85 db		 test	 ebx, ebx
  000b8	75 69		 jne	 SHORT $LN11@ElixirMix

; 2876 : 
; 2877 : 		return;
; 2878 : 	}
; 2879 : 
; 2880 : 	g_ChaosBox.LogChaosItem(lpObj, "Elixir Mix");

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CHFCKLND@Elixir?5Mix?$AA@
  000bf	56		 push	 esi
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  000c5	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 2881 : 	LogAddTD("[Elemental System] Elixir Mix Start");

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NNKLGBLG@?$FLElemental?5System?$FN?5Elixir?5Mix?5St@
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d5	83 c4 04	 add	 esp, 4

; 2882 : 
; 2883 : 	lpObj->ChaosSuccessRate = 80;

  000d8	c7 86 1c 12 00
	00 50 00 00 00	 mov	 DWORD PTR [esi+4636], 80 ; 00000050H

; 2884 : 	int nChaosNeedMoney = 100000;
; 2885 : 
; 2886 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  000e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000e7	ff 36		 push	 DWORD PTR [esi]
  000e9	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  000ee	8b c8		 mov	 ecx, eax
  000f0	b8 a0 86 01 00	 mov	 eax, 100000		; 000186a0H
  000f5	f7 e9		 imul	 ecx
  000f7	53		 push	 ebx
  000f8	6a 64		 push	 100			; 00000064H
  000fa	52		 push	 edx
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 __alldiv
  00101	8b c8		 mov	 ecx, eax

; 2887 : 
; 2888 : 	if ( iChaosTaxMoney < 0 )

  00103	33 c0		 xor	 eax, eax
  00105	85 c9		 test	 ecx, ecx
  00107	0f 48 c8	 cmovs	 ecx, eax

; 2889 : 	{
; 2890 : 		iChaosTaxMoney = 0;
; 2891 : 	}
; 2892 : 
; 2893 : 	nChaosNeedMoney += iChaosTaxMoney;

  0010a	8d b9 a0 86 01
	00		 lea	 edi, DWORD PTR [ecx+100000]

; 2894 : 
; 2895 : 	if ( nChaosNeedMoney < 0 )

  00110	85 ff		 test	 edi, edi
  00112	0f 48 f8	 cmovs	 edi, eax

; 2896 : 	{
; 2897 : 		nChaosNeedMoney = 0;
; 2898 : 	}
; 2899 : 
; 2900 : 	if ( lpObj->Money < nChaosNeedMoney )

  00115	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  0011b	3b c7		 cmp	 eax, edi
  0011d	7d 34		 jge	 SHORT $LN14@ElixirMix

; 2901 : 	{
; 2902 : 		pMsg.Result = ELEMENTAL_NOZEN;

  0011f	c6 45 ef f9	 mov	 BYTE PTR _pMsg$[ebp+3], 249 ; 000000f9H
$LN11@ElixirMix:

; 2871 : 		iOtherItemCount != 0 )
; 2872 : 
; 2873 : 	{
; 2874 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00123	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00127	50		 push	 eax
  00128	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0012b	50		 push	 eax
  0012c	ff 36		 push	 DWORD PTR [esi]
  0012e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@ElixirMix:

; 2875 : 		lpObj->ChaosLock = FALSE;

  00136	5f		 pop	 edi
  00137	c7 86 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4640], 0
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx

; 2942 : 	}
; 2943 : }

  00143	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00146	33 cd		 xor	 ecx, ebp
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 04 00	 ret	 4
$LN14@ElixirMix:

; 2903 : 		
; 2904 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 2905 : 		lpObj->ChaosLock = FALSE;
; 2906 : 
; 2907 : 		return;
; 2908 : 	}
; 2909 : 
; 2910 : 	lpObj->Money -= nChaosNeedMoney;

  00153	2b c7		 sub	 eax, edi

; 2911 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  00155	51		 push	 ecx
  00156	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0015b	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00161	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 2912 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00166	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0016c	ff 36		 push	 DWORD PTR [esi]
  0016e	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00173	83 c4 08	 add	 esp, 8

; 2913 : 
; 2914 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00176	e8 00 00 00 00	 call	 _rand
  0017b	99		 cdq
  0017c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00181	f7 f9		 idiv	 ecx
  00183	3b 96 1c 12 00
	00		 cmp	 edx, DWORD PTR [esi+4636]
  00189	7d 69		 jge	 SHORT $LN15@ElixirMix

; 2915 : 	{
; 2916 : 		int type = ITEMGET(12,147);
; 2917 : 
; 2918 : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, type , 0, 0, 0, 0, 0, -1, 0, 0);

  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	6a 00		 push	 0
  00191	6a 00		 push	 0
  00193	6a ff		 push	 -1
  00195	6a 00		 push	 0
  00197	6a 00		 push	 0
  00199	6a 00		 push	 0
  0019b	6a 00		 push	 0
  0019d	6a 00		 push	 0
  0019f	68 93 18 00 00	 push	 6291			; 00001893H
  001a4	6a 00		 push	 0
  001a6	6a 00		 push	 0
  001a8	68 ff 00 00 00	 push	 255			; 000000ffH
  001ad	ff 36		 push	 DWORD PTR [esi]
  001af	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 2919 : 		::gObjInventoryCommit(lpObj->m_Index);

  001b4	ff 36		 push	 DWORD PTR [esi]
  001b6	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  001bb	83 c4 40	 add	 esp, 64			; 00000040H

; 2920 : #if( __4GAMERS__ == 1 )
; 2921 : 			g_Achievements.GD_UpdateMixData(lpObj, true);
; 2922 : #endif
; 2923 : 		LogAddTD("[Elemental System][Elixir Mix] [%s][%s] CBMix Success %d Money : %d-%d",

  001be	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001c1	57		 push	 edi
  001c2	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  001c8	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  001ce	83 c6 52	 add	 esi, 82			; 00000052H
  001d1	50		 push	 eax
  001d2	56		 push	 esi
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@CFOIEEJA@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2942 : 	}
; 2943 : }

  001de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e1	83 c4 18	 add	 esp, 24			; 00000018H
  001e4	33 cd		 xor	 ecx, ebp
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ee	8b e5		 mov	 esp, ebp
  001f0	5d		 pop	 ebp
  001f1	c2 04 00	 ret	 4
$LN15@ElixirMix:

; 2924 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 2925 : 
; 2926 : 	}
; 2927 : 	else
; 2928 : 	{
; 2929 : #if( __4GAMERS__ == 1 )
; 2930 : 			g_Achievements.GD_UpdateMixData(lpObj, false);
; 2931 : #endif
; 2932 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  001f4	56		 push	 esi
  001f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  001fa	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 2933 : 		::GCUserChaosBoxSend(lpObj, 0);

  001ff	6a 00		 push	 0
  00201	56		 push	 esi
  00202	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2934 : 
; 2935 : 		pMsg.Result = ELEMENTAL_FAIL1;
; 2936 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00207	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0020b	50		 push	 eax
  0020c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0020f	c6 45 ef f7	 mov	 BYTE PTR _pMsg$[ebp+3], 247 ; 000000f7H
  00213	50		 push	 eax
  00214	ff 36		 push	 DWORD PTR [esi]
  00216	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2937 : 
; 2938 : 		LogAddTD("[Elemental System][Elixir Mix] [%s][%s] CBMix Fail %d Money : %d-%d ",

  0021b	57		 push	 edi
  0021c	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00222	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00225	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  0022b	50		 push	 eax
  0022c	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0022f	50		 push	 eax
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@EKMPONBC@?$FLElemental?5System?$FN?$FLElixir?5Mix?$FN?5?$FL@
  00235	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0023b	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2939 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 2940 : 
; 2941 : 		lpObj->ChaosLock = FALSE;

  0023e	e9 f3 fe ff ff	 jmp	 $LN24@ElixirMix
?ElixirMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CElementalSystem::ElixirMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?MithrilMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iMithrilType$1$ = -36					; size = 4
_iChaosCount$1$ = -32					; size = 4
_pMsg$ = -28						; size = 16
_iBounchOfMithrilCount$1$ = -12				; size = 4
_SocketOption$1 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?MithrilMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CElementalSystem::MithrilMix, COMDAT
; _this$ = ecx

; 2723 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 2724 : 	lpObj->ChaosLock = TRUE;
; 2725 : 
; 2726 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2727 : 
; 2728 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00015	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00018	57		 push	 edi
  00019	6a 10		 push	 16			; 00000010H
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	50		 push	 eax
  00021	c7 86 20 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4640], 1
  0002b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2729 : 	pMsg.Result = ELEMENTAL_IMPROPER;
; 2730 : 
; 2731 : 	int iBounchOfMithrilCount = 0;
; 2732 : 	int iMithrilType = -1;

  00030	83 c8 ff	 or	 eax, -1
  00033	c6 45 e7 fb	 mov	 BYTE PTR _pMsg$[ebp+3], 251 ; 000000fbH
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iBounchOfMithrilCount$1$[ebp], 0

; 2733 : 	int iChaosCount = 0;
; 2734 : 	int iOtherItemCount = 0;

  00041	33 db		 xor	 ebx, ebx
  00043	89 45 dc	 mov	 DWORD PTR _iMithrilType$1$[ebp], eax
  00046	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iChaosCount$1$[ebp], 0
  0004d	33 ff		 xor	 edi, edi
  0004f	90		 npad	 1
$LL4@MithrilMix:

; 2738 : 	{
; 2739 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00056	03 cf		 add	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 42		 jne	 SHORT $LN22@MithrilMix

; 2740 : 		{
; 2741 : 			if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,148) )

  00062	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  00068	ba 94 18 00 00	 mov	 edx, 6292		; 00001894H
  0006d	0f b7 4c 38 06	 movzx	 ecx, WORD PTR [eax+edi+6]
  00072	66 3b ca	 cmp	 cx, dx
  00075	75 14		 jne	 SHORT $LN6@MithrilMix

; 2742 : 			{
; 2743 : 				iMithrilType = lpObj->pChaosBox[n].m_SocketBonus;
; 2744 : 				iBounchOfMithrilCount++;

  00077	8b 4d f4	 mov	 ecx, DWORD PTR _iBounchOfMithrilCount$1$[ebp]
  0007a	0f b6 84 38 c7
	00 00 00	 movzx	 eax, BYTE PTR [eax+edi+199]
  00082	41		 inc	 ecx
  00083	89 45 dc	 mov	 DWORD PTR _iMithrilType$1$[ebp], eax
  00086	89 4d f4	 mov	 DWORD PTR _iBounchOfMithrilCount$1$[ebp], ecx
  00089	eb 1c		 jmp	 SHORT $LN23@MithrilMix
$LN6@MithrilMix:

; 2745 : 			}
; 2746 : 			else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(12,15) )

  0008b	b8 0f 18 00 00	 mov	 eax, 6159		; 0000180fH
  00090	66 3b c8	 cmp	 cx, ax

; 2747 : 			{
; 2748 : 				iChaosCount++;

  00093	8b 45 e0	 mov	 eax, DWORD PTR _iChaosCount$1$[ebp]

; 2749 : 			}
; 2750 : 			else

  00096	8b 4d f4	 mov	 ecx, DWORD PTR _iBounchOfMithrilCount$1$[ebp]
  00099	75 06		 jne	 SHORT $LN8@MithrilMix

; 2747 : 			{
; 2748 : 				iChaosCount++;

  0009b	40		 inc	 eax
  0009c	89 45 e0	 mov	 DWORD PTR _iChaosCount$1$[ebp], eax

; 2749 : 			}
; 2750 : 			else

  0009f	eb 09		 jmp	 SHORT $LN2@MithrilMix
$LN8@MithrilMix:

; 2751 : 			{
; 2752 : 				iOtherItemCount++;

  000a1	43		 inc	 ebx
  000a2	eb 06		 jmp	 SHORT $LN2@MithrilMix
$LN22@MithrilMix:
  000a4	8b 4d f4	 mov	 ecx, DWORD PTR _iBounchOfMithrilCount$1$[ebp]
$LN23@MithrilMix:
  000a7	8b 45 e0	 mov	 eax, DWORD PTR _iChaosCount$1$[ebp]
$LN2@MithrilMix:

; 2735 : 
; 2736 : 
; 2737 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000aa	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000b0	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  000b6	7c 98		 jl	 SHORT $LL4@MithrilMix

; 2753 : 			}
; 2754 : 		}
; 2755 : 	}
; 2756 : 
; 2757 : 	if( iBounchOfMithrilCount != 1 ||
; 2758 : 		iChaosCount != 1 ||

  000b8	83 f9 01	 cmp	 ecx, 1
  000bb	75 71		 jne	 SHORT $LN11@MithrilMix
  000bd	3b c1		 cmp	 eax, ecx
  000bf	75 6d		 jne	 SHORT $LN11@MithrilMix
  000c1	85 db		 test	 ebx, ebx
  000c3	75 69		 jne	 SHORT $LN11@MithrilMix

; 2764 : 
; 2765 : 		return;
; 2766 : 	}
; 2767 : 
; 2768 : 	g_ChaosBox.LogChaosItem(lpObj, "Mithril Mix");

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JOFENNCC@Mithril?5Mix?$AA@
  000ca	56		 push	 esi
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  000d0	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 2769 : 	LogAddTD("[Elemental System] Mithril Mix Start");

  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KHNHOBHG@?$FLElemental?5System?$FN?5Mithril?5Mix?5S@
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e0	83 c4 04	 add	 esp, 4

; 2770 : 
; 2771 : 	lpObj->ChaosSuccessRate = 80;

  000e3	c7 86 1c 12 00
	00 50 00 00 00	 mov	 DWORD PTR [esi+4636], 80 ; 00000050H

; 2772 : 	int nChaosNeedMoney = 100000;
; 2773 : 
; 2774 : 	int iChaosTaxMoney = (int)((__int64)nChaosNeedMoney * (__int64)g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / (__int64)100);

  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000f2	ff 36		 push	 DWORD PTR [esi]
  000f4	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  000f9	8b c8		 mov	 ecx, eax
  000fb	b8 a0 86 01 00	 mov	 eax, 100000		; 000186a0H
  00100	f7 e9		 imul	 ecx
  00102	53		 push	 ebx
  00103	6a 64		 push	 100			; 00000064H
  00105	52		 push	 edx
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 __alldiv
  0010c	8b c8		 mov	 ecx, eax

; 2775 : 
; 2776 : 	if ( iChaosTaxMoney < 0 )

  0010e	33 c0		 xor	 eax, eax
  00110	85 c9		 test	 ecx, ecx
  00112	0f 48 c8	 cmovs	 ecx, eax

; 2777 : 	{
; 2778 : 		iChaosTaxMoney = 0;
; 2779 : 	}
; 2780 : 
; 2781 : 	nChaosNeedMoney += iChaosTaxMoney;

  00115	8d b9 a0 86 01
	00		 lea	 edi, DWORD PTR [ecx+100000]

; 2782 : 
; 2783 : 	if ( nChaosNeedMoney < 0 )

  0011b	85 ff		 test	 edi, edi
  0011d	0f 48 f8	 cmovs	 edi, eax

; 2784 : 	{
; 2785 : 		nChaosNeedMoney = 0;
; 2786 : 	}
; 2787 : 
; 2788 : 	if ( lpObj->Money < nChaosNeedMoney )

  00120	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00126	3b c7		 cmp	 eax, edi
  00128	7d 34		 jge	 SHORT $LN14@MithrilMix

; 2789 : 	{
; 2790 : 		pMsg.Result = ELEMENTAL_NOZEN;

  0012a	c6 45 e7 f9	 mov	 BYTE PTR _pMsg$[ebp+3], 249 ; 000000f9H
$LN11@MithrilMix:

; 2759 : 		iOtherItemCount != 0 )
; 2760 : 
; 2761 : 	{
; 2762 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0012e	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00132	50		 push	 eax
  00133	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00136	50		 push	 eax
  00137	ff 36		 push	 DWORD PTR [esi]
  00139	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@MithrilMix:

; 2763 : 		lpObj->ChaosLock = FALSE;

  00141	5f		 pop	 edi
  00142	c7 86 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4640], 0
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx

; 2833 : 	}
; 2834 : }

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00151	33 cd		 xor	 ecx, ebp
  00153	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
$LN14@MithrilMix:

; 2791 : 		
; 2792 : 		DataSend(lpObj->m_Index, (BYTE *)&pMsg, pMsg.h.size);
; 2793 : 		lpObj->ChaosLock = FALSE;
; 2794 : 
; 2795 : 		return;
; 2796 : 	}
; 2797 : 
; 2798 : 	lpObj->Money -= nChaosNeedMoney;

  0015e	2b c7		 sub	 eax, edi

; 2799 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  00160	51		 push	 ecx
  00161	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00166	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0016c	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 2800 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00171	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00177	ff 36		 push	 DWORD PTR [esi]
  00179	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0017e	83 c4 08	 add	 esp, 8

; 2801 : 
; 2802 : 	if ( (rand()%100) < lpObj->ChaosSuccessRate )

  00181	e8 00 00 00 00	 call	 _rand
  00186	99		 cdq
  00187	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0018c	f7 f9		 idiv	 ecx
  0018e	3b 96 1c 12 00
	00		 cmp	 edx, DWORD PTR [esi+4636]
  00194	7d 78		 jge	 SHORT $LN15@MithrilMix

; 2803 : 	{
; 2804 : 		int type = ITEMGET(12,145);
; 2805 : 
; 2806 : 		BYTE SocketBonus = iMithrilType;
; 2807 : 		BYTE SocketOption[5] = {-1};
; 2808 : 
; 2809 : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, type , 0, 0, 0, 0, 0, -1, 0, 0,SocketBonus,SocketOption);

  00196	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$1[ebp]
  00199	c6 45 f4 ff	 mov	 BYTE PTR _SocketOption$1[ebp], 255 ; 000000ffH
  0019d	50		 push	 eax
  0019e	8b 45 dc	 mov	 eax, DWORD PTR _iMithrilType$1$[ebp]
  001a1	50		 push	 eax
  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	6a ff		 push	 -1
  001a8	6a 00		 push	 0
  001aa	6a 00		 push	 0
  001ac	6a 00		 push	 0
  001ae	6a 00		 push	 0
  001b0	6a 00		 push	 0
  001b2	68 91 18 00 00	 push	 6289			; 00001891H
  001b7	6a 00		 push	 0
  001b9	6a 00		 push	 0
  001bb	68 ff 00 00 00	 push	 255			; 000000ffH
  001c0	ff 36		 push	 DWORD PTR [esi]
  001c2	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _SocketOption$1[ebp+1], 0
  001c9	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 2810 : 		::gObjInventoryCommit(lpObj->m_Index);

  001ce	ff 36		 push	 DWORD PTR [esi]
  001d0	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  001d5	83 c4 40	 add	 esp, 64			; 00000040H

; 2811 : #if( __4GAMERS__ == 1 )
; 2812 : 			g_Achievements.GD_UpdateMixData(lpObj, true);
; 2813 : #endif
; 2814 : 		LogAddTD("[Elemental System][Mithril Mix] [%s][%s] CBMix Success %d Money : %d-%d",

  001d8	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001db	57		 push	 edi
  001dc	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  001e2	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  001e8	83 c6 52	 add	 esi, 82			; 00000052H
  001eb	50		 push	 eax
  001ec	56		 push	 esi
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@MHGFDFME@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2833 : 	}
; 2834 : }

  001f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fb	83 c4 18	 add	 esp, 24			; 00000018H
  001fe	33 cd		 xor	 ecx, ebp
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx
  00203	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 04 00	 ret	 4
$LN15@MithrilMix:

; 2815 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 2816 : 
; 2817 : 	}
; 2818 : 	else
; 2819 : 	{
; 2820 : #if( __4GAMERS__ == 1 )
; 2821 : 			g_Achievements.GD_UpdateMixData(lpObj, false);
; 2822 : #endif
; 2823 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  0020e	56		 push	 esi
  0020f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00214	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 2824 : 		::GCUserChaosBoxSend(lpObj, 0);

  00219	6a 00		 push	 0
  0021b	56		 push	 esi
  0021c	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 2825 : 
; 2826 : 		pMsg.Result = ELEMENTAL_FAIL1;
; 2827 : 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00221	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00225	50		 push	 eax
  00226	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00229	c6 45 e7 f7	 mov	 BYTE PTR _pMsg$[ebp+3], 247 ; 000000f7H
  0022d	50		 push	 eax
  0022e	ff 36		 push	 DWORD PTR [esi]
  00230	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2828 : 
; 2829 : 		LogAddTD("[Elemental System][Mithril Mix] [%s][%s] CBMix Fail %d Money : %d-%d ",

  00235	57		 push	 edi
  00236	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0023c	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0023f	ff b6 1c 12 00
	00		 push	 DWORD PTR [esi+4636]
  00245	50		 push	 eax
  00246	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00249	50		 push	 eax
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@PECHNODK@?$FLElemental?5System?$FN?$FLMithril?5Mix?$FN?5@
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00255	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2830 : 			lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, nChaosNeedMoney);
; 2831 : 
; 2832 : 		lpObj->ChaosLock = FALSE;

  00258	e9 e4 fe ff ff	 jmp	 $LN24@MithrilMix
?MithrilMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CElementalSystem::MithrilMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -28					; size = 4
_aIndex$GSCopy$1$ = -24					; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z PROC ; CElementalSystem::CGUpgradeButtonClick, COMDAT
; _this$ = ecx

; 2630 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]

; 2631 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2632 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00014	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001b	6a 10		 push	 16			; 00000010H
  0001d	68 86 00 00 00	 push	 134			; 00000086H
  00022	50		 push	 eax
  00023	89 4d e4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00026	89 7d e8	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], edi
  00029	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2633 : 	pMsg.Result = CB_IMPROPER_MATERIALS;
; 2634 : 
; 2635 : 	if ( !gObjIsConnectedGP(aIndex))

  0002e	57		 push	 edi
  0002f	c6 45 ef fb	 mov	 BYTE PTR _pMsg$[ebp+3], 251 ; 000000fbH
  00033	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	85 c0		 test	 eax, eax
  0003d	75 2c		 jne	 SHORT $LN7@CGUpgradeB

; 2636 : 	{
; 2637 : 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  0003f	68 4d 0a 00 00	 push	 2637			; 00000a4dH
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KNKAACGF@ElementalSystem?4cpp?$AA@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  0004e	6a 02		 push	 2
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00056	83 c4 10	 add	 esp, 16			; 00000010H
  00059	5f		 pop	 edi
  0005a	5b		 pop	 ebx

; 2719 : 	}
; 2720 : }

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
$LN7@CGUpgradeB:
  0006b	56		 push	 esi

; 2638 : 		return;
; 2639 : 	}
; 2640 : 
; 2641 : 	LPOBJ lpObj = &gObj[aIndex];

  0006c	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00072	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2642 : 
; 2643 : 	if ( lpObj->ChaosLock == TRUE )

  00078	83 be 20 12 00
	00 01		 cmp	 DWORD PTR [esi+4640], 1
  0007f	75 34		 jne	 SHORT $LN8@CGUpgradeB

; 2644 : 	{
; 2645 : 		LogAdd("[%s][%s] Already Used Chaos",

  00081	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00084	50		 push	 eax
  00085	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00088	50		 push	 eax
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2646 : 			lpObj->AccountID, lpObj->Name);
; 2647 : 
; 2648 : 		pMsg.Result = CB_ALREADY_OPEN;
; 2649 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00094	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00098	50		 push	 eax
  00099	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009c	c6 45 ef fe	 mov	 BYTE PTR _pMsg$[ebp+3], 254 ; 000000feH
  000a0	50		 push	 eax
  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a7	83 c4 18	 add	 esp, 24			; 00000018H

; 2650 : 
; 2651 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(2, 198)), lpObj->m_Index, 1);

  000aa	6a 01		 push	 1
  000ac	ff 36		 push	 DWORD PTR [esi]
  000ae	68 c6 02 00 00	 push	 710			; 000002c6H

; 2652 : 		return;

  000b3	eb 3b		 jmp	 SHORT $LN33@CGUpgradeB
$LN8@CGUpgradeB:

; 2653 : 	}
; 2654 : 
; 2655 : 	if ( lpObj->m_bPShopOpen == true )

  000b5	80 be 5c 12 00
	00 01		 cmp	 BYTE PTR [esi+4700], 1
  000bc	75 58		 jne	 SHORT $LN9@CGUpgradeB

; 2656 : 	{
; 2657 : 		LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed",

  000be	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000c1	50		 push	 eax
  000c2	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000c5	50		 push	 eax
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2658 : 			lpObj->AccountID, lpObj->Name);
; 2659 : 
; 2660 : 		pMsg.Result = CB_PSHOP_OPEN;
; 2661 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000d1	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000d5	50		 push	 eax
  000d6	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000d9	c6 45 ef fd	 mov	 BYTE PTR _pMsg$[ebp+3], 253 ; 000000fdH
  000dd	50		 push	 eax
  000de	57		 push	 edi
  000df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e4	83 c4 18	 add	 esp, 24			; 00000018H

; 2662 : 
; 2663 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  000e7	6a 01		 push	 1
  000e9	ff 36		 push	 DWORD PTR [esi]
  000eb	68 c2 04 00 00	 push	 1218			; 000004c2H
$LN33@CGUpgradeB:
  000f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000f5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	5e		 pop	 esi
  00104	5f		 pop	 edi
  00105	5b		 pop	 ebx

; 2719 : 	}
; 2720 : }

  00106	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00109	33 cd		 xor	 ecx, ebp
  0010b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 08 00	 ret	 8
$LN9@CGUpgradeB:

; 2664 : 		return;
; 2665 : 	}
; 2666 : 
; 2667 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00116	33 ff		 xor	 edi, edi
  00118	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@CGUpgradeB:

; 2668 : 	{
; 2669 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00120	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00126	03 cf		 add	 ecx, edi
  00128	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 85 9f 00 00
	00		 jne	 $LN2@CGUpgradeB

; 2670 : 		{
; 2671 : 			if( lpObj->pChaosBox[n].m_Type == ITEMGET(12,221) ||
; 2672 : 				lpObj->pChaosBox[n].m_Type == ITEMGET(12,231) ||
; 2673 : 				lpObj->pChaosBox[n].m_Type == ITEMGET(12,241) ||
; 2674 : 				lpObj->pChaosBox[n].m_Type == ITEMGET(12,251) ||

  00136	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  0013c	ba dd 18 00 00	 mov	 edx, 6365		; 000018ddH
  00141	03 cf		 add	 ecx, edi
  00143	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00147	66 3b c2	 cmp	 ax, dx
  0014a	74 28		 je	 SHORT $LN12@CGUpgradeB
  0014c	ba e7 18 00 00	 mov	 edx, 6375		; 000018e7H
  00151	66 3b c2	 cmp	 ax, dx
  00154	74 1e		 je	 SHORT $LN12@CGUpgradeB
  00156	ba f1 18 00 00	 mov	 edx, 6385		; 000018f1H
  0015b	66 3b c2	 cmp	 ax, dx
  0015e	74 14		 je	 SHORT $LN12@CGUpgradeB
  00160	ba fb 18 00 00	 mov	 edx, 6395		; 000018fbH
  00165	66 3b c2	 cmp	 ax, dx
  00168	74 0a		 je	 SHORT $LN12@CGUpgradeB
  0016a	ba 05 19 00 00	 mov	 edx, 6405		; 00001905H
  0016f	66 3b c2	 cmp	 ax, dx
  00172	75 61		 jne	 SHORT $LN2@CGUpgradeB
$LN12@CGUpgradeB:

; 2675 : 				lpObj->pChaosBox[n].m_Type == ITEMGET(12,261) )
; 2676 : 			{
; 2677 : 				int iActiveRank = lpObj->pChaosBox[n].m_SocketBonus/16;

  00174	0f b6 81 c7 00
	00 00		 movzx	 eax, BYTE PTR [ecx+199]
  0017b	c1 e8 04	 shr	 eax, 4

; 2678 : 				
; 2679 : 				if( iActiveRank  <= 0 || iActiveRank > 5  )

  0017e	85 c0		 test	 eax, eax
  00180	0f 8e a6 00 00
	00		 jle	 $LN14@CGUpgradeB
  00186	83 f8 05	 cmp	 eax, 5
  00189	0f 8f 9d 00 00
	00		 jg	 $LN14@CGUpgradeB

; 2684 : 					return;
; 2685 : 				}
; 2686 : 
; 2687 : 				int iUpdateLevel = lpObj->pChaosBox[n].m_SocketOption[iActiveRank-1]/16;

  0018f	0f b6 94 01 c7
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+199]

; 2688 : 
; 2689 : 				if( lpMsg->btType == 0 )

  00197	8a 4b 04	 mov	 cl, BYTE PTR [ebx+4]
  0019a	c1 ea 04	 shr	 edx, 4
  0019d	84 c9		 test	 cl, cl
  0019f	75 1a		 jne	 SHORT $LN15@CGUpgradeB

; 2690 : 				{
; 2691 : 					if( (iUpdateLevel+1) != lpMsg->btLevel )

  001a1	0f b6 4b 05	 movzx	 ecx, BYTE PTR [ebx+5]
  001a5	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001a8	3b c1		 cmp	 eax, ecx
  001aa	74 29		 je	 SHORT $LN2@CGUpgradeB

; 2692 : 					{
; 2693 : 						LogAdd("[%s][%s] Ertel level info error !",lpObj->AccountID, lpObj->Name);

  001ac	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001af	50		 push	 eax
  001b0	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  001b3	50		 push	 eax
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KJHJFHEO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5level?5info?5error?5@

; 2694 : 
; 2695 : 						DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2696 : 						return;

  001b9	eb 7e		 jmp	 SHORT $LN32@CGUpgradeB
$LN15@CGUpgradeB:

; 2697 : 					}
; 2698 : 				}
; 2699 : 				else if( lpMsg->btType == 1 )

  001bb	80 f9 01	 cmp	 cl, 1
  001be	75 15		 jne	 SHORT $LN2@CGUpgradeB

; 2700 : 				{
; 2701 : 					if( iUpdateLevel < 7 || iActiveRank == 5 || lpMsg->btLevel < 1 || lpMsg->btLevel>5 )

  001c0	83 fa 07	 cmp	 edx, 7
  001c3	7c 58		 jl	 SHORT $LN20@CGUpgradeB
  001c5	83 f8 05	 cmp	 eax, 5
  001c8	74 53		 je	 SHORT $LN20@CGUpgradeB
  001ca	8a 43 05	 mov	 al, BYTE PTR [ebx+5]
  001cd	3a c1		 cmp	 al, cl
  001cf	72 4c		 jb	 SHORT $LN20@CGUpgradeB
  001d1	3c 05		 cmp	 al, 5
  001d3	77 48		 ja	 SHORT $LN20@CGUpgradeB
$LN2@CGUpgradeB:

; 2664 : 		return;
; 2665 : 	}
; 2666 : 
; 2667 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  001d5	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  001db	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  001e1	0f 8c 39 ff ff
	ff		 jl	 $LL4@CGUpgradeB

; 2707 : 					}
; 2708 : 				}
; 2709 : 			}
; 2710 : 		}
; 2711 : 	}
; 2712 : 
; 2713 : 	lpObj->bIsChaosMixCompleted = true;

  001e7	c6 86 09 16 00
	00 01		 mov	 BYTE PTR [esi+5641], 1

; 2714 : 
; 2715 : 	switch( lpMsg->btType )

  001ee	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  001f2	83 e8 00	 sub	 eax, 0
  001f5	74 6f		 je	 SHORT $LN21@CGUpgradeB
  001f7	83 e8 01	 sub	 eax, 1
  001fa	75 73		 jne	 SHORT $LN31@CGUpgradeB

; 2718 : 	case 1:	ErrtelRankUp(lpObj,lpMsg->btLevel);	break;

  001fc	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00200	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00203	50		 push	 eax
  00204	56		 push	 esi
  00205	e8 00 00 00 00	 call	 ?ErrtelRankUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@E@Z ; CElementalSystem::ErrtelRankUp
  0020a	5e		 pop	 esi
  0020b	5f		 pop	 edi
  0020c	5b		 pop	 ebx

; 2719 : 	}
; 2720 : }

  0020d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00210	33 cd		 xor	 ecx, ebp
  00212	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c2 08 00	 ret	 8
$LN20@CGUpgradeB:

; 2702 : 					{
; 2703 : 						LogAdd("[%s][%s] Ertel rank up info error !",lpObj->AccountID, lpObj->Name);

  0021d	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00220	50		 push	 eax
  00221	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00224	50		 push	 eax
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@ICIBLGAE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5up?5info?5erro@

; 2704 : 
; 2705 : 						DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2706 : 						return;

  0022a	eb 0d		 jmp	 SHORT $LN32@CGUpgradeB
$LN14@CGUpgradeB:

; 2680 : 				{
; 2681 : 					LogAdd("[%s][%s] Ertel rank info error !",lpObj->AccountID, lpObj->Name);

  0022c	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0022f	50		 push	 eax
  00230	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00233	50		 push	 eax
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FIEELGCG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ertel?5rank?5info?5error?5?$CB@
$LN32@CGUpgradeB:
  00239	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2682 : 
; 2683 : 					DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0023f	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00243	50		 push	 eax
  00244	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00247	50		 push	 eax
  00248	ff 75 e8	 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  0024b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00250	83 c4 18	 add	 esp, 24			; 00000018H
  00253	5e		 pop	 esi
  00254	5f		 pop	 edi
  00255	5b		 pop	 ebx

; 2719 : 	}
; 2720 : }

  00256	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00259	33 cd		 xor	 ecx, ebp
  0025b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c2 08 00	 ret	 8
$LN21@CGUpgradeB:

; 2716 : 	{
; 2717 : 	case 0:	ErrtelLevelUp(lpObj);	break;

  00266	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00269	56		 push	 esi
  0026a	e8 00 00 00 00	 call	 ?ErrtelLevelUp@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::ErrtelLevelUp
$LN31@CGUpgradeB:

; 2719 : 	}
; 2720 : }

  0026f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00272	5e		 pop	 esi
  00273	5f		 pop	 edi
  00274	33 cd		 xor	 ecx, ebp
  00276	5b		 pop	 ebx
  00277	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c2 08 00	 ret	 8
?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z ENDP ; CElementalSystem::CGUpgradeButtonClick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$1$ = -24					; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z PROC ; CElementalSystem::CGCombineButtonClick, COMDAT
; _this$ = ecx

; 2562 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	57		 push	 edi

; 2563 : 	PMSG_CHAOSMIXRESULT pMsg;
; 2564 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00018	6a 10		 push	 16			; 00000010H
  0001a	89 45 e8	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], eax
  0001d	8b f9		 mov	 edi, ecx
  0001f	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00022	68 86 00 00 00	 push	 134			; 00000086H
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2565 : 	pMsg.Result = CB_ERROR;
; 2566 : 
; 2567 : 	if ( !gObjIsConnectedGP(aIndex))

  0002d	53		 push	 ebx
  0002e	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00032	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	85 c0		 test	 eax, eax
  0003c	75 2c		 jne	 SHORT $LN4@CGCombineB

; 2568 : 	{
; 2569 : 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  0003e	68 09 0a 00 00	 push	 2569			; 00000a09H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KNKAACGF@ElementalSystem?4cpp?$AA@
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  0004d	6a 02		 push	 2
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	5f		 pop	 edi
  00059	5b		 pop	 ebx

; 2625 : 		break;
; 2626 : 	}
; 2627 : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN4@CGCombineB:
  0006a	56		 push	 esi

; 2570 : 		return;
; 2571 : 	}
; 2572 : 
; 2573 : 	LPOBJ lpObj = &gObj[aIndex];

  0006b	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00071	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2574 : 
; 2575 : 	if ( lpObj->ChaosLock == TRUE )

  00077	83 be 20 12 00
	00 01		 cmp	 DWORD PTR [esi+4640], 1
  0007e	75 34		 jne	 SHORT $LN5@CGCombineB

; 2576 : 	{
; 2577 : 		LogAdd("[%s][%s] Already Used Chaos",

  00080	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00083	50		 push	 eax
  00084	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00087	50		 push	 eax
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2578 : 			lpObj->AccountID, lpObj->Name);
; 2579 : 
; 2580 : 		pMsg.Result = CB_ALREADY_OPEN;
; 2581 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00093	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00097	50		 push	 eax
  00098	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009b	c6 45 ef fe	 mov	 BYTE PTR _pMsg$[ebp+3], 254 ; 000000feH
  0009f	50		 push	 eax
  000a0	53		 push	 ebx
  000a1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a6	83 c4 18	 add	 esp, 24			; 00000018H

; 2582 : 
; 2583 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(2, 198)), lpObj->m_Index, 1);

  000a9	6a 01		 push	 1
  000ab	ff 36		 push	 DWORD PTR [esi]
  000ad	68 c6 02 00 00	 push	 710			; 000002c6H

; 2584 : 		return;

  000b2	eb 3b		 jmp	 SHORT $LN15@CGCombineB
$LN5@CGCombineB:

; 2585 : 	}
; 2586 : 
; 2587 : 	if ( lpObj->m_bPShopOpen == true )

  000b4	80 be 5c 12 00
	00 01		 cmp	 BYTE PTR [esi+4700], 1
  000bb	75 58		 jne	 SHORT $LN6@CGCombineB

; 2588 : 	{
; 2589 : 		LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed",

  000bd	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000c0	50		 push	 eax
  000c1	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000c4	50		 push	 eax
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2590 : 			lpObj->AccountID, lpObj->Name);
; 2591 : 
; 2592 : 		pMsg.Result = CB_PSHOP_OPEN;
; 2593 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000d0	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000d4	50		 push	 eax
  000d5	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000d8	c6 45 ef fd	 mov	 BYTE PTR _pMsg$[ebp+3], 253 ; 000000fdH
  000dc	50		 push	 eax
  000dd	53		 push	 ebx
  000de	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e3	83 c4 18	 add	 esp, 24			; 00000018H

; 2594 : 
; 2595 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  000e6	6a 01		 push	 1
  000e8	ff 36		 push	 DWORD PTR [esi]
  000ea	68 c2 04 00 00	 push	 1218			; 000004c2H
$LN15@CGCombineB:
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000f4	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	5e		 pop	 esi
  00103	5f		 pop	 edi
  00104	5b		 pop	 ebx

; 2625 : 		break;
; 2626 : 	}
; 2627 : }

  00105	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00108	33 cd		 xor	 ecx, ebp
  0010a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 08 00	 ret	 8
$LN6@CGCombineB:

; 2596 : 		return;
; 2597 : 	}
; 2598 : 
; 2599 : 	lpObj->bIsChaosMixCompleted = true;
; 2600 : 	int iMixType = lpMsg->MixId;

  00115	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00118	c6 86 09 16 00
	00 01		 mov	 BYTE PTR [esi+5641], 1
  0011f	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]

; 2601 : 
; 2602 : 	switch ( iMixType )

  00123	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00126	83 f8 11	 cmp	 eax, 17			; 00000011H
  00129	77 7a		 ja	 SHORT $LN11@CGCombineB
  0012b	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN13@CGCombineB[eax]
  00132	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN17@CGCombineB[eax*4]
$LN7@CGCombineB:

; 2603 : 	{
; 2604 : 	case ELEMENTAL_MIX_MITHRIL:	MithrilMix(lpObj);	break;

  00139	56		 push	 esi
  0013a	8b cf		 mov	 ecx, edi
  0013c	e8 00 00 00 00	 call	 ?MithrilMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::MithrilMix
  00141	5e		 pop	 esi
  00142	5f		 pop	 edi
  00143	5b		 pop	 ebx

; 2625 : 		break;
; 2626 : 	}
; 2627 : }

  00144	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 08 00	 ret	 8
$LN8@CGCombineB:

; 2605 : 	case ELEMENTAL_MIX_ELIXIR:	ElixirMix(lpObj);	break;

  00154	56		 push	 esi
  00155	8b cf		 mov	 ecx, edi
  00157	e8 00 00 00 00	 call	 ?ElixirMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::ElixirMix
  0015c	5e		 pop	 esi
  0015d	5f		 pop	 edi
  0015e	5b		 pop	 ebx

; 2625 : 		break;
; 2626 : 	}
; 2627 : }

  0015f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00162	33 cd		 xor	 ecx, ebp
  00164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c2 08 00	 ret	 8
$LN9@CGCombineB:

; 2606 : 	case ELEMENTAL_MIX_ERRTEL:	ErrtelMix(lpObj);	break;

  0016f	56		 push	 esi
  00170	8b cf		 mov	 ecx, edi
  00172	e8 00 00 00 00	 call	 ?ErrtelMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::ErrtelMix
  00177	5e		 pop	 esi
  00178	5f		 pop	 edi
  00179	5b		 pop	 ebx

; 2625 : 		break;
; 2626 : 	}
; 2627 : }

  0017a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017d	33 cd		 xor	 ecx, ebp
  0017f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c2 08 00	 ret	 8
$LN10@CGCombineB:

; 2607 : 	case ELEMENTAL_MIX_DECOMPOSE1:
; 2608 : 	case ELEMENTAL_MIX_DECOMPOSE2:
; 2609 : 	case ELEMENTAL_MIX_DECOMPOSE3:
; 2610 : 	case ELEMENTAL_MIX_DECOMPOSE4:
; 2611 : 	case ELEMENTAL_MIX_DECOMPOSE5:
; 2612 : 	case ELEMENTAL_MIX_DECOMPOSE6:
; 2613 : 	case ELEMENTAL_MIX_DECOMPOSE7:
; 2614 : 	case ELEMENTAL_MIX_DECOMPOSE8:
; 2615 : 	case ELEMENTAL_MIX_DECOMPOSE9:
; 2616 : 	case ELEMENTAL_MIX_DECOMPOSE10:
; 2617 : 	case ELEMENTAL_MIX_DECOMPOSE11:
; 2618 : 	case ELEMENTAL_MIX_DECOMPOSE12:
; 2619 : 	case ELEMENTAL_MIX_DECOMPOSE13:
; 2620 : 	case ELEMENTAL_MIX_DECOMPOSE14:
; 2621 : 	case ELEMENTAL_MIX_DECOMPOSE15:
; 2622 : 		PentagramMix(lpObj);	break;

  0018a	56		 push	 esi
  0018b	8b cf		 mov	 ecx, edi
  0018d	e8 00 00 00 00	 call	 ?PentagramMix@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::PentagramMix
  00192	5e		 pop	 esi
  00193	5f		 pop	 edi
  00194	5b		 pop	 ebx

; 2625 : 		break;
; 2626 : 	}
; 2627 : }

  00195	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00198	33 cd		 xor	 ecx, ebp
  0019a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c2 08 00	 ret	 8
$LN11@CGCombineB:

; 2623 : 	default:
; 2624 : 		LogAddTD("[Elemental System] [%s][%s] Undefine chaosmix type detect %d",lpObj->AccountID, lpObj->Name, iMixType);

  001a5	51		 push	 ecx
  001a6	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001a9	50		 push	 eax
  001aa	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  001ad	50		 push	 eax
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HJKEFHCH@?$FLElemental?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Unde@
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2625 : 		break;
; 2626 : 	}
; 2627 : }

  001b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bc	83 c4 10	 add	 esp, 16			; 00000010H
  001bf	33 cd		 xor	 ecx, ebp
  001c1	5e		 pop	 esi
  001c2	5f		 pop	 edi
  001c3	5b		 pop	 ebx
  001c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
  001cf	90		 npad	 1
$LN17@CGCombineB:
  001d0	00 00 00 00	 DD	 $LN7@CGCombineB
  001d4	00 00 00 00	 DD	 $LN8@CGCombineB
  001d8	00 00 00 00	 DD	 $LN9@CGCombineB
  001dc	00 00 00 00	 DD	 $LN10@CGCombineB
$LN13@CGCombineB:
  001e0	00		 DB	 0
  001e1	01		 DB	 1
  001e2	02		 DB	 2
  001e3	03		 DB	 3
  001e4	03		 DB	 3
  001e5	03		 DB	 3
  001e6	03		 DB	 3
  001e7	03		 DB	 3
  001e8	03		 DB	 3
  001e9	03		 DB	 3
  001ea	03		 DB	 3
  001eb	03		 DB	 3
  001ec	03		 DB	 3
  001ed	03		 DB	 3
  001ee	03		 DB	 3
  001ef	03		 DB	 3
  001f0	03		 DB	 3
  001f1	03		 DB	 3
?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z ENDP ; CElementalSystem::CGCombineButtonClick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?CheckBonusRequirement@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@PAVCItem@@PAUPENTAGRAM_OPTION_INFO@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpPentagram$ = 12					; size = 4
_OptionInfo$ = 16					; size = 4
?CheckBonusRequirement@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@PAVCItem@@PAUPENTAGRAM_OPTION_INFO@@@Z PROC ; CElementalSystem::CheckBonusRequirement, COMDAT
; _this$ = ecx

; 952  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 953  : 
; 954  : 	for(int i = 0; i < 3; i++)

  00003	8b 45 10	 mov	 eax, DWORD PTR _OptionInfo$[ebp]
  00006	53		 push	 ebx

; 965  : 
; 966  : 		BYTE btRank = OptionInfo->m_Reqs[i].m_btRankReq;
; 967  : 		BYTE btLevel = OptionInfo->m_Reqs[i].m_btLevelReq;
; 968  : 
; 969  : 		if( lpObj->pErtelList1[iErtelID].Option[btRank] == 15 ||

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _lpPentagram$[ebp]
  0000f	33 f6		 xor	 esi, esi
  00011	83 c0 02	 add	 eax, 2
$LL4@CheckBonus:

; 955  : 	{
; 956  : 		BYTE ErtelType = OptionInfo->m_Reqs[i].m_btErtelType;
; 957  : 
; 958  : 		if( ErtelType == (BYTE)-1 )

  00014	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  00017	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  0001a	74 33		 je	 SHORT $LN2@CheckBonus

; 959  : 			continue;
; 960  : 
; 961  : 		int iErtelID = lpPentagram->m_SocketOption[ErtelType];

  0001c	0f b6 c9	 movzx	 ecx, cl
  0001f	0f b6 94 39 c8
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edi+200]

; 962  : 
; 963  : 		if( iErtelID < 0 || iErtelID >= MAX_ERTEL )

  00027	85 d2		 test	 edx, edx
  00029	78 39		 js	 SHORT $LN7@CheckBonus
  0002b	83 fa 64	 cmp	 edx, 100		; 00000064H
  0002e	7d 34		 jge	 SHORT $LN7@CheckBonus

; 965  : 
; 966  : 		BYTE btRank = OptionInfo->m_Reqs[i].m_btRankReq;
; 967  : 		BYTE btLevel = OptionInfo->m_Reqs[i].m_btLevelReq;
; 968  : 
; 969  : 		if( lpObj->pErtelList1[iErtelID].Option[btRank] == 15 ||

  00030	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00033	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00036	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00039	8b 8b dc 26 00
	00		 mov	 ecx, DWORD PTR [ebx+9948]
  0003f	80 7c 0a 02 0f	 cmp	 BYTE PTR [edx+ecx+2], 15 ; 0000000fH
  00044	74 1e		 je	 SHORT $LN7@CheckBonus
  00046	8a 4c 0a 07	 mov	 cl, BYTE PTR [edx+ecx+7]
  0004a	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  0004d	72 15		 jb	 SHORT $LN7@CheckBonus
$LN2@CheckBonus:

; 953  : 
; 954  : 	for(int i = 0; i < 3; i++)

  0004f	46		 inc	 esi
  00050	83 c0 03	 add	 eax, 3
  00053	83 fe 03	 cmp	 esi, 3
  00056	7c bc		 jl	 SHORT $LL4@CheckBonus

; 970  : 			lpObj->pErtelList1[iErtelID].Level[btRank] < btLevel )
; 971  : 			return false;
; 972  : 	}
; 973  : 
; 974  : 	return true;

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	5b		 pop	 ebx

; 975  : }

  00060	5d		 pop	 ebp
  00061	c2 0c 00	 ret	 12			; 0000000cH
$LN7@CheckBonus:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 964  : 			return false;

  00066	33 c0		 xor	 eax, eax
  00068	5b		 pop	 ebx

; 975  : }

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?CheckBonusRequirement@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@PAVCItem@@PAUPENTAGRAM_OPTION_INFO@@@Z ENDP ; CElementalSystem::CheckBonusRequirement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetPentagramOption@CElementalSystem@@QAEPAUPENTAGRAM_OPTION_INFO@@H@Z
_TEXT	SEGMENT
_OptionID$ = 8						; size = 4
?GetPentagramOption@CElementalSystem@@QAEPAUPENTAGRAM_OPTION_INFO@@H@Z PROC ; CElementalSystem::GetPentagramOption, COMDAT
; _this$ = ecx

; 942  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 943  : 	for(int i = 0; i < MAX_PENTAGRAM_OPTIONS; i++)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _OptionID$[ebp]
  00008	8d b1 fa 19 00
	00		 lea	 esi, DWORD PTR [ecx+6650]
  0000e	33 c0		 xor	 eax, eax
$LL4@GetPentagr:

; 944  : 	{
; 945  : 		if( this->m_PentagramOptionInfo[i].m_btOptionID == OptionID )

  00010	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00013	3b d7		 cmp	 edx, edi
  00015	74 11		 je	 SHORT $LN8@GetPentagr

; 943  : 	for(int i = 0; i < MAX_PENTAGRAM_OPTIONS; i++)

  00017	40		 inc	 eax
  00018	83 c6 0a	 add	 esi, 10			; 0000000aH
  0001b	83 f8 07	 cmp	 eax, 7
  0001e	7c f0		 jl	 SHORT $LL4@GetPentagr

; 947  : 	}
; 948  : 	return NULL;

  00020	5f		 pop	 edi
  00021	33 c0		 xor	 eax, eax
  00023	5e		 pop	 esi

; 949  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN8@GetPentagr:

; 946  : 			return &this->m_PentagramOptionInfo[i];

  00028	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0002b	8d 80 fd 0c 00
	00		 lea	 eax, DWORD PTR [eax+3325]
  00031	5f		 pop	 edi
  00032	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00035	5e		 pop	 esi

; 949  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?GetPentagramOption@CElementalSystem@@QAEPAUPENTAGRAM_OPTION_INFO@@H@Z ENDP ; CElementalSystem::GetPentagramOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetPentagram@CElementalSystem@@QAEPAUPENTAGRAM_OPTION@@H@Z
_TEXT	SEGMENT
_PentagramID$ = 8					; size = 4
?GetPentagram@CElementalSystem@@QAEPAUPENTAGRAM_OPTION@@H@Z PROC ; CElementalSystem::GetPentagram, COMDAT
; _this$ = ecx

; 932  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 933  : 	for(int i = 0; i < MAX_PENTAGRAM_ITEMS; i++)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _PentagramID$[ebp]
  00008	8d b1 46 19 00
	00		 lea	 esi, DWORD PTR [ecx+6470]
  0000e	33 c0		 xor	 eax, eax
$LL4@GetPentagr:

; 934  : 	{
; 935  : 		if( this->m_PentagramItems[i].m_itemId == PentagramID )

  00010	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00013	3b d7		 cmp	 edx, edi
  00015	74 11		 je	 SHORT $LN8@GetPentagr

; 933  : 	for(int i = 0; i < MAX_PENTAGRAM_ITEMS; i++)

  00017	40		 inc	 eax
  00018	83 c6 0c	 add	 esi, 12			; 0000000cH
  0001b	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0001e	7c f0		 jl	 SHORT $LL4@GetPentagr

; 937  : 	}
; 938  : 	return NULL;

  00020	5f		 pop	 edi
  00021	33 c0		 xor	 eax, eax
  00023	5e		 pop	 esi

; 939  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN8@GetPentagr:

; 936  : 			return &this->m_PentagramItems[i];

  00028	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002b	8d 04 85 46 19
	00 00		 lea	 eax, DWORD PTR [eax*4+6470]
  00032	5f		 pop	 edi
  00033	03 c1		 add	 eax, ecx
  00035	5e		 pop	 esi

; 939  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?GetPentagram@CElementalSystem@@QAEPAUPENTAGRAM_OPTION@@H@Z ENDP ; CElementalSystem::GetPentagram
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetErtel@CElementalSystem@@QAEPAUERTEL_USER@@PAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iErtelID$ = 12						; size = 4
_Type$ = 16						; size = 4
?GetErtel@CElementalSystem@@QAEPAUERTEL_USER@@PAUOBJECTSTRUCT@@HH@Z PROC ; CElementalSystem::GetErtel, COMDAT
; _this$ = ecx

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 	if( iErtelID < 0 || iErtelID >= MAX_ERTEL )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iErtelID$[ebp]
  00006	83 f8 63	 cmp	 eax, 99			; 00000063H
  00009	77 32		 ja	 SHORT $LN3@GetErtel

; 586  : 
; 587  : 	if( Type == ERTEL_INVENTORY )

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _Type$[ebp]
  0000e	85 c9		 test	 ecx, ecx
  00010	75 13		 jne	 SHORT $LN4@GetErtel

; 588  : 		return &lpObj->pErtelList1[iErtelID];

  00012	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	8b 80 dc 26 00
	00		 mov	 eax, DWORD PTR [eax+9948]
  0001e	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 591  : 
; 592  : return 0;
; 593  : }

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
$LN4@GetErtel:

; 589  : 	else if( Type == ERTEL_WAREHOUSE )

  00025	83 f9 01	 cmp	 ecx, 1
  00028	75 13		 jne	 SHORT $LN3@GetErtel

; 590  : 		return &lpObj->pErtelList2[iErtelID];

  0002a	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00030	8b 80 e0 26 00
	00		 mov	 eax, DWORD PTR [eax+9952]
  00036	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 591  : 
; 592  : return 0;
; 593  : }

  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@GetErtel:

; 585  : 		return 0;

  0003d	33 c0		 xor	 eax, eax

; 591  : 
; 592  : return 0;
; 593  : }

  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
?GetErtel@CElementalSystem@@QAEPAUERTEL_USER@@PAUOBJECTSTRUCT@@HH@Z ENDP ; CElementalSystem::GetErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetErtelOption@CElementalSystem@@QAEPAUERTEL_OPTION@@H@Z
_TEXT	SEGMENT
_iOptionID$ = 8						; size = 4
?GetErtelOption@CElementalSystem@@QAEPAUERTEL_OPTION@@H@Z PROC ; CElementalSystem::GetErtelOption, COMDAT
; _this$ = ecx

; 632  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 633  : 	for(int i = 0; i < MAX_ERTEL_OPTION; i++)	{

  00004	8b 75 08	 mov	 esi, DWORD PTR _iOptionID$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8d 87 6e 03 00
	00		 lea	 eax, DWORD PTR [edi+878]
$LL4@GetErtelOp:

; 634  : 		if( m_ErtelOption[i].btId == (BYTE)-1 )

  00012	80 78 f8 ff	 cmp	 BYTE PTR [eax-8], 255	; 000000ffH
  00016	74 07		 je	 SHORT $LN2@GetErtelOp

; 635  : 			continue;
; 636  : 
; 637  : 		if( m_ErtelOption[i].wType == iOptionID )

  00018	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0001b	3b ce		 cmp	 ecx, esi
  0001d	74 11		 je	 SHORT $LN9@GetErtelOp
$LN2@GetErtelOp:

; 633  : 	for(int i = 0; i < MAX_ERTEL_OPTION; i++)	{

  0001f	42		 inc	 edx
  00020	83 c0 38	 add	 eax, 56			; 00000038H
  00023	83 fa 64	 cmp	 edx, 100		; 00000064H
  00026	7c ea		 jl	 SHORT $LL4@GetErtelOp

; 639  : 	}
; 640  : return NULL;

  00028	5f		 pop	 edi
  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 641  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN9@GetErtelOp:

; 638  : 			return &m_ErtelOption[i];

  00030	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00037	2b c2		 sub	 eax, edx
  00039	8d 04 c5 66 03
	00 00		 lea	 eax, DWORD PTR [eax*8+870]
  00040	03 c7		 add	 eax, edi
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 641  : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?GetErtelOption@CElementalSystem@@QAEPAUERTEL_OPTION@@H@Z ENDP ; CElementalSystem::GetErtelOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetErtelOption@CElementalSystem@@QAEEHE@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_iErtel$ = 8						; size = 4
_btRank$ = 12						; size = 1
?GetErtelOption@CElementalSystem@@QAEEHE@Z PROC		; CElementalSystem::GetErtelOption, COMDAT
; _this$ = ecx

; 2534 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 2535 : 	m_OptionRate.InitPool();

  00006	8d 81 40 1a 00
	00		 lea	 eax, DWORD PTR [ecx+6720]
  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	57		 push	 edi
  00010	8b c8		 mov	 ecx, eax
  00012	e8 00 00 00 00	 call	 ?InitPool@TRandomPoolMgr@@QAEXXZ ; TRandomPoolMgr::InitPool
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]

; 2536 : 
; 2537 : 	int count = 0;

  0001a	33 db		 xor	 ebx, ebx

; 2538 : 
; 2539 : 	for(int i = 0; i < MAX_ERTEL_OPTION; i++)	{

  0001c	33 ff		 xor	 edi, edi
  0001e	8d b1 68 03 00
	00		 lea	 esi, DWORD PTR [ecx+872]
$LL4@GetErtelOp:

; 2540 : 		if( m_ErtelOption[i].btId == (BYTE)-1 )

  00024	80 7e fe ff	 cmp	 BYTE PTR [esi-2], 255	; 000000ffH
  00028	74 27		 je	 SHORT $LN2@GetErtelOp

; 2541 : 			continue;
; 2542 : 
; 2543 : 		if( m_ErtelOption[i].ItemID != iErtel )

  0002a	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0002d	3b 45 08	 cmp	 eax, DWORD PTR _iErtel$[ebp]
  00030	75 1f		 jne	 SHORT $LN2@GetErtelOp

; 2544 : 			continue;
; 2545 : 
; 2546 : 		if( m_ErtelOption[i].btRank != btRank )

  00032	8a 45 0c	 mov	 al, BYTE PTR _btRank$[ebp]
  00035	38 46 02	 cmp	 BYTE PTR [esi+2], al
  00038	75 17		 jne	 SHORT $LN2@GetErtelOp

; 2547 : 			continue;
; 2548 : 
; 2549 : 		m_OptionRate.AddValue(i,m_ErtelOption[i].OptionRate);

  0003a	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  0003e	50		 push	 eax
  0003f	8d 81 40 1a 00
	00		 lea	 eax, DWORD PTR [ecx+6720]
  00045	57		 push	 edi
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 ?AddValue@TRandomPoolMgr@@QAE_NHH@Z ; TRandomPoolMgr::AddValue
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]

; 2550 : 		count++;

  00050	43		 inc	 ebx
$LN2@GetErtelOp:

; 2538 : 
; 2539 : 	for(int i = 0; i < MAX_ERTEL_OPTION; i++)	{

  00051	47		 inc	 edi
  00052	83 c6 38	 add	 esi, 56			; 00000038H
  00055	83 ff 64	 cmp	 edi, 100		; 00000064H
  00058	7c ca		 jl	 SHORT $LL4@GetErtelOp

; 2551 : 	}
; 2552 : 
; 2553 : 	if( count == 0 )

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	85 db		 test	 ebx, ebx
  0005e	5b		 pop	 ebx
  0005f	75 08		 jne	 SHORT $LN8@GetErtelOp

; 2554 : 		return (BYTE)-1;

  00061	0c ff		 or	 al, 255			; 000000ffH

; 2559 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
$LN8@GetErtelOp:

; 2555 : 
; 2556 : 	int iErtelId = m_OptionRate.GetRandomValue(eRANDOMPOOL_BY_WEIGHT);

  00069	6a 01		 push	 1
  0006b	8d 89 40 1a 00
	00		 lea	 ecx, DWORD PTR [ecx+6720]
  00071	e8 00 00 00 00	 call	 ?GetRandomValue@TRandomPoolMgr@@QAEHW4eRandomPoolSelectType@@@Z ; TRandomPoolMgr::GetRandomValue
  00076	8b c8		 mov	 ecx, eax

; 2557 : 
; 2558 : return m_ErtelOption[iErtelId].btOption;

  00078	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0007f	2b c1		 sub	 eax, ecx
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00084	8a 84 c1 6b 03
	00 00		 mov	 al, BYTE PTR [ecx+eax*8+875]

; 2559 : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?GetErtelOption@CElementalSystem@@QAEEHE@Z ENDP		; CElementalSystem::GetErtelOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetSlotCount@CElementalSystem@@QAEEPAVCItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?GetSlotCount@CElementalSystem@@QAEEPAVCItem@@@Z PROC	; CElementalSystem::GetSlotCount, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 597  : 	BYTE count = 0;
; 598  : 	for(int i = 0; i < 5; i++)	{
; 599  : 		if( pItem->m_SocketOption[i] != (BYTE)-1 )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00006	32 c0		 xor	 al, al
  00008	0f b6 c0	 movzx	 eax, al
  0000b	ba 01 00 00 00	 mov	 edx, 1
  00010	80 b9 c8 00 00
	00 ff		 cmp	 BYTE PTR [ecx+200], 255	; 000000ffH
  00017	0f 45 c2	 cmovne	 eax, edx
  0001a	80 b9 c9 00 00
	00 ff		 cmp	 BYTE PTR [ecx+201], 255	; 000000ffH
  00021	74 02		 je	 SHORT $LN14@GetSlotCou

; 600  : 			count++;

  00023	fe c0		 inc	 al
$LN14@GetSlotCou:

; 597  : 	BYTE count = 0;
; 598  : 	for(int i = 0; i < 5; i++)	{
; 599  : 		if( pItem->m_SocketOption[i] != (BYTE)-1 )

  00025	80 b9 ca 00 00
	00 ff		 cmp	 BYTE PTR [ecx+202], 255	; 000000ffH
  0002c	74 02		 je	 SHORT $LN16@GetSlotCou

; 600  : 			count++;

  0002e	fe c0		 inc	 al
$LN16@GetSlotCou:

; 597  : 	BYTE count = 0;
; 598  : 	for(int i = 0; i < 5; i++)	{
; 599  : 		if( pItem->m_SocketOption[i] != (BYTE)-1 )

  00030	80 b9 cb 00 00
	00 ff		 cmp	 BYTE PTR [ecx+203], 255	; 000000ffH
  00037	74 02		 je	 SHORT $LN18@GetSlotCou

; 600  : 			count++;

  00039	fe c0		 inc	 al
$LN18@GetSlotCou:

; 597  : 	BYTE count = 0;
; 598  : 	for(int i = 0; i < 5; i++)	{
; 599  : 		if( pItem->m_SocketOption[i] != (BYTE)-1 )

  0003b	80 b9 cc 00 00
	00 ff		 cmp	 BYTE PTR [ecx+204], 255	; 000000ffH
  00042	74 02		 je	 SHORT $LN20@GetSlotCou

; 600  : 			count++;

  00044	fe c0		 inc	 al
$LN20@GetSlotCou:

; 601  : 	}
; 602  : 
; 603  : return count;
; 604  : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?GetSlotCount@CElementalSystem@@QAEEPAVCItem@@@Z ENDP	; CElementalSystem::GetSlotCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?RemoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iErtelID$ = 12						; size = 4
_Type$ = 16						; size = 4
?RemoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z PROC ; CElementalSystem::RemoveErtel, COMDAT
; _this$ = ecx

; 607  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 608  : 	if( iErtelID < 0 || iErtelID >= MAX_ERTEL )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iErtelID$[ebp]
  00006	83 f8 63	 cmp	 eax, 99			; 00000063H
  00009	77 38		 ja	 SHORT $LN3@RemoveErte

; 609  : 		return;
; 610  : 
; 611  : 	if( Type == ERTEL_INVENTORY )

  0000b	8b 4d 10	 mov	 ecx, DWORD PTR _Type$[ebp]
  0000e	85 c9		 test	 ecx, ecx
  00010	75 18		 jne	 SHORT $LN4@RemoveErte

; 612  : 		lpObj->pErtelList1[iErtelID].Clear();

  00012	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	8b 80 dc 26 00
	00		 mov	 eax, DWORD PTR [eax+9948]

; 614  : 		lpObj->pErtelList2[iErtelID].Clear();

  0001e	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00021	e8 00 00 00 00	 call	 ?Clear@ERTEL_USER@@QAEXXZ ; ERTEL_USER::Clear

; 615  : 		
; 616  : }

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
$LN4@RemoveErte:

; 613  : 	else if( Type == ERTEL_WAREHOUSE )

  0002a	83 f9 01	 cmp	 ecx, 1
  0002d	75 14		 jne	 SHORT $LN3@RemoveErte

; 614  : 		lpObj->pErtelList2[iErtelID].Clear();

  0002f	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00032	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00035	8b 80 e0 26 00
	00		 mov	 eax, DWORD PTR [eax+9952]
  0003b	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  0003e	e8 00 00 00 00	 call	 ?Clear@ERTEL_USER@@QAEXXZ ; ERTEL_USER::Clear
$LN3@RemoveErte:

; 615  : 		
; 616  : }

  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
?RemoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ENDP ; CElementalSystem::RemoveErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
; File c:\users\michel\desktop\source\gameserver\source\user.h
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?TradeErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z
_TEXT	SEGMENT
_lpTradeObj$ = 8					; size = 4
_lpSourceErtel$1$ = 12					; size = 4
_lpObj$ = 12						; size = 4
_lpTargetErtel$1$ = 16					; size = 4
_TargetItem$ = 16					; size = 4
?TradeErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z PROC ; CElementalSystem::TradeErtel, COMDAT
; _this$ = ecx

; 2476 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 2477 : 	if( !IsPentagram(TargetItem->m_Type) )

  00004	8b 7d 10	 mov	 edi, DWORD PTR _TargetItem$[ebp]
  00007	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?IsPentagram@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsPentagram
  00011	85 c0		 test	 eax, eax
  00013	0f 84 a2 00 00
	00		 je	 $LN3@TradeErtel

; 2478 : 		return;
; 2479 : 
; 2480 : 	ERTEL_USER* lpTargetErtel;
; 2481 : 	ERTEL_USER* lpSourceErtel;
; 2482 : 
; 2483 : 	lpTargetErtel = lpObj->pErtelList1;

  00019	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]

; 2484 : 	lpSourceErtel = lpTradeObj->pErtelList1;
; 2485 : 
; 2486 : 	TargetItem->m_Durability -= 1;

  0001c	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]
  00021	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00029	53		 push	 ebx
  0002a	8b 88 dc 26 00
	00		 mov	 ecx, DWORD PTR [eax+9948]
  00030	bb 05 00 00 00	 mov	 ebx, 5
  00035	8b 45 08	 mov	 eax, DWORD PTR _lpTradeObj$[ebp]
  00038	56		 push	 esi
  00039	89 4d 10	 mov	 DWORD PTR _lpTargetErtel$1$[ebp], ecx
  0003c	8b b0 dc 26 00
	00		 mov	 esi, DWORD PTR [eax+9948]
  00042	f3 0f 11 47 24	 movss	 DWORD PTR [edi+36], xmm0
  00047	81 c7 c8 00 00
	00		 add	 edi, 200		; 000000c8H
  0004d	89 75 0c	 mov	 DWORD PTR _lpSourceErtel$1$[ebp], esi
$LL4@TradeErtel:

; 2489 : 
; 2490 : 		if( TargetItem->m_SocketOption[i] == (BYTE)-1 ||

  00050	8a 07		 mov	 al, BYTE PTR [edi]
  00052	3c ff		 cmp	 al, 255			; 000000ffH
  00054	74 5d		 je	 SHORT $LN2@TradeErtel
  00056	3c fe		 cmp	 al, 254			; 000000feH
  00058	74 59		 je	 SHORT $LN2@TradeErtel

; 2491 : 			TargetItem->m_SocketOption[i] == (BYTE)-2 )
; 2492 : 		{
; 2493 : 			continue;
; 2494 : 		}
; 2495 : 
; 2496 : 		int ErtelID = TargetItem->m_SocketOption[i];

  0005a	0f b6 d0	 movzx	 edx, al

; 2497 : 
; 2498 : 		for(int n = 0; n < MAX_ERTEL; n++)	{

  0005d	33 c0		 xor	 eax, eax
  0005f	90		 npad	 1
$LL7@TradeErtel:

; 2499 : 			if( lpTargetErtel[n].btType != (BYTE)-1 )

  00060	80 39 ff	 cmp	 BYTE PTR [ecx], 255	; 000000ffH
  00063	74 0b		 je	 SHORT $LN11@TradeErtel

; 2497 : 
; 2498 : 		for(int n = 0; n < MAX_ERTEL; n++)	{

  00065	40		 inc	 eax
  00066	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00069	83 f8 64	 cmp	 eax, 100		; 00000064H
  0006c	7c f2		 jl	 SHORT $LL7@TradeErtel

; 2489 : 
; 2490 : 		if( TargetItem->m_SocketOption[i] == (BYTE)-1 ||

  0006e	eb 40		 jmp	 SHORT $LN30@TradeErtel
$LN11@TradeErtel:

; 2500 : 				continue;
; 2501 : 
; 2502 : 			TargetItem->m_SocketOption[i] = n;

  00070	88 07		 mov	 BYTE PTR [edi], al

; 2503 : 			lpTargetErtel[n] = lpSourceErtel[ErtelID];

  00072	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00075	8b 45 10	 mov	 eax, DWORD PTR _lpTargetErtel$1$[ebp]
  00078	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0007b	f3 0f 7e 04 96	 movq	 xmm0, QWORD PTR [esi+edx*4]
  00080	66 0f d6 04 88	 movq	 QWORD PTR [eax+ecx*4], xmm0
  00085	8b 44 96 08	 mov	 eax, DWORD PTR [esi+edx*4+8]
  00089	8b 75 10	 mov	 esi, DWORD PTR _lpTargetErtel$1$[ebp]
  0008c	89 44 8e 08	 mov	 DWORD PTR [esi+ecx*4+8], eax
; File c:\users\michel\desktop\source\gameserver\source\user.h

; 603  : 		for(int i = 0; i < 5; i++)	{

  00090	33 c0		 xor	 eax, eax
  00092	8b 75 0c	 mov	 esi, DWORD PTR _lpSourceErtel$1$[ebp]
  00095	66 c7 04 96 ff
	ff		 mov	 WORD PTR [esi+edx*4], 65535 ; 0000ffffH

; 604  : 			Option[i] = 0x0F;

  0009b	8d 0c 96	 lea	 ecx, DWORD PTR [esi+edx*4]
  0009e	66 90		 npad	 2
$LL16@TradeErtel:
  000a0	c6 44 01 02 0f	 mov	 BYTE PTR [ecx+eax+2], 15 ; 0000000fH
  000a5	40		 inc	 eax

; 605  : 			Level[1] = 0x0F;

  000a6	c6 44 96 08 0f	 mov	 BYTE PTR [esi+edx*4+8], 15 ; 0000000fH
  000ab	83 f8 05	 cmp	 eax, 5
  000ae	7c f0		 jl	 SHORT $LL16@TradeErtel
$LN30@TradeErtel:
  000b0	8b 4d 10	 mov	 ecx, DWORD PTR _lpTargetErtel$1$[ebp]
$LN2@TradeErtel:
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp

; 2488 : 	for(int i = 0; i < 5; i++)	{

  000b3	47		 inc	 edi
  000b4	83 eb 01	 sub	 ebx, 1
  000b7	75 97		 jne	 SHORT $LL4@TradeErtel
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
$LN3@TradeErtel:
  000bb	5f		 pop	 edi

; 2504 : 			lpSourceErtel[ErtelID].Clear();
; 2505 : 			break;
; 2506 : 		}
; 2507 : 	}
; 2508 : }

  000bc	5d		 pop	 ebp
  000bd	c2 0c 00	 ret	 12			; 0000000cH
?TradeErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z ENDP ; CElementalSystem::TradeErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
; File c:\users\michel\desktop\source\gameserver\source\user.h
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_lpSourceErtel$1$ = -4					; size = 4
_lpShopObj$ = 8						; size = 4
_lpObj$ = 12						; size = 4
_lpTargetErtel$1$ = 16					; size = 4
_TargetItem$ = 16					; size = 4
?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z PROC ; CElementalSystem::PShopErtel, COMDAT
; _this$ = ecx

; 2438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 2439 : 	if( !IsPentagram(TargetItem->m_Type) )

  00007	8b 7d 10	 mov	 edi, DWORD PTR _TargetItem$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?IsPentagram@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsPentagram
  00017	85 c0		 test	 eax, eax
  00019	0f 84 b7 00 00
	00		 je	 $LN1@PShopErtel

; 2440 : 		return;
; 2441 : 
; 2442 : 	ERTEL_USER* lpTargetErtel;
; 2443 : 	ERTEL_USER* lpSourceErtel;
; 2444 : 
; 2445 : 	lpTargetErtel = lpObj->pErtelList1;
; 2446 : 	lpSourceErtel = lpShopObj->pErtelList1;
; 2447 : 
; 2448 : 	TargetItem->m_Durability -= 1;

  0001f	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00027	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0002f	53		 push	 ebx
  00030	56		 push	 esi
  00031	8b 75 08	 mov	 esi, DWORD PTR _lpShopObj$[ebp]
  00034	bb 05 00 00 00	 mov	 ebx, 5
  00039	8b 89 dc 26 00
	00		 mov	 ecx, DWORD PTR [ecx+9948]
  0003f	89 4d 10	 mov	 DWORD PTR _lpTargetErtel$1$[ebp], ecx
  00042	8b b6 dc 26 00
	00		 mov	 esi, DWORD PTR [esi+9948]
  00048	f3 0f 11 47 24	 movss	 DWORD PTR [edi+36], xmm0
  0004d	81 c7 c8 00 00
	00		 add	 edi, 200		; 000000c8H
  00053	89 75 fc	 mov	 DWORD PTR _lpSourceErtel$1$[ebp], esi
$LL4@PShopErtel:

; 2451 : 
; 2452 : 		if( TargetItem->m_SocketOption[i] == (BYTE)-1 ||

  00056	8a 07		 mov	 al, BYTE PTR [edi]
  00058	3c ff		 cmp	 al, 255			; 000000ffH
  0005a	74 5a		 je	 SHORT $LN2@PShopErtel
  0005c	3c fe		 cmp	 al, 254			; 000000feH
  0005e	74 56		 je	 SHORT $LN2@PShopErtel

; 2453 : 			TargetItem->m_SocketOption[i] == (BYTE)-2 )
; 2454 : 		{
; 2455 : 			continue;
; 2456 : 		}
; 2457 : 
; 2458 : 		int ErtelID = TargetItem->m_SocketOption[i];

  00060	0f b6 d0	 movzx	 edx, al

; 2459 : 
; 2460 : 		for(int n = 0; n < MAX_ERTEL; n++)	{

  00063	33 c0		 xor	 eax, eax
$LL7@PShopErtel:

; 2461 : 			if( lpTargetErtel[n].btType != (BYTE)-1 )

  00065	80 39 ff	 cmp	 BYTE PTR [ecx], 255	; 000000ffH
  00068	74 0b		 je	 SHORT $LN11@PShopErtel

; 2459 : 
; 2460 : 		for(int n = 0; n < MAX_ERTEL; n++)	{

  0006a	40		 inc	 eax
  0006b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0006e	83 f8 64	 cmp	 eax, 100		; 00000064H
  00071	7c f2		 jl	 SHORT $LL7@PShopErtel

; 2451 : 
; 2452 : 		if( TargetItem->m_SocketOption[i] == (BYTE)-1 ||

  00073	eb 3e		 jmp	 SHORT $LN30@PShopErtel
$LN11@PShopErtel:

; 2462 : 				continue;
; 2463 : 
; 2464 : 			TargetItem->m_SocketOption[i] = n;

  00075	88 07		 mov	 BYTE PTR [edi], al

; 2465 : 			lpTargetErtel[n] = lpSourceErtel[ErtelID];

  00077	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0007a	8b 45 10	 mov	 eax, DWORD PTR _lpTargetErtel$1$[ebp]
  0007d	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00080	f3 0f 7e 04 96	 movq	 xmm0, QWORD PTR [esi+edx*4]
  00085	66 0f d6 04 88	 movq	 QWORD PTR [eax+ecx*4], xmm0
  0008a	8b 44 96 08	 mov	 eax, DWORD PTR [esi+edx*4+8]
  0008e	8b 75 10	 mov	 esi, DWORD PTR _lpTargetErtel$1$[ebp]
  00091	89 44 8e 08	 mov	 DWORD PTR [esi+ecx*4+8], eax
; File c:\users\michel\desktop\source\gameserver\source\user.h

; 603  : 		for(int i = 0; i < 5; i++)	{

  00095	33 c0		 xor	 eax, eax
  00097	8b 75 fc	 mov	 esi, DWORD PTR _lpSourceErtel$1$[ebp]
  0009a	66 c7 04 96 ff
	ff		 mov	 WORD PTR [esi+edx*4], 65535 ; 0000ffffH

; 604  : 			Option[i] = 0x0F;

  000a0	8d 0c 96	 lea	 ecx, DWORD PTR [esi+edx*4]
$LL16@PShopErtel:
  000a3	c6 44 01 02 0f	 mov	 BYTE PTR [ecx+eax+2], 15 ; 0000000fH
  000a8	40		 inc	 eax

; 605  : 			Level[1] = 0x0F;

  000a9	c6 44 96 08 0f	 mov	 BYTE PTR [esi+edx*4+8], 15 ; 0000000fH
  000ae	83 f8 05	 cmp	 eax, 5
  000b1	7c f0		 jl	 SHORT $LL16@PShopErtel
$LN30@PShopErtel:
  000b3	8b 4d 10	 mov	 ecx, DWORD PTR _lpTargetErtel$1$[ebp]
$LN2@PShopErtel:
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp

; 2450 : 	for(int i = 0; i < 5; i++)	{

  000b6	47		 inc	 edi
  000b7	83 eb 01	 sub	 ebx, 1
  000ba	75 9a		 jne	 SHORT $LL4@PShopErtel

; 2466 : 			lpSourceErtel[ErtelID].Clear();
; 2467 : 			break;
; 2468 : 		}
; 2469 : 	}
; 2470 : 
; 2471 : 	SendElementalItems(lpShopObj,ERTEL_INVENTORY);

  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000bf	53		 push	 ebx
  000c0	ff 75 08	 push	 DWORD PTR _lpShopObj$[ebp]
  000c3	e8 00 00 00 00	 call	 ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems

; 2472 : 	SendElementalItems(lpObj,ERTEL_INVENTORY);

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000cb	53		 push	 ebx
  000cc	ff 75 0c	 push	 DWORD PTR _lpObj$[ebp]
  000cf	e8 00 00 00 00	 call	 ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
$LN1@PShopErtel:
  000d6	5f		 pop	 edi

; 2473 : }

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 0c 00	 ret	 12			; 0000000cH
?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z ENDP ; CElementalSystem::PShopErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
; File c:\users\michel\desktop\source\gameserver\source\user.h
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?MoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@EPAE@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpSourceErtel$1$ = 12					; size = 4
_TargetItem$ = 12					; size = 4
_lpTargetErtel$1$ = 16					; size = 4
_tFlag$ = 16						; size = 1
_siteminfo$ = 20					; size = 4
?MoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@EPAE@Z PROC ; CElementalSystem::MoveErtel, COMDAT
; _this$ = ecx

; 2393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2394 : 	if( !IsPentagram(TargetItem->m_Type) )

  00005	8b 75 0c	 mov	 esi, DWORD PTR _TargetItem$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000b	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?IsPentagram@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsPentagram
  00015	85 c0		 test	 eax, eax
  00017	0f 84 d2 00 00
	00		 je	 $LN1@MoveErtel

; 2395 : 		return;
; 2396 : 
; 2397 : 	ERTEL_USER* lpTargetErtel;
; 2398 : 	ERTEL_USER* lpSourceErtel;
; 2399 : 
; 2400 : 	if( tFlag == ERTEL_INVENTORY )	{

  0001d	80 7d 10 00	 cmp	 BYTE PTR _tFlag$[ebp], 0
  00021	53		 push	 ebx

; 2401 : 		lpTargetErtel = lpObj->pErtelList1;

  00022	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00025	57		 push	 edi
  00026	75 11		 jne	 SHORT $LN9@MoveErtel
  00028	8b 83 dc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9948]
  0002e	89 45 10	 mov	 DWORD PTR _lpTargetErtel$1$[ebp], eax

; 2402 : 		lpSourceErtel = lpObj->pErtelList2;

  00031	8b 83 e0 26 00
	00		 mov	 eax, DWORD PTR [ebx+9952]

; 2403 : 	}
; 2404 : 	else	{

  00037	eb 0f		 jmp	 SHORT $LN32@MoveErtel
$LN9@MoveErtel:

; 2405 : 		lpTargetErtel = lpObj->pErtelList2;

  00039	8b 83 e0 26 00
	00		 mov	 eax, DWORD PTR [ebx+9952]
  0003f	89 45 10	 mov	 DWORD PTR _lpTargetErtel$1$[ebp], eax

; 2406 : 		lpSourceErtel = lpObj->pErtelList1;

  00042	8b 83 dc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9948]
$LN32@MoveErtel:

; 2407 : 	}
; 2408 : 
; 2409 : 
; 2410 : 	for(int i = 0; i < 5; i++)	{

  00048	8b 5d 10	 mov	 ebx, DWORD PTR _lpTargetErtel$1$[ebp]
  0004b	8d 96 c8 00 00
	00		 lea	 edx, DWORD PTR [esi+200]
  00051	bf 38 ff ff ff	 mov	 edi, -200		; ffffff38H
  00056	89 45 0c	 mov	 DWORD PTR _lpSourceErtel$1$[ebp], eax
  00059	2b fe		 sub	 edi, esi
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@MoveErtel:

; 2411 : 
; 2412 : 		if( TargetItem->m_SocketOption[i] == (BYTE)-1 ||

  00060	8a 02		 mov	 al, BYTE PTR [edx]
  00062	3c ff		 cmp	 al, 255			; 000000ffH
  00064	74 65		 je	 SHORT $LN2@MoveErtel
  00066	3c fe		 cmp	 al, 254			; 000000feH
  00068	74 61		 je	 SHORT $LN2@MoveErtel

; 2413 : 			TargetItem->m_SocketOption[i] == (BYTE)-2 )
; 2414 : 		{
; 2415 : 			continue;
; 2416 : 		}
; 2417 : 
; 2418 : 		int ErtelID = TargetItem->m_SocketOption[i];

  0006a	0f b6 f0	 movzx	 esi, al

; 2419 : 
; 2420 : 		for(int n = 0; n < MAX_ERTEL; n++)	{

  0006d	33 c9		 xor	 ecx, ecx
  0006f	8b c3		 mov	 eax, ebx
$LL7@MoveErtel:

; 2421 : 			if( lpTargetErtel[n].btType != (BYTE)-1 )

  00071	80 38 ff	 cmp	 BYTE PTR [eax], 255	; 000000ffH
  00074	74 0b		 je	 SHORT $LN13@MoveErtel

; 2419 : 
; 2420 : 		for(int n = 0; n < MAX_ERTEL; n++)	{

  00076	41		 inc	 ecx
  00077	83 c0 0c	 add	 eax, 12			; 0000000cH
  0007a	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0007d	7c f2		 jl	 SHORT $LL7@MoveErtel

; 2411 : 
; 2412 : 		if( TargetItem->m_SocketOption[i] == (BYTE)-1 ||

  0007f	eb 3e		 jmp	 SHORT $LN17@MoveErtel
$LN13@MoveErtel:

; 2422 : 				continue;
; 2423 : 
; 2424 : 			TargetItem->m_SocketOption[i] = n;
; 2425 : 			lpTargetErtel[n] = lpSourceErtel[ErtelID];

  00081	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00084	88 0a		 mov	 BYTE PTR [edx], cl
  00086	8b 75 0c	 mov	 esi, DWORD PTR _lpSourceErtel$1$[ebp]
  00089	f3 0f 7e 04 86	 movq	 xmm0, QWORD PTR [esi+eax*4]
  0008e	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
  00091	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00094	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  00097	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0009b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0009e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File c:\users\michel\desktop\source\gameserver\source\user.h

; 603  : 		for(int i = 0; i < 5; i++)	{

  000a1	33 c0		 xor	 eax, eax
  000a3	66 c7 06 ff ff	 mov	 WORD PTR [esi], 65535	; 0000ffffH
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL18@MoveErtel:

; 604  : 			Option[i] = 0x0F;

  000b0	c6 44 06 02 0f	 mov	 BYTE PTR [esi+eax+2], 15 ; 0000000fH
  000b5	40		 inc	 eax

; 605  : 			Level[1] = 0x0F;

  000b6	c6 46 08 0f	 mov	 BYTE PTR [esi+8], 15	; 0000000fH
  000ba	83 f8 05	 cmp	 eax, 5
  000bd	7c f1		 jl	 SHORT $LL18@MoveErtel
$LN17@MoveErtel:
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp

; 2430 : 		siteminfo[7+i] = TargetItem->m_SocketOption[i];

  000bf	8b 75 14	 mov	 esi, DWORD PTR _siteminfo$[ebp]
  000c2	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  000c5	8a 02		 mov	 al, BYTE PTR [edx]
  000c7	88 44 31 07	 mov	 BYTE PTR [ecx+esi+7], al
$LN2@MoveErtel:

; 2407 : 	}
; 2408 : 
; 2409 : 
; 2410 : 	for(int i = 0; i < 5; i++)	{

  000cb	42		 inc	 edx
  000cc	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  000cf	83 f8 05	 cmp	 eax, 5
  000d2	7c 8c		 jl	 SHORT $LL4@MoveErtel

; 2431 : 	}
; 2432 : 
; 2433 : 	SendElementalItems(lpObj,ERTEL_INVENTORY);

  000d4	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000da	6a 00		 push	 0
  000dc	53		 push	 ebx
  000dd	e8 00 00 00 00	 call	 ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems

; 2434 : 	SendElementalItems(lpObj,ERTEL_WAREHOUSE);

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000e5	6a 01		 push	 1
  000e7	53		 push	 ebx
  000e8	e8 00 00 00 00	 call	 ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems
  000ed	5f		 pop	 edi
  000ee	5b		 pop	 ebx
$LN1@MoveErtel:
  000ef	5e		 pop	 esi

; 2435 : }

  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 10 00	 ret	 16			; 00000010H
?MoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@EPAE@Z ENDP ; CElementalSystem::MoveErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_TargetItem$ = 12					; size = 4
?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z PROC ; CElementalSystem::ClearErtel, COMDAT
; _this$ = ecx

; 2511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2512 : 	if( !IsPentagram(TargetItem->m_Type) )

  00005	8b 75 0c	 mov	 esi, DWORD PTR _TargetItem$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?IsPentagram@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsPentagram
  00014	85 c0		 test	 eax, eax
  00016	74 3a		 je	 SHORT $LN1@ClearErtel

; 2513 : 		return;
; 2514 : 
; 2515 : 
; 2516 : 	ERTEL_USER* lpTargetErtel;
; 2517 : 	lpTargetErtel = lpObj->pErtelList1;
; 2518 : 
; 2519 : 	for(int i = 0; i < 5; i++)	{

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0001b	81 c6 c8 00 00
	00		 add	 esi, 200		; 000000c8H
  00021	57		 push	 edi
  00022	bf 05 00 00 00	 mov	 edi, 5
$LL4@ClearErtel:

; 2520 : 
; 2521 : 		if( TargetItem->m_SocketOption[i] == (BYTE)-1 ||

  00027	8a 06		 mov	 al, BYTE PTR [esi]
  00029	3c ff		 cmp	 al, 255			; 000000ffH
  0002b	74 15		 je	 SHORT $LN2@ClearErtel
  0002d	3c fe		 cmp	 al, 254			; 000000feH
  0002f	74 11		 je	 SHORT $LN2@ClearErtel

; 2522 : 			TargetItem->m_SocketOption[i] == (BYTE)-2 )
; 2523 : 		{
; 2524 : 			continue;
; 2525 : 		}
; 2526 : 
; 2527 : 		RemoveErtel(lpObj,TargetItem->m_SocketOption[i],ERTEL_INVENTORY);

  00031	6a 00		 push	 0
  00033	0f b6 c0	 movzx	 eax, al
  00036	50		 push	 eax
  00037	51		 push	 ecx
  00038	8b cb		 mov	 ecx, ebx
  0003a	e8 00 00 00 00	 call	 ?RemoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CElementalSystem::RemoveErtel
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
$LN2@ClearErtel:

; 2513 : 		return;
; 2514 : 
; 2515 : 
; 2516 : 	ERTEL_USER* lpTargetErtel;
; 2517 : 	lpTargetErtel = lpObj->pErtelList1;
; 2518 : 
; 2519 : 	for(int i = 0; i < 5; i++)	{

  00042	46		 inc	 esi
  00043	83 ef 01	 sub	 edi, 1
  00046	75 df		 jne	 SHORT $LL4@ClearErtel

; 2528 : 	}
; 2529 : 
; 2530 : 	SendElementalItems(lpObj,ERTEL_INVENTORY);

  00048	57		 push	 edi
  00049	51		 push	 ecx
  0004a	8b cb		 mov	 ecx, ebx
  0004c	e8 00 00 00 00	 call	 ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::SendElementalItems
  00051	5f		 pop	 edi
$LN1@ClearErtel:
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx

; 2531 : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z ENDP ; CElementalSystem::ClearErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?InsertErtel@CElementalSystem@@QAEEPAUOBJECTSTRUCT@@PAVCItem@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_ErtelItem$ = 12					; size = 4
?InsertErtel@CElementalSystem@@QAEEPAUOBJECTSTRUCT@@PAVCItem@@@Z PROC ; CElementalSystem::InsertErtel, COMDAT
; _this$ = ecx

; 2206 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2208 : 		if( lpObj->pErtelList1[i].btType == (BYTE)-1 )	{

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	8b 90 dc 26 00
	00		 mov	 edx, DWORD PTR [eax+9948]
  0000e	8b c2		 mov	 eax, edx
$LL4@InsertErte:
  00010	80 38 ff	 cmp	 BYTE PTR [eax], 255	; 000000ffH
  00013	74 0f		 je	 SHORT $LN8@InsertErte

; 2207 : 	for(int i = 0; i < MAX_ERTEL; i++)	{

  00015	41		 inc	 ecx
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0001c	7c f2		 jl	 SHORT $LL4@InsertErte

; 2229 : 		}
; 2230 : 	}
; 2231 : 	return -1;

  0001e	0c ff		 or	 al, 255			; 000000ffH

; 2232 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN8@InsertErte:
  00024	56		 push	 esi

; 2209 : 			ERTEL_USER* lpErtel = &lpObj->pErtelList1[i];
; 2210 : 
; 2211 : 			lpErtel->btType = 1+(ErtelItem->m_Type - ITEMGET(12,221))/10;

  00025	8b 75 0c	 mov	 esi, DWORD PTR _ErtelItem$[ebp]
  00028	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0002b	57		 push	 edi
  0002c	8d 3c 82	 lea	 edi, DWORD PTR [edx+eax*4]
  0002f	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00034	0f bf 56 06	 movsx	 edx, WORD PTR [esi+6]
  00038	81 ea dd 18 00
	00		 sub	 edx, 6365		; 000018ddH
  0003e	f7 ea		 imul	 edx
  00040	c1 fa 02	 sar	 edx, 2
  00043	8b c2		 mov	 eax, edx
  00045	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00048	03 c2		 add	 eax, edx
  0004a	fe c0		 inc	 al
  0004c	88 07		 mov	 BYTE PTR [edi], al

; 2212 : 			lpErtel->btAttribute = ErtelItem->m_SocketBonus;

  0004e	0f b6 86 c7 00
	00 00		 movzx	 eax, BYTE PTR [esi+199]
  00055	88 47 01	 mov	 BYTE PTR [edi+1], al

; 2213 : 
; 2214 : 			lpErtel->Option[0] = ErtelItem->m_SocketOption[0]%16;

  00058	0f b6 86 c8 00
	00 00		 movzx	 eax, BYTE PTR [esi+200]
  0005f	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00064	79 05		 jns	 SHORT $LN12@InsertErte
  00066	48		 dec	 eax
  00067	83 c8 f0	 or	 eax, -16		; fffffff0H
  0006a	40		 inc	 eax
$LN12@InsertErte:
  0006b	88 47 02	 mov	 BYTE PTR [edi+2], al

; 2215 : 			lpErtel->Level[0] = ErtelItem->m_SocketOption[0]/16;

  0006e	0f b6 86 c8 00
	00 00		 movzx	 eax, BYTE PTR [esi+200]
  00075	c0 e8 04	 shr	 al, 4
  00078	88 47 07	 mov	 BYTE PTR [edi+7], al

; 2216 : 
; 2217 : 			lpErtel->Option[1] = ErtelItem->m_SocketOption[1]%16;

  0007b	0f b6 86 c9 00
	00 00		 movzx	 eax, BYTE PTR [esi+201]
  00082	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00087	79 05		 jns	 SHORT $LN13@InsertErte
  00089	48		 dec	 eax
  0008a	83 c8 f0	 or	 eax, -16		; fffffff0H
  0008d	40		 inc	 eax
$LN13@InsertErte:
  0008e	88 47 03	 mov	 BYTE PTR [edi+3], al

; 2218 : 			lpErtel->Level[1] = ErtelItem->m_SocketOption[1]/16;

  00091	0f b6 86 c9 00
	00 00		 movzx	 eax, BYTE PTR [esi+201]
  00098	c0 e8 04	 shr	 al, 4
  0009b	88 47 08	 mov	 BYTE PTR [edi+8], al

; 2219 : 
; 2220 : 			lpErtel->Option[2] = ErtelItem->m_SocketOption[2]%16;

  0009e	0f b6 86 ca 00
	00 00		 movzx	 eax, BYTE PTR [esi+202]
  000a5	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  000aa	79 05		 jns	 SHORT $LN14@InsertErte
  000ac	48		 dec	 eax
  000ad	83 c8 f0	 or	 eax, -16		; fffffff0H
  000b0	40		 inc	 eax
$LN14@InsertErte:
  000b1	88 47 04	 mov	 BYTE PTR [edi+4], al

; 2221 : 			lpErtel->Level[2] = ErtelItem->m_SocketOption[2]/16;

  000b4	0f b6 86 ca 00
	00 00		 movzx	 eax, BYTE PTR [esi+202]
  000bb	c0 e8 04	 shr	 al, 4
  000be	88 47 09	 mov	 BYTE PTR [edi+9], al

; 2222 : 
; 2223 : 			lpErtel->Option[3] = ErtelItem->m_SocketOption[3]%16;

  000c1	0f b6 86 cb 00
	00 00		 movzx	 eax, BYTE PTR [esi+203]
  000c8	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  000cd	79 05		 jns	 SHORT $LN15@InsertErte
  000cf	48		 dec	 eax
  000d0	83 c8 f0	 or	 eax, -16		; fffffff0H
  000d3	40		 inc	 eax
$LN15@InsertErte:
  000d4	88 47 05	 mov	 BYTE PTR [edi+5], al

; 2224 : 			lpErtel->Level[3] = ErtelItem->m_SocketOption[3]/16;

  000d7	0f b6 86 cb 00
	00 00		 movzx	 eax, BYTE PTR [esi+203]
  000de	c0 e8 04	 shr	 al, 4
  000e1	88 47 0a	 mov	 BYTE PTR [edi+10], al

; 2225 : 
; 2226 : 			lpErtel->Option[4] = ErtelItem->m_SocketOption[4]%16;

  000e4	0f b6 86 cc 00
	00 00		 movzx	 eax, BYTE PTR [esi+204]
  000eb	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  000f0	79 05		 jns	 SHORT $LN16@InsertErte
  000f2	48		 dec	 eax
  000f3	83 c8 f0	 or	 eax, -16		; fffffff0H
  000f6	40		 inc	 eax
$LN16@InsertErte:
  000f7	88 47 06	 mov	 BYTE PTR [edi+6], al

; 2227 : 			lpErtel->Level[4] = ErtelItem->m_SocketOption[4]/16;

  000fa	0f b6 86 cc 00
	00 00		 movzx	 eax, BYTE PTR [esi+204]
  00101	c0 e8 04	 shr	 al, 4
  00104	88 47 0b	 mov	 BYTE PTR [edi+11], al

; 2228 : 			return i;

  00107	8a c1		 mov	 al, cl
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi

; 2232 : }

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
?InsertErtel@CElementalSystem@@QAEEPAUOBJECTSTRUCT@@PAVCItem@@@Z ENDP ; CElementalSystem::InsertErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$1$ = -44					; size = 4
_lpSource$1$ = -40					; size = 4
_SocketBonus$1 = -36					; size = 1
_this$GSCopy$1$ = -32					; size = 4
_pResult$ = -28						; size = 5
_pMsg$ = -20						; size = 7
_SocketOption$2 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z PROC ; CElementalSystem::CGRemoveErtel, COMDAT
; _this$ = ecx

; 2110 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	89 4d e0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00017	89 5d d4	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], ebx
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 2111 : 	if( lpMsg == NULL )

  0001e	85 db		 test	 ebx, ebx
  00020	0f 84 cf 02 00
	00		 je	 $LN1@CGRemoveEr

; 2112 : 		return;
; 2113 : 
; 2114 : 	if( !gObjIsConnected(aIndex) )

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 be 02 00
	00		 je	 $LN1@CGRemoveEr

; 2115 : 	{
; 2116 : 		return;
; 2117 : 	}
; 2118 : 
; 2119 : 	LPOBJ lpObj = &gObj[aIndex];

  00037	56		 push	 esi
  00038	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0003e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2120 : 
; 2121 : 	if( lpObj->m_IfState.use )

  00044	f6 86 b8 11 00
	00 03		 test	 BYTE PTR [esi+4536], 3
  0004b	0f 85 a3 02 00
	00		 jne	 $LN28@CGRemoveEr

; 2122 : 	{
; 2123 : 		return;
; 2124 : 	}
; 2125 : 
; 2126 : 	PMSG_ANS_REMOVEERTEL pMsg;
; 2127 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEC,0x1,sizeof(pMsg));

  00051	6a 07		 push	 7
  00053	6a 01		 push	 1
  00055	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00058	68 ec 00 00 00	 push	 236			; 000000ecH
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2128 : 
; 2129 : 	pMsg.btResult = 0;
; 2130 : 	pMsg.btType = ERTEL_INVENTORY;
; 2131 : 	pMsg.btPos = lpMsg->ErtelPos;

  00063	8a 53 08	 mov	 dl, BYTE PTR [ebx+8]
  00066	83 c4 10	 add	 esp, 16			; 00000010H

; 2132 : 
; 2133 : 	if( !MAIN_INVENTORY_RANGE(lpMsg->iPentagramPos) )

  00069	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0006c	c6 45 f0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00070	c6 45 f2 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0
  00074	88 55 f1	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00077	85 c9		 test	 ecx, ecx
  00079	0f 88 4f 02 00
	00		 js	 $LN27@CGRemoveEr
  0007f	33 c0		 xor	 eax, eax
  00081	81 f9 cb 00 00
	00		 cmp	 ecx, 203		; 000000cbH
  00087	0f 9e c0	 setle	 al
  0008a	85 c0		 test	 eax, eax
  0008c	0f 84 3c 02 00
	00		 je	 $LN27@CGRemoveEr

; 2137 : 		return;
; 2138 : 	}
; 2139 : 
; 2140 : 	CItem* lpSource = &lpObj->pInventory[lpMsg->iPentagramPos];

  00092	69 c9 d4 00 00
	00		 imul	 ecx, ecx, 212

; 2141 : 
; 2142 : 	if( lpSource->m_SocketOption[pMsg.btPos] == (BYTE)-1 ||

  00098	0f b6 c2	 movzx	 eax, dl
  0009b	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]
  000a1	89 4d d8	 mov	 DWORD PTR _lpSource$1$[ebp], ecx
  000a4	8a 84 08 c8 00
	00 00		 mov	 al, BYTE PTR [eax+ecx+200]
  000ab	3c ff		 cmp	 al, 255			; 000000ffH
  000ad	0f 84 1b 02 00
	00		 je	 $LN27@CGRemoveEr
  000b3	3c fe		 cmp	 al, 254			; 000000feH
  000b5	0f 84 13 02 00
	00		 je	 $LN27@CGRemoveEr

; 2143 : 		lpSource->m_SocketOption[pMsg.btPos] == (BYTE)-2 )
; 2144 : 	{
; 2145 : 		LogAddTD("[Ertel Remove][ERROR] Inventory range error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);
; 2146 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2147 : 		return;
; 2148 : 	}
; 2149 : 
; 2150 : 	ERTEL_USER* lpErtel = GetErtel(lpObj,lpSource->m_SocketOption[pMsg.btPos],ERTEL_INVENTORY);

  000bb	8b 4d e0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000be	6a 00		 push	 0
  000c0	0f b6 c0	 movzx	 eax, al
  000c3	50		 push	 eax
  000c4	56		 push	 esi
  000c5	e8 00 00 00 00	 call	 ?GetErtel@CElementalSystem@@QAEPAUERTEL_USER@@PAUOBJECTSTRUCT@@HH@Z ; CElementalSystem::GetErtel
  000ca	8b d8		 mov	 ebx, eax

; 2151 : 
; 2152 : 	if( lpErtel == NULL )

  000cc	85 db		 test	 ebx, ebx
  000ce	0f 84 fa 01 00
	00		 je	 $LN27@CGRemoveEr

; 2153 : 	{
; 2154 : 		LogAddTD("[Ertel Remove][ERROR] Inventory range error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);
; 2155 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2156 : 		return;
; 2157 : 	}
; 2158 : 
; 2159 : 	if( !CheckInventoryEmptySpace(lpObj,2,2) )

  000d4	6a 02		 push	 2
  000d6	6a 02		 push	 2
  000d8	56		 push	 esi
  000d9	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e1	85 c0		 test	 eax, eax
  000e3	75 29		 jne	 SHORT $LN12@CGRemoveEr

; 2160 : 	{
; 2161 : 		pMsg.btResult = 100;
; 2162 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000e5	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000e9	50		 push	 eax
  000ea	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ed	c6 45 f0 64	 mov	 BYTE PTR _pMsg$[ebp+4], 100 ; 00000064H
  000f1	50		 push	 eax
  000f2	57		 push	 edi
  000f3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fb	5e		 pop	 esi
  000fc	5f		 pop	 edi
  000fd	5b		 pop	 ebx

; 2203 : }

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 08 00	 ret	 8
$LN12@CGRemoveEr:

; 2163 : 		return;
; 2164 : 	}	
; 2165 : 
; 2166 : 	if( rand()%100 < 50 )

  0010e	e8 00 00 00 00	 call	 _rand
  00113	99		 cdq
  00114	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00119	f7 f9		 idiv	 ecx
  0011b	83 fa 32	 cmp	 edx, 50			; 00000032H
  0011e	0f 8d e0 00 00
	00		 jge	 $LN13@CGRemoveEr

; 2167 : 	{
; 2168 : 		pMsg.btResult = 1;
; 2169 : 		int Type = ITEMGET(12,221+10*pMsg.btPos);

  00124	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+5]
  00128	c6 45 f0 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 2170 : 
; 2171 : 		BYTE SocketBonus = lpErtel->btAttribute;
; 2172 : 		BYTE SocketOption[5] = {-1};

  0012c	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _SocketOption$2[ebp+1], 0

; 2173 : 
; 2174 : 		for(int i = 0; i < 5; i++)	{
; 2175 : 			SocketOption[i] = lpErtel->Level[i]*16 | lpErtel->Option[i];
; 2176 : 		}
; 2177 : 
; 2178 : 		ItemSerialCreateSend(lpObj->m_Index,235,lpObj->X,lpObj->Y,Type,0,0,0,0,0,lpObj->m_Index,0,0,SocketBonus,SocketOption);

  00133	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00135	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00138	8d 14 45 dd 18
	00 00		 lea	 edx, DWORD PTR [eax*2+6365]
  0013f	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  00143	88 45 dc	 mov	 BYTE PTR _SocketBonus$1[ebp], al
  00146	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  0014a	c0 e0 04	 shl	 al, 4
  0014d	0a 43 02	 or	 al, BYTE PTR [ebx+2]
  00150	88 45 f4	 mov	 BYTE PTR _SocketOption$2[ebp], al
  00153	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  00157	c0 e0 04	 shl	 al, 4
  0015a	0a 43 03	 or	 al, BYTE PTR [ebx+3]
  0015d	88 45 f5	 mov	 BYTE PTR _SocketOption$2[ebp+1], al
  00160	0f b6 43 09	 movzx	 eax, BYTE PTR [ebx+9]
  00164	c0 e0 04	 shl	 al, 4
  00167	0a 43 04	 or	 al, BYTE PTR [ebx+4]
  0016a	88 45 f6	 mov	 BYTE PTR _SocketOption$2[ebp+2], al
  0016d	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  00171	c0 e0 04	 shl	 al, 4
  00174	0a 43 05	 or	 al, BYTE PTR [ebx+5]
  00177	88 45 f7	 mov	 BYTE PTR _SocketOption$2[ebp+3], al
  0017a	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  0017e	c0 e0 04	 shl	 al, 4
  00181	0a 43 06	 or	 al, BYTE PTR [ebx+6]
  00184	88 45 f8	 mov	 BYTE PTR _SocketOption$2[ebp+4], al
  00187	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$2[ebp]
  0018a	50		 push	 eax
  0018b	ff 75 dc	 push	 DWORD PTR _SocketBonus$1[ebp]
  0018e	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00195	6a 00		 push	 0
  00197	6a 00		 push	 0
  00199	51		 push	 ecx
  0019a	6a 00		 push	 0
  0019c	6a 00		 push	 0
  0019e	6a 00		 push	 0
  001a0	6a 00		 push	 0
  001a2	6a 00		 push	 0
  001a4	52		 push	 edx
  001a5	50		 push	 eax
  001a6	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  001ad	50		 push	 eax
  001ae	68 eb 00 00 00	 push	 235			; 000000ebH
  001b3	51		 push	 ecx
  001b4	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 2179 : 
; 2180 : 		LogAddTD("[Ertel Remove] [%d] (%s)(%s) [Success] ErrtelID: %d, Op1[%d/%d],Op2[%d/%d],Op3[%d/%d],Op4[%d/%d],Op5[%d/%d]",aIndex,lpObj->AccountID,lpObj->Name,

  001b9	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  001bd	50		 push	 eax
  001be	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  001c2	50		 push	 eax
  001c3	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  001c7	50		 push	 eax
  001c8	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  001cc	50		 push	 eax
  001cd	0f b6 43 09	 movzx	 eax, BYTE PTR [ebx+9]
  001d1	50		 push	 eax
  001d2	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  001d6	50		 push	 eax
  001d7	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  001db	50		 push	 eax
  001dc	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  001e0	50		 push	 eax
  001e1	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  001e5	50		 push	 eax
  001e6	0f b6 43 02	 movzx	 eax, BYTE PTR [ebx+2]
  001ea	50		 push	 eax
  001eb	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  001ee	50		 push	 eax
  001ef	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  001f2	50		 push	 eax
  001f3	57		 push	 edi
  001f4	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@MHCJODDO@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLSu@
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001ff	83 c4 74	 add	 esp, 116		; 00000074H

; 2181 : 			lpErtel->Option[0],lpErtel->Level[0],lpErtel->Option[1],lpErtel->Level[1],
; 2182 : 			lpErtel->Option[2],lpErtel->Level[2],lpErtel->Option[3],lpErtel->Level[3],
; 2183 : 			lpErtel->Option[4],lpErtel->Level[4]);
; 2184 : 	}
; 2185 : 	else

  00202	eb 4d		 jmp	 SHORT $LN14@CGRemoveEr
$LN13@CGRemoveEr:

; 2186 : 	{
; 2187 : 		pMsg.btResult = 2;

  00204	c6 45 f0 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2

; 2188 : 		LogAddTD("[Ertel Remove] [%d] (%s)(%s) [Fail] ErrtelID: %d, Op1[%d/%d],Op2[%d/%d],Op3[%d/%d],Op4[%d/%d],Op5[%d/%d]",aIndex,lpObj->AccountID,lpObj->Name,

  00208	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  0020c	50		 push	 eax
  0020d	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  00211	50		 push	 eax
  00212	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  00216	50		 push	 eax
  00217	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0021b	50		 push	 eax
  0021c	0f b6 43 09	 movzx	 eax, BYTE PTR [ebx+9]
  00220	50		 push	 eax
  00221	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00225	50		 push	 eax
  00226	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  0022a	50		 push	 eax
  0022b	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  0022f	50		 push	 eax
  00230	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  00234	50		 push	 eax
  00235	0f b6 43 02	 movzx	 eax, BYTE PTR [ebx+2]
  00239	50		 push	 eax
  0023a	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0023d	50		 push	 eax
  0023e	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00241	50		 push	 eax
  00242	57		 push	 edi
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@CBGBFNDC@?$FLErtel?5Remove?$FN?5?$FL?$CFd?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$FLFa@
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0024e	83 c4 38	 add	 esp, 56			; 00000038H
$LN14@CGRemoveEr:

; 2189 : 			lpErtel->Option[0],lpErtel->Level[0],lpErtel->Option[1],lpErtel->Level[1],
; 2190 : 			lpErtel->Option[2],lpErtel->Level[2],lpErtel->Option[3],lpErtel->Level[3],
; 2191 : 			lpErtel->Option[4],lpErtel->Level[4]);
; 2192 : 	}
; 2193 : 
; 2194 : 	RemoveErtel(lpObj,lpSource->m_SocketOption[pMsg.btPos],ERTEL_INVENTORY);

  00251	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+5]
  00255	8b 5d d8	 mov	 ebx, DWORD PTR _lpSource$1$[ebp]
  00258	8b 4d e0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0025b	6a 00		 push	 0
  0025d	0f b6 84 18 c8
	00 00 00	 movzx	 eax, BYTE PTR [eax+ebx+200]
  00265	50		 push	 eax
  00266	56		 push	 esi
  00267	e8 00 00 00 00	 call	 ?RemoveErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CElementalSystem::RemoveErtel

; 2195 : 	lpSource->m_SocketOption[pMsg.btPos] = (BYTE)-2;

  0026c	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+5]
  00270	c6 84 18 c8 00
	00 00 fe	 mov	 BYTE PTR [eax+ebx+200], 254 ; 000000feH

; 2196 : 	GCInventoryItemOneSend(aIndex, lpMsg->iPentagramPos);

  00278	8b 45 d4	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0027b	ff 70 04	 push	 DWORD PTR [eax+4]
  0027e	57		 push	 edi
  0027f	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 2197 : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00284	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00288	50		 push	 eax
  00289	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0028c	50		 push	 eax
  0028d	57		 push	 edi
  0028e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2198 : 
; 2199 : 	PMSG_ERTEL_RESULT pResult;
; 2200 : 	PHeadSubSetB((LPBYTE)&pResult,0xEC,0x04,sizeof(pResult));

  00293	6a 05		 push	 5
  00295	6a 04		 push	 4
  00297	8d 45 e4	 lea	 eax, DWORD PTR _pResult$[ebp]
  0029a	68 ec 00 00 00	 push	 236			; 000000ecH
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2201 : 	pResult.btResult = TRUE;
; 2202 : 	DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  002a5	0f b6 45 e5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002a9	50		 push	 eax
  002aa	8d 45 e4	 lea	 eax, DWORD PTR _pResult$[ebp]
  002ad	c6 45 e8 01	 mov	 BYTE PTR _pResult$[ebp+4], 1
  002b1	50		 push	 eax
  002b2	57		 push	 edi
  002b3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b8	83 c4 30	 add	 esp, 48			; 00000030H
  002bb	5e		 pop	 esi
  002bc	5f		 pop	 edi
  002bd	5b		 pop	 ebx

; 2203 : }

  002be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c1	33 cd		 xor	 ecx, ebp
  002c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c8	8b e5		 mov	 esp, ebp
  002ca	5d		 pop	 ebp
  002cb	c2 08 00	 ret	 8
$LN27@CGRemoveEr:

; 2134 : 	{
; 2135 : 		LogAddTD("[Ertel Remove][ERROR] Inventory range error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  002ce	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  002d1	50		 push	 eax
  002d2	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  002d5	50		 push	 eax
  002d6	57		 push	 edi
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@DICEMIHC@?$FLErtel?5Remove?$FN?$FLERROR?$FN?5Inventory?5@
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2136 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  002e2	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002e6	50		 push	 eax
  002e7	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002ea	50		 push	 eax
  002eb	57		 push	 edi
  002ec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002f1	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN28@CGRemoveEr:
  002f4	5e		 pop	 esi
$LN1@CGRemoveEr:

; 2203 : }

  002f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f8	5f		 pop	 edi
  002f9	33 cd		 xor	 ecx, ebp
  002fb	5b		 pop	 ebx
  002fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00301	8b e5		 mov	 esp, ebp
  00303	5d		 pop	 ebp
  00304	c2 08 00	 ret	 8
?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z ENDP ; CElementalSystem::CGRemoveErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z
_TEXT	SEGMENT
_lpSource$1$ = -56					; size = 4
_lpMsg$GSCopy$1$ = -52					; size = 4
_lpTarget$1$ = -48					; size = 4
tv659 = -44						; size = 4
_this$GSCopy$1$ = -40					; size = 4
_pResult$ = -36						; size = 5
_pMsg$ = -28						; size = 22
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z PROC ; CElementalSystem::CGInsertErtel, COMDAT
; _this$ = ecx

; 2006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	89 4d d8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00017	89 5d cc	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], ebx
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 2007 : 	if( lpMsg == NULL )

  0001e	85 db		 test	 ebx, ebx
  00020	0f 84 68 02 00
	00		 je	 $LN1@CGInsertEr

; 2008 : 		return;
; 2009 : 
; 2010 : 	if( !gObjIsConnected(aIndex) )

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 57 02 00
	00		 je	 $LN1@CGInsertEr

; 2011 : 	{
; 2012 : 		return;
; 2013 : 	}
; 2014 : 
; 2015 : 	LPOBJ lpObj = &gObj[aIndex];

  00037	56		 push	 esi
  00038	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0003e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2016 : 
; 2017 : 	if( lpObj->m_IfState.use )

  00044	f6 86 b8 11 00
	00 03		 test	 BYTE PTR [esi+4536], 3
  0004b	0f 85 3c 02 00
	00		 jne	 $LN37@CGInsertEr

; 2018 : 	{
; 2019 : 		return;
; 2020 : 	}
; 2021 : 
; 2022 : 	PMSG_ANS_INSERTERTEL pMsg;
; 2023 : 	PHeadSubSetB((LPBYTE)&pMsg,0xEC,0x00,sizeof(pMsg));

  00051	6a 16		 push	 22			; 00000016H
  00053	6a 00		 push	 0
  00055	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00058	68 ec 00 00 00	 push	 236			; 000000ecH
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2024 : 
; 2025 : 	pMsg.btResult = FALSE;
; 2026 : 
; 2027 : 	
; 2028 : 
; 2029 : 	if( !MAIN_INVENTORY_RANGE(lpMsg->iSource) ||

  00063	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0006d	85 c9		 test	 ecx, ecx
  0006f	0f 88 f2 01 00
	00		 js	 $LN11@CGInsertEr
  00075	33 c0		 xor	 eax, eax
  00077	81 f9 cb 00 00
	00		 cmp	 ecx, 203		; 000000cbH
  0007d	0f 9e c0	 setle	 al
  00080	85 c0		 test	 eax, eax
  00082	0f 84 df 01 00
	00		 je	 $LN11@CGInsertEr
  00088	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0008b	85 d2		 test	 edx, edx
  0008d	0f 88 d4 01 00
	00		 js	 $LN11@CGInsertEr
  00093	33 c0		 xor	 eax, eax
  00095	81 fa cb 00 00
	00		 cmp	 edx, 203		; 000000cbH
  0009b	0f 9e c0	 setle	 al
  0009e	85 c0		 test	 eax, eax
  000a0	0f 84 c1 01 00
	00		 je	 $LN11@CGInsertEr

; 2034 : 		return;
; 2035 : 	}
; 2036 : 
; 2037 : 	CItem* lpSource = &lpObj->pInventory[lpMsg->iSource];

  000a6	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  000ac	69 c9 d4 00 00
	00		 imul	 ecx, ecx, 212

; 2038 : 	CItem* lpTarget = &lpObj->pInventory[lpMsg->iTarget];

  000b2	69 d2 d4 00 00
	00		 imul	 edx, edx, 212
  000b8	03 c8		 add	 ecx, eax
  000ba	03 d0		 add	 edx, eax
  000bc	89 4d c8	 mov	 DWORD PTR _lpSource$1$[ebp], ecx
  000bf	89 55 d0	 mov	 DWORD PTR _lpTarget$1$[ebp], edx

; 2039 : 
; 2040 : 	int Socket = -1;
; 2041 : 
; 2042 : 	switch( lpSource->m_Type )	{

  000c2	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]
  000c6	05 23 e7 ff ff	 add	 eax, -6365		; ffffe723H
  000cb	83 f8 28	 cmp	 eax, 40			; 00000028H
  000ce	0f 87 83 01 00
	00		 ja	 $LN35@CGInsertEr
  000d4	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN36@CGInsertEr[eax]
  000db	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN40@CGInsertEr[eax*4]
$LN12@CGInsertEr:

; 2043 : 	case ITEMGET(12,221):	Socket = 0;	break;

  000e2	33 db		 xor	 ebx, ebx
  000e4	eb 1a		 jmp	 SHORT $LN17@CGInsertEr
$LN13@CGInsertEr:

; 2044 : 	case ITEMGET(12,231):	Socket = 1;	break;

  000e6	bb 01 00 00 00	 mov	 ebx, 1
  000eb	eb 13		 jmp	 SHORT $LN17@CGInsertEr
$LN14@CGInsertEr:

; 2045 : 	case ITEMGET(12,241):	Socket = 2;	break;

  000ed	bb 02 00 00 00	 mov	 ebx, 2
  000f2	eb 0c		 jmp	 SHORT $LN17@CGInsertEr
$LN15@CGInsertEr:

; 2046 : 	case ITEMGET(12,251):	Socket = 3;	break;

  000f4	bb 03 00 00 00	 mov	 ebx, 3
  000f9	eb 05		 jmp	 SHORT $LN17@CGInsertEr
$LN16@CGInsertEr:

; 2047 : 	case ITEMGET(12,261):	Socket = 4;	break;

  000fb	bb 04 00 00 00	 mov	 ebx, 4
$LN17@CGInsertEr:

; 2054 : 	}
; 2055 : 
; 2056 : 	if( lpTarget->m_SocketOption[Socket] != (BYTE)-2 )

  00100	8d 82 c8 00 00
	00		 lea	 eax, DWORD PTR [edx+200]
  00106	03 c3		 add	 eax, ebx
  00108	89 45 d4	 mov	 DWORD PTR tv659[ebp], eax
  0010b	80 38 fe	 cmp	 BYTE PTR [eax], 254	; 000000feH
  0010e	74 13		 je	 SHORT $LN18@CGInsertEr

; 2057 : 	{
; 2058 : 		LogAddTD("[Ertel Insert][ERROR] ErtelSocket not empty ! [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  00110	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00113	50		 push	 eax
  00114	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00117	50		 push	 eax
  00118	57		 push	 edi
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@FIGMOAKP@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelSocke@

; 2059 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2060 : 		return;

  0011e	e9 52 01 00 00	 jmp	 $LN38@CGInsertEr
$LN18@CGInsertEr:

; 2061 : 	}
; 2062 : 
; 2063 : 	if( (lpSource->m_SocketBonus&0x0F) != (lpTarget->m_SocketBonus&0x0F) )

  00123	8a 81 c7 00 00
	00		 mov	 al, BYTE PTR [ecx+199]
  00129	32 82 c7 00 00
	00		 xor	 al, BYTE PTR [edx+199]
  0012f	a8 0f		 test	 al, 15			; 0000000fH
  00131	74 13		 je	 SHORT $LN19@CGInsertEr

; 2064 : 	{
; 2065 : 		LogAddTD("[Ertel Insert][ERROR] Ertel element dont match book element ! [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  00133	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00136	50		 push	 eax
  00137	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0013a	50		 push	 eax
  0013b	57		 push	 edi
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LLEHKIAN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5elem@

; 2066 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2067 : 		return;

  00141	e9 2f 01 00 00	 jmp	 $LN38@CGInsertEr
$LN19@CGInsertEr:

; 2068 : 	}
; 2069 : 
; 2070 : 	int ErtelID = InsertErtel(lpObj,lpSource);

  00146	51		 push	 ecx
  00147	8b 4d d8	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0014a	56		 push	 esi
  0014b	e8 00 00 00 00	 call	 ?InsertErtel@CElementalSystem@@QAEEPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CElementalSystem::InsertErtel
  00150	0f b6 d0	 movzx	 edx, al

; 2071 : 
; 2072 : 	if( ErtelID == (BYTE)-1 )

  00153	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00159	75 13		 jne	 SHORT $LN20@CGInsertEr

; 2073 : 	{
; 2074 : 		LogAddTD("[Ertel Insert][ERROR] Ertel list is full ! [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  0015b	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0015e	50		 push	 eax
  0015f	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00162	50		 push	 eax
  00163	57		 push	 edi
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@NHPFFHEF@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Ertel?5list@

; 2075 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2076 : 		return;

  00169	e9 07 01 00 00	 jmp	 $LN38@CGInsertEr
$LN20@CGInsertEr:

; 2077 : 	}
; 2078 : 
; 2079 : 	ERTEL_USER* lpErtel = &lpObj->pErtelList1[ErtelID];

  0016e	8b 86 dc 26 00
	00		 mov	 eax, DWORD PTR [esi+9948]
  00174	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00177	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]

; 2080 : 
; 2081 : 	lpTarget->m_SocketOption[Socket] = ErtelID;

  0017a	8b 45 d4	 mov	 eax, DWORD PTR tv659[ebp]
  0017d	88 10		 mov	 BYTE PTR [eax], dl

; 2082 : 
; 2083 : 	pMsg.ErtelInfo.btType = ERTEL_INVENTORY;
; 2084 : 	pMsg.ErtelInfo.btId = ErtelID;
; 2085 : 	pMsg.ErtelInfo.btAttribute = lpTarget->m_SocketBonus;

  0017f	8b 45 d0	 mov	 eax, DWORD PTR _lpTarget$1$[ebp]
  00182	c6 45 e9 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00186	88 55 ea	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  00189	8a 80 c7 00 00
	00		 mov	 al, BYTE PTR [eax+199]
  0018f	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 2086 : 	pMsg.ErtelInfo.btIndex = 12;
; 2087 : 	pMsg.ErtelInfo.wNumber = 221 + Socket*10;

  00192	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]
  00195	8d 04 45 dd 00
	00 00		 lea	 eax, DWORD PTR [eax*2+221]
  0019c	c6 45 ec 0c	 mov	 BYTE PTR _pMsg$[ebp+8], 12 ; 0000000cH
  001a0	66 89 45 ed	 mov	 WORD PTR _pMsg$[ebp+9], ax

; 2088 : 	pMsg.ErtelInfo.btUnk4 = 0;

  001a4	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+11], 0

; 2089 : 
; 2090 : 	for(int i = 0; i < 5; i++)	{
; 2091 : 		pMsg.ErtelInfo.Option[i].OptionID = lpErtel->Option[i];

  001a8	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  001ab	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 2092 : 		pMsg.ErtelInfo.Option[i].OptionLevel = lpErtel->Level[i];

  001ae	8a 41 07	 mov	 al, BYTE PTR [ecx+7]
  001b1	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+13], al
  001b4	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  001b7	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+14], al
  001ba	8a 41 08	 mov	 al, BYTE PTR [ecx+8]
  001bd	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+15], al
  001c0	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  001c3	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+16], al
  001c6	8a 41 09	 mov	 al, BYTE PTR [ecx+9]
  001c9	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+17], al
  001cc	8a 41 05	 mov	 al, BYTE PTR [ecx+5]
  001cf	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+18], al
  001d2	8a 41 0a	 mov	 al, BYTE PTR [ecx+10]
  001d5	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+19], al
  001d8	8a 41 06	 mov	 al, BYTE PTR [ecx+6]
  001db	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+20], al
  001de	8a 41 0b	 mov	 al, BYTE PTR [ecx+11]
  001e1	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+21], al

; 2093 : 	}
; 2094 : 	pMsg.btResult = TRUE;
; 2095 : 
; 2096 : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  001e4	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001e8	50		 push	 eax
  001e9	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001ec	c6 45 e8 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  001f0	50		 push	 eax
  001f1	57		 push	 edi
  001f2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2097 : 
; 2098 : 	PMSG_ERTEL_RESULT pResult;
; 2099 : 	PHeadSubSetB((LPBYTE)&pResult,0xEC,0x04,sizeof(pResult));

  001f7	6a 05		 push	 5
  001f9	6a 04		 push	 4
  001fb	8d 45 dc	 lea	 eax, DWORD PTR _pResult$[ebp]
  001fe	68 ec 00 00 00	 push	 236			; 000000ecH
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2100 : 	pResult.btResult = TRUE;
; 2101 : 
; 2102 : 	gObjInventoryItemSet(aIndex, lpMsg->iSource, -1);

  00209	8b 75 cc	 mov	 esi, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0020c	68 ff 00 00 00	 push	 255			; 000000ffH
  00211	c6 45 e0 01	 mov	 BYTE PTR _pResult$[ebp+4], 1
  00215	ff 76 08	 push	 DWORD PTR [esi+8]
  00218	57		 push	 edi
  00219	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 2103 : 	lpSource->Clear();

  0021e	8b 4d c8	 mov	 ecx, DWORD PTR _lpSource$1$[ebp]
  00221	83 c4 28	 add	 esp, 40			; 00000028H
  00224	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 2104 : 	GCInventoryItemOneSend(aIndex, lpMsg->iTarget);

  00229	ff 76 04	 push	 DWORD PTR [esi+4]
  0022c	57		 push	 edi
  0022d	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 2105 : 
; 2106 : 	DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  00232	0f b6 45 dd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00236	50		 push	 eax
  00237	8d 45 dc	 lea	 eax, DWORD PTR _pResult$[ebp]
  0023a	50		 push	 eax
  0023b	57		 push	 edi
  0023c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00241	83 c4 14	 add	 esp, 20			; 00000014H
  00244	5e		 pop	 esi
  00245	5f		 pop	 edi
  00246	5b		 pop	 ebx

; 2107 : }

  00247	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024a	33 cd		 xor	 ecx, ebp
  0024c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00251	8b e5		 mov	 esp, ebp
  00253	5d		 pop	 ebp
  00254	c2 08 00	 ret	 8
$LN35@CGInsertEr:

; 2048 : 	}
; 2049 : 
; 2050 : 	if( Socket == -1 )	{
; 2051 : 		LogAddTD("[Ertel Insert][ERROR] ErtelID == -1 [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  00257	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0025a	50		 push	 eax
  0025b	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0025e	50		 push	 eax
  0025f	57		 push	 edi
  00260	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@FBKJFJKK@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5ErtelID?5?$DN?$DN@

; 2052 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 2053 : 		return;

  00265	eb 0e		 jmp	 SHORT $LN38@CGInsertEr
$LN11@CGInsertEr:

; 2030 : 		!MAIN_INVENTORY_RANGE(lpMsg->iTarget) )
; 2031 : 	{
; 2032 : 		LogAddTD("[Ertel Insert][ERROR] Inventory range error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  00267	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0026a	50		 push	 eax
  0026b	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0026e	50		 push	 eax
  0026f	57		 push	 edi
  00270	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@JCIFHKLN@?$FLErtel?5Insert?$FN?$FLERROR?$FN?5Inventory?5@
$LN38@CGInsertEr:
  00275	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2033 : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0027b	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0027f	50		 push	 eax
  00280	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00283	50		 push	 eax
  00284	57		 push	 edi
  00285	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0028a	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN37@CGInsertEr:
  0028d	5e		 pop	 esi
$LN1@CGInsertEr:

; 2107 : }

  0028e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00291	5f		 pop	 edi
  00292	33 cd		 xor	 ecx, ebp
  00294	5b		 pop	 ebx
  00295	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029a	8b e5		 mov	 esp, ebp
  0029c	5d		 pop	 ebp
  0029d	c2 08 00	 ret	 8
$LN40@CGInsertEr:
  002a0	00 00 00 00	 DD	 $LN12@CGInsertEr
  002a4	00 00 00 00	 DD	 $LN13@CGInsertEr
  002a8	00 00 00 00	 DD	 $LN14@CGInsertEr
  002ac	00 00 00 00	 DD	 $LN15@CGInsertEr
  002b0	00 00 00 00	 DD	 $LN16@CGInsertEr
  002b4	00 00 00 00	 DD	 $LN35@CGInsertEr
$LN36@CGInsertEr:
  002b8	00		 DB	 0
  002b9	05		 DB	 5
  002ba	05		 DB	 5
  002bb	05		 DB	 5
  002bc	05		 DB	 5
  002bd	05		 DB	 5
  002be	05		 DB	 5
  002bf	05		 DB	 5
  002c0	05		 DB	 5
  002c1	05		 DB	 5
  002c2	01		 DB	 1
  002c3	05		 DB	 5
  002c4	05		 DB	 5
  002c5	05		 DB	 5
  002c6	05		 DB	 5
  002c7	05		 DB	 5
  002c8	05		 DB	 5
  002c9	05		 DB	 5
  002ca	05		 DB	 5
  002cb	05		 DB	 5
  002cc	02		 DB	 2
  002cd	05		 DB	 5
  002ce	05		 DB	 5
  002cf	05		 DB	 5
  002d0	05		 DB	 5
  002d1	05		 DB	 5
  002d2	05		 DB	 5
  002d3	05		 DB	 5
  002d4	05		 DB	 5
  002d5	05		 DB	 5
  002d6	03		 DB	 3
  002d7	05		 DB	 5
  002d8	05		 DB	 5
  002d9	05		 DB	 5
  002da	05		 DB	 5
  002db	05		 DB	 5
  002dc	05		 DB	 5
  002dd	05		 DB	 5
  002de	05		 DB	 5
  002df	05		 DB	 5
  002e0	04		 DB	 4
?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z ENDP ; CElementalSystem::CGInsertErtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?BuildErtelInfo@CElementalSystem@@QAEXPAUPMSG_ERTELINFO@@PAUERTEL_USER@@HH@Z
_TEXT	SEGMENT
_lpErtelInfo$ = 8					; size = 4
_Ertel$ = 12						; size = 4
_Id$ = 16						; size = 4
_Type$ = 20						; size = 4
?BuildErtelInfo@CElementalSystem@@QAEXPAUPMSG_ERTELINFO@@PAUERTEL_USER@@HH@Z PROC ; CElementalSystem::BuildErtelInfo, COMDAT
; _this$ = ecx

; 2235 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2236 : 	lpErtelInfo->btType = Type;
; 2237 : 	lpErtelInfo->btId = Id;
; 2238 : 	lpErtelInfo->btIndex = 12;
; 2239 : 	lpErtelInfo->wNumber = 221 + (Ertel->btType-1)*10;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _Ertel$[ebp]
  00006	8a 45 14	 mov	 al, BYTE PTR _Type$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _lpErtelInfo$[ebp]
  0000d	88 06		 mov	 BYTE PTR [esi], al
  0000f	8a 45 10	 mov	 al, BYTE PTR _Id$[ebp]
  00012	88 46 01	 mov	 BYTE PTR [esi+1], al
  00015	c6 46 03 0c	 mov	 BYTE PTR [esi+3], 12	; 0000000cH
  00019	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0001c	66 48		 dec	 ax
  0001e	66 8b c8	 mov	 cx, ax
  00021	66 c1 e0 02	 shl	 ax, 2
  00025	66 03 c8	 add	 cx, ax
  00028	b8 dd 00 00 00	 mov	 eax, 221		; 000000ddH
  0002d	66 03 c9	 add	 cx, cx
  00030	66 03 c8	 add	 cx, ax
  00033	66 89 4e 04	 mov	 WORD PTR [esi+4], cx

; 2240 : 	lpErtelInfo->btAttribute = Ertel->btAttribute;

  00037	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0003b	88 46 02	 mov	 BYTE PTR [esi+2], al

; 2241 : 
; 2242 : 	lpErtelInfo->Option[0].OptionID = Ertel->Option[0];

  0003e	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00042	88 46 07	 mov	 BYTE PTR [esi+7], al

; 2243 : 	lpErtelInfo->Option[0].OptionLevel = Ertel->Level[0];

  00045	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  00049	88 46 08	 mov	 BYTE PTR [esi+8], al

; 2244 : 
; 2245 : 	lpErtelInfo->Option[1].OptionID = Ertel->Option[1];

  0004c	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00050	88 46 09	 mov	 BYTE PTR [esi+9], al

; 2246 : 	lpErtelInfo->Option[1].OptionLevel = Ertel->Level[1];

  00053	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  00057	88 46 0a	 mov	 BYTE PTR [esi+10], al

; 2247 : 
; 2248 : 	lpErtelInfo->Option[2].OptionID = Ertel->Option[2];

  0005a	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0005e	88 46 0b	 mov	 BYTE PTR [esi+11], al

; 2249 : 	lpErtelInfo->Option[2].OptionLevel = Ertel->Level[2];

  00061	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  00065	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 2250 : 
; 2251 : 	lpErtelInfo->Option[3].OptionID = Ertel->Option[3];

  00068	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  0006c	88 46 0d	 mov	 BYTE PTR [esi+13], al

; 2252 : 	lpErtelInfo->Option[3].OptionLevel = Ertel->Level[3];

  0006f	0f b6 42 0a	 movzx	 eax, BYTE PTR [edx+10]
  00073	88 46 0e	 mov	 BYTE PTR [esi+14], al

; 2253 : 
; 2254 : 	lpErtelInfo->Option[4].OptionID = Ertel->Option[4];

  00076	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  0007a	88 46 0f	 mov	 BYTE PTR [esi+15], al

; 2255 : 	lpErtelInfo->Option[4].OptionLevel = Ertel->Level[4];

  0007d	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  00081	88 46 10	 mov	 BYTE PTR [esi+16], al
  00084	5e		 pop	 esi

; 2256 : }

  00085	5d		 pop	 ebp
  00086	c2 10 00	 ret	 16			; 00000010H
?BuildErtelInfo@CElementalSystem@@QAEXPAUPMSG_ERTELINFO@@PAUERTEL_USER@@HH@Z ENDP ; CElementalSystem::BuildErtelInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?SendTradeElementalItem@CElementalSystem@@QAEXHH@Z
_TEXT	SEGMENT
_this$1$ = -2068					; size = 4
tv288 = -2064						; size = 4
_lOfs$1$ = -2060					; size = 4
_count$1$ = -2056					; size = 4
_cBUFFER$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
?SendTradeElementalItem@CElementalSystem@@QAEXHH@Z PROC	; CElementalSystem::SendTradeElementalItem, COMDAT
; _this$ = ecx

; 2351 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	68 00 08 00 00	 push	 2048			; 00000800H
  0001b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00021	8b f1		 mov	 esi, ecx
  00023	6a 00		 push	 0
  00025	50		 push	 eax
  00026	89 b5 ec f7 ff
	ff		 mov	 DWORD PTR _this$1$[ebp], esi
  0002c	e8 00 00 00 00	 call	 _memset

; 2352 : 	BYTE cBUFFER[2048] = {0};
; 2353 : 
; 2354 : 	PMSG_SEND_ERTELINFO* lpMsg = (PMSG_SEND_ERTELINFO*)&cBUFFER[0];
; 2355 : 	PMSG_ERTELINFO* lpMsgBody = (PMSG_ERTELINFO*)&cBUFFER[sizeof(PMSG_SEND_ERTELINFO)];
; 2356 : 
; 2357 : 	PHeadSubSetW((LPBYTE)lpMsg,0xEE,0x01,sizeof(PMSG_SEND_ERTELINFO));

  00031	6a 08		 push	 8
  00033	6a 01		 push	 1
  00035	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  0003b	68 ee 00 00 00	 push	 238			; 000000eeH
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?PHeadSubSetW@@YAXPAEEEH@Z ; PHeadSubSetW

; 2358 : 
; 2359 : 	int lOfs = sizeof(PMSG_SEND_ERTELINFO);
; 2360 : 	ERTEL_USER* lpErtelList = NULL;
; 2361 : 
; 2362 : 	LPOBJ lpTradeObj = &gObj[aSourceIndex];

  00046	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aSourceIndex$[ebp], 10048

; 2363 : 
; 2364 : 	int count = 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	b9 08 00 00 00	 mov	 ecx, 8
  00054	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _count$1$[ebp], eax
  0005a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005d	89 8d f4 f7 ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  00063	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	33 ff		 xor	 edi, edi
  0006b	0f 1f 44 00 00	 npad	 5
$LL4@SendTradeE:

; 2367 : 		if( !IsPentagram(lpTradeObj->Trade[n].m_Type) )

  00070	8b 83 e8 11 00
	00		 mov	 eax, DWORD PTR [ebx+4584]
  00076	8b ce		 mov	 ecx, esi
  00078	0f bf 44 38 06	 movsx	 eax, WORD PTR [eax+edi+6]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?IsPentagram@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsPentagram
  00083	85 c0		 test	 eax, eax
  00085	0f 84 83 00 00
	00		 je	 $LN2@SendTradeE

; 2368 : 			continue;
; 2369 : 
; 2370 : 		for(int i = 0; i < 5; i++)	{

  0008b	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _count$1$[ebp]
  00091	8d 95 04 f8 ff
	ff		 lea	 edx, DWORD PTR _cBUFFER$[ebp+8]
  00097	c1 e0 04	 shl	 eax, 4
  0009a	33 f6		 xor	 esi, esi
  0009c	03 d0		 add	 edx, eax
  0009e	03 95 f8 f7 ff
	ff		 add	 edx, DWORD PTR _count$1$[ebp]
  000a4	89 95 f0 f7 ff
	ff		 mov	 DWORD PTR tv288[ebp], edx
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL7@SendTradeE:

; 2371 : 			if( lpTradeObj->Trade[n].m_SocketOption[i] == (BYTE)-1 ||

  000b0	8b 83 e8 11 00
	00		 mov	 eax, DWORD PTR [ebx+4584]
  000b6	03 c7		 add	 eax, edi
  000b8	8a 84 30 c8 00
	00 00		 mov	 al, BYTE PTR [eax+esi+200]
  000bf	3c ff		 cmp	 al, 255			; 000000ffH
  000c1	74 3f		 je	 SHORT $LN5@SendTradeE
  000c3	3c fe		 cmp	 al, 254			; 000000feH
  000c5	74 3b		 je	 SHORT $LN5@SendTradeE

; 2372 : 				lpTradeObj->Trade[n].m_SocketOption[i] == (BYTE)-2 )
; 2373 : 				continue;
; 2374 : 
; 2375 : 			int ErtelID = lpTradeObj->Trade[n].m_SocketOption[i];

  000c7	0f b6 c0	 movzx	 eax, al

; 2376 : 
; 2377 : 			BuildErtelInfo(&lpMsgBody[count],&lpTradeObj->pErtelList1[ErtelID],ErtelID,ERTEL_TRADE);

  000ca	6a 02		 push	 2
  000cc	50		 push	 eax
  000cd	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000d0	8b 83 dc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9948]
  000d6	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000d9	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _this$1$[ebp]
  000df	50		 push	 eax
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 ?BuildErtelInfo@CElementalSystem@@QAEXPAUPMSG_ERTELINFO@@PAUERTEL_USER@@HH@Z ; CElementalSystem::BuildErtelInfo

; 2378 : 			count++;

  000e6	8b 95 f0 f7 ff
	ff		 mov	 edx, DWORD PTR tv288[ebp]
  000ec	ff 85 f8 f7 ff
	ff		 inc	 DWORD PTR _count$1$[ebp]
  000f2	83 c2 11	 add	 edx, 17			; 00000011H

; 2379 : 			lOfs += sizeof(PMSG_ERTELINFO);

  000f5	83 85 f4 f7 ff
	ff 11		 add	 DWORD PTR _lOfs$1$[ebp], 17 ; 00000011H
  000fc	89 95 f0 f7 ff
	ff		 mov	 DWORD PTR tv288[ebp], edx
$LN5@SendTradeE:

; 2368 : 			continue;
; 2369 : 
; 2370 : 		for(int i = 0; i < 5; i++)	{

  00102	46		 inc	 esi
  00103	83 fe 05	 cmp	 esi, 5
  00106	7c a8		 jl	 SHORT $LL7@SendTradeE
  00108	8b b5 ec f7 ff
	ff		 mov	 esi, DWORD PTR _this$1$[ebp]
$LN2@SendTradeE:

; 2365 : 
; 2366 : 	for(int n = 0; n < TRADE_BOX_SIZE; n++)	{

  0010e	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00114	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  0011a	0f 8c 50 ff ff
	ff		 jl	 $LL4@SendTradeE

; 2380 : 		}
; 2381 : 	}
; 2382 : 
; 2383 : 	lpMsg->btType = ERTEL_TRADE;
; 2384 : 	lpMsg->btCount = count;
; 2385 : 	lpMsg->h.sizeL = SET_NUMBERL(lOfs);

  00120	8b 8d f4 f7 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  00126	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _count$1$[ebp]
  0012c	88 85 02 f8 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+6], al

; 2386 : 	lpMsg->h.sizeH = SET_NUMBERH(lOfs);

  00132	8b c1		 mov	 eax, ecx
  00134	c1 e8 08	 shr	 eax, 8
  00137	88 85 fd f7 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], al

; 2387 : 	lpMsg->btResult = TRUE;
; 2388 : 
; 2389 : 	DataSend(aTargetIndex,(LPBYTE)lpMsg,lOfs);

  0013d	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00143	51		 push	 ecx
  00144	50		 push	 eax
  00145	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00148	c6 85 03 f8 ff
	ff 02		 mov	 BYTE PTR _cBUFFER$[ebp+7], 2
  0014f	88 8d fe f7 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], cl
  00155	c6 85 01 f8 ff
	ff 01		 mov	 BYTE PTR _cBUFFER$[ebp+5], 1
  0015c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2390 : }

  00161	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH
  00167	33 cd		 xor	 ecx, ebp
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c2 08 00	 ret	 8
?SendTradeElementalItem@CElementalSystem@@QAEXHH@Z ENDP	; CElementalSystem::SendTradeElementalItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?SendShopElementalItem@CElementalSystem@@QAEXHH@Z
_TEXT	SEGMENT
_this$1$ = -2068					; size = 4
tv290 = -2064						; size = 4
_lOfs$1$ = -2060					; size = 4
_count$1$ = -2056					; size = 4
_cBUFFER$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
?SendShopElementalItem@CElementalSystem@@QAEXHH@Z PROC	; CElementalSystem::SendShopElementalItem, COMDAT
; _this$ = ecx

; 2306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	68 00 08 00 00	 push	 2048			; 00000800H
  0001b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00021	8b f1		 mov	 esi, ecx
  00023	6a 00		 push	 0
  00025	50		 push	 eax
  00026	89 b5 ec f7 ff
	ff		 mov	 DWORD PTR _this$1$[ebp], esi
  0002c	e8 00 00 00 00	 call	 _memset

; 2307 : 	BYTE cBUFFER[2048] = {0};
; 2308 : 
; 2309 : 	PMSG_SEND_ERTELINFO* lpMsg = (PMSG_SEND_ERTELINFO*)&cBUFFER[0];
; 2310 : 	PMSG_ERTELINFO* lpMsgBody = (PMSG_ERTELINFO*)&cBUFFER[sizeof(PMSG_SEND_ERTELINFO)];
; 2311 : 
; 2312 : 	PHeadSubSetW((LPBYTE)lpMsg,0xEE,0x01,sizeof(PMSG_SEND_ERTELINFO));

  00031	6a 08		 push	 8
  00033	6a 01		 push	 1
  00035	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  0003b	68 ee 00 00 00	 push	 238			; 000000eeH
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?PHeadSubSetW@@YAXPAEEEH@Z ; PHeadSubSetW

; 2313 : 
; 2314 : 	int lOfs = sizeof(PMSG_SEND_ERTELINFO);
; 2315 : 	ERTEL_USER* lpErtelList = NULL;
; 2316 : 
; 2317 : 	LPOBJ lpShopObj = &gObj[aSourceIndex];

  00046	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aSourceIndex$[ebp], 10048
  0004d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00050	b9 08 00 00 00	 mov	 ecx, 8
  00055	bf f0 a8 00 00	 mov	 edi, 43248		; 0000a8f0H
  0005a	89 8d f4 f7 ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  00060	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2318 : 
; 2319 : 	int count = 0;

  00066	33 c0		 xor	 eax, eax
  00068	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _count$1$[ebp], eax
  0006e	66 90		 npad	 2
$LL4@SendShopEl:

; 2322 : 		if( !IsPentagram(lpShopObj->pInventory[n].m_Type) )

  00070	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00076	8b ce		 mov	 ecx, esi
  00078	0f bf 44 38 06	 movsx	 eax, WORD PTR [eax+edi+6]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?IsPentagram@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsPentagram
  00083	85 c0		 test	 eax, eax
  00085	0f 84 83 00 00
	00		 je	 $LN2@SendShopEl

; 2323 : 			continue;
; 2324 : 
; 2325 : 		for(int i = 0; i < 5; i++)	{

  0008b	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _count$1$[ebp]
  00091	8d 95 04 f8 ff
	ff		 lea	 edx, DWORD PTR _cBUFFER$[ebp+8]
  00097	c1 e0 04	 shl	 eax, 4
  0009a	33 f6		 xor	 esi, esi
  0009c	03 d0		 add	 edx, eax
  0009e	03 95 f8 f7 ff
	ff		 add	 edx, DWORD PTR _count$1$[ebp]
  000a4	89 95 f0 f7 ff
	ff		 mov	 DWORD PTR tv290[ebp], edx
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL7@SendShopEl:

; 2326 : 			if( lpShopObj->pInventory[n].m_SocketOption[i] == (BYTE)-1 ||

  000b0	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  000b6	03 c7		 add	 eax, edi
  000b8	8a 84 30 c8 00
	00 00		 mov	 al, BYTE PTR [eax+esi+200]
  000bf	3c ff		 cmp	 al, 255			; 000000ffH
  000c1	74 3f		 je	 SHORT $LN5@SendShopEl
  000c3	3c fe		 cmp	 al, 254			; 000000feH
  000c5	74 3b		 je	 SHORT $LN5@SendShopEl

; 2327 : 				lpShopObj->pInventory[n].m_SocketOption[i] == (BYTE)-2 )
; 2328 : 				continue;
; 2329 : 
; 2330 : 			int ErtelID = lpShopObj->pInventory[n].m_SocketOption[i];

  000c7	0f b6 c0	 movzx	 eax, al

; 2331 : 
; 2332 : 			BuildErtelInfo(&lpMsgBody[count],&lpShopObj->pErtelList1[ErtelID],ErtelID,ERTEL_STORE);

  000ca	6a 03		 push	 3
  000cc	50		 push	 eax
  000cd	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000d0	8b 83 dc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9948]
  000d6	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000d9	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _this$1$[ebp]
  000df	50		 push	 eax
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 ?BuildErtelInfo@CElementalSystem@@QAEXPAUPMSG_ERTELINFO@@PAUERTEL_USER@@HH@Z ; CElementalSystem::BuildErtelInfo

; 2333 : 			count++;

  000e6	8b 95 f0 f7 ff
	ff		 mov	 edx, DWORD PTR tv290[ebp]
  000ec	ff 85 f8 f7 ff
	ff		 inc	 DWORD PTR _count$1$[ebp]
  000f2	83 c2 11	 add	 edx, 17			; 00000011H

; 2334 : 			lOfs += sizeof(PMSG_ERTELINFO);

  000f5	83 85 f4 f7 ff
	ff 11		 add	 DWORD PTR _lOfs$1$[ebp], 17 ; 00000011H
  000fc	89 95 f0 f7 ff
	ff		 mov	 DWORD PTR tv290[ebp], edx
$LN5@SendShopEl:

; 2323 : 			continue;
; 2324 : 
; 2325 : 		for(int i = 0; i < 5; i++)	{

  00102	46		 inc	 esi
  00103	83 fe 05	 cmp	 esi, 5
  00106	7c a8		 jl	 SHORT $LL7@SendShopEl
  00108	8b b5 ec f7 ff
	ff		 mov	 esi, DWORD PTR _this$1$[ebp]
$LN2@SendShopEl:

; 2320 : 
; 2321 : 	for(int n = MAIN_INVENTORY_SIZE; n < (INVENTORY_SIZE-1); n++)	{

  0010e	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00114	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  0011a	0f 8c 50 ff ff
	ff		 jl	 $LL4@SendShopEl

; 2335 : 		}
; 2336 : 	}
; 2337 : 
; 2338 : 	if( count > 0 )

  00120	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _count$1$[ebp]
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	85 c0		 test	 eax, eax
  0012b	7e 3e		 jle	 SHORT $LN11@SendShopEl

; 2339 : 	{
; 2340 : 		lpMsg->btType = ERTEL_STORE;
; 2341 : 		lpMsg->btCount = count;
; 2342 : 		lpMsg->h.sizeL = SET_NUMBERL(lOfs);

  0012d	8b 8d f4 f7 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  00133	88 85 02 f8 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+6], al

; 2343 : 		lpMsg->h.sizeH = SET_NUMBERH(lOfs);

  00139	8b c1		 mov	 eax, ecx
  0013b	c1 e8 08	 shr	 eax, 8
  0013e	88 85 fd f7 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], al

; 2344 : 		lpMsg->btResult = TRUE;
; 2345 : 
; 2346 : 		DataSend(aTargetIndex,(LPBYTE)lpMsg,lOfs);

  00144	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  0014a	51		 push	 ecx
  0014b	50		 push	 eax
  0014c	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0014f	c6 85 03 f8 ff
	ff 03		 mov	 BYTE PTR _cBUFFER$[ebp+7], 3
  00156	88 8d fe f7 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], cl
  0015c	c6 85 01 f8 ff
	ff 01		 mov	 BYTE PTR _cBUFFER$[ebp+5], 1
  00163	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@SendShopEl:

; 2347 : 	}
; 2348 : }

  0016b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016e	33 cd		 xor	 ecx, ebp
  00170	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 08 00	 ret	 8
?SendShopElementalItem@CElementalSystem@@QAEXHH@Z ENDP	; CElementalSystem::SendShopElementalItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$GSCopy$1$ = -2068				; size = 4
_this$1$ = -2064					; size = 4
_lOfs$1$ = -2060					; size = 4
_count$1$ = -2056					; size = 4
_cBUFFER$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_Type$ = 12						; size = 4
?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z PROC ; CElementalSystem::SendElementalItems, COMDAT
; _this$ = ecx

; 2259 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00017	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  0001d	56		 push	 esi
  0001e	68 00 08 00 00	 push	 2048			; 00000800H
  00023	6a 00		 push	 0
  00025	50		 push	 eax
  00026	89 8d f0 f7 ff
	ff		 mov	 DWORD PTR _this$1$[ebp], ecx
  0002c	89 9d ec f7 ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$1$[ebp], ebx
  00032	e8 00 00 00 00	 call	 _memset

; 2260 : 	BYTE cBUFFER[2048] = {0};
; 2261 : 
; 2262 : 	PMSG_SEND_ERTELINFO* lpMsg = (PMSG_SEND_ERTELINFO*)&cBUFFER[0];
; 2263 : 	PMSG_ERTELINFO* lpMsgBody = (PMSG_ERTELINFO*)&cBUFFER[sizeof(PMSG_SEND_ERTELINFO)];
; 2264 : 
; 2265 : 	PHeadSubSetW((LPBYTE)lpMsg,0xEE,0x01,sizeof(PMSG_SEND_ERTELINFO));

  00037	6a 08		 push	 8
  00039	6a 01		 push	 1
  0003b	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00041	68 ee 00 00 00	 push	 238			; 000000eeH
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?PHeadSubSetW@@YAXPAEEEH@Z ; PHeadSubSetW

; 2266 : 
; 2267 : 	int lOfs = sizeof(PMSG_SEND_ERTELINFO);
; 2268 : 	ERTEL_USER* lpErtelList = NULL;
; 2269 : 
; 2270 : 	if( Type == ERTEL_INVENTORY )

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  0004f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00052	b9 08 00 00 00	 mov	 ecx, 8
  00057	89 8d f4 f7 ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  0005d	85 c0		 test	 eax, eax
  0005f	75 08		 jne	 SHORT $LN5@SendElemen

; 2271 : 	{
; 2272 : 		lpErtelList = lpObj->pErtelList1;

  00061	8b b3 dc 26 00
	00		 mov	 esi, DWORD PTR [ebx+9948]
  00067	eb 0f		 jmp	 SHORT $LN7@SendElemen
$LN5@SendElemen:

; 2273 : 	}
; 2274 : 	else if( Type == ERTEL_WAREHOUSE )

  00069	83 f8 01	 cmp	 eax, 1
  0006c	0f 85 ab 00 00
	00		 jne	 $LN1@SendElemen

; 2275 : 	{
; 2276 : 		lpErtelList = lpObj->pErtelList2;

  00072	8b b3 e0 26 00
	00		 mov	 esi, DWORD PTR [ebx+9952]
$LN7@SendElemen:

; 2277 : 	}
; 2278 : 
; 2279 : 	if( lpErtelList == NULL )

  00078	85 f6		 test	 esi, esi
  0007a	0f 84 9d 00 00
	00		 je	 $LN1@SendElemen

; 2280 : 		return;
; 2281 : 
; 2282 : 	int count = 0;

  00080	33 d2		 xor	 edx, edx
  00082	8d 9d 04 f8 ff
	ff		 lea	 ebx, DWORD PTR _cBUFFER$[ebp+8]
  00088	57		 push	 edi
  00089	89 95 f8 f7 ff
	ff		 mov	 DWORD PTR _count$1$[ebp], edx

; 2283 : 
; 2284 : 	for(int i = 0; i < MAX_ERTEL; i++ )	{

  0008f	33 ff		 xor	 edi, edi
$LL4@SendElemen:

; 2285 : 		if( lpErtelList[i].btType == (BYTE)-1 )

  00091	80 3e ff	 cmp	 BYTE PTR [esi], 255	; 000000ffH
  00094	74 31		 je	 SHORT $LN2@SendElemen

; 2286 : 			continue;
; 2287 : 
; 2288 : 		BuildErtelInfo(&lpMsgBody[count],&lpErtelList[i],i,Type);

  00096	8b 8d f0 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$1$[ebp]
  0009c	50		 push	 eax
  0009d	57		 push	 edi
  0009e	56		 push	 esi
  0009f	53		 push	 ebx
  000a0	e8 00 00 00 00	 call	 ?BuildErtelInfo@CElementalSystem@@QAEXPAUPMSG_ERTELINFO@@PAUERTEL_USER@@HH@Z ; CElementalSystem::BuildErtelInfo

; 2289 : 
; 2290 : 		count++;

  000a5	8b 95 f8 f7 ff
	ff		 mov	 edx, DWORD PTR _count$1$[ebp]
  000ab	83 c3 11	 add	 ebx, 17			; 00000011H

; 2291 : 		lOfs += sizeof(PMSG_ERTELINFO);

  000ae	8b 8d f4 f7 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  000b4	42		 inc	 edx
  000b5	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  000b8	83 c1 11	 add	 ecx, 17			; 00000011H
  000bb	89 95 f8 f7 ff
	ff		 mov	 DWORD PTR _count$1$[ebp], edx
  000c1	89 8d f4 f7 ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
$LN2@SendElemen:

; 2283 : 
; 2284 : 	for(int i = 0; i < MAX_ERTEL; i++ )	{

  000c7	47		 inc	 edi
  000c8	83 c6 0c	 add	 esi, 12			; 0000000cH
  000cb	83 ff 64	 cmp	 edi, 100		; 00000064H
  000ce	7c c1		 jl	 SHORT $LL4@SendElemen

; 2292 : 	}
; 2293 : 
; 2294 : 	lpMsg->btType = Type;

  000d0	88 85 03 f8 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+7], al

; 2295 : 	lpMsg->btCount = count;
; 2296 : 	lpMsg->h.sizeL = SET_NUMBERL(lOfs);
; 2297 : 	lpMsg->h.sizeH = SET_NUMBERH(lOfs);
; 2298 : 
; 2299 : 	if( count > 0 )

  000d6	be 01 00 00 00	 mov	 esi, 1
  000db	8b c1		 mov	 eax, ecx
  000dd	88 95 02 f8 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+6], dl
  000e3	c1 e8 08	 shr	 eax, 8
  000e6	85 d2		 test	 edx, edx
  000e8	88 85 fd f7 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], al
  000ee	0f b6 85 01 f8
	ff ff		 movzx	 eax, BYTE PTR _cBUFFER$[ebp+5]
  000f5	0f 4f c6	 cmovg	 eax, esi
  000f8	88 8d fe f7 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], cl
  000fe	88 85 01 f8 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+5], al

; 2300 : 		lpMsg->btResult = TRUE;
; 2301 : 
; 2302 : 	DataSend(lpObj->m_Index,(LPBYTE)lpMsg,lOfs);

  00104	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  0010a	51		 push	 ecx
  0010b	50		 push	 eax
  0010c	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _lpObj$GSCopy$1$[ebp]
  00112	ff 30		 push	 DWORD PTR [eax]
  00114	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	5f		 pop	 edi
$LN1@SendElemen:

; 2303 : }

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00120	5e		 pop	 esi
  00121	33 cd		 xor	 ecx, ebp
  00123	5b		 pop	 ebx
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 08 00	 ret	 8
?SendElementalItems@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ENDP ; CElementalSystem::SendElementalItems
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetAttackDamage@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0HPAVCMagicInf@@EE@Z
_TEXT	SEGMENT
_ElementalDamage$ = -48					; size = 4
_sub$ = -44						; size = 4
tv344 = -40						; size = 4
_AddDamageMax$ = -36					; size = 4
_AddDamageMin$1$ = -32					; size = 4
_cDamage$ = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_targetdefense$ = 16					; size = 4
_lpMagic$ = 20						; size = 4
_btAttackElement$ = 24					; size = 1
_IncreaseDamage$ = 28					; size = 4
_btDefenseElement$ = 28					; size = 1
?GetAttackDamage@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0HPAVCMagicInf@@EE@Z PROC ; CElementalSystem::GetAttackDamage, COMDAT
; _this$ = ecx

; 1221 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetAttackDamage@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0HPAVCMagicInf@@EE@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 20	 sub	 esp, 32			; 00000020H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	8b f9		 mov	 edi, ecx

; 1222 : 	int sub = 0;

  00035	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _sub$[ebp], 0

; 1223 : 	BYTE cDamage = 0;

  0003c	32 c0		 xor	 al, al
  0003e	89 45 d8	 mov	 DWORD PTR tv344[ebp], eax
  00041	88 45 e7	 mov	 BYTE PTR _cDamage$[ebp], al

; 1224 : 	int ElementalDamage = 0;

  00044	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ElementalDamage$[ebp], 0

; 1225 : 	int AddDamageMin = 0;

  0004b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _AddDamageMin$1$[ebp], 0

; 1226 : 	int AddDamageMax = 0;

  00052	33 f6		 xor	 esi, esi
  00054	89 75 dc	 mov	 DWORD PTR _AddDamageMax$[ebp], esi

; 1227 : 	int IncreaseDamage = (btDefenseElement==ELEMENT_NONE) ? 120 : m_DamageTable[btAttackElement][btDefenseElement];

  00057	8a 4d 1c	 mov	 cl, BYTE PTR _btDefenseElement$[ebp]
  0005a	84 c9		 test	 cl, cl
  0005c	75 05		 jne	 SHORT $LN26@GetAttackD
  0005e	8d 7e 78	 lea	 edi, DWORD PTR [esi+120]
  00061	eb 18		 jmp	 SHORT $LN27@GetAttackD
$LN26@GetAttackD:
  00063	0f b6 55 18	 movzx	 edx, BYTE PTR _btAttackElement$[ebp]
  00067	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  0006a	0f b6 c9	 movzx	 ecx, cl
  0006d	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00070	0f b6 bc 01 4c
	03 00 00	 movzx	 edi, BYTE PTR [ecx+eax+844]
  00078	8a 4d 1c	 mov	 cl, BYTE PTR _btDefenseElement$[ebp]
$LN27@GetAttackD:

; 1228 : 
; 1229 : 	if( lpObj->Type == OBJ_USER )

  0007b	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0007e	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  00082	0f 85 32 01 00
	00		 jne	 $LN17@GetAttackD

; 1230 : 	{
; 1231 : 		switch( btDefenseElement )

  00088	0f b6 c1	 movzx	 eax, cl
  0008b	48		 dec	 eax
  0008c	83 f8 04	 cmp	 eax, 4
  0008f	77 1a		 ja	 SHORT $LN2@GetAttackD
  00091	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN41@GetAttackD[eax*4]
$LN5@GetAttackD:

; 1232 : 		{
; 1233 : 		case ELEMENT_FIRE:
; 1234 : 			IncreaseDamage += lpObj->m_ElementalOptions->m_AddFirePercDmg;

  00098	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  0009e	03 38		 add	 edi, DWORD PTR [eax]

; 1235 : 			break;
; 1236 : 		case ELEMENT_WATER:
; 1237 : 			IncreaseDamage += lpObj->m_ElementalOptions->m_AddWaterPercDmg;
; 1238 : 			break;

  000a0	eb 09		 jmp	 SHORT $LN2@GetAttackD
$LN9@GetAttackD:

; 1239 : 		case ELEMENT_EARTH:
; 1240 : 			IncreaseDamage += lpObj->m_ElementalOptions->m_AddWaterPercDmg;
; 1241 : 			break;
; 1242 : 		case ELEMENT_WIND:
; 1243 : 			IncreaseDamage += lpObj->m_ElementalOptions->m_AddWaterPercDmg;
; 1244 : 			break;
; 1245 : 		case ELEMENT_DARK:
; 1246 : 			IncreaseDamage += lpObj->m_ElementalOptions->m_AddWaterPercDmg;

  000a2	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  000a8	03 78 04	 add	 edi, DWORD PTR [eax+4]
$LN2@GetAttackD:

; 1247 : 			break;
; 1248 : 		}
; 1249 : 
; 1250 : 		if( lpTargetObj->Type == OBJ_USER )

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000ae	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  000b2	0f 85 92 00 00
	00		 jne	 $LN10@GetAttackD

; 1251 : 		{
; 1252 : 			IncreaseDamage += 30;
; 1253 : 			IncreaseDamage += lpObj->m_ElementalOptions->m_IncreasePVP;

  000b8	8b 8b fc 26 00
	00		 mov	 ecx, DWORD PTR [ebx+9980]
  000be	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  000c1	83 c0 1e	 add	 eax, 30			; 0000001eH
  000c4	03 f8		 add	 edi, eax

; 1254 : 
; 1255 : 			AddDamageMin += lpObj->m_ElementalOptions->m_AddDmgPVP;

  000c6	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  000c9	89 45 e0	 mov	 DWORD PTR _AddDamageMin$1$[ebp], eax

; 1256 : 			AddDamageMax += lpObj->m_ElementalOptions->m_AddDmgPVP;

  000cc	8b f0		 mov	 esi, eax

; 1257 : 
; 1258 : 			if( MagicDamageC.GetSkillDistance(lpMagic->m_Skill) >= 3)

  000ce	8b 45 14	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000d1	ff 70 08	 push	 DWORD PTR [eax+8]
  000d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  000d9	e8 00 00 00 00	 call	 ?GetSkillDistance@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillDistance
  000de	83 f8 03	 cmp	 eax, 3

; 1259 : 			{
; 1260 : 				AddDamageMin += lpObj->m_ElementalOptions->m_AddRangedPVP;

  000e1	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]

; 1257 : 
; 1258 : 			if( MagicDamageC.GetSkillDistance(lpMagic->m_Skill) >= 3)

  000e7	7c 05		 jl	 SHORT $LN12@GetAttackD

; 1259 : 			{
; 1260 : 				AddDamageMin += lpObj->m_ElementalOptions->m_AddRangedPVP;

  000e9	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 1261 : 				AddDamageMax += lpObj->m_ElementalOptions->m_AddRangedPVP;
; 1262 : 			}
; 1263 : 			else

  000ec	eb 03		 jmp	 SHORT $LN38@GetAttackD
$LN12@GetAttackD:

; 1264 : 			{
; 1265 : 				AddDamageMin += lpObj->m_ElementalOptions->m_AddMaleePVP;

  000ee	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
$LN38@GetAttackD:
  000f1	01 45 e0	 add	 DWORD PTR _AddDamageMin$1$[ebp], eax

; 1266 : 				AddDamageMax += lpObj->m_ElementalOptions->m_AddMaleePVP;

  000f4	03 f0		 add	 esi, eax
  000f6	89 75 dc	 mov	 DWORD PTR _AddDamageMax$[ebp], esi

; 1267 : 			}
; 1268 : 
; 1269 : 			if( rand()%100 < (lpObj->m_ElementalOptions->m_AddCritRatePVP+lpObj->m_ElementalOptions->m_AddCritRate) )

  000f9	8b b3 fc 26 00
	00		 mov	 esi, DWORD PTR [ebx+9980]
  000ff	e8 00 00 00 00	 call	 _rand
  00104	99		 cdq
  00105	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0010a	f7 f9		 idiv	 ecx
  0010c	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00112	03 46 24	 add	 eax, DWORD PTR [esi+36]
  00115	8b 4d d8	 mov	 ecx, DWORD PTR tv344[ebp]
  00118	0f b6 c9	 movzx	 ecx, cl
  0011b	be 01 00 00 00	 mov	 esi, 1
  00120	3b d0		 cmp	 edx, eax
  00122	0f 4c ce	 cmovl	 ecx, esi
  00125	89 4d d8	 mov	 DWORD PTR tv344[ebp], ecx
  00128	88 4d e7	 mov	 BYTE PTR _cDamage$[ebp], cl

; 1270 : 			{
; 1271 : 				cDamage = 1;
; 1272 : 			}
; 1273 : 
; 1274 : 			if( rand()%100 < lpObj->m_ElementalOptions->m_ExcRatePVP )

  0012b	e8 00 00 00 00	 call	 _rand
  00130	99		 cdq
  00131	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00136	f7 f9		 idiv	 ecx
  00138	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]

; 1277 : 			}
; 1278 : 		}
; 1279 : 		else

  0013e	8b 75 dc	 mov	 esi, DWORD PTR _AddDamageMax$[ebp]

; 1270 : 			{
; 1271 : 				cDamage = 1;
; 1272 : 			}
; 1273 : 
; 1274 : 			if( rand()%100 < lpObj->m_ElementalOptions->m_ExcRatePVP )

  00141	3b 50 6c	 cmp	 edx, DWORD PTR [eax+108]
  00144	7d 74		 jge	 SHORT $LN17@GetAttackD

; 1275 : 			{
; 1276 : 				cDamage = 2;

  00146	b0 02		 mov	 al, 2

; 1277 : 			}
; 1278 : 		}
; 1279 : 		else

  00148	eb 6a		 jmp	 SHORT $LN40@GetAttackD
$LN10@GetAttackD:

; 1280 : 		{
; 1281 : 			IncreaseDamage += lpObj->m_ElementalOptions->m_IncreasePVE;

  0014a	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  00150	03 78 64	 add	 edi, DWORD PTR [eax+100]

; 1282 : 
; 1283 : 			AddDamageMin += lpObj->m_ElementalOptions->m_AddDmgPVE;

  00153	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00156	89 45 e0	 mov	 DWORD PTR _AddDamageMin$1$[ebp], eax

; 1284 : 			AddDamageMax += lpObj->m_ElementalOptions->m_AddDmgPVE;

  00159	89 45 dc	 mov	 DWORD PTR _AddDamageMax$[ebp], eax

; 1285 : 
; 1286 : 			if( rand()%100 < (lpObj->m_ElementalOptions->m_AddCritRatePVE+lpObj->m_ElementalOptions->m_AddCritRate) )

  0015c	8b b3 fc 26 00
	00		 mov	 esi, DWORD PTR [ebx+9980]
  00162	e8 00 00 00 00	 call	 _rand
  00167	99		 cdq
  00168	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0016d	f7 f9		 idiv	 ecx
  0016f	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00175	03 46 28	 add	 eax, DWORD PTR [esi+40]
  00178	8b 4d d8	 mov	 ecx, DWORD PTR tv344[ebp]
  0017b	0f b6 d9	 movzx	 ebx, cl
  0017e	b9 01 00 00 00	 mov	 ecx, 1
  00183	3b d0		 cmp	 edx, eax
  00185	0f 4c d9	 cmovl	 ebx, ecx

; 1287 : 			{
; 1288 : 				cDamage = 1;
; 1289 : 			}
; 1290 : 
; 1291 : 			if( rand()%100 < lpObj->m_ElementalOptions->m_ExcRatePVE )

  00188	e8 00 00 00 00	 call	 _rand
  0018d	99		 cdq
  0018e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00193	f7 f9		 idiv	 ecx
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00198	8b 81 fc 26 00
	00		 mov	 eax, DWORD PTR [ecx+9980]
  0019e	0f b6 cb	 movzx	 ecx, bl
  001a1	be 02 00 00 00	 mov	 esi, 2
  001a6	3b 50 70	 cmp	 edx, DWORD PTR [eax+112]
  001a9	0f 4c ce	 cmovl	 ecx, esi
  001ac	8a c1		 mov	 al, cl
  001ae	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  001b1	8b 75 dc	 mov	 esi, DWORD PTR _AddDamageMax$[ebp]
$LN40@GetAttackD:
  001b4	88 45 e7	 mov	 BYTE PTR _cDamage$[ebp], al
  001b7	89 45 d8	 mov	 DWORD PTR tv344[ebp], eax
$LN17@GetAttackD:

; 1292 : 			{
; 1293 : 				cDamage = 2;
; 1294 : 			}
; 1295 : 		}
; 1296 : 	}
; 1297 : 
; 1298 : 	if( lpTargetObj->Type == OBJ_USER )

  001ba	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001bd	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  001c1	75 14		 jne	 SHORT $LN20@GetAttackD

; 1301 : 		{
; 1302 : 			IncreaseDamage -= lpTargetObj->m_ElementalOptions->m_DecreasePVP;

  001c3	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]

; 1299 : 	{
; 1300 : 		if( lpObj->Type == OBJ_USER )

  001c9	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  001cd	75 05		 jne	 SHORT $LN19@GetAttackD

; 1301 : 		{
; 1302 : 			IncreaseDamage -= lpTargetObj->m_ElementalOptions->m_DecreasePVP;

  001cf	2b 78 50	 sub	 edi, DWORD PTR [eax+80]

; 1303 : 		}
; 1304 : 		else

  001d2	eb 03		 jmp	 SHORT $LN20@GetAttackD
$LN19@GetAttackD:

; 1305 : 		{
; 1306 : 			IncreaseDamage -= lpTargetObj->m_ElementalOptions->m_DecreasePVE;

  001d4	2b 78 54	 sub	 edi, DWORD PTR [eax+84]
$LN20@GetAttackD:

; 1307 : 		}
; 1308 : 	}
; 1309 : 
; 1310 : 	if( IncreaseDamage < 0 )

  001d7	33 c0		 xor	 eax, eax
  001d9	85 ff		 test	 edi, edi
  001db	0f 48 f8	 cmovs	 edi, eax
  001de	89 7d 1c	 mov	 DWORD PTR _IncreaseDamage$[ebp], edi

; 1311 : 		IncreaseDamage = 0;
; 1312 : 
; 1313 : 	__try

  001e1	89 45 fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], eax

; 1314 : 	{
; 1315 : 
; 1316 : 		//MsgOutput(lpObj->m_Index,"Base: [%d~%d]",lpObj->m_ElementalDamageMin,lpObj->m_ElementalDamageMax);
; 1317 : 		//MsgOutput(lpObj->m_Index,"Increase dmg: %d%%",IncreaseDamage);
; 1318 : 		//MsgOutput(lpObj->m_Index,"Add: [%d~%d]",AddDamageMin,AddDamageMax);
; 1319 : 
; 1320 : 		sub = ( lpObj->m_ElementalDamageMax + AddDamageMax) - (lpObj->m_ElementalDamageMin+ AddDamageMin);	// #formula

  001e4	8b 83 ec 26 00
	00		 mov	 eax, DWORD PTR [ebx+9964]
  001ea	2b 45 e0	 sub	 eax, DWORD PTR _AddDamageMin$1$[ebp]
  001ed	2b 83 e8 26 00
	00		 sub	 eax, DWORD PTR [ebx+9960]
  001f3	03 c6		 add	 eax, esi
  001f5	89 45 d4	 mov	 DWORD PTR _sub$[ebp], eax

; 1321 : 		ElementalDamage = (lpObj->m_ElementalDamageMin+ AddDamageMin)+(rand()%(sub+1));

  001f8	e8 00 00 00 00	 call	 _rand
  001fd	8b 4d d4	 mov	 ecx, DWORD PTR _sub$[ebp]
  00200	41		 inc	 ecx
  00201	99		 cdq
  00202	f7 f9		 idiv	 ecx
  00204	8b f2		 mov	 esi, edx
  00206	03 75 e0	 add	 esi, DWORD PTR _AddDamageMin$1$[ebp]
  00209	03 b3 e8 26 00
	00		 add	 esi, DWORD PTR [ebx+9960]
  0020f	89 75 d0	 mov	 DWORD PTR _ElementalDamage$[ebp], esi

; 1322 : 	}

  00212	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00219	8b 4d d8	 mov	 ecx, DWORD PTR tv344[ebp]
  0021c	eb 23		 jmp	 SHORT $LN39@GetAttackD
$LN29@GetAttackD:
$LN42@GetAttackD:

; 1323 : 	__except ( sub=1, 1 )

  0021e	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _sub$[ebp], 1
  00225	b8 01 00 00 00	 mov	 eax, 1
$LN36@GetAttackD:
$LN31@GetAttackD:
  0022a	c3		 ret	 0
$LN30@GetAttackD:
  0022b	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 1322 : 	}

  0022e	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00235	8a 4d e7	 mov	 cl, BYTE PTR _cDamage$[ebp]
  00238	8b 75 d0	 mov	 esi, DWORD PTR _ElementalDamage$[ebp]
  0023b	8b 7d 1c	 mov	 edi, DWORD PTR _IncreaseDamage$[ebp]
  0023e	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
$LN39@GetAttackD:
  00241	8b 45 dc	 mov	 eax, DWORD PTR _AddDamageMax$[ebp]

; 1324 : 	{
; 1325 : 
; 1326 : 	}
; 1327 : 
; 1328 : 	if( cDamage )

  00244	84 c9		 test	 cl, cl
  00246	74 26		 je	 SHORT $LN24@GetAttackD

; 1329 : 	{
; 1330 : 		ElementalDamage = lpObj->m_ElementalDamageMax + AddDamageMax;

  00248	8b b3 ec 26 00
	00		 mov	 esi, DWORD PTR [ebx+9964]
  0024e	03 f0		 add	 esi, eax

; 1331 : 
; 1332 : 		if( cDamage == 2)

  00250	80 f9 02	 cmp	 cl, 2
  00253	75 19		 jne	 SHORT $LN24@GetAttackD

; 1333 : 			ElementalDamage += ElementalDamage*20/100;

  00255	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  00258	c1 e1 02	 shl	 ecx, 2
  0025b	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00260	f7 e9		 imul	 ecx
  00262	c1 fa 05	 sar	 edx, 5
  00265	8b c2		 mov	 eax, edx
  00267	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0026a	03 c2		 add	 eax, edx
  0026c	03 f0		 add	 esi, eax
$LN24@GetAttackD:

; 1334 : 	}
; 1335 : 	//MsgOutput(lpObj->m_Index,"ElementalDamage: [%d]",ElementalDamage);
; 1336 : 
; 1337 : 	ElementalDamage = ElementalDamage*IncreaseDamage/100;

  0026e	0f af fe	 imul	 edi, esi
  00271	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00276	f7 ef		 imul	 edi
  00278	c1 fa 05	 sar	 edx, 5
  0027b	8b c2		 mov	 eax, edx
  0027d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00280	03 c2		 add	 eax, edx

; 1338 : 	ElementalDamage -= targetdefense;

  00282	2b 45 10	 sub	 eax, DWORD PTR _targetdefense$[ebp]

; 1339 : 
; 1340 : return ElementalDamage;
; 1341 : }

  00285	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00288	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0028f	59		 pop	 ecx
  00290	5f		 pop	 edi
  00291	5e		 pop	 esi
  00292	5b		 pop	 ebx
  00293	8b e5		 mov	 esp, ebp
  00295	5d		 pop	 ebp
  00296	c2 18 00	 ret	 24			; 00000018H
  00299	0f 1f 00	 npad	 3
$LN41@GetAttackD:
  0029c	00 00 00 00	 DD	 $LN5@GetAttackD
  002a0	00 00 00 00	 DD	 $LN9@GetAttackD
  002a4	00 00 00 00	 DD	 $LN9@GetAttackD
  002a8	00 00 00 00	 DD	 $LN9@GetAttackD
  002ac	00 00 00 00	 DD	 $LN9@GetAttackD
?GetAttackDamage@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0HPAVCMagicInf@@EE@Z ENDP ; CElementalSystem::GetAttackDamage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?GetTargetDefense@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@E@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_btAttackElement$ = 20					; size = 1
?GetTargetDefense@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@E@Z PROC ; CElementalSystem::GetTargetDefense, COMDAT
; _this$ = ecx

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1172 : 	int IncreaseDefense = 0;
; 1173 : 	int targetdefense = lpTargetObj->m_ElementalDefense;

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  00008	33 d2		 xor	 edx, edx

; 1174 : 
; 1175 : 	if( lpTargetObj->Type == OBJ_USER )

  0000a	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0000e	8b b7 f0 26 00
	00		 mov	 esi, DWORD PTR [edi+9968]
  00014	0f 85 8f 00 00
	00		 jne	 $LN15@GetTargetD

; 1176 : 	{
; 1177 : 		switch( btAttackElement )

  0001a	0f b6 45 14	 movzx	 eax, BYTE PTR _btAttackElement$[ebp]
  0001e	48		 dec	 eax
  0001f	83 f8 04	 cmp	 eax, 4
  00022	77 1b		 ja	 SHORT $LN2@GetTargetD
  00024	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@GetTargetD[eax*4]
$LN5@GetTargetD:

; 1178 : 		{
; 1179 : 		case ELEMENT_FIRE:
; 1180 : 			IncreaseDefense += lpTargetObj->m_ElementalOptions->m_AddFirePercDef;

  0002b	8b 87 fc 26 00
	00		 mov	 eax, DWORD PTR [edi+9980]
  00031	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]

; 1181 : 			break;
; 1182 : 		case ELEMENT_WATER:
; 1183 : 			IncreaseDefense += lpTargetObj->m_ElementalOptions->m_AddWaterPercDef;
; 1184 : 			break;

  00034	eb 09		 jmp	 SHORT $LN2@GetTargetD
$LN9@GetTargetD:

; 1185 : 		case ELEMENT_EARTH:
; 1186 : 			IncreaseDefense += lpTargetObj->m_ElementalOptions->m_AddWaterPercDef;
; 1187 : 			break;
; 1188 : 		case ELEMENT_WIND:
; 1189 : 			IncreaseDefense += lpTargetObj->m_ElementalOptions->m_AddWaterPercDef;
; 1190 : 			break;
; 1191 : 		case ELEMENT_DARK:
; 1192 : 			IncreaseDefense += lpTargetObj->m_ElementalOptions->m_AddWaterPercDef;

  00036	8b 87 fc 26 00
	00		 mov	 eax, DWORD PTR [edi+9980]
  0003c	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
$LN2@GetTargetD:

; 1193 : 			break;
; 1194 : 		}
; 1195 : 
; 1196 : 		targetdefense += targetdefense*IncreaseDefense/100;

  0003f	8b ce		 mov	 ecx, esi
  00041	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00046	0f af ca	 imul	 ecx, edx
  00049	f7 e9		 imul	 ecx
  0004b	c1 fa 05	 sar	 edx, 5
  0004e	8b c2		 mov	 eax, edx
  00050	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00053	03 c2		 add	 eax, edx
  00055	03 f0		 add	 esi, eax

; 1197 : 
; 1198 : 		if( lpObj->Type == OBJ_USER )

  00057	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005a	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  0005e	75 40		 jne	 SHORT $LN10@GetTargetD

; 1199 : 		{
; 1200 : 			targetdefense += lpTargetObj->m_ElementalOptions->m_AddDefPVP;
; 1201 : 
; 1202 : 			if( MagicDamageC.GetSkillDistance(lpMagic->m_Skill) >= 3)

  00060	8b 4d 10	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00063	8b 87 fc 26 00
	00		 mov	 eax, DWORD PTR [edi+9980]
  00069	ff 71 08	 push	 DWORD PTR [ecx+8]
  0006c	03 70 40	 add	 esi, DWORD PTR [eax+64]
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00074	e8 00 00 00 00	 call	 ?GetSkillDistance@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillDistance
  00079	83 f8 03	 cmp	 eax, 3
  0007c	7c 11		 jl	 SHORT $LN12@GetTargetD

; 1203 : 			{
; 1204 : 				targetdefense += lpTargetObj->m_ElementalOptions->m_AddRangedDefPVP;

  0007e	8b 8f fc 26 00
	00		 mov	 ecx, DWORD PTR [edi+9980]
  00084	5f		 pop	 edi
  00085	03 71 48	 add	 esi, DWORD PTR [ecx+72]

; 1214 : 		}
; 1215 : 	}
; 1216 : 
; 1217 : return targetdefense;

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1218 : }

  0008b	5d		 pop	 ebp
  0008c	c2 10 00	 ret	 16			; 00000010H
$LN12@GetTargetD:

; 1205 : 			}
; 1206 : 			else
; 1207 : 			{
; 1208 : 				targetdefense += lpTargetObj->m_ElementalOptions->m_AddMaleeDefPVP;

  0008f	8b 87 fc 26 00
	00		 mov	 eax, DWORD PTR [edi+9980]
  00095	5f		 pop	 edi
  00096	03 70 4c	 add	 esi, DWORD PTR [eax+76]

; 1214 : 		}
; 1215 : 	}
; 1216 : 
; 1217 : return targetdefense;

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi

; 1218 : }

  0009c	5d		 pop	 ebp
  0009d	c2 10 00	 ret	 16			; 00000010H
$LN10@GetTargetD:

; 1209 : 			}
; 1210 : 		}
; 1211 : 		else
; 1212 : 		{
; 1213 : 			targetdefense += lpObj->m_ElementalOptions->m_AddDefPVE;

  000a0	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  000a6	03 70 44	 add	 esi, DWORD PTR [eax+68]
$LN15@GetTargetD:

; 1214 : 		}
; 1215 : 	}
; 1216 : 
; 1217 : return targetdefense;

  000a9	5f		 pop	 edi
  000aa	8b c6		 mov	 eax, esi
  000ac	5e		 pop	 esi

; 1218 : }

  000ad	5d		 pop	 ebp
  000ae	c2 10 00	 ret	 16			; 00000010H
  000b1	0f 1f 00	 npad	 3
$LN18@GetTargetD:
  000b4	00 00 00 00	 DD	 $LN5@GetTargetD
  000b8	00 00 00 00	 DD	 $LN9@GetTargetD
  000bc	00 00 00 00	 DD	 $LN9@GetTargetD
  000c0	00 00 00 00	 DD	 $LN9@GetTargetD
  000c4	00 00 00 00	 DD	 $LN9@GetTargetD
?GetTargetDefense@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@E@Z ENDP ; CElementalSystem::GetTargetDefense
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?Attack@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@@Z
_TEXT	SEGMENT
_btTargetElement$ = -8					; size = 1
_this$1$ = -4						; size = 4
_AttackDamage$1$ = -4					; size = 4
_btElement$ = 8						; size = 1
_lpObj$ = 8						; size = 4
_skill$1$ = 12						; size = 4
_lpTargetObj$ = 12					; size = 4
_lpCallObj$1$ = 16					; size = 4
_lpMagic$ = 16						; size = 4
?Attack@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@@Z PROC ; CElementalSystem::Attack, COMDAT
; _this$ = ecx

; 1344 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1345 : 	LPOBJ lpCallObj;
; 1346 : 	LPOBJ lpCallTargetObj;
; 1347 : 
; 1348 : 	BYTE btElement = lpObj->m_btAttribute;
; 1349 : 	BYTE btTargetElement = lpTargetObj->m_btAttribute;

  00008	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00011	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  00014	8a 86 e4 26 00
	00		 mov	 al, BYTE PTR [esi+9956]
  0001a	88 45 f8	 mov	 BYTE PTR _btTargetElement$[ebp], al
  0001d	8a 8f e4 26 00
	00		 mov	 cl, BYTE PTR [edi+9956]
  00023	88 4d 08	 mov	 BYTE PTR _btElement$[ebp], cl

; 1350 : 
; 1351 : 	if( btElement == ELEMENT_NONE )

  00026	84 c9		 test	 cl, cl
  00028	74 3d		 je	 SHORT $LN8@Attack

; 1352 : 		return false;
; 1353 : 
; 1354 : 	if( !lpTargetObj->Live )

  0002a	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  0002e	74 37		 je	 SHORT $LN8@Attack

; 1355 : 		return false;
; 1356 : 
; 1357 : 	if( lpObj->Type == OBJ_USER && lpMagic == NULL )

  00030	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00034	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00037	75 04		 jne	 SHORT $LN6@Attack
  00039	85 c0		 test	 eax, eax
  0003b	74 2a		 je	 SHORT $LN8@Attack
$LN6@Attack:

; 1358 : 		return false;
; 1359 : 	
; 1360 : 	int skill = 0;

  0003d	33 c9		 xor	 ecx, ecx
  0003f	89 4d 0c	 mov	 DWORD PTR _skill$1$[ebp], ecx

; 1361 : 
; 1362 : 	if( lpMagic )

  00042	85 c0		 test	 eax, eax
  00044	74 06		 je	 SHORT $LN7@Attack

; 1363 : 	{
; 1364 : 		skill = lpMagic->m_Skill;

  00046	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00049	89 4d 0c	 mov	 DWORD PTR _skill$1$[ebp], ecx
$LN7@Attack:

; 1365 : 	}
; 1366 : 
; 1367 : 	switch(skill)

  0004c	8d 81 25 ff ff
	ff		 lea	 eax, DWORD PTR [ecx-219]
  00052	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00057	77 19		 ja	 SHORT $LN9@Attack
  00059	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN157@Attack[eax]
  00060	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN169@Attack[eax*4]
$LN8@Attack:
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 1368 : 	{
; 1369 : 	case AT_SKILL_SLEEP:
; 1370 : 	case AT_SKILL_WEAKNESS:
; 1371 : 	case AT_SKILL_INNOVATION:
; 1372 : 	case AT_MSKILL_SUM_SLEEP1:
; 1373 : 	case AT_MSKILL_SUM_INNOVATION1:
; 1374 : 	case AT_MSKILL_SUM_WEAKNESS1:
; 1375 : 		return false;

  00069	33 c0		 xor	 eax, eax
  0006b	5b		 pop	 ebx

; 1885 : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 0c 00	 ret	 12			; 0000000cH
$LN9@Attack:

; 1376 : 	default:	break;
; 1377 : 	}
; 1378 : 
; 1379 : 	if ( (lpTargetObj->Authority&2) == 2 )

  00072	8b 86 bc 01 00
	00		 mov	 eax, DWORD PTR [esi+444]
  00078	a8 02		 test	 al, 2
  0007a	75 eb		 jne	 SHORT $LN8@Attack

; 1380 : 		return FALSE;
; 1381 : 
; 1382 : 	if ( (lpObj->Authority&32) == 32 ||

  0007c	f6 87 bc 01 00
	00 20		 test	 BYTE PTR [edi+444], 32	; 00000020H
  00083	75 04		 jne	 SHORT $LN12@Attack
  00085	a8 20		 test	 al, 32			; 00000020H
  00087	74 0f		 je	 SHORT $LN13@Attack
$LN12@Attack:

; 1383 : 		 (lpTargetObj->Authority&32) == 32 )
; 1384 : 	{
; 1385 : 		if( gObjCheckUsedBuffEffect(lpObj,BUFF_INVISIBILITY) == TRUE)

  00089	6a 12		 push	 18			; 00000012H
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00091	83 c4 08	 add	 esp, 8
  00094	3c 01		 cmp	 al, 1
  00096	74 cf		 je	 SHORT $LN8@Attack
$LN13@Attack:

; 1386 : 		{
; 1387 : 			return false;
; 1388 : 		}
; 1389 : 	}
; 1390 : 
; 1391 : 	if ( lpObj->MapNumber != lpTargetObj->MapNumber )

  00098	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  0009e	3a 86 23 01 00
	00		 cmp	 al, BYTE PTR [esi+291]
  000a4	75 c1		 jne	 SHORT $LN8@Attack

; 1392 : 	{
; 1393 : 		return false;
; 1394 : 	}
; 1395 : 
; 1396 : #if (__GENS_SYSTEM__ == 1)
; 1397 : 	if (gGensSystem.GetFriendlyFire() && gGensSystem.GensMap(lpObj->MapNumber)) {

  000a6	80 3d 38 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+56, 0
  000ad	74 2c		 je	 SHORT $LN16@Attack
  000af	0f b6 c0	 movzx	 eax, al
  000b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?GensMap@CGensSystem@@QAEHH@Z ; CGensSystem::GensMap
  000bd	85 c0		 test	 eax, eax
  000bf	74 1a		 je	 SHORT $LN16@Attack

; 1398 : 		if (lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER
; 1399 : 			&& lpObj->m_GensInfo.btFamily == lpTargetObj->m_GensInfo.btFamily) {

  000c1	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  000c5	75 14		 jne	 SHORT $LN16@Attack
  000c7	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  000cb	75 0e		 jne	 SHORT $LN16@Attack
  000cd	8a 87 ac 26 00
	00		 mov	 al, BYTE PTR [edi+9900]
  000d3	3a 86 ac 26 00
	00		 cmp	 al, BYTE PTR [esi+9900]
  000d9	74 8c		 je	 SHORT $LN8@Attack
$LN16@Attack:

; 1400 : 			return false;
; 1401 : 		}
; 1402 : 	}
; 1403 : #endif
; 1404 : 
; 1405 : 	if ( lpObj->MapNumber == MAP_INDEX_PKFIELD && lpObj->m_iDuelUser == -1)

  000db	80 bf 23 01 00
	00 40		 cmp	 BYTE PTR [edi+291], 64	; 00000040H
  000e2	75 0d		 jne	 SHORT $LN17@Attack
  000e4	83 bf 50 12 00
	00 ff		 cmp	 DWORD PTR [edi+4688], -1
  000eb	0f 84 76 ff ff
	ff		 je	 $LN8@Attack
$LN17@Attack:

; 1406 : 	{
; 1407 : 		return false;
; 1408 : 	}
; 1409 : 
; 1410 : #if (GS_CASTLE == 1)
; 1411 : 
; 1412 : 	if(g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_READY || g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_END)

  000f1	a1 8c a8 0f 00	 mov	 eax, DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1026188
  000f6	83 f8 03	 cmp	 eax, 3
  000f9	74 05		 je	 SHORT $LN19@Attack
  000fb	83 f8 05	 cmp	 eax, 5
  000fe	75 13		 jne	 SHORT $LN20@Attack
$LN19@Attack:

; 1413 : 	{
; 1414 : 		if( ((lpTargetObj->MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE) ? TRUE : FALSE) && lpTargetObj->Type == OBJ_MONSTER)

  00100	80 be 23 01 00
	00 22		 cmp	 BYTE PTR [esi+291], 34	; 00000022H
  00107	75 0a		 jne	 SHORT $LN20@Attack
  00109	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  0010d	0f 84 54 ff ff
	ff		 je	 $LN8@Attack
$LN20@Attack:

; 1415 : 		{
; 1416 : 			return FALSE;
; 1417 : 		}
; 1418 : 	}
; 1419 : 
; 1420 : #endif
; 1421 : 
; 1422 : 	if ( lpObj->GuildNumber > 0 )

  00113	83 bf 14 06 00
	00 00		 cmp	 DWORD PTR [edi+1556], 0
  0011a	7e 5e		 jle	 SHORT $LN28@Attack

; 1423 : 	{
; 1424 : 		if ( lpObj->lpGuild )

  0011c	8b 87 18 06 00
	00		 mov	 eax, DWORD PTR [edi+1560]
  00122	85 c0		 test	 eax, eax
  00124	74 54		 je	 SHORT $LN28@Attack

; 1425 : 		{
; 1426 : 			if ( lpObj->lpGuild->WarState )

  00126	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  0012d	74 1b		 je	 SHORT $LN25@Attack

; 1427 : 			{
; 1428 : 				if ( lpObj->lpGuild->WarType == 1 )

  0012f	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1
  00136	75 12		 jne	 SHORT $LN25@Attack

; 1429 : 				{
; 1430 : 					if ( !GetBattleSoccerGoalMove(0) )

  00138	6a 00		 push	 0
  0013a	e8 00 00 00 00	 call	 ?GetBattleSoccerGoalMove@@YAHH@Z ; GetBattleSoccerGoalMove
  0013f	83 c4 04	 add	 esp, 4
  00142	85 c0		 test	 eax, eax
  00144	0f 84 42 07 00
	00		 je	 $LN131@Attack
$LN25@Attack:

; 1431 : 					{
; 1432 : 						return TRUE;
; 1433 : 					}
; 1434 : 				}
; 1435 : 			}
; 1436 : 
; 1437 : 			if ( lpObj->lpGuild->WarState )

  0014a	8b 87 18 06 00
	00		 mov	 eax, DWORD PTR [edi+1560]
  00150	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  00157	74 21		 je	 SHORT $LN28@Attack

; 1438 : 			{
; 1439 : 				if ( lpObj->lpGuild->WarType == 0 )

  00159	80 b8 92 05 00
	00 00		 cmp	 BYTE PTR [eax+1426], 0
  00160	75 18		 jne	 SHORT $LN28@Attack

; 1440 : 				{
; 1441 : 					if ( lpTargetObj->Type == OBJ_MONSTER )

  00162	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  00166	0f 85 f8 00 00
	00		 jne	 $LN41@Attack

; 1882 : 		}
; 1883 : 	}
; 1884 : 	return TRUE;

  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi
  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	5b		 pop	 ebx

; 1885 : }

  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c2 0c 00	 ret	 12			; 0000000cH
$LN28@Attack:

; 1442 : 					{
; 1443 : 						return TRUE;
; 1444 : 					}
; 1445 : 				}
; 1446 : 			}
; 1447 : 		}
; 1448 : 	}
; 1449 : 
; 1450 : 	if ( lpTargetObj->Type == OBJ_MONSTER )

  0017a	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  0017e	0f 85 e0 00 00
	00		 jne	 $LN41@Attack

; 1451 : 	{
; 1452 : 		if ( lpTargetObj->m_iMonsterBattleDelay > 0 )

  00184	80 be a9 05 00
	00 00		 cmp	 BYTE PTR [esi+1449], 0
  0018b	0f 8f fb 06 00
	00		 jg	 $LN131@Attack

; 1453 : 			return TRUE;
; 1454 : 
; 1455 : 		if ( lpTargetObj->Class == 200 )

  00191	b8 c8 00 00 00	 mov	 eax, 200		; 000000c8H
  00196	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  0019d	0f 84 e9 06 00
	00		 je	 $LN131@Attack

; 1456 : 		{
; 1457 : 			return TRUE;
; 1458 : 		}
; 1459 : 
; 1460 : 		if ( gObjCheckUsedBuffEffect(lpTargetObj,BUFF_MONSTERMAGIC_RESIST) == TRUE )

  001a3	6a 3f		 push	 63			; 0000003fH
  001a5	56		 push	 esi
  001a6	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  001ab	83 c4 08	 add	 esp, 8
  001ae	3c 01		 cmp	 al, 1
  001b0	75 1c		 jne	 SHORT $LN33@Attack

; 1461 : 		{
; 1462 : 			BOOL bCheckAttackIsMagicType = gObjCheckAttackTypeMagic(lpObj->Class, skill);

  001b2	ff 75 0c	 push	 DWORD PTR _skill$1$[ebp]
  001b5	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 ?gObjCheckAttackTypeMagic@@YAHHH@Z ; gObjCheckAttackTypeMagic
  001c2	83 c4 08	 add	 esp, 8

; 1463 : 
; 1464 : 			if ( bCheckAttackIsMagicType == 1 )

  001c5	83 f8 01	 cmp	 eax, 1
  001c8	0f 84 be 06 00
	00		 je	 $LN131@Attack
$LN33@Attack:

; 1465 : 			{
; 1466 : 				return TRUE;
; 1467 : 			}
; 1468 : 		}
; 1469 : 
; 1470 : 		if ( gObjCheckUsedBuffEffect(lpTargetObj,BUFF_MONCHEMISTRY_RESIST) == TRUE  )

  001ce	6a 40		 push	 64			; 00000040H
  001d0	56		 push	 esi
  001d1	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  001d6	83 c4 08	 add	 esp, 8
  001d9	3c 01		 cmp	 al, 1
  001db	75 1b		 jne	 SHORT $LN35@Attack

; 1471 : 		{
; 1472 : 			BOOL bCheckAttackIsMagicType = gObjCheckAttackTypeMagic(lpObj->Class, skill);

  001dd	ff 75 0c	 push	 DWORD PTR _skill$1$[ebp]
  001e0	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 ?gObjCheckAttackTypeMagic@@YAHHH@Z ; gObjCheckAttackTypeMagic
  001ed	83 c4 08	 add	 esp, 8

; 1473 : 
; 1474 : 			if ( bCheckAttackIsMagicType == 0 )

  001f0	85 c0		 test	 eax, eax
  001f2	0f 84 94 06 00
	00		 je	 $LN131@Attack
$LN35@Attack:

; 1475 : 			{
; 1476 : 				return TRUE;
; 1477 : 			}
; 1478 : 		}
; 1479 : 
; 1480 : 
; 1481 : 		if ( lpTargetObj->m_MonsterSkillElementInfo.m_iSkillElementImmuneTime > 0 )

  001f8	83 be b0 20 00
	00 00		 cmp	 DWORD PTR [esi+8368], 0
  001ff	7e 0f		 jle	 SHORT $LN37@Attack

; 1482 : 		{
; 1483 : 			if ( lpTargetObj->m_MonsterSkillElementInfo.m_iSkillElementImmuneNumber == skill )

  00201	8b 45 0c	 mov	 eax, DWORD PTR _skill$1$[ebp]
  00204	39 86 ac 20 00
	00		 cmp	 DWORD PTR [esi+8364], eax
  0020a	0f 84 7c 06 00
	00		 je	 $LN131@Attack
$LN37@Attack:

; 1484 : 			{
; 1485 : 				return TRUE;
; 1486 : 			}
; 1487 : 		}
; 1488 : 
; 1489 : 		if ( lpTargetObj->m_MonsterSkillElementInfo.m_iSkillElementSpecialImmuneTime > 0 )

  00210	83 be c8 20 00
	00 00		 cmp	 DWORD PTR [esi+8392], 0
  00217	0f 8f 6f 06 00
	00		 jg	 $LN131@Attack

; 1490 : 		{
; 1491 : 			return TRUE;
; 1492 : 		}
; 1493 : 
; 1494 : 		if ( lpTargetObj->Class == 523 )

  0021d	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  00224	b9 0b 02 00 00	 mov	 ecx, 523		; 0000020bH
  00229	66 3b c1	 cmp	 ax, cx
  0022c	0f 84 5a 06 00
	00		 je	 $LN131@Attack

; 1495 : 			return true;
; 1496 : 
; 1497 : 		if ( lpTargetObj->Class >= 524 && lpTargetObj->Class <= 528 && lpTargetObj->Class != 526 )

  00232	b9 0c 02 00 00	 mov	 ecx, 524		; 0000020cH
  00237	66 3b c1	 cmp	 ax, cx
  0023a	72 28		 jb	 SHORT $LN41@Attack
  0023c	b9 10 02 00 00	 mov	 ecx, 528		; 00000210H
  00241	66 3b c1	 cmp	 ax, cx
  00244	77 1e		 ja	 SHORT $LN41@Attack
  00246	b9 0e 02 00 00	 mov	 ecx, 526		; 0000020eH
  0024b	66 3b c1	 cmp	 ax, cx
  0024e	74 14		 je	 SHORT $LN41@Attack

; 1498 : 		{
; 1499 : 			if( !g_ImperialGuardian.IsAttackAbleMonster(lpTargetObj->m_Index) )

  00250	ff 36		 push	 DWORD PTR [esi]
  00252	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  00257	e8 00 00 00 00	 call	 ?IsAttackAbleMonster@CImperialGuardian@@QAE_NH@Z ; CImperialGuardian::IsAttackAbleMonster
  0025c	84 c0		 test	 al, al
  0025e	0f 84 28 06 00
	00		 je	 $LN131@Attack
$LN41@Attack:

; 1500 : 				return true;
; 1501 : 		}
; 1502 : 	}
; 1503 : 
; 1504 : 	if ( lpTargetObj->Type == OBJ_USER )

  00264	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00268	0f 85 82 00 00
	00		 jne	 $LN48@Attack

; 1505 : 	{
; 1506 : 		if( lpTargetObj->m_ElementalOptions->m_ResistElement != 0 )

  0026e	8b 9e fc 26 00
	00		 mov	 ebx, DWORD PTR [esi+9980]
  00274	83 bb 90 00 00
	00 00		 cmp	 DWORD PTR [ebx+144], 0
  0027b	74 19		 je	 SHORT $LN44@Attack

; 1507 : 		{
; 1508 : 			if( rand()%100 < lpTargetObj->m_ElementalOptions->m_ResistElement )

  0027d	e8 00 00 00 00	 call	 _rand
  00282	99		 cdq
  00283	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00288	f7 f9		 idiv	 ecx
  0028a	3b 93 90 00 00
	00		 cmp	 edx, DWORD PTR [ebx+144]
  00290	0f 8c 00 01 00
	00		 jl	 $LN166@Attack
$LN44@Attack:

; 1509 : 			{
; 1510 : 				GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index,0,btElement);
; 1511 : 				return FALSE;
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 		if( lpTargetObj->m_ElementalOptions->m_ResistStrongElement != 0 )

  00296	83 bb 8c 00 00
	00 00		 cmp	 DWORD PTR [ebx+140], 0

; 1516 : 		{
; 1517 : 			if( this->m_DamageTable[lpObj->m_btAttribute][lpTargetObj->m_btAttribute] > 100 )

  0029d	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  002a0	74 3d		 je	 SHORT $LN47@Attack
  002a2	0f b6 97 e4 26
	00 00		 movzx	 edx, BYTE PTR [edi+9956]
  002a9	0f b6 8e e4 26
	00 00		 movzx	 ecx, BYTE PTR [esi+9956]
  002b0	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  002b3	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  002b6	80 bc 01 4c 03
	00 00 64	 cmp	 BYTE PTR [ecx+eax+844], 100 ; 00000064H
  002be	76 1f		 jbe	 SHORT $LN47@Attack

; 1518 : 			{
; 1519 : 				if( rand()%100 < lpTargetObj->m_ElementalOptions->m_ResistStrongElement )

  002c0	e8 00 00 00 00	 call	 _rand
  002c5	99		 cdq
  002c6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  002cb	f7 f9		 idiv	 ecx
  002cd	8b 86 fc 26 00
	00		 mov	 eax, DWORD PTR [esi+9980]
  002d3	3b 90 8c 00 00
	00		 cmp	 edx, DWORD PTR [eax+140]
  002d9	0f 8c b7 00 00
	00		 jl	 $LN166@Attack
$LN47@Attack:

; 1520 : 				{
; 1521 : 					GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index,0,btElement);
; 1522 : 					return FALSE;
; 1523 : 				}
; 1524 : 			}
; 1525 : 		}
; 1526 : 
; 1527 : 		if ( !gObjIsConnected(lpTargetObj))

  002df	56		 push	 esi
  002e0	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  002e5	83 c4 04	 add	 esp, 4
  002e8	85 c0		 test	 eax, eax
  002ea	0f 84 77 fd ff
	ff		 je	 $LN8@Attack
$LN48@Attack:

; 1528 : 		{
; 1529 : 			return FALSE;
; 1530 : 		}
; 1531 : 	}
; 1532 : 
; 1533 : 	if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_MONSTER )	// PLAYER VS MONSTER

  002f0	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  002f4	75 18		 jne	 SHORT $LN51@Attack
  002f6	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  002fa	75 12		 jne	 SHORT $LN51@Attack

; 1534 : 	{
; 1535 : 		if ( lpObj->m_RecallMon >= 0 )

  002fc	8b 87 30 06 00
	00		 mov	 eax, DWORD PTR [edi+1584]
  00302	85 c0		 test	 eax, eax
  00304	78 08		 js	 SHORT $LN51@Attack

; 1536 : 		{
; 1537 : 			if ( lpObj->m_RecallMon == lpTargetObj->m_Index )

  00306	3b 06		 cmp	 eax, DWORD PTR [esi]
  00308	0f 84 59 fd ff
	ff		 je	 $LN8@Attack
$LN51@Attack:

; 1538 : 			{
; 1539 : 				return FALSE;
; 1540 : 			}
; 1541 : 		}
; 1542 : 	}
; 1543 : 
; 1544 : 	if ( !gObjAttackQ(lpTargetObj))

  0030e	56		 push	 esi
  0030f	e8 00 00 00 00	 call	 ?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z ; gObjAttackQ
  00314	83 c4 04	 add	 esp, 4
  00317	85 c0		 test	 eax, eax
  00319	0f 84 48 fd ff
	ff		 je	 $LN8@Attack

; 1545 : 		return FALSE;
; 1546 : 
; 1547 : 	if ( lpObj->m_RecallMon >= 0 )

  0031f	83 bf 30 06 00
	00 00		 cmp	 DWORD PTR [edi+1584], 0
  00326	7c 0b		 jl	 SHORT $LN53@Attack

; 1548 : 		gObjCallMonsterSetEnemy(lpObj, lpTargetObj->m_Index);

  00328	ff 36		 push	 DWORD PTR [esi]
  0032a	57		 push	 edi
  0032b	e8 00 00 00 00	 call	 ?gObjCallMonsterSetEnemy@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCallMonsterSetEnemy
  00330	83 c4 08	 add	 esp, 8
$LN53@Attack:

; 1549 : 
; 1550 : 	if ( CheckAttackArea(lpObj, lpTargetObj) == FALSE )

  00333	56		 push	 esi
  00334	57		 push	 edi
  00335	8b cb		 mov	 ecx, ebx
  00337	e8 00 00 00 00	 call	 ?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ; CObjBaseAttack::CheckAttackArea
  0033c	85 c0		 test	 eax, eax
  0033e	0f 84 23 fd ff
	ff		 je	 $LN8@Attack

; 1551 : 		return FALSE;
; 1552 : 
; 1553 : 	lpCallObj = lpObj;
; 1554 : 
; 1555 : 	//Check start
; 1556 : 
; 1557 : 	if ( lpObj->Type == OBJ_MONSTER )

  00344	80 7f 50 02	 cmp	 BYTE PTR [edi+80], 2
  00348	8b c7		 mov	 eax, edi
  0034a	75 16		 jne	 SHORT $LN56@Attack

; 1558 : 	{
; 1559 : 		if ( lpObj->m_RecallMon >= 0 )

  0034c	8b 8f 30 06 00
	00		 mov	 ecx, DWORD PTR [edi+1584]
  00352	85 c9		 test	 ecx, ecx
  00354	78 0c		 js	 SHORT $LN56@Attack

; 1560 : 		{
; 1561 : 			lpCallObj = &gObj[lpObj->m_RecallMon];

  00356	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  0035c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN56@Attack:

; 1562 : 		}
; 1563 : 	}
; 1564 : 
; 1565 : 	lpCallTargetObj = lpTargetObj;
; 1566 : 
; 1567 : 	if ( lpTargetObj->Type == OBJ_MONSTER )
; 1568 : 	{
; 1569 : 		if ( lpTargetObj->m_RecallMon >= 0 )
; 1570 : 		{
; 1571 : 			lpCallTargetObj = &gObj[lpTargetObj->m_RecallMon];
; 1572 : 		}
; 1573 : 	}
; 1574 : 
; 1575 : 	if ( PkCheck(lpCallObj, lpTargetObj) == FALSE )

  00362	56		 push	 esi
  00363	50		 push	 eax
  00364	8b cb		 mov	 ecx, ebx
  00366	e8 00 00 00 00	 call	 ?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ; CObjBaseAttack::PkCheck
  0036b	85 c0		 test	 eax, eax
  0036d	0f 84 f4 fc ff
	ff		 je	 $LN8@Attack

; 1576 : 		return FALSE;
; 1577 : 
; 1578 : 	int Strength = lpObj->Strength + lpObj->AddStrength;
; 1579 : 	int Dexterity = lpObj->Dexterity + lpObj->AddDexterity;
; 1580 : 	int Vitality = lpObj->Vitality + lpObj->AddVitality;
; 1581 : 	int Energy = lpObj->Energy + lpObj->AddEnergy;
; 1582 : 	BOOL bIsOnDuel = gObjDuelCheck(lpObj, lpTargetObj);

  00373	56		 push	 esi
  00374	57		 push	 edi
  00375	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  0037a	83 c4 08	 add	 esp, 8

; 1583 : 	
; 1584 : 	
; 1585 : 	if( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER )

  0037d	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00381	75 2f		 jne	 SHORT $LN60@Attack
  00383	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00387	75 29		 jne	 SHORT $LN60@Attack

; 1586 : 	{
; 1587 : 		if ( !MissCheckPvP(lpObj, lpTargetObj) )

  00389	56		 push	 esi
  0038a	57		 push	 edi
  0038b	8b cb		 mov	 ecx, ebx
  0038d	e8 00 00 00 00	 call	 ?MissCheckPvP@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ; CElementalSystem::MissCheckPvP
$LN167@Attack:
  00392	85 c0		 test	 eax, eax
  00394	75 27		 jne	 SHORT $LN63@Attack
$LN166@Attack:

; 1588 : 		{
; 1589 : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index,0,btElement);

  00396	ff 75 08	 push	 DWORD PTR _btElement$[ebp]
  00399	6a 00		 push	 0
  0039b	ff 36		 push	 DWORD PTR [esi]
  0039d	ff 37		 push	 DWORD PTR [edi]
  0039f	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHE@Z ; GCDamageSend
  003a4	83 c4 10	 add	 esp, 16			; 00000010H

; 1590 : 			return FALSE;

  003a7	33 c0		 xor	 eax, eax
  003a9	5f		 pop	 edi
  003aa	5e		 pop	 esi
  003ab	5b		 pop	 ebx

; 1885 : }

  003ac	8b e5		 mov	 esp, ebp
  003ae	5d		 pop	 ebp
  003af	c2 0c 00	 ret	 12			; 0000000cH
$LN60@Attack:

; 1591 : 		}
; 1592 : 	}
; 1593 : 	else if( !MissCheck(lpObj, lpTargetObj) )

  003b2	56		 push	 esi
  003b3	57		 push	 edi
  003b4	8b cb		 mov	 ecx, ebx
  003b6	e8 00 00 00 00	 call	 ?MissCheck@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ; CElementalSystem::MissCheck

; 1594 : 	{
; 1595 : 		
; 1596 : 		GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index,0,btElement);
; 1597 : 		return FALSE;

  003bb	eb d5		 jmp	 SHORT $LN167@Attack
$LN63@Attack:

; 1598 : 	}
; 1599 : 
; 1600 : 	int targetdefense = GetTargetDefense(lpObj,lpTargetObj,lpMagic,btElement);

  003bd	ff 75 08	 push	 DWORD PTR _btElement$[ebp]
  003c0	8b cb		 mov	 ecx, ebx
  003c2	ff 75 10	 push	 DWORD PTR _lpMagic$[ebp]
  003c5	56		 push	 esi
  003c6	57		 push	 edi
  003c7	e8 00 00 00 00	 call	 ?GetTargetDefense@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@E@Z ; CElementalSystem::GetTargetDefense

; 1601 : 	int AttackDamage = GetAttackDamage(lpObj,lpTargetObj, targetdefense, lpMagic,btElement,btTargetElement);

  003cc	ff 75 f8	 push	 DWORD PTR _btTargetElement$[ebp]
  003cf	8b cb		 mov	 ecx, ebx
  003d1	ff 75 08	 push	 DWORD PTR _btElement$[ebp]
  003d4	ff 75 10	 push	 DWORD PTR _lpMagic$[ebp]
  003d7	50		 push	 eax
  003d8	56		 push	 esi
  003d9	57		 push	 edi
  003da	e8 00 00 00 00	 call	 ?GetAttackDamage@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0HPAVCMagicInf@@EE@Z ; CElementalSystem::GetAttackDamage
  003df	8b d8		 mov	 ebx, eax

; 1602 : 
; 1603 : 	if( AttackDamage <= 0 )

  003e1	85 db		 test	 ebx, ebx
  003e3	7e b1		 jle	 SHORT $LN166@Attack

; 1604 : 	{
; 1605 : 		GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index,0,btElement);
; 1606 : 		return false;
; 1607 : 	}
; 1608 : 
; 1609 : 	int tlevel = (lpObj->Level+lpObj->MasterLevel) / 10;

  003e5	0f bf 87 96 00
	00 00		 movsx	 eax, WORD PTR [edi+150]
  003ec	0f bf 8f a8 00
	00 00		 movsx	 ecx, WORD PTR [edi+168]
  003f3	03 c8		 add	 ecx, eax
  003f5	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  003fa	f7 e9		 imul	 ecx

; 1610 : 
; 1611 : 	if ( AttackDamage < tlevel )

  003fc	b9 01 00 00 00	 mov	 ecx, 1
  00401	c1 fa 02	 sar	 edx, 2
  00404	8b c2		 mov	 eax, edx
  00406	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00409	03 c2		 add	 eax, edx
  0040b	3b d8		 cmp	 ebx, eax
  0040d	7d 07		 jge	 SHORT $LN65@Attack

; 1612 : 	{
; 1613 : 		if ( tlevel < 1 )

  0040f	3b c1		 cmp	 eax, ecx
  00411	8b d8		 mov	 ebx, eax
  00413	0f 4c d9	 cmovl	 ebx, ecx
$LN65@Attack:

; 1614 : 		{
; 1615 : 			tlevel = 1;
; 1616 : 		}
; 1617 : 		AttackDamage = tlevel;
; 1618 : 	}
; 1619 : 
; 1620 : 	gObjSpriteDamage(lpTargetObj, AttackDamage);

  00416	53		 push	 ebx
  00417	56		 push	 esi
  00418	e8 00 00 00 00	 call	 ?gObjSpriteDamage@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjSpriteDamage
  0041d	83 c4 08	 add	 esp, 8

; 1621 : 
; 1622 : 
; 1623 : #if (GS_CASTLE == 1)
; 1624 : 
; 1625 : 	if(g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE
; 1626 : 		&& lpObj->Type == OBJ_USER
; 1627 : 		&& lpTargetObj->Type == OBJ_USER
; 1628 : 		&& lpObj->MapNumber == MAP_INDEX_CASTLESIEGE
; 1629 : 		&& lpTargetObj->MapNumber == MAP_INDEX_CASTLESIEGE )

  00420	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00425	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0042a	83 f8 07	 cmp	 eax, 7
  0042d	75 4c		 jne	 SHORT $LN69@Attack
  0042f	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00433	0f 85 2c 01 00
	00		 jne	 $LN82@Attack
  00439	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0043d	75 3c		 jne	 SHORT $LN69@Attack
  0043f	80 bf 23 01 00
	00 1e		 cmp	 BYTE PTR [edi+291], 30	; 0000001eH
  00446	75 33		 jne	 SHORT $LN69@Attack
  00448	80 be 23 01 00
	00 1e		 cmp	 BYTE PTR [esi+291], 30	; 0000001eH
  0044f	75 2a		 jne	 SHORT $LN69@Attack

; 1630 : 	{
; 1631 : 		if(lpObj->m_btCsJoinSide == lpTargetObj->m_btCsJoinSide)

  00451	8a 87 5a 20 00
	00		 mov	 al, BYTE PTR [edi+8282]

; 1632 : 		{
; 1633 : 			AttackDamage = AttackDamage * 20 / 100;

  00457	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  0045a	3a 86 5a 20 00
	00		 cmp	 al, BYTE PTR [esi+8282]
  00460	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00465	75 05		 jne	 SHORT $LN68@Attack
  00467	c1 e1 02	 shl	 ecx, 2

; 1634 : 		}
; 1635 : 		else

  0046a	eb 03		 jmp	 SHORT $LN162@Attack
$LN68@Attack:

; 1636 : 		{
; 1637 : 			AttackDamage = AttackDamage * 40 / 100;

  0046c	c1 e1 03	 shl	 ecx, 3
$LN162@Attack:
  0046f	f7 e9		 imul	 ecx
  00471	c1 fa 05	 sar	 edx, 5
  00474	8b da		 mov	 ebx, edx
  00476	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00479	03 da		 add	 ebx, edx
$LN69@Attack:

; 1638 : 		}
; 1639 : 	}
; 1640 : #endif
; 1641 : 
; 1642 : 	if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_MONSTER )

  0047b	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0047f	0f 85 e0 00 00
	00		 jne	 $LN82@Attack
  00485	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  00489	0f 85 d6 00 00
	00		 jne	 $LN82@Attack

; 1643 : 	{
; 1644 : 		if ( lpTargetObj->Class == 283 )

  0048f	b8 1b 01 00 00	 mov	 eax, 283		; 0000011bH
  00494	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  0049b	75 5d		 jne	 SHORT $LN75@Attack

; 1645 : 		{
; 1646 : 			if ( gObjCheckUsedBuffEffect(lpObj,BUFF_POT_BLESS) == TRUE )

  0049d	6a 0a		 push	 10			; 0000000aH
  0049f	57		 push	 edi
  004a0	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  004a5	83 c4 08	 add	 esp, 8
  004a8	3c 01		 cmp	 al, 1
  004aa	74 4e		 je	 SHORT $LN75@Attack

; 1647 : 			{
; 1648 : 			}
; 1649 : 			else if ( gObjCheckUsedBuffEffect(lpObj,BUFF_POT_SOUL) == TRUE )

  004ac	6a 0b		 push	 11			; 0000000bH
  004ae	57		 push	 edi
  004af	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  004b4	83 c4 08	 add	 esp, 8
  004b7	3c 01		 cmp	 al, 1
  004b9	74 3f		 je	 SHORT $LN75@Attack

; 1650 : 			{
; 1651 : 			}
; 1652 : 			else 
; 1653 : 			{
; 1654 : 				if ( lpObj->m_iAccumulatedDamage > 100 )

  004bb	8b 87 68 20 00
	00		 mov	 eax, DWORD PTR [edi+8296]
  004c1	83 f8 64	 cmp	 eax, 100		; 00000064H
  004c4	7e 18		 jle	 SHORT $LN76@Attack

; 1655 : 				{
; 1656 : 					gObjWeaponDurDownInCastle(lpObj, lpTargetObj, 1);

  004c6	6a 01		 push	 1
  004c8	56		 push	 esi
  004c9	57		 push	 edi
  004ca	e8 00 00 00 00	 call	 ?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z ; gObjWeaponDurDownInCastle
  004cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1657 : 					lpObj->m_iAccumulatedDamage = 0;

  004d2	c7 87 68 20 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+8296], 0

; 1658 : 				}
; 1659 : 				else

  004dc	eb 08		 jmp	 SHORT $LN77@Attack
$LN76@Attack:

; 1660 : 				{
; 1661 : 					lpObj->m_iAccumulatedDamage += AttackDamage;

  004de	03 c3		 add	 eax, ebx
  004e0	89 87 68 20 00
	00		 mov	 DWORD PTR [edi+8296], eax
$LN77@Attack:

; 1662 : 				}
; 1663 : 
; 1664 : 				AttackDamage = AttackDamage * 5 / 100;

  004e6	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  004e9	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  004ee	f7 e9		 imul	 ecx
  004f0	c1 fa 05	 sar	 edx, 5
  004f3	8b da		 mov	 ebx, edx
  004f5	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  004f8	03 da		 add	 ebx, edx
$LN75@Attack:

; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 		if ( lpTargetObj->Class == 277 )

  004fa	b8 15 01 00 00	 mov	 eax, 277		; 00000115H
  004ff	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  00506	75 5d		 jne	 SHORT $LN82@Attack

; 1669 : 		{
; 1670 : 			if ( gObjCheckUsedBuffEffect(lpObj,BUFF_POT_BLESS) == TRUE )

  00508	6a 0a		 push	 10			; 0000000aH
  0050a	57		 push	 edi
  0050b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00510	83 c4 08	 add	 esp, 8
  00513	3c 01		 cmp	 al, 1
  00515	74 4e		 je	 SHORT $LN82@Attack

; 1671 : 			{
; 1672 : 			}
; 1673 : 			else if ( gObjCheckUsedBuffEffect(lpObj,BUFF_POT_SOUL) == TRUE )

  00517	6a 0b		 push	 11			; 0000000bH
  00519	57		 push	 edi
  0051a	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0051f	83 c4 08	 add	 esp, 8
  00522	3c 01		 cmp	 al, 1
  00524	74 3f		 je	 SHORT $LN82@Attack

; 1674 : 			{
; 1675 : 			}
; 1676 : 			else 
; 1677 : 			{
; 1678 : 				if ( lpObj->m_iAccumulatedDamage > 100 )

  00526	8b 87 68 20 00
	00		 mov	 eax, DWORD PTR [edi+8296]
  0052c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0052f	7e 18		 jle	 SHORT $LN83@Attack

; 1679 : 				{
; 1680 : 					gObjWeaponDurDownInCastle(lpObj, lpTargetObj, 1);

  00531	6a 01		 push	 1
  00533	56		 push	 esi
  00534	57		 push	 edi
  00535	e8 00 00 00 00	 call	 ?gObjWeaponDurDownInCastle@@YAXPAUOBJECTSTRUCT@@0H@Z ; gObjWeaponDurDownInCastle
  0053a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 : 					lpObj->m_iAccumulatedDamage = 0;

  0053d	c7 87 68 20 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+8296], 0

; 1682 : 				}
; 1683 : 				else

  00547	eb 08		 jmp	 SHORT $LN84@Attack
$LN83@Attack:

; 1684 : 				{
; 1685 : 					lpObj->m_iAccumulatedDamage += AttackDamage;

  00549	03 c3		 add	 eax, ebx
  0054b	89 87 68 20 00
	00		 mov	 DWORD PTR [edi+8296], eax
$LN84@Attack:

; 1686 : 				}
; 1687 : 
; 1688 : 				AttackDamage = AttackDamage * 5 / 100;

  00551	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  00554	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00559	f7 e9		 imul	 ecx
  0055b	c1 fa 05	 sar	 edx, 5
  0055e	8b da		 mov	 ebx, edx
  00560	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00563	03 da		 add	 ebx, edx
$LN82@Attack:

; 1689 : 			}
; 1690 : 		}
; 1691 : 	}
; 1692 : 
; 1693 : 	if ( AttackDamage < 0 )

  00565	33 c0		 xor	 eax, eax
  00567	85 db		 test	 ebx, ebx
  00569	0f 48 d8	 cmovs	 ebx, eax

; 1694 : 		AttackDamage = 0;
; 1695 : 
; 1696 : 
; 1697 : 	if ( lpTargetObj->Type == OBJ_MONSTER )

  0056c	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  00570	89 5d fc	 mov	 DWORD PTR _AttackDamage$1$[ebp], ebx
  00573	75 41		 jne	 SHORT $LN87@Attack

; 1698 : 	{
; 1699 : 		gObjAddMsgSendDelay(lpTargetObj, 0, lpObj->m_Index, 100, 0);

  00575	50		 push	 eax
  00576	6a 64		 push	 100			; 00000064H
  00578	ff 37		 push	 DWORD PTR [edi]
  0057a	50		 push	 eax
  0057b	56		 push	 esi
  0057c	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay

; 1700 : 		lpTargetObj->LastAttackerID = lpObj->m_Index;

  00581	66 8b 0f	 mov	 cx, WORD PTR [edi]
  00584	83 c4 14	 add	 esp, 20			; 00000014H

; 1701 : 
; 1702 : 		if ( lpTargetObj->m_iCurrentAI )	

  00587	83 be d0 20 00
	00 00		 cmp	 DWORD PTR [esi+8400], 0
  0058e	66 89 8e 3e 06
	00 00		 mov	 WORD PTR [esi+1598], cx
  00595	74 1f		 je	 SHORT $LN87@Attack

; 1703 : 		{
; 1704 : 			lpTargetObj->m_Agro.IncAgro(lpObj->m_Index, AttackDamage / 50);

  00597	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0059c	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  005a2	f7 eb		 imul	 ebx
  005a4	c1 fa 04	 sar	 edx, 4
  005a7	8b c2		 mov	 eax, edx
  005a9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005ac	03 c2		 add	 eax, edx
  005ae	50		 push	 eax
  005af	ff 37		 push	 DWORD PTR [edi]
  005b1	e8 00 00 00 00	 call	 ?IncAgro@TMonsterAIAgro@@QAEHHH@Z ; TMonsterAIAgro::IncAgro
$LN87@Attack:

; 1705 : 		}
; 1706 : 	}
; 1707 : 
; 1708 : 	BOOL selfdefense = 0;
; 1709 : 	lpCallObj = lpTargetObj;
; 1710 : 	
; 1711 : 	if ( lpTargetObj->Type == OBJ_MONSTER )

  005b6	8a 4e 50	 mov	 cl, BYTE PTR [esi+80]
  005b9	33 db		 xor	 ebx, ebx
  005bb	89 75 10	 mov	 DWORD PTR _lpCallObj$1$[ebp], esi
  005be	80 f9 02	 cmp	 cl, 2
  005c1	75 19		 jne	 SHORT $LN89@Attack

; 1712 : 	{
; 1713 : 		if ( lpTargetObj->m_RecallMon >= 0 )

  005c3	8b 86 30 06 00
	00		 mov	 eax, DWORD PTR [esi+1584]
  005c9	85 c0		 test	 eax, eax
  005cb	78 0f		 js	 SHORT $LN89@Attack

; 1714 : 		{
; 1715 : 			lpCallObj = &gObj[lpTargetObj->m_RecallMon];

  005cd	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  005d3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005d9	89 45 10	 mov	 DWORD PTR _lpCallObj$1$[ebp], eax
$LN89@Attack:

; 1716 : 		}
; 1717 : 	}
; 1718 : 
; 1719 : 	if ( AttackDamage >= 1 )

  005dc	83 7d fc 01	 cmp	 DWORD PTR _AttackDamage$1$[ebp], 1
  005e0	0f 8c 3c 01 00
	00		 jl	 $LN113@Attack

; 1720 : 	{
; 1721 : 		if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER )

  005e6	8a 47 50	 mov	 al, BYTE PTR [edi+80]
  005e9	3c 01		 cmp	 al, 1
  005eb	0f 85 bd 00 00
	00		 jne	 $LN91@Attack
  005f1	3a c8		 cmp	 cl, al
  005f3	0f 85 b5 00 00
	00		 jne	 $LN91@Attack

; 1722 : 		{
; 1723 : 			if ( gObjDuelCheck(lpObj, lpTargetObj) )

  005f9	56		 push	 esi
  005fa	57		 push	 edi
  005fb	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  00600	83 c4 08	 add	 esp, 8
  00603	85 c0		 test	 eax, eax
  00605	75 77		 jne	 SHORT $LN97@Attack

; 1724 : 			{
; 1725 : 				selfdefense = 0;
; 1726 : 			}
; 1727 : 			else if ( CC_MAP_RANGE(lpObj->MapNumber) || CC_MAP_RANGE(lpTargetObj->MapNumber) )

  00607	8a 8f 23 01 00
	00		 mov	 cl, BYTE PTR [edi+291]
  0060d	80 f9 35	 cmp	 cl, 53			; 00000035H
  00610	74 6c		 je	 SHORT $LN97@Attack
  00612	80 f9 12	 cmp	 cl, 18			; 00000012H
  00615	72 0b		 jb	 SHORT $LN153@Attack
  00617	b0 17		 mov	 al, 23			; 00000017H
  00619	3a c1		 cmp	 al, cl
  0061b	1b c0		 sbb	 eax, eax
  0061d	83 c0 01	 add	 eax, 1
  00620	75 5c		 jne	 SHORT $LN97@Attack
$LN153@Attack:
  00622	8a 96 23 01 00
	00		 mov	 dl, BYTE PTR [esi+291]
  00628	80 fa 35	 cmp	 dl, 53			; 00000035H
  0062b	74 51		 je	 SHORT $LN97@Attack
  0062d	80 fa 12	 cmp	 dl, 18			; 00000012H
  00630	72 0b		 jb	 SHORT $LN154@Attack
  00632	b0 17		 mov	 al, 23			; 00000017H
  00634	3a c2		 cmp	 al, dl
  00636	1b c0		 sbb	 eax, eax
  00638	83 c0 01	 add	 eax, 1
  0063b	75 41		 jne	 SHORT $LN97@Attack
$LN154@Attack:

; 1730 : 			}
; 1731 : 			else if ( IT_MAP_RANGE(lpObj->MapNumber) || IT_MAP_RANGE(lpTargetObj->MapNumber) )

  0063d	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00640	72 0b		 jb	 SHORT $LN155@Attack
  00642	b0 32		 mov	 al, 50			; 00000032H
  00644	3a c1		 cmp	 al, cl
  00646	1b c0		 sbb	 eax, eax
  00648	83 c0 01	 add	 eax, 1
  0064b	75 31		 jne	 SHORT $LN97@Attack
$LN155@Attack:
  0064d	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00650	72 0b		 jb	 SHORT $LN156@Attack
  00652	b0 32		 mov	 al, 50			; 00000032H
  00654	3a c2		 cmp	 al, dl
  00656	1b c0		 sbb	 eax, eax
  00658	83 c0 01	 add	 eax, 1
  0065b	75 21		 jne	 SHORT $LN97@Attack
$LN156@Attack:

; 1732 : 			{
; 1733 : 				selfdefense = 0;
; 1734 : 			}
; 1735 : 			else if ( lpObj->MapNumber == MAP_INDEX_VULCANUS || lpTargetObj->MapNumber == MAP_INDEX_VULCANUS )

  0065d	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  00660	74 1c		 je	 SHORT $LN97@Attack
  00662	80 fa 3f	 cmp	 dl, 63			; 0000003fH
  00665	74 17		 je	 SHORT $LN97@Attack

; 1736 : 			{
; 1737 : 				selfdefense = 0;
; 1738 : 			}
; 1739 : #if (__GENS_SYSTEM__ == 1)
; 1740 : 			else if ( gGensSystem.GensMap(lpObj->MapNumber) )

  00667	0f b6 c1	 movzx	 eax, cl
  0066a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  0066f	50		 push	 eax
  00670	e8 00 00 00 00	 call	 ?GensMap@CGensSystem@@QAEHH@Z ; CGensSystem::GensMap
  00675	8b d8		 mov	 ebx, eax
  00677	f7 db		 neg	 ebx
  00679	1b db		 sbb	 ebx, ebx
  0067b	43		 inc	 ebx

; 1741 : 			{
; 1742 : 				selfdefense = 0;
; 1743 : 			}
; 1744 : #endif
; 1745 : 			else
; 1746 : 			{
; 1747 : 				selfdefense = 1;

  0067c	eb 02		 jmp	 SHORT $LN105@Attack
$LN97@Attack:

; 1728 : 			{
; 1729 : 				selfdefense = 0;

  0067e	33 db		 xor	 ebx, ebx
$LN105@Attack:

; 1748 : 			}
; 1749 : 
; 1750 : 			if ( gObjGetRelationShip(lpObj, lpTargetObj) == 2 )

  00680	56		 push	 esi
  00681	57		 push	 edi
  00682	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip
  00687	33 d2		 xor	 edx, edx
  00689	83 c4 08	 add	 esp, 8
  0068c	83 f8 02	 cmp	 eax, 2

; 1751 : 			{
; 1752 : 				selfdefense = FALSE;
; 1753 : 			}
; 1754 : #if (GS_CASTLE == 1)			
; 1755 : 			if(g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE && lpObj->m_btCsJoinSide > 0)

  0068f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00694	0f 44 da	 cmove	 ebx, edx
  00697	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0069c	83 f8 07	 cmp	 eax, 7
  0069f	75 24		 jne	 SHORT $LN109@Attack
  006a1	80 bf 5a 20 00
	00 00		 cmp	 BYTE PTR [edi+8282], 0
  006a8	76 1b		 jbe	 SHORT $LN109@Attack

; 1756 : 			{
; 1757 : 				selfdefense = FALSE;

  006aa	33 db		 xor	 ebx, ebx

; 1758 : 			}
; 1759 : #endif
; 1760 : 		}

  006ac	eb 17		 jmp	 SHORT $LN109@Attack
$LN91@Attack:

; 1761 : 		else if ( lpTargetObj->Type == OBJ_MONSTER && lpObj->Type == OBJ_USER )

  006ae	80 f9 02	 cmp	 cl, 2
  006b1	75 12		 jne	 SHORT $LN109@Attack
  006b3	3c 01		 cmp	 al, 1
  006b5	75 0e		 jne	 SHORT $LN109@Attack

; 1762 : 		{
; 1763 : 			if ( lpTargetObj->m_RecallMon >= 0 )

  006b7	39 9e 30 06 00
	00		 cmp	 DWORD PTR [esi+1584], ebx
  006bd	b8 01 00 00 00	 mov	 eax, 1
  006c2	0f 4d d8	 cmovge	 ebx, eax
$LN109@Attack:

; 1764 : 			{
; 1765 : 				selfdefense = TRUE;
; 1766 : 			}
; 1767 : 		}
; 1768 : 
; 1769 : 		if( lpTargetObj->Type == OBJ_USER )

  006c5	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  006c9	75 0a		 jne	 SHORT $LN110@Attack

; 1770 : 		{
; 1771 : 			gObjArmorRandomDurDown(lpTargetObj, lpObj);

  006cb	57		 push	 edi
  006cc	56		 push	 esi
  006cd	e8 00 00 00 00	 call	 ?gObjArmorRandomDurDown@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjArmorRandomDurDown
  006d2	83 c4 08	 add	 esp, 8
$LN110@Attack:

; 1772 : 		}
; 1773 : 
; 1774 : 		if ( gObjCheckUsedBuffEffect(lpTargetObj,BUFF_ICEARROW) == TRUE )

  006d5	6a 39		 push	 57			; 00000039H
  006d7	56		 push	 esi
  006d8	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  006dd	83 c4 08	 add	 esp, 8
  006e0	3c 01		 cmp	 al, 1
  006e2	75 24		 jne	 SHORT $LN112@Attack

; 1775 : 		{
; 1776 : 			gObjAddBuffEffect(lpTargetObj,BUFF_ICEARROW,-1);

  006e4	6a ff		 push	 -1
  006e6	6a 39		 push	 57			; 00000039H
  006e8	56		 push	 esi
  006e9	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HH@Z ; gObjAddBuffEffect

; 1777 : 
; 1778 : 			if ( gObjCheckUsedBuffEffect(lpTargetObj,BUFF_ICEARROW) == FALSE )

  006ee	6a 39		 push	 57			; 00000039H
  006f0	56		 push	 esi
  006f1	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  006f6	83 c4 14	 add	 esp, 20			; 00000014H
  006f9	84 c0		 test	 al, al
  006fb	75 0b		 jne	 SHORT $LN112@Attack

; 1779 : 			{
; 1780 : 				GCMagicCancelSend(lpTargetObj,51);

  006fd	6a 33		 push	 51			; 00000033H
  006ff	56		 push	 esi
  00700	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCMagicCancelSend
  00705	83 c4 08	 add	 esp, 8
$LN112@Attack:

; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 		if ( gObjCheckUsedBuffEffect(lpTargetObj,BUFF_SLEEP) == TRUE )

  00708	6a 48		 push	 72			; 00000048H
  0070a	56		 push	 esi
  0070b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00710	83 c4 08	 add	 esp, 8
  00713	3c 01		 cmp	 al, 1
  00715	75 0b		 jne	 SHORT $LN113@Attack

; 1785 : 		{
; 1786 : 			gObjRemoveBuffEffect(lpTargetObj,BUFF_SLEEP);

  00717	6a 48		 push	 72			; 00000048H
  00719	56		 push	 esi
  0071a	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  0071f	83 c4 08	 add	 esp, 8
$LN113@Attack:

; 1787 : 		}
; 1788 : 	}
; 1789 : 
; 1790 : 	if ( lpObj->PartyNumber >= 0 &&

  00722	8b 8f 0c 06 00
	00		 mov	 ecx, DWORD PTR [edi+1548]
  00728	85 c9		 test	 ecx, ecx
  0072a	78 11		 js	 SHORT $LN115@Attack
  0072c	8b 45 10	 mov	 eax, DWORD PTR _lpCallObj$1$[ebp]
  0072f	8b 80 0c 06 00
	00		 mov	 eax, DWORD PTR [eax+1548]
  00735	85 c0		 test	 eax, eax
  00737	78 04		 js	 SHORT $LN115@Attack

; 1791 : 		 lpCallObj->PartyNumber >= 0)
; 1792 : 	{
; 1793 : 		if( lpObj->PartyNumber == lpCallObj->PartyNumber )

  00739	3b c8		 cmp	 ecx, eax
  0073b	74 3a		 je	 SHORT $LN119@Attack
$LN115@Attack:

; 1794 : 		{
; 1795 : 			selfdefense = 0;
; 1796 : 		}
; 1797 : 	}
; 1798 : 
; 1799 : 	if ( selfdefense == TRUE )

  0073d	83 fb 01	 cmp	 ebx, 1
  00740	75 35		 jne	 SHORT $LN119@Attack

; 1800 : 	{
; 1801 : 		if ( !gObjTargetGuildWarCheck(lpObj, lpCallObj) )

  00742	8b 5d 10	 mov	 ebx, DWORD PTR _lpCallObj$1$[ebp]
  00745	53		 push	 ebx
  00746	57		 push	 edi
  00747	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0074c	83 c4 08	 add	 esp, 8
  0074f	85 c0		 test	 eax, eax
  00751	75 24		 jne	 SHORT $LN119@Attack

; 1802 : 		{
; 1803 : 			if( lpCallObj->PartyNumber >= 0 )

  00753	8b 83 0c 06 00
	00		 mov	 eax, DWORD PTR [ebx+1548]
  00759	85 c0		 test	 eax, eax
  0075b	78 0f		 js	 SHORT $LN118@Attack

; 1804 : 			{
; 1805 : 				int bTmp = 0;
; 1806 : 				int PartyNumber = lpCallObj->PartyNumber;
; 1807 : 
; 1808 : 				if( gParty.GetPartyPkLevel(PartyNumber) < 5 )

  0075d	50		 push	 eax
  0075e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00763	e8 00 00 00 00	 call	 ?GetPartyPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPartyPkLevel
  00768	3c 05		 cmp	 al, 5
  0076a	7d 0b		 jge	 SHORT $LN119@Attack
$LN118@Attack:

; 1809 : 				{
; 1810 : 					gObjCheckSelfDefense(lpObj, lpCallObj->m_Index);
; 1811 : 				}
; 1812 : 			}
; 1813 : 			else
; 1814 : 			{
; 1815 : 				gObjCheckSelfDefense(lpObj, lpCallObj->m_Index);

  0076c	ff 33		 push	 DWORD PTR [ebx]
  0076e	57		 push	 edi
  0076f	e8 00 00 00 00	 call	 ?gObjCheckSelfDefense@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjCheckSelfDefense
  00774	83 c4 08	 add	 esp, 8
$LN119@Attack:

; 1816 : 			}
; 1817 : 		}
; 1818 : 	}
; 1819 : 
; 1820 : 	if ( lpTargetObj->Class == 275 )	// KUNDUN

  00777	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  0077c	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  00783	75 3f		 jne	 SHORT $LN123@Attack

; 1821 : 	{
; 1822 : 		if ( lpTargetObj->m_iMonsterBattleDelay <= 0 )

  00785	80 be a9 05 00
	00 00		 cmp	 BYTE PTR [esi+1449], 0
  0078c	7f 36		 jg	 SHORT $LN123@Attack

; 1823 : 		{
; 1824 : 			if ( (rand()%15) < 1 )

  0078e	e8 00 00 00 00	 call	 _rand
  00793	99		 cdq
  00794	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00799	f7 f9		 idiv	 ecx
  0079b	83 fa 01	 cmp	 edx, 1
  0079e	7d 24		 jge	 SHORT $LN123@Attack

; 1825 : 			{
; 1826 : 				gObjAddMsgSendDelay(lpTargetObj, 4, lpObj->m_Index, 100, 0);

  007a0	6a 00		 push	 0
  007a2	6a 64		 push	 100			; 00000064H
  007a4	ff 37		 push	 DWORD PTR [edi]
  007a6	6a 04		 push	 4
  007a8	56		 push	 esi
  007a9	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay

; 1827 : 				lpTargetObj->m_iMonsterBattleDelay = 10;

  007ae	c6 86 a9 05 00
	00 0a		 mov	 BYTE PTR [esi+1449], 10	; 0000000aH

; 1828 : 				GCActionSend(lpTargetObj, 126, lpTargetObj->m_Index, lpObj->m_Index);

  007b5	ff 37		 push	 DWORD PTR [edi]
  007b7	ff 36		 push	 DWORD PTR [esi]
  007b9	6a 7e		 push	 126			; 0000007eH
  007bb	56		 push	 esi
  007bc	e8 00 00 00 00	 call	 ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ; GCActionSend
  007c1	83 c4 24	 add	 esp, 36			; 00000024H
$LN123@Attack:

; 1829 : 			}
; 1830 : 		}
; 1831 : 	}
; 1832 : 
; 1833 : 	lpObj->m_Rest = 0;
; 1834 : 
; 1835 : 	if ( AttackDamage > 0 )

  007c4	8b 5d fc	 mov	 ebx, DWORD PTR _AttackDamage$1$[ebp]
  007c7	c6 87 d4 01 00
	00 00		 mov	 BYTE PTR [edi+468], 0
  007ce	85 db		 test	 ebx, ebx
  007d0	7e 71		 jle	 SHORT $LN124@Attack

; 1836 : 	{
; 1837 : 
; 1838 : 		if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER )

  007d2	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  007d6	75 23		 jne	 SHORT $LN126@Attack
  007d8	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  007dc	75 1d		 jne	 SHORT $LN126@Attack

; 1839 : 		{
; 1840 : 			int iTempShieldDamage = gclassObjAttack.GetShieldDamage(lpObj, lpTargetObj, AttackDamage);

  007de	53		 push	 ebx
  007df	56		 push	 esi
  007e0	57		 push	 edi
  007e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gclassObjAttack@@3VCObjAttack@@A ; gclassObjAttack
  007e6	e8 00 00 00 00	 call	 ?GetShieldDamage@CObjAttack@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjAttack::GetShieldDamage

; 1841 : 			lpTargetObj->iShield -= iTempShieldDamage;

  007eb	29 86 2c 01 00
	00		 sub	 DWORD PTR [esi+300], eax

; 1842 : 			lpTargetObj->Life -= AttackDamage - iTempShieldDamage;

  007f1	8b cb		 mov	 ecx, ebx
  007f3	2b c8		 sub	 ecx, eax
  007f5	66 0f 6e c1	 movd	 xmm0, ecx

; 1843 : 
; 1844 : 			if ( lpTargetObj->Life < 0.0f )
; 1845 : 			{
; 1846 : 				lpTargetObj->Life = 0.0f;
; 1847 : 			}
; 1848 : 		}
; 1849 : 		else

  007f9	eb 04		 jmp	 SHORT $LN164@Attack
$LN126@Attack:
  007fb	66 0f 6e c3	 movd	 xmm0, ebx
$LN164@Attack:

; 1850 : 		{
; 1851 : 			lpTargetObj->Life -= AttackDamage;

  007ff	f3 0f 10 8e d8
	00 00 00	 movss	 xmm1, DWORD PTR [esi+216]
  00807	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0080a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0080e	0f 57 c0	 xorps	 xmm0, xmm0

; 1852 : 
; 1853 : 			if ( lpTargetObj->Life < 0.0f )

  00811	0f 2f c1	 comiss	 xmm0, xmm1
  00814	f3 0f 11 8e d8
	00 00 00	 movss	 DWORD PTR [esi+216], xmm1
  0081c	76 0a		 jbe	 SHORT $LN129@Attack

; 1854 : 			{
; 1855 : 				lpTargetObj->Life = 0.0f;

  0081e	c7 86 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+216], 0
$LN129@Attack:

; 1856 : 			}
; 1857 : 		}
; 1858 : 
; 1859 : 		gObjLifeCheck(lpTargetObj,lpObj,AttackDamage,4,btElement,0,skill,0);

  00828	0f b6 45 08	 movzx	 eax, BYTE PTR _btElement$[ebp]
  0082c	6a 00		 push	 0
  0082e	ff 75 0c	 push	 DWORD PTR _skill$1$[ebp]
  00831	6a 00		 push	 0
  00833	50		 push	 eax
  00834	6a 04		 push	 4
  00836	53		 push	 ebx
  00837	57		 push	 edi
  00838	56		 push	 esi
  00839	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z ; gObjLifeCheck
  0083e	83 c4 20	 add	 esp, 32			; 00000020H

; 1860 : 	}
; 1861 : 	else

  00841	eb 11		 jmp	 SHORT $LN125@Attack
$LN124@Attack:

; 1862 : 	{
; 1863 : 		GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, btElement);

  00843	ff 75 08	 push	 DWORD PTR _btElement$[ebp]
  00846	6a 00		 push	 0
  00848	ff 36		 push	 DWORD PTR [esi]
  0084a	ff 37		 push	 DWORD PTR [edi]
  0084c	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHE@Z ; GCDamageSend
  00851	83 c4 10	 add	 esp, 16			; 00000010H
$LN125@Attack:

; 1864 : 	}
; 1865 : 
; 1866 : 	if ( lpObj->Life <= 0.0f && lpObj->Type == OBJ_USER )

  00854	0f 57 c0	 xorps	 xmm0, xmm0
  00857	0f 2f 87 d8 00
	00 00		 comiss	 xmm0, DWORD PTR [edi+216]
  0085e	72 2c		 jb	 SHORT $LN131@Attack
  00860	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00864	75 26		 jne	 SHORT $LN131@Attack

; 1867 : 	{
; 1868 : 		if ( lpObj->m_CheckLifeTime <= 0 )

  00866	83 bf 64 14 00
	00 00		 cmp	 DWORD PTR [edi+5220], 0
  0086d	7f 1d		 jg	 SHORT $LN131@Attack

; 1869 : 		{
; 1870 : 			lpObj->lpAttackObj = lpTargetObj;

  0086f	89 b7 b4 05 00
	00		 mov	 DWORD PTR [edi+1460], esi

; 1871 : 
; 1872 : 			if ( lpTargetObj->Type == OBJ_USER )

  00875	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1

; 1873 : 			{
; 1874 : 				lpObj->m_bAttackerKilled = true;
; 1875 : 			}
; 1876 : 			else
; 1877 : 			{
; 1878 : 				lpObj->m_bAttackerKilled = false;
; 1879 : 			}
; 1880 : 
; 1881 : 			lpObj->m_CheckLifeTime = 3;

  00879	c7 87 64 14 00
	00 03 00 00 00	 mov	 DWORD PTR [edi+5220], 3
  00883	0f 94 c1	 sete	 cl
  00886	88 8f c0 05 00
	00		 mov	 BYTE PTR [edi+1472], cl
$LN131@Attack:

; 1882 : 		}
; 1883 : 	}
; 1884 : 	return TRUE;

  0088c	5f		 pop	 edi
  0088d	5e		 pop	 esi
  0088e	b8 01 00 00 00	 mov	 eax, 1
  00893	5b		 pop	 ebx

; 1885 : }

  00894	8b e5		 mov	 esp, ebp
  00896	5d		 pop	 ebp
  00897	c2 0c 00	 ret	 12			; 0000000cH
  0089a	66 90		 npad	 2
$LN169@Attack:
  0089c	00 00 00 00	 DD	 $LN8@Attack
  008a0	00 00 00 00	 DD	 $LN9@Attack
$LN157@Attack:
  008a4	00		 DB	 0
  008a5	01		 DB	 1
  008a6	00		 DB	 0
  008a7	00		 DB	 0
  008a8	01		 DB	 1
  008a9	01		 DB	 1
  008aa	01		 DB	 1
  008ab	01		 DB	 1
  008ac	01		 DB	 1
  008ad	01		 DB	 1
  008ae	01		 DB	 1
  008af	01		 DB	 1
  008b0	01		 DB	 1
  008b1	01		 DB	 1
  008b2	01		 DB	 1
  008b3	01		 DB	 1
  008b4	01		 DB	 1
  008b5	01		 DB	 1
  008b6	01		 DB	 1
  008b7	01		 DB	 1
  008b8	01		 DB	 1
  008b9	01		 DB	 1
  008ba	01		 DB	 1
  008bb	01		 DB	 1
  008bc	01		 DB	 1
  008bd	01		 DB	 1
  008be	01		 DB	 1
  008bf	01		 DB	 1
  008c0	01		 DB	 1
  008c1	01		 DB	 1
  008c2	01		 DB	 1
  008c3	01		 DB	 1
  008c4	01		 DB	 1
  008c5	01		 DB	 1
  008c6	01		 DB	 1
  008c7	01		 DB	 1
  008c8	01		 DB	 1
  008c9	01		 DB	 1
  008ca	01		 DB	 1
  008cb	01		 DB	 1
  008cc	01		 DB	 1
  008cd	01		 DB	 1
  008ce	01		 DB	 1
  008cf	01		 DB	 1
  008d0	01		 DB	 1
  008d1	01		 DB	 1
  008d2	01		 DB	 1
  008d3	01		 DB	 1
  008d4	01		 DB	 1
  008d5	01		 DB	 1
  008d6	01		 DB	 1
  008d7	01		 DB	 1
  008d8	01		 DB	 1
  008d9	01		 DB	 1
  008da	01		 DB	 1
  008db	01		 DB	 1
  008dc	01		 DB	 1
  008dd	01		 DB	 1
  008de	01		 DB	 1
  008df	01		 DB	 1
  008e0	01		 DB	 1
  008e1	01		 DB	 1
  008e2	01		 DB	 1
  008e3	01		 DB	 1
  008e4	01		 DB	 1
  008e5	01		 DB	 1
  008e6	01		 DB	 1
  008e7	01		 DB	 1
  008e8	01		 DB	 1
  008e9	01		 DB	 1
  008ea	01		 DB	 1
  008eb	01		 DB	 1
  008ec	01		 DB	 1
  008ed	01		 DB	 1
  008ee	01		 DB	 1
  008ef	01		 DB	 1
  008f0	01		 DB	 1
  008f1	01		 DB	 1
  008f2	01		 DB	 1
  008f3	01		 DB	 1
  008f4	01		 DB	 1
  008f5	01		 DB	 1
  008f6	01		 DB	 1
  008f7	01		 DB	 1
  008f8	01		 DB	 1
  008f9	01		 DB	 1
  008fa	01		 DB	 1
  008fb	01		 DB	 1
  008fc	01		 DB	 1
  008fd	01		 DB	 1
  008fe	01		 DB	 1
  008ff	01		 DB	 1
  00900	01		 DB	 1
  00901	01		 DB	 1
  00902	01		 DB	 1
  00903	01		 DB	 1
  00904	01		 DB	 1
  00905	01		 DB	 1
  00906	01		 DB	 1
  00907	01		 DB	 1
  00908	01		 DB	 1
  00909	01		 DB	 1
  0090a	01		 DB	 1
  0090b	01		 DB	 1
  0090c	01		 DB	 1
  0090d	01		 DB	 1
  0090e	01		 DB	 1
  0090f	01		 DB	 1
  00910	01		 DB	 1
  00911	01		 DB	 1
  00912	01		 DB	 1
  00913	01		 DB	 1
  00914	01		 DB	 1
  00915	01		 DB	 1
  00916	01		 DB	 1
  00917	01		 DB	 1
  00918	01		 DB	 1
  00919	01		 DB	 1
  0091a	01		 DB	 1
  0091b	01		 DB	 1
  0091c	01		 DB	 1
  0091d	01		 DB	 1
  0091e	01		 DB	 1
  0091f	01		 DB	 1
  00920	01		 DB	 1
  00921	01		 DB	 1
  00922	01		 DB	 1
  00923	01		 DB	 1
  00924	01		 DB	 1
  00925	01		 DB	 1
  00926	01		 DB	 1
  00927	01		 DB	 1
  00928	01		 DB	 1
  00929	01		 DB	 1
  0092a	01		 DB	 1
  0092b	01		 DB	 1
  0092c	01		 DB	 1
  0092d	01		 DB	 1
  0092e	01		 DB	 1
  0092f	01		 DB	 1
  00930	01		 DB	 1
  00931	01		 DB	 1
  00932	01		 DB	 1
  00933	01		 DB	 1
  00934	01		 DB	 1
  00935	01		 DB	 1
  00936	01		 DB	 1
  00937	01		 DB	 1
  00938	01		 DB	 1
  00939	01		 DB	 1
  0093a	01		 DB	 1
  0093b	01		 DB	 1
  0093c	01		 DB	 1
  0093d	01		 DB	 1
  0093e	01		 DB	 1
  0093f	01		 DB	 1
  00940	01		 DB	 1
  00941	01		 DB	 1
  00942	01		 DB	 1
  00943	01		 DB	 1
  00944	01		 DB	 1
  00945	01		 DB	 1
  00946	01		 DB	 1
  00947	01		 DB	 1
  00948	01		 DB	 1
  00949	01		 DB	 1
  0094a	01		 DB	 1
  0094b	01		 DB	 1
  0094c	01		 DB	 1
  0094d	01		 DB	 1
  0094e	01		 DB	 1
  0094f	01		 DB	 1
  00950	01		 DB	 1
  00951	01		 DB	 1
  00952	01		 DB	 1
  00953	01		 DB	 1
  00954	01		 DB	 1
  00955	01		 DB	 1
  00956	01		 DB	 1
  00957	01		 DB	 1
  00958	01		 DB	 1
  00959	01		 DB	 1
  0095a	01		 DB	 1
  0095b	01		 DB	 1
  0095c	01		 DB	 1
  0095d	01		 DB	 1
  0095e	01		 DB	 1
  0095f	01		 DB	 1
  00960	01		 DB	 1
  00961	01		 DB	 1
  00962	01		 DB	 1
  00963	01		 DB	 1
  00964	01		 DB	 1
  00965	01		 DB	 1
  00966	01		 DB	 1
  00967	01		 DB	 1
  00968	01		 DB	 1
  00969	01		 DB	 1
  0096a	01		 DB	 1
  0096b	01		 DB	 1
  0096c	01		 DB	 1
  0096d	01		 DB	 1
  0096e	01		 DB	 1
  0096f	01		 DB	 1
  00970	01		 DB	 1
  00971	01		 DB	 1
  00972	01		 DB	 1
  00973	01		 DB	 1
  00974	01		 DB	 1
  00975	01		 DB	 1
  00976	01		 DB	 1
  00977	01		 DB	 1
  00978	01		 DB	 1
  00979	01		 DB	 1
  0097a	01		 DB	 1
  0097b	01		 DB	 1
  0097c	01		 DB	 1
  0097d	01		 DB	 1
  0097e	01		 DB	 1
  0097f	01		 DB	 1
  00980	01		 DB	 1
  00981	01		 DB	 1
  00982	01		 DB	 1
  00983	01		 DB	 1
  00984	01		 DB	 1
  00985	01		 DB	 1
  00986	01		 DB	 1
  00987	01		 DB	 1
  00988	01		 DB	 1
  00989	01		 DB	 1
  0098a	01		 DB	 1
  0098b	01		 DB	 1
  0098c	01		 DB	 1
  0098d	01		 DB	 1
  0098e	01		 DB	 1
  0098f	00		 DB	 0
  00990	01		 DB	 1
  00991	01		 DB	 1
  00992	01		 DB	 1
  00993	01		 DB	 1
  00994	00		 DB	 0
  00995	00		 DB	 0
?Attack@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0PAVCMagicInf@@@Z ENDP ; CElementalSystem::Attack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
; File c:\users\michel\desktop\source\gameserver\source\comboattack.h
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?MissCheckPvP@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_TargetLevel$1$ = 8					; size = 4
_lpObj$ = 8						; size = 4
_Level$1$ = 12						; size = 4
_lpTargetObj$ = 12					; size = 4
?MissCheckPvP@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z PROC ; CElementalSystem::MissCheckPvP, COMDAT
; _this$ = ecx

; 1075 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1076 : 	float iAttackRate = 0;
; 1077 : 	float iDefenseRate = 0;
; 1078 : 	int iAttackSuccessRate = 0;
; 1079 : 
; 1080 : 	if ( IT_MAP_RANGE(lpTargetObj->MapNumber) &&

  00006	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  0000f	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  00012	8a 97 23 01 00
	00		 mov	 dl, BYTE PTR [edi+291]
  00018	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  0001b	0f 82 95 00 00
	00		 jb	 $LN5@MissCheckP
  00021	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00026	3a c2		 cmp	 al, dl
  00028	1b c0		 sbb	 eax, eax
  0002a	83 c0 01	 add	 eax, 1
  0002d	0f 84 83 00 00
	00		 je	 $LN5@MissCheckP
  00033	52		 push	 edx
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00039	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  0003e	3c 02		 cmp	 al, 2
  00040	75 74		 jne	 SHORT $LN5@MissCheckP

; 1081 : 			 g_IllusionTemple.GetState(lpTargetObj->MapNumber) == IT_STATE_PLAYING)
; 1082 : 	{
; 1083 : 		if( lpTargetObj->Type == OBJ_USER )

  00042	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00046	75 3f		 jne	 SHORT $LN4@MissCheckP

; 1084 : 		{
; 1085 : 			if( g_IllusionTemple.Is1stSkillActive(lpTargetObj->iTempleIndex,lpTargetObj->MapNumber) )

  00048	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00054	50		 push	 eax
  00055	ff b7 78 24 00
	00		 push	 DWORD PTR [edi+9336]
  0005b	e8 00 00 00 00	 call	 ?Is1stSkillActive@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::Is1stSkillActive
  00060	85 c0		 test	 eax, eax
  00062	74 23		 je	 SHORT $LN4@MissCheckP

; 1086 : 			{
; 1087 : 				GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);

  00064	8b ce		 mov	 ecx, esi
  00066	0f b6 81 e4 26
	00 00		 movzx	 eax, BYTE PTR [ecx+9956]
  0006d	50		 push	 eax
  0006e	6a 00		 push	 0
  00070	ff 37		 push	 DWORD PTR [edi]
  00072	ff 31		 push	 DWORD PTR [ecx]

; 1093 : 		{
; 1094 : 			GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);

  00074	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHE@Z ; GCDamageSend
  00079	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@MissCheckP:

; 1124 : 		return FALSE;

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	33 c0		 xor	 eax, eax
  00080	5b		 pop	 ebx

; 1168 : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
$LN4@MissCheckP:

; 1088 : 				return FALSE;
; 1089 : 			}
; 1090 : 		}
; 1091 : 		
; 1092 : 		if( lpObj->PartyNumber == lpTargetObj->PartyNumber )

  00087	8b 86 0c 06 00
	00		 mov	 eax, DWORD PTR [esi+1548]
  0008d	3b 87 0c 06 00
	00		 cmp	 eax, DWORD PTR [edi+1548]
  00093	75 21		 jne	 SHORT $LN5@MissCheckP

; 1093 : 		{
; 1094 : 			GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);

  00095	0f b6 86 e4 26
	00 00		 movzx	 eax, BYTE PTR [esi+9956]
  0009c	50		 push	 eax
  0009d	6a 00		 push	 0
  0009f	ff 37		 push	 DWORD PTR [edi]
  000a1	ff 36		 push	 DWORD PTR [esi]
  000a3	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHE@Z ; GCDamageSend
  000a8	83 c4 10	 add	 esp, 16			; 00000010H

; 1124 : 		return FALSE;

  000ab	33 c0		 xor	 eax, eax
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx

; 1168 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN5@MissCheckP:

; 1095 : 			return FALSE;
; 1096 : 		}
; 1097 : 	}	
; 1098 : 
; 1099 : 	int Level = lpObj->Level + lpObj->MasterLevel;

  000b6	0f b7 86 96 00
	00 00		 movzx	 eax, WORD PTR [esi+150]
  000bd	0f bf 8e a8 00
	00 00		 movsx	 ecx, WORD PTR [esi+168]
  000c4	98		 cwde
  000c5	03 c8		 add	 ecx, eax

; 1100 : 
; 1101 : 	ELEMENT_CLASS_INFO* classInfo = &this->m_classinfo[lpObj->Class];

  000c7	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  000ce	8b d0		 mov	 edx, eax
  000d0	89 4d 0c	 mov	 DWORD PTR _Level$1$[ebp], ecx
  000d3	c1 e2 04	 shl	 edx, 4
  000d6	2b d0		 sub	 edx, eax

; 1102 : 
; 1103 : 	iAttackRate = Level*classInfo->AttRate_LEVELMUL_PVP;
; 1104 : 	iAttackRate += (lpObj->Strength+lpObj->AddStrength)*classInfo->AttRate_MUL_PVP[0];

  000d8	0f b7 86 d0 00
	00 00		 movzx	 eax, WORD PTR [esi+208]
  000df	66 0f 6e d9	 movd	 xmm3, ecx
  000e3	0f b7 8e fc 00
	00 00		 movzx	 ecx, WORD PTR [esi+252]
  000ea	03 c8		 add	 ecx, eax

; 1105 : 	iAttackRate += (lpObj->Dexterity+lpObj->AddDexterity)*classInfo->AttRate_MUL_PVP[1];

  000ec	0f b7 86 d2 00
	00 00		 movzx	 eax, WORD PTR [esi+210]
  000f3	f3 0f 10 44 d3
	64		 movss	 xmm0, DWORD PTR [ebx+edx*8+100]
  000f9	0f 5b db	 cvtdq2ps xmm3, xmm3
  000fc	66 0f 6e d1	 movd	 xmm2, ecx
  00100	0f b7 8e fe 00
	00 00		 movzx	 ecx, WORD PTR [esi+254]
  00107	03 c8		 add	 ecx, eax
  00109	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 1106 : 	iAttackRate += (lpObj->Vitality+lpObj->AddVitality)*classInfo->AttRate_MUL_PVP[2];

  0010d	0f b7 86 d4 00
	00 00		 movzx	 eax, WORD PTR [esi+212]
  00114	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00117	f3 0f 59 54 d3
	68		 mulss	 xmm2, DWORD PTR [ebx+edx*8+104]
  0011d	f3 0f 58 d0	 addss	 xmm2, xmm0
  00121	66 0f 6e c1	 movd	 xmm0, ecx
  00125	0f b7 8e 00 01
	00 00		 movzx	 ecx, WORD PTR [esi+256]
  0012c	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0012f	03 c8		 add	 ecx, eax

; 1107 : 	iAttackRate += (lpObj->Energy+lpObj->AddEnergy)*classInfo->AttRate_MUL_PVP[3];

  00131	0f b7 86 d6 00
	00 00		 movzx	 eax, WORD PTR [esi+214]
  00138	f3 0f 59 44 d3
	6c		 mulss	 xmm0, DWORD PTR [ebx+edx*8+108]
  0013e	f3 0f 58 d0	 addss	 xmm2, xmm0
  00142	66 0f 6e c1	 movd	 xmm0, ecx
  00146	0f b7 8e 02 01
	00 00		 movzx	 ecx, WORD PTR [esi+258]
  0014d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00150	03 c8		 add	 ecx, eax

; 1108 : 	iAttackRate += (lpObj->Leadership+lpObj->AddLeadership)*classInfo->AttRate_MUL_PVP[4];

  00152	0f b7 86 f4 00
	00 00		 movzx	 eax, WORD PTR [esi+244]
  00159	f3 0f 59 44 d3
	70		 mulss	 xmm0, DWORD PTR [ebx+edx*8+112]
  0015f	f3 0f 58 d0	 addss	 xmm2, xmm0
  00163	66 0f 6e c1	 movd	 xmm0, ecx
  00167	0f b7 8e f6 00
	00 00		 movzx	 ecx, WORD PTR [esi+246]
  0016e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00171	03 c8		 add	 ecx, eax

; 1109 : 
; 1110 : 	int TargetLevel = lpTargetObj->Level + lpTargetObj->MasterLevel;

  00173	0f b7 87 96 00
	00 00		 movzx	 eax, WORD PTR [edi+150]
  0017a	98		 cwde
  0017b	f3 0f 59 44 d3
	74		 mulss	 xmm0, DWORD PTR [ebx+edx*8+116]
  00181	f3 0f 58 d0	 addss	 xmm2, xmm0
  00185	66 0f 6e c1	 movd	 xmm0, ecx

; 1111 : 	classInfo = &this->m_classinfo[lpTargetObj->Class];
; 1112 : 
; 1113 : 	iDefenseRate = TargetLevel*classInfo->DefRate_LEVELMUL_PVP;
; 1114 : 	iDefenseRate += (lpTargetObj->Strength+lpTargetObj->AddStrength)*classInfo->DefRate_MUL_PVP[0];

  00189	0f b7 8f fc 00
	00 00		 movzx	 ecx, WORD PTR [edi+252]
  00190	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00193	f3 0f 59 44 d3
	78		 mulss	 xmm0, DWORD PTR [ebx+edx*8+120]
  00199	0f bf 9f a8 00
	00 00		 movsx	 ebx, WORD PTR [edi+168]
  001a0	03 d8		 add	 ebx, eax
  001a2	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  001a9	8b d0		 mov	 edx, eax
  001ab	89 5d 08	 mov	 DWORD PTR _TargetLevel$1$[ebp], ebx
  001ae	c1 e2 04	 shl	 edx, 4
  001b1	f3 0f 58 d0	 addss	 xmm2, xmm0
  001b5	2b d0		 sub	 edx, eax
  001b7	0f b7 87 d0 00
	00 00		 movzx	 eax, WORD PTR [edi+208]
  001be	03 c8		 add	 ecx, eax
  001c0	66 0f 6e c3	 movd	 xmm0, ebx
  001c4	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c7	8b d8		 mov	 ebx, eax
  001c9	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001cc	66 0f 6e c9	 movd	 xmm1, ecx
  001d0	f3 0f 59 44 d3
	4c		 mulss	 xmm0, DWORD PTR [ebx+edx*8+76]

; 1115 : 	iDefenseRate += (lpTargetObj->Dexterity+lpTargetObj->AddDexterity)*classInfo->DefRate_MUL_PVP[1];

  001d6	0f b7 8f fe 00
	00 00		 movzx	 ecx, WORD PTR [edi+254]
  001dd	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001e0	f3 0f 59 4c d0
	50		 mulss	 xmm1, DWORD PTR [eax+edx*8+80]
  001e6	0f b7 87 d2 00
	00 00		 movzx	 eax, WORD PTR [edi+210]
  001ed	03 c8		 add	 ecx, eax

; 1116 : 	iDefenseRate += (lpTargetObj->Vitality+lpTargetObj->AddVitality)*classInfo->DefRate_MUL_PVP[2];

  001ef	0f b7 87 d4 00
	00 00		 movzx	 eax, WORD PTR [edi+212]
  001f6	f3 0f 58 c8	 addss	 xmm1, xmm0
  001fa	66 0f 6e c1	 movd	 xmm0, ecx
  001fe	0f b7 8f 00 01
	00 00		 movzx	 ecx, WORD PTR [edi+256]
  00205	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00208	03 c8		 add	 ecx, eax
  0020a	f3 0f 59 44 d3
	54		 mulss	 xmm0, DWORD PTR [ebx+edx*8+84]
  00210	f3 0f 58 c8	 addss	 xmm1, xmm0
  00214	66 0f 6e c1	 movd	 xmm0, ecx
  00218	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0021b	f3 0f 59 44 d3
	58		 mulss	 xmm0, DWORD PTR [ebx+edx*8+88]

; 1117 : 	iDefenseRate += (lpTargetObj->Energy+lpTargetObj->AddEnergy)*classInfo->DefRate_MUL_PVP[3];

  00221	0f b7 87 d6 00
	00 00		 movzx	 eax, WORD PTR [edi+214]
  00228	0f b7 8f 02 01
	00 00		 movzx	 ecx, WORD PTR [edi+258]
  0022f	03 c8		 add	 ecx, eax

; 1118 : 	iDefenseRate += (lpTargetObj->Leadership+lpTargetObj->AddLeadership)*classInfo->DefRate_MUL_PVP[4];
; 1119 : 
; 1120 : 	iAttackRate += iAttackRate*lpObj->m_ElementalOptions->m_AddAttackRate/100;

  00231	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@42c80000
  00239	0f b7 87 f4 00
	00 00		 movzx	 eax, WORD PTR [edi+244]
  00240	f3 0f 58 c8	 addss	 xmm1, xmm0
  00244	66 0f 6e c1	 movd	 xmm0, ecx
  00248	0f b7 8f f6 00
	00 00		 movzx	 ecx, WORD PTR [edi+246]
  0024f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00252	03 c8		 add	 ecx, eax
  00254	8b 86 fc 26 00
	00		 mov	 eax, DWORD PTR [esi+9980]
  0025a	66 0f 6e 60 58	 movd	 xmm4, DWORD PTR [eax+88]
  0025f	f3 0f 59 44 d3
	5c		 mulss	 xmm0, DWORD PTR [ebx+edx*8+92]

; 1121 : 	iDefenseRate += iDefenseRate*lpTargetObj->m_ElementalOptions->m_AddDefenseRate/100;

  00265	8b 87 fc 26 00
	00		 mov	 eax, DWORD PTR [edi+9980]
  0026b	0f 5b e4	 cvtdq2ps xmm4, xmm4
  0026e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00272	66 0f 6e c1	 movd	 xmm0, ecx
  00276	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00279	f3 0f 59 e2	 mulss	 xmm4, xmm2
  0027d	f3 0f 59 44 d3
	60		 mulss	 xmm0, DWORD PTR [ebx+edx*8+96]
  00283	f3 0f 5e e5	 divss	 xmm4, xmm5
  00287	f3 0f 58 c8	 addss	 xmm1, xmm0
  0028b	66 0f 6e 40 5c	 movd	 xmm0, DWORD PTR [eax+92]
  00290	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00293	f3 0f 58 e2	 addss	 xmm4, xmm2
  00297	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0029b	f3 0f 5e c5	 divss	 xmm0, xmm5
  0029f	f3 0f 58 c1	 addss	 xmm0, xmm1
  002a3	0f 57 c9	 xorps	 xmm1, xmm1

; 1122 : 
; 1123 : 	if ( iAttackRate <= 0.0f || iDefenseRate <= 0.0f || lpObj->Level <= 0 || lpTargetObj->Level <= 0 )

  002a6	0f 2f cc	 comiss	 xmm1, xmm4
  002a9	0f 83 cd fd ff
	ff		 jae	 $LN7@MissCheckP
  002af	0f 2f c8	 comiss	 xmm1, xmm0
  002b2	0f 83 c4 fd ff
	ff		 jae	 $LN7@MissCheckP
  002b8	0f b7 86 96 00
	00 00		 movzx	 eax, WORD PTR [esi+150]
  002bf	66 85 c0	 test	 ax, ax
  002c2	0f 8e b4 fd ff
	ff		 jle	 $LN7@MissCheckP
  002c8	0f b7 87 96 00
	00 00		 movzx	 eax, WORD PTR [edi+150]
  002cf	66 85 c0	 test	 ax, ax
  002d2	0f 8e a4 fd ff
	ff		 jle	 $LN7@MissCheckP

; 1125 : 
; 1126 : 	float iExpressionA = ( iAttackRate * 10000.0f ) / ( iAttackRate + iDefenseRate );	// #formula

  002d8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@461c4000
  002e0	f3 0f 58 c4	 addss	 xmm0, xmm4

; 1127 : 	float iExpressionB = ( Level * 10000.0f ) / ( Level + TargetLevel );	// #formula

  002e4	8b 4d 08	 mov	 ecx, DWORD PTR _TargetLevel$1$[ebp]
  002e7	0f 28 d4	 movaps	 xmm2, xmm4
  002ea	8b 55 0c	 mov	 edx, DWORD PTR _Level$1$[ebp]
  002ed	f3 0f 59 d1	 mulss	 xmm2, xmm1
  002f1	f3 0f 59 d9	 mulss	 xmm3, xmm1
  002f5	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1128 : 
; 1129 : 	iExpressionA /= 10000.0f;
; 1130 : 	iExpressionB /= 10000.0f;
; 1131 : 
; 1132 : 	iAttackSuccessRate = (int)(100.0f * iExpressionA * g_fSuccessAttackRateOption * iExpressionB);
; 1133 : 
; 1134 : 	if ( (TargetLevel - Level) >= 100 )

  002f8	2b ca		 sub	 ecx, edx
  002fa	f3 0f 5e d0	 divss	 xmm2, xmm0
  002fe	66 0f 6e c0	 movd	 xmm0, eax
  00302	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00305	f3 0f 5e d1	 divss	 xmm2, xmm1
  00309	f3 0f 5e d8	 divss	 xmm3, xmm0
  0030d	f3 0f 59 d5	 mulss	 xmm2, xmm5
  00311	f3 0f 5e d9	 divss	 xmm3, xmm1
  00315	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR ?g_fSuccessAttackRateOption@@3MA
  0031d	f3 0f 59 d3	 mulss	 xmm2, xmm3
  00321	f3 0f 2c da	 cvttss2si ebx, xmm2
  00325	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00328	7c 05		 jl	 SHORT $LN8@MissCheckP

; 1135 : 	{
; 1136 : 		iAttackSuccessRate -= 5;

  0032a	83 eb 05	 sub	 ebx, 5
  0032d	eb 18		 jmp	 SHORT $LN12@MissCheckP
$LN8@MissCheckP:

; 1137 : 	}
; 1138 : 	else if ( (TargetLevel - Level ) >= 200 )

  0032f	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  00335	7c 05		 jl	 SHORT $LN10@MissCheckP

; 1139 : 	{
; 1140 : 		iAttackSuccessRate -= 10;

  00337	83 eb 0a	 sub	 ebx, 10			; 0000000aH
  0033a	eb 0b		 jmp	 SHORT $LN12@MissCheckP
$LN10@MissCheckP:

; 1141 : 	}
; 1142 : 	else if ( (TargetLevel - Level) >= 300 )

  0033c	81 f9 2c 01 00
	00		 cmp	 ecx, 300		; 0000012cH
  00342	7c 03		 jl	 SHORT $LN12@MissCheckP

; 1143 : 	{
; 1144 : 		iAttackSuccessRate -= 15;

  00344	83 eb 0f	 sub	 ebx, 15			; 0000000fH
$LN12@MissCheckP:

; 1145 : 	}
; 1146 : 
; 1147 : 	int dwRate = rand() % 100;

  00347	e8 00 00 00 00	 call	 _rand
  0034c	99		 cdq
  0034d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00352	f7 f9		 idiv	 ecx

; 1148 : 
; 1149 : 	if ( dwRate > iAttackSuccessRate )

  00354	3b d3		 cmp	 edx, ebx
  00356	7e 79		 jle	 SHORT $LN13@MissCheckP

; 1150 : 	{
; 1151 : 		GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);

  00358	0f b6 86 e4 26
	00 00		 movzx	 eax, BYTE PTR [esi+9956]
  0035f	50		 push	 eax
  00360	6a 00		 push	 0
  00362	ff 37		 push	 DWORD PTR [edi]
  00364	ff 36		 push	 DWORD PTR [esi]
  00366	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHE@Z ; GCDamageSend
  0036b	83 c4 10	 add	 esp, 16			; 00000010H

; 1152 : 
; 1153 : 		if ( g_bShieldComboMissOptionOn == TRUE )

  0036e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bShieldComboMissOptionOn@@3HA, 1 ; g_bShieldComboMissOptionOn
  00375	0f 85 01 fd ff
	ff		 jne	 $LN7@MissCheckP

; 1154 : 		{
; 1155 : 			if ( lpObj->comboSkill.ProgressIndex >= 0 )

  0037b	83 be 8c 00 00
	00 00		 cmp	 DWORD PTR [esi+140], 0
  00382	0f 8c f4 fc ff
	ff		 jl	 $LN7@MissCheckP

; 1156 : 			{
; 1157 : 				LogAddTD("[Shield] ComboSkill Cancel! [%s][%s]",

  00388	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0038b	50		 push	 eax
  0038c	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0038f	50		 push	 eax
  00390	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JAMJMJON@?$FLShield?$FN?5ComboSkill?5Cancel?$CB?5?$FL?$CFs?$FN@
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0039b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\michel\desktop\source\gameserver\source\comboattack.h

; 19   : 		this->dwTime = 0;

  0039e	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0

; 20   : 		this->Skill[0] = -1;

  003a8	83 c8 ff	 or	 eax, -1
  003ab	66 89 86 84 00
	00 00		 mov	 WORD PTR [esi+132], ax

; 21   : 		this->Skill[1] = -1;

  003b2	66 89 86 86 00
	00 00		 mov	 WORD PTR [esi+134], ax

; 22   : 		this->Skill[2] = -1;

  003b9	66 89 86 88 00
	00 00		 mov	 WORD PTR [esi+136], ax
  003c0	5f		 pop	 edi

; 23   : 		this->ProgressIndex = -1;

  003c1	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp

; 1124 : 		return FALSE;

  003c7	33 c0		 xor	 eax, eax
  003c9	5e		 pop	 esi
  003ca	5b		 pop	 ebx

; 1168 : }

  003cb	8b e5		 mov	 esp, ebp
  003cd	5d		 pop	 ebp
  003ce	c2 08 00	 ret	 8
$LN13@MissCheckP:
  003d1	5f		 pop	 edi
  003d2	5e		 pop	 esi

; 1158 : 					lpObj->AccountID, lpObj->Name);
; 1159 : 
; 1160 : 				lpObj->comboSkill.Init();
; 1161 : 			}
; 1162 : 		}
; 1163 : 
; 1164 : 		return FALSE;
; 1165 : 	}
; 1166 : 
; 1167 : 	return TRUE;

  003d3	b8 01 00 00 00	 mov	 eax, 1
  003d8	5b		 pop	 ebx

; 1168 : }

  003d9	8b e5		 mov	 esp, ebp
  003db	5d		 pop	 ebp
  003dc	c2 08 00	 ret	 8
?MissCheckPvP@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP ; CElementalSystem::MissCheckPvP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?MissCheck@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_iDefenseRate$2 = -32					; size = 4
_this$1$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
_iAttackRate$2$ = 12					; size = 4
_lpTargetObj$ = 12					; size = 4
?MissCheck@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z PROC ; CElementalSystem::MissCheck, COMDAT
; _this$ = ecx

; 980  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?MissCheck@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 10	 sub	 esp, 16			; 00000010H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR _this$1$[ebp], ecx

; 981  : #if(__NOVUS__==1)
; 982  : 	if( lpObj->Type == OBJ_MONSTER && lpTargetObj->Type == OBJ_USER )
; 983  : 	{
; 984  : 		if( g_SoulSystem.IsMap(lpTargetObj->MapNumber) && !g_SoulSystem.WithSoul(lpTargetObj) )
; 985  : 		{
; 986  : 			LogAddC(2, "[DEBUG] [SoulSystem] [%s] Miss ignored", lpTargetObj->Name);
; 987  : 			return 1;
; 988  : 		}
; 989  : 	}
; 990  : #endif
; 991  : 
; 992  : 	__try

  00036	9b		 fwait
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 993  : 	{
; 994  : 		BOOL bAllMiss = FALSE;
; 995  : 		int iAttackRate = 0;
; 996  : 		int iDefenseRate = lpTargetObj->m_ElementalDefenseRate;

  0003e	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  00041	8b b7 f8 26 00
	00		 mov	 esi, DWORD PTR [edi+9976]
  00047	89 75 e0	 mov	 DWORD PTR _iDefenseRate$2[ebp], esi

; 997  : 		
; 998  : 		if( lpTargetObj->Type == OBJ_USER )

  0004a	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0004e	75 22		 jne	 SHORT $LN24@MissCheck

; 999  : 		{
; 1000 : 			iDefenseRate += iDefenseRate*lpTargetObj->m_ElementalOptions->m_AddDefenseRate/100;

  00050	8b 87 fc 26 00
	00		 mov	 eax, DWORD PTR [edi+9980]
  00056	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00059	0f af ce	 imul	 ecx, esi
  0005c	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00061	f7 e9		 imul	 ecx
  00063	c1 fa 05	 sar	 edx, 5
  00066	8b c2		 mov	 eax, edx
  00068	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0006b	03 c2		 add	 eax, edx
  0006d	03 f0		 add	 esi, eax
  0006f	89 75 e0	 mov	 DWORD PTR _iDefenseRate$2[ebp], esi
$LN24@MissCheck:

; 1001 : 		}
; 1002 : 
; 1003 : 		if ( IT_MAP_RANGE(lpTargetObj->MapNumber) && g_IllusionTemple.GetState(lpTargetObj->MapNumber) == IT_STATE_PLAYING)

  00072	8a 8f 23 01 00
	00		 mov	 cl, BYTE PTR [edi+291]
  00078	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0007b	0f 82 86 00 00
	00		 jb	 $LN25@MissCheck
  00081	b0 32		 mov	 al, 50			; 00000032H
  00083	3a c1		 cmp	 al, cl
  00085	1b c0		 sbb	 eax, eax
  00087	83 c0 01	 add	 eax, 1
  0008a	74 7b		 je	 SHORT $LN25@MissCheck
  0008c	51		 push	 ecx
  0008d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00092	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  00097	3c 02		 cmp	 al, 2
  00099	75 6c		 jne	 SHORT $LN25@MissCheck

; 1004 : 		{
; 1005 : 			if( lpTargetObj->Type == OBJ_USER )

  0009b	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0009f	75 3a		 jne	 SHORT $LN6@MissCheck

; 1006 : 			{
; 1007 : 				if( g_IllusionTemple.Is1stSkillActive(lpTargetObj->iTempleIndex,lpTargetObj->MapNumber) )

  000a1	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  000a8	50		 push	 eax
  000a9	ff b7 78 24 00
	00		 push	 DWORD PTR [edi+9336]
  000af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000b4	e8 00 00 00 00	 call	 ?Is1stSkillActive@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::Is1stSkillActive
  000b9	85 c0		 test	 eax, eax
  000bb	74 1e		 je	 SHORT $LN6@MissCheck

; 1008 : 				{
; 1009 : 					GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);

  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c0	0f b6 81 e4 26
	00 00		 movzx	 eax, BYTE PTR [ecx+9956]
  000c7	50		 push	 eax
  000c8	6a 00		 push	 0
  000ca	ff 37		 push	 DWORD PTR [edi]
  000cc	ff 31		 push	 DWORD PTR [ecx]
  000ce	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHE@Z ; GCDamageSend
  000d3	83 c4 10	 add	 esp, 16			; 00000010H

; 1010 : 					return FALSE;

  000d6	e9 11 02 00 00	 jmp	 $LN27@MissCheck
$LN6@MissCheck:

; 1011 : 				}
; 1012 : 			}
; 1013 : 			
; 1014 : 			if( lpObj->PartyNumber == lpTargetObj->PartyNumber )

  000db	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  000de	8b 83 0c 06 00
	00		 mov	 eax, DWORD PTR [ebx+1548]
  000e4	3b 87 0c 06 00
	00		 cmp	 eax, DWORD PTR [edi+1548]
  000ea	75 1e		 jne	 SHORT $LN7@MissCheck
$LN28@MissCheck:

; 1015 : 			{
; 1016 : 				GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);

  000ec	0f b6 83 e4 26
	00 00		 movzx	 eax, BYTE PTR [ebx+9956]
  000f3	50		 push	 eax
  000f4	6a 00		 push	 0
  000f6	ff 37		 push	 DWORD PTR [edi]
  000f8	ff 33		 push	 DWORD PTR [ebx]
  000fa	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHE@Z ; GCDamageSend
  000ff	83 c4 10	 add	 esp, 16			; 00000010H

; 1017 : 				return FALSE;

  00102	e9 e5 01 00 00	 jmp	 $LN27@MissCheck
$LN25@MissCheck:
  00107	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
$LN7@MissCheck:

; 1018 : 			}
; 1019 : 		}	
; 1020 : 
; 1021 : 		if ( lpObj->Type == OBJ_USER )	// Miss for Uses

  0010a	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  0010e	0f 85 38 01 00
	00		 jne	 $LN8@MissCheck

; 1022 : 		{
; 1023 : 			int Level = lpObj->Level + lpObj->MasterLevel;

  00114	0f bf 93 a8 00
	00 00		 movsx	 edx, WORD PTR [ebx+168]
  0011b	0f bf 83 96 00
	00 00		 movsx	 eax, WORD PTR [ebx+150]
  00122	03 d0		 add	 edx, eax

; 1024 : 			ELEMENT_CLASS_INFO* classInfo = &this->m_classinfo[lpObj->Class];

  00124	0f b7 83 90 00
	00 00		 movzx	 eax, WORD PTR [ebx+144]
  0012b	8b f0		 mov	 esi, eax
  0012d	c1 e6 04	 shl	 esi, 4
  00130	2b f0		 sub	 esi, eax

; 1026 : 			iAttackRate += (lpObj->Strength+lpObj->AddStrength)*classInfo->AttRate_MUL[0];

  00132	0f b7 8b fc 00
	00 00		 movzx	 ecx, WORD PTR [ebx+252]
  00139	0f b7 83 d0 00
	00 00		 movzx	 eax, WORD PTR [ebx+208]
  00140	03 c8		 add	 ecx, eax
  00142	66 0f 6e c9	 movd	 xmm1, ecx
  00146	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00149	8b 45 e4	 mov	 eax, DWORD PTR _this$1$[ebp]
  0014c	f3 0f 59 4c f0
	38		 mulss	 xmm1, DWORD PTR [eax+esi*8+56]
  00152	66 0f 6e c2	 movd	 xmm0, edx

; 1025 : 			iAttackRate = Level*classInfo->AttRate_LEVELMUL;

  00156	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00159	8b d0		 mov	 edx, eax
  0015b	f3 0f 59 44 f2
	34		 mulss	 xmm0, DWORD PTR [edx+esi*8+52]
  00161	f3 0f 2c c0	 cvttss2si eax, xmm0
  00165	66 0f 6e c0	 movd	 xmm0, eax

; 1026 : 			iAttackRate += (lpObj->Strength+lpObj->AddStrength)*classInfo->AttRate_MUL[0];

  00169	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0016c	f3 0f 58 c8	 addss	 xmm1, xmm0
  00170	f3 0f 2c c1	 cvttss2si eax, xmm1
  00174	66 0f 6e c8	 movd	 xmm1, eax

; 1027 : 			iAttackRate += (lpObj->Dexterity+lpObj->AddDexterity)*classInfo->AttRate_MUL[1];

  00178	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0017b	0f b7 8b fe 00
	00 00		 movzx	 ecx, WORD PTR [ebx+254]
  00182	0f b7 83 d2 00
	00 00		 movzx	 eax, WORD PTR [ebx+210]
  00189	03 c8		 add	 ecx, eax
  0018b	66 0f 6e c1	 movd	 xmm0, ecx
  0018f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00192	f3 0f 59 44 f2
	3c		 mulss	 xmm0, DWORD PTR [edx+esi*8+60]
  00198	f3 0f 58 c8	 addss	 xmm1, xmm0
  0019c	f3 0f 2c c1	 cvttss2si eax, xmm1
  001a0	66 0f 6e c8	 movd	 xmm1, eax

; 1028 : 			iAttackRate += (lpObj->Vitality+lpObj->AddVitality)*classInfo->AttRate_MUL[2];

  001a4	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001a7	0f b7 8b 00 01
	00 00		 movzx	 ecx, WORD PTR [ebx+256]
  001ae	0f b7 83 d4 00
	00 00		 movzx	 eax, WORD PTR [ebx+212]
  001b5	03 c8		 add	 ecx, eax
  001b7	66 0f 6e c1	 movd	 xmm0, ecx
  001bb	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001be	f3 0f 59 44 f2
	40		 mulss	 xmm0, DWORD PTR [edx+esi*8+64]
  001c4	f3 0f 58 c8	 addss	 xmm1, xmm0
  001c8	f3 0f 2c c1	 cvttss2si eax, xmm1
  001cc	66 0f 6e c8	 movd	 xmm1, eax

; 1029 : 			iAttackRate += (lpObj->Energy+lpObj->AddEnergy)*classInfo->AttRate_MUL[3];

  001d0	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001d3	0f b7 8b 02 01
	00 00		 movzx	 ecx, WORD PTR [ebx+258]
  001da	0f b7 83 d6 00
	00 00		 movzx	 eax, WORD PTR [ebx+214]
  001e1	03 c8		 add	 ecx, eax
  001e3	66 0f 6e c1	 movd	 xmm0, ecx
  001e7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001ea	f3 0f 59 44 f2
	44		 mulss	 xmm0, DWORD PTR [edx+esi*8+68]
  001f0	f3 0f 58 c8	 addss	 xmm1, xmm0
  001f4	f3 0f 2c c1	 cvttss2si eax, xmm1
  001f8	66 0f 6e c8	 movd	 xmm1, eax

; 1030 : 			iAttackRate += (lpObj->Leadership+lpObj->AddLeadership)*classInfo->AttRate_MUL[4];

  001fc	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001ff	0f b7 8b f6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+246]
  00206	0f b7 83 f4 00
	00 00		 movzx	 eax, WORD PTR [ebx+244]
  0020d	03 c8		 add	 ecx, eax
  0020f	66 0f 6e c1	 movd	 xmm0, ecx
  00213	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00216	f3 0f 59 44 f2
	48		 mulss	 xmm0, DWORD PTR [edx+esi*8+72]
  0021c	f3 0f 58 c8	 addss	 xmm1, xmm0
  00220	f3 0f 2c c1	 cvttss2si eax, xmm1

; 1031 : 			iAttackRate += iAttackRate*lpObj->m_ElementalOptions->m_AddAttackRate/100;

  00224	8b 8b fc 26 00
	00		 mov	 ecx, DWORD PTR [ebx+9980]
  0022a	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  0022d	0f af c8	 imul	 ecx, eax
  00230	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00235	f7 e9		 imul	 ecx
  00237	c1 fa 05	 sar	 edx, 5
  0023a	8b c2		 mov	 eax, edx
  0023c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0023f	03 c2		 add	 eax, edx
  00241	f3 0f 2c c9	 cvttss2si ecx, xmm1
  00245	03 c8		 add	 ecx, eax

; 1032 : 		}
; 1033 : 		else	// Miss for Monsters

  00247	8b 75 e0	 mov	 esi, DWORD PTR _iDefenseRate$2[ebp]
  0024a	eb 06		 jmp	 SHORT $LN9@MissCheck
$LN8@MissCheck:

; 1034 : 		{
; 1035 : 			iAttackRate = lpObj->m_ElementalAttackRate;

  0024c	8b 8b f4 26 00
	00		 mov	 ecx, DWORD PTR [ebx+9972]
$LN9@MissCheck:

; 1036 : 		}
; 1037 : 
; 1038 : 		if ( iAttackRate < iDefenseRate )

  00252	ba 01 00 00 00	 mov	 edx, 1
  00257	3b ce		 cmp	 ecx, esi
  00259	b8 00 00 00 00	 mov	 eax, 0
  0025e	0f 4c c2	 cmovl	 eax, edx

; 1039 : 		{
; 1040 : 			bAllMiss = TRUE;
; 1041 : 		}
; 1042 : 
; 1043 : 		if( iAttackRate < 1 )

  00261	3b ca		 cmp	 ecx, edx
  00263	0f 4c ca	 cmovl	 ecx, edx
  00266	89 4d 0c	 mov	 DWORD PTR _iAttackRate$2$[ebp], ecx

; 1044 : 		{
; 1045 : 			iAttackRate = 1;
; 1046 : 		}
; 1047 : 
; 1048 : 		if ( bAllMiss != FALSE )	// When All Miss

  00269	85 c0		 test	 eax, eax
  0026b	74 17		 je	 SHORT $LN12@MissCheck

; 1049 : 		{
; 1050 : 			if ( (rand()%100) >= 5 )

  0026d	e8 00 00 00 00	 call	 _rand
  00272	99		 cdq
  00273	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00278	f7 f9		 idiv	 ecx
  0027a	83 fa 05	 cmp	 edx, 5
  0027d	7c 16		 jl	 SHORT $LN15@MissCheck

; 1051 : 			{
; 1052 : 				GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);
; 1053 : 				return FALSE;

  0027f	e9 68 fe ff ff	 jmp	 $LN28@MissCheck
$LN12@MissCheck:

; 1054 : 			}
; 1055 : 		}
; 1056 : 		else	// if the is a chance  ot hit the target
; 1057 : 		{
; 1058 : 			if ( (rand()%iAttackRate) < iDefenseRate)

  00284	e8 00 00 00 00	 call	 _rand
  00289	99		 cdq
  0028a	f7 7d 0c	 idiv	 DWORD PTR _iAttackRate$2$[ebp]
  0028d	3b d6		 cmp	 edx, esi
  0028f	0f 8c 57 fe ff
	ff		 jl	 $LN28@MissCheck
$LN15@MissCheck:

; 1059 : 			{
; 1060 : 				GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, lpObj->m_btAttribute);
; 1061 : 				return FALSE;
; 1062 : 			}
; 1063 : 		}
; 1064 : 	}

  00295	9b		 fwait
  00296	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 1069 : 	}
; 1070 : 
; 1071 : 	return TRUE;

  0029d	b8 01 00 00 00	 mov	 eax, 1

; 1072 : }

  002a2	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  002a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ac	59		 pop	 ecx
  002ad	5f		 pop	 edi
  002ae	5e		 pop	 esi
  002af	5b		 pop	 ebx
  002b0	8b e5		 mov	 esp, ebp
  002b2	5d		 pop	 ebp
  002b3	c2 08 00	 ret	 8
$LN20@MissCheck:
$LN29@MissCheck:

; 1065 : 	__except (lpObj->Level=1,-1)

  002b6	b9 01 00 00 00	 mov	 ecx, 1
  002bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002be	66 89 88 96 00
	00 00		 mov	 WORD PTR [eax+150], cx
  002c5	83 c8 ff	 or	 eax, -1
$LN26@MissCheck:
$LN22@MissCheck:
  002c8	c3		 ret	 0
$LN21@MissCheck:
  002c9	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 1066 : 	{
; 1067 : 		LogAdd(lMsg.Get(MSGGET(2, 12)), lpObj->Name);

  002cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cf	83 c0 5d	 add	 eax, 93			; 0000005dH
  002d2	50		 push	 eax
  002d3	68 0c 02 00 00	 push	 524			; 0000020cH
  002d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002dd	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002e2	50		 push	 eax
  002e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002e9	83 c4 08	 add	 esp, 8
$LN27@MissCheck:

; 1068 : 		return FALSE;

  002ec	9b		 fwait
  002ed	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  002f4	33 c0		 xor	 eax, eax

; 1072 : }

  002f6	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  002f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00300	59		 pop	 ecx
  00301	5f		 pop	 edi
  00302	5e		 pop	 esi
  00303	5b		 pop	 ebx
  00304	8b e5		 mov	 esp, ebp
  00306	5d		 pop	 ebp
  00307	c2 08 00	 ret	 8
?MissCheck@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP ; CElementalSystem::MissCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ApplyBonusOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z
_TEXT	SEGMENT
tv322 = -8						; size = 4
_this$1$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpPentagram$ = 12					; size = 4
?ApplyBonusOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z PROC ; CElementalSystem::ApplyBonusOptions, COMDAT
; _this$ = ecx

; 885  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 886  : 	PENTAGRAM_OPTION* pPentagramInfo = GetPentagram(lpPentagram->m_Type);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _lpPentagram$[ebp]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi
  0000f	0f bf 40 06	 movsx	 eax, WORD PTR [eax+6]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?GetPentagram@CElementalSystem@@QAEPAUPENTAGRAM_OPTION@@H@Z ; CElementalSystem::GetPentagram

; 887  : 
; 888  : 	if( pPentagramInfo == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	0f 84 bf 00 00
	00		 je	 $LN3@ApplyBonus

; 889  : 		return;
; 890  : 
; 891  : 	for(int i = 0; i < 9; i++)

  00021	53		 push	 ebx
  00022	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00025	56		 push	 esi
  00026	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  00029	c7 45 f8 09 00
	00 00		 mov	 DWORD PTR tv322[ebp], 9
$LL4@ApplyBonus:

; 892  : 	{
; 893  : 		if( pPentagramInfo->m_btOption[i] != 0 )

  00030	8a 06		 mov	 al, BYTE PTR [esi]
  00032	84 c0		 test	 al, al
  00034	0f 84 99 00 00
	00		 je	 $LN2@ApplyBonus

; 894  : 		{
; 895  : 			PENTAGRAM_OPTION_INFO* pPentagramOption = this->GetPentagramOption(pPentagramInfo->m_btOption[i]);

  0003a	0f b6 c0	 movzx	 eax, al
  0003d	8b cf		 mov	 ecx, edi
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?GetPentagramOption@CElementalSystem@@QAEPAUPENTAGRAM_OPTION_INFO@@H@Z ; CElementalSystem::GetPentagramOption
  00045	8b f8		 mov	 edi, eax

; 896  : 
; 897  : 			if( pPentagramOption == NULL )

  00047	85 ff		 test	 edi, edi
  00049	0f 84 81 00 00
	00		 je	 $LN26@ApplyBonus

; 898  : 				continue;
; 899  : 
; 900  : 			if( !CheckBonusRequirement(lpObj,lpPentagram,pPentagramOption) )

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00052	57		 push	 edi
  00053	ff 75 0c	 push	 DWORD PTR _lpPentagram$[ebp]
  00056	53		 push	 ebx
  00057	e8 00 00 00 00	 call	 ?CheckBonusRequirement@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@PAVCItem@@PAUPENTAGRAM_OPTION_INFO@@@Z ; CElementalSystem::CheckBonusRequirement
  0005c	85 c0		 test	 eax, eax
  0005e	74 70		 je	 SHORT $LN26@ApplyBonus

; 901  : 				continue;
; 902  : 
; 903  : 			switch( pPentagramOption->m_btOptionID )

  00060	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00063	48		 dec	 eax
  00064	83 f8 06	 cmp	 eax, 6
  00067	77 67		 ja	 SHORT $LN26@ApplyBonus
  00069	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN28@ApplyBonus[eax*4]
$LN11@ApplyBonus:

; 904  : 			{
; 905  : 			case 1:
; 906  : 				lpObj->m_ElementalOptions->m_AddPentagramDamage += 10;

  00070	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  00076	83 40 78 0a	 add	 DWORD PTR [eax+120], 10	; 0000000aH

; 907  : 				break;

  0007a	eb 54		 jmp	 SHORT $LN26@ApplyBonus
$LN12@ApplyBonus:

; 908  : 			case 2:
; 909  : 				lpObj->m_ElementalOptions->m_AddPentagramDefense += 10;

  0007c	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  00082	83 40 7c 0a	 add	 DWORD PTR [eax+124], 10	; 0000000aH

; 910  : 				break;

  00086	eb 48		 jmp	 SHORT $LN26@ApplyBonus
$LN13@ApplyBonus:

; 911  : 			case 3:
; 912  : 				lpObj->m_ElementalOptions->m_AddCritRate += 10;

  00088	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  0008e	83 80 80 00 00
	00 0a		 add	 DWORD PTR [eax+128], 10	; 0000000aH

; 913  : 				break;

  00095	eb 39		 jmp	 SHORT $LN26@ApplyBonus
$LN14@ApplyBonus:

; 914  : 			case 4:
; 915  : 				lpObj->m_ElementalOptions->m_DefToElement += 5;

  00097	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  0009d	83 80 84 00 00
	00 05		 add	 DWORD PTR [eax+132], 5

; 916  : 				break;

  000a4	eb 2a		 jmp	 SHORT $LN26@ApplyBonus
$LN15@ApplyBonus:

; 917  : 			case 5:
; 918  : 				lpObj->m_ElementalOptions->m_AttToElement += 1;

  000a6	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  000ac	ff 80 88 00 00
	00		 inc	 DWORD PTR [eax+136]

; 919  : 				break;

  000b2	eb 1c		 jmp	 SHORT $LN26@ApplyBonus
$LN16@ApplyBonus:

; 920  : 			case 6:
; 921  : 				lpObj->m_ElementalOptions->m_ResistStrongElement += 10;

  000b4	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  000ba	83 80 8c 00 00
	00 0a		 add	 DWORD PTR [eax+140], 10	; 0000000aH

; 922  : 				break;

  000c1	eb 0d		 jmp	 SHORT $LN26@ApplyBonus
$LN17@ApplyBonus:

; 923  : 			case 7:
; 924  : 				lpObj->m_ElementalOptions->m_ResistElement += 10;

  000c3	8b 83 fc 26 00
	00		 mov	 eax, DWORD PTR [ebx+9980]
  000c9	83 80 90 00 00
	00 0a		 add	 DWORD PTR [eax+144], 10	; 0000000aH
$LN26@ApplyBonus:
  000d0	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
$LN2@ApplyBonus:

; 889  : 		return;
; 890  : 
; 891  : 	for(int i = 0; i < 9; i++)

  000d3	46		 inc	 esi
  000d4	83 6d f8 01	 sub	 DWORD PTR tv322[ebp], 1
  000d8	0f 85 52 ff ff
	ff		 jne	 $LL4@ApplyBonus
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
$LN3@ApplyBonus:
  000e0	5f		 pop	 edi

; 925  : 				break;
; 926  : 			}
; 927  : 		}
; 928  : 	}
; 929  : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
  000e7	90		 npad	 1
$LN28@ApplyBonus:
  000e8	00 00 00 00	 DD	 $LN11@ApplyBonus
  000ec	00 00 00 00	 DD	 $LN12@ApplyBonus
  000f0	00 00 00 00	 DD	 $LN13@ApplyBonus
  000f4	00 00 00 00	 DD	 $LN14@ApplyBonus
  000f8	00 00 00 00	 DD	 $LN15@ApplyBonus
  000fc	00 00 00 00	 DD	 $LN16@ApplyBonus
  00100	00 00 00 00	 DD	 $LN17@ApplyBonus
?ApplyBonusOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z ENDP ; CElementalSystem::ApplyBonusOptions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ApplyOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iOptionID$ = 12					; size = 4
_Level$ = 16						; size = 4
?ApplyOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z PROC ; CElementalSystem::ApplyOption, COMDAT
; _this$ = ecx

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 730  : 	ERTEL_OPTION* lpOption = GetErtelOption(iOptionID);

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iOptionID$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?GetErtelOption@CElementalSystem@@QAEPAUERTEL_OPTION@@H@Z ; CElementalSystem::GetErtelOption

; 731  : 
; 732  : 	if( lpOption == NULL )

  0000d	85 c0		 test	 eax, eax
  0000f	0f 84 d4 02 00
	00		 je	 $LN2@ApplyOptio

; 733  : 		return;
; 734  : 
; 735  : 	int _IncValue = lpOption->Option[Level];

  00015	8b 4d 10	 mov	 ecx, DWORD PTR _Level$[ebp]
  00018	0f b7 4c 48 0a	 movzx	 ecx, WORD PTR [eax+ecx*2+10]

; 736  : 	int _IncType = lpOption->btIncType;
; 737  : 
; 738  : 	switch( iOptionID )

  0001d	81 fe 91 01 00
	00		 cmp	 esi, 401		; 00000191H
  00023	0f 8f 43 01 00
	00		 jg	 $LN46@ApplyOptio
  00029	0f 84 2c 01 00
	00		 je	 $LN32@ApplyOptio
  0002f	83 c6 9b	 add	 esi, -101		; ffffff9bH
  00032	81 fe f1 00 00
	00		 cmp	 esi, 241		; 000000f1H
  00038	0f 87 ab 02 00
	00		 ja	 $LN2@ApplyOptio
  0003e	0f b6 86 00 00
	00 00		 movzx	 eax, BYTE PTR $LN47@ApplyOptio[esi]
  00045	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN50@ApplyOptio[eax*4]
$LN5@ApplyOptio:

; 739  : 	{
; 740  : 	case 101:
; 741  : 		lpObj->m_ElementalDamageMin += _IncValue;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004f	5e		 pop	 esi
  00050	01 88 e8 26 00
	00		 add	 DWORD PTR [eax+9960], ecx

; 742  : 		lpObj->m_ElementalDamageMax += _IncValue;

  00056	01 88 ec 26 00
	00		 add	 DWORD PTR [eax+9964], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN6@ApplyOptio:

; 743  : 		break;
; 744  : 	case 111:
; 745  : 	case 311:
; 746  : 		lpObj->m_ElementalOptions->m_AddFirePercDmg += _IncValue;

  00060	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00063	5e		 pop	 esi
  00064	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  0006a	01 08		 add	 DWORD PTR [eax], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0006c	5d		 pop	 ebp
  0006d	c2 0c 00	 ret	 12			; 0000000cH
$LN7@ApplyOptio:

; 747  : 		break;
; 748  : 	case 112:
; 749  : 	case 312:
; 750  : 		lpObj->m_ElementalOptions->m_AddWaterPercDmg += _IncValue;

  00070	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00073	5e		 pop	 esi
  00074	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  0007a	01 48 04	 add	 DWORD PTR [eax+4], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
$LN8@ApplyOptio:

; 751  : 		break;
; 752  : 	case 113:
; 753  : 	case 313:
; 754  : 		lpObj->m_ElementalOptions->m_AddEarthPercDmg += _IncValue;

  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	5e		 pop	 esi
  00085	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  0008b	01 48 08	 add	 DWORD PTR [eax+8], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0008e	5d		 pop	 ebp
  0008f	c2 0c 00	 ret	 12			; 0000000cH
$LN9@ApplyOptio:

; 755  : 		break;
; 756  : 	case 114:
; 757  : 	case 314:
; 758  : 		lpObj->m_ElementalOptions->m_AddWindPercDmg += _IncValue;

  00092	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00095	5e		 pop	 esi
  00096	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  0009c	01 48 0c	 add	 DWORD PTR [eax+12], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0009f	5d		 pop	 ebp
  000a0	c2 0c 00	 ret	 12			; 0000000cH
$LN10@ApplyOptio:

; 759  : 		break;
; 760  : 	case 115:
; 761  : 	case 315:
; 762  : 		lpObj->m_ElementalOptions->m_AddDarkPercDmg += _IncValue;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a6	5e		 pop	 esi
  000a7	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  000ad	01 48 10	 add	 DWORD PTR [eax+16], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  000b0	5d		 pop	 ebp
  000b1	c2 0c 00	 ret	 12			; 0000000cH
$LN11@ApplyOptio:

; 763  : 		break;
; 764  : 	case 121:
; 765  : 	case 321:
; 766  : 		lpObj->m_ElementalOptions->m_AddDmgPVP += _IncValue;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	5e		 pop	 esi
  000b8	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  000be	01 48 14	 add	 DWORD PTR [eax+20], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  000c1	5d		 pop	 ebp
  000c2	c2 0c 00	 ret	 12			; 0000000cH
$LN12@ApplyOptio:

; 767  : 		break;
; 768  : 	case 122:
; 769  : 	case 322:
; 770  : 		lpObj->m_ElementalOptions->m_AddDmgPVE += _IncValue;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c8	5e		 pop	 esi
  000c9	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  000cf	01 48 18	 add	 DWORD PTR [eax+24], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH
$LN13@ApplyOptio:

; 771  : 		break;
; 772  : 	case 131:
; 773  : 	case 331:
; 774  : 		lpObj->m_ElementalOptions->m_AddRangedPVP += _IncValue;

  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	5e		 pop	 esi
  000da	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  000e0	01 48 1c	 add	 DWORD PTR [eax+28], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  000e3	5d		 pop	 ebp
  000e4	c2 0c 00	 ret	 12			; 0000000cH
$LN14@ApplyOptio:

; 775  : 		break;
; 776  : 	case 132:
; 777  : 	case 332:
; 778  : 		lpObj->m_ElementalOptions->m_AddMaleePVP += _IncValue;

  000e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	5e		 pop	 esi
  000eb	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  000f1	01 48 20	 add	 DWORD PTR [eax+32], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  000f4	5d		 pop	 ebp
  000f5	c2 0c 00	 ret	 12			; 0000000cH
$LN15@ApplyOptio:

; 779  : 		break;
; 780  : 	case 141:
; 781  : 		lpObj->m_ElementalOptions->m_AddCritRatePVP += _IncValue;

  000f8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fb	5e		 pop	 esi
  000fc	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00102	01 48 24	 add	 DWORD PTR [eax+36], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00105	5d		 pop	 ebp
  00106	c2 0c 00	 ret	 12			; 0000000cH
$LN16@ApplyOptio:

; 782  : 		break;
; 783  : 	case 142:
; 784  : 		lpObj->m_ElementalOptions->m_AddCritRatePVE += _IncValue;

  00109	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	5e		 pop	 esi
  0010d	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00113	01 48 28	 add	 DWORD PTR [eax+40], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00116	5d		 pop	 ebp
  00117	c2 0c 00	 ret	 12			; 0000000cH
$LN17@ApplyOptio:

; 785  : 		break;
; 786  : 	case 201:
; 787  : 		lpObj->m_ElementalDefense += _IncValue;

  0011a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011d	5e		 pop	 esi
  0011e	01 88 f0 26 00
	00		 add	 DWORD PTR [eax+9968], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00124	5d		 pop	 ebp
  00125	c2 0c 00	 ret	 12			; 0000000cH
$LN29@ApplyOptio:

; 832  : 		break;
; 833  : 	case 301:
; 834  : 		lpObj->m_ElementalOptions->m_AddAttackRate += _IncValue;

  00128	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012b	5e		 pop	 esi
  0012c	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00132	01 48 58	 add	 DWORD PTR [eax+88], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00135	5d		 pop	 ebp
  00136	c2 0c 00	 ret	 12			; 0000000cH
$LN30@ApplyOptio:

; 835  : 		break;
; 836  : 	case 341:
; 837  : 		lpObj->m_ElementalOptions->m_IncreasePVP += _IncValue;

  00139	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013c	5e		 pop	 esi
  0013d	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00143	01 48 60	 add	 DWORD PTR [eax+96], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00146	5d		 pop	 ebp
  00147	c2 0c 00	 ret	 12			; 0000000cH
$LN31@ApplyOptio:

; 838  : 		break;
; 839  : 	case 342:
; 840  : 		lpObj->m_ElementalOptions->m_IncreasePVE += _IncValue;

  0014a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014d	5e		 pop	 esi
  0014e	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00154	01 48 64	 add	 DWORD PTR [eax+100], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00157	5d		 pop	 ebp
  00158	c2 0c 00	 ret	 12			; 0000000cH
$LN32@ApplyOptio:

; 841  : 		break;
; 842  : 	case 401:
; 843  : 		lpObj->m_ElementalOptions->m_AddDefenseRate += _IncValue;

  0015b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015e	5e		 pop	 esi
  0015f	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00165	01 48 5c	 add	 DWORD PTR [eax+92], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00168	5d		 pop	 ebp
  00169	c2 0c 00	 ret	 12			; 0000000cH
$LN46@ApplyOptio:

; 736  : 	int _IncType = lpOption->btIncType;
; 737  : 
; 738  : 	switch( iOptionID )

  0016c	81 c6 65 fe ff
	ff		 add	 esi, -411		; fffffe65H
  00172	81 fe 82 00 00
	00		 cmp	 esi, 130		; 00000082H
  00178	0f 87 6b 01 00
	00		 ja	 $LN2@ApplyOptio
  0017e	0f b6 86 00 00
	00 00		 movzx	 eax, BYTE PTR $LN48@ApplyOptio[esi]
  00185	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN51@ApplyOptio[eax*4]
$LN18@ApplyOptio:

; 788  : 		break;
; 789  : 	case 211:
; 790  : 	case 411:
; 791  : 		lpObj->m_ElementalOptions->m_AddFirePercDef += _IncValue;

  0018c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018f	5e		 pop	 esi
  00190	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00196	01 48 2c	 add	 DWORD PTR [eax+44], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00199	5d		 pop	 ebp
  0019a	c2 0c 00	 ret	 12			; 0000000cH
$LN19@ApplyOptio:

; 792  : 		break;
; 793  : 	case 212:
; 794  : 	case 412:
; 795  : 		lpObj->m_ElementalOptions->m_AddWaterPercDef += _IncValue;

  0019d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a0	5e		 pop	 esi
  001a1	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  001a7	01 48 30	 add	 DWORD PTR [eax+48], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  001aa	5d		 pop	 ebp
  001ab	c2 0c 00	 ret	 12			; 0000000cH
$LN20@ApplyOptio:

; 796  : 		break;
; 797  : 	case 213:
; 798  : 	case 413:
; 799  : 		lpObj->m_ElementalOptions->m_AddEarthPercDef += _IncValue;

  001ae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b1	5e		 pop	 esi
  001b2	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  001b8	01 48 34	 add	 DWORD PTR [eax+52], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  001bb	5d		 pop	 ebp
  001bc	c2 0c 00	 ret	 12			; 0000000cH
$LN21@ApplyOptio:

; 800  : 		break;
; 801  : 	case 214:
; 802  : 	case 414:
; 803  : 		lpObj->m_ElementalOptions->m_AddWindPercDef += _IncValue;

  001bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c2	5e		 pop	 esi
  001c3	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  001c9	01 48 38	 add	 DWORD PTR [eax+56], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  001cc	5d		 pop	 ebp
  001cd	c2 0c 00	 ret	 12			; 0000000cH
$LN22@ApplyOptio:

; 804  : 		break;
; 805  : 	case 215:
; 806  : 	case 415:
; 807  : 		lpObj->m_ElementalOptions->m_AddDarkPercDef += _IncValue;

  001d0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d3	5e		 pop	 esi
  001d4	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  001da	01 48 3c	 add	 DWORD PTR [eax+60], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  001dd	5d		 pop	 ebp
  001de	c2 0c 00	 ret	 12			; 0000000cH
$LN23@ApplyOptio:

; 808  : 		break;
; 809  : 	case 221:
; 810  : 	case 421:
; 811  : 		lpObj->m_ElementalOptions->m_AddDefPVP += _IncValue;

  001e1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e4	5e		 pop	 esi
  001e5	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  001eb	01 48 40	 add	 DWORD PTR [eax+64], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  001ee	5d		 pop	 ebp
  001ef	c2 0c 00	 ret	 12			; 0000000cH
$LN24@ApplyOptio:

; 812  : 		break;
; 813  : 	case 222:
; 814  : 	case 422:
; 815  : 		lpObj->m_ElementalOptions->m_AddDefPVE += _IncValue;

  001f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f5	5e		 pop	 esi
  001f6	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  001fc	01 48 44	 add	 DWORD PTR [eax+68], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  001ff	5d		 pop	 ebp
  00200	c2 0c 00	 ret	 12			; 0000000cH
$LN25@ApplyOptio:

; 816  : 		break;
; 817  : 	case 231:
; 818  : 	case 431:
; 819  : 		lpObj->m_ElementalOptions->m_AddRangedDefPVP += _IncValue;

  00203	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00206	5e		 pop	 esi
  00207	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  0020d	01 48 48	 add	 DWORD PTR [eax+72], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00210	5d		 pop	 ebp
  00211	c2 0c 00	 ret	 12			; 0000000cH
$LN27@ApplyOptio:

; 820  : 		break;
; 821  : 	case 232:
; 822  : 	case 432:
; 823  : 		lpObj->m_ElementalOptions->m_AddRangedDefPVP += _IncValue;
; 824  : 		break;
; 825  : 	case 241:
; 826  : 	case 441:
; 827  : 		lpObj->m_ElementalOptions->m_DecreasePVP += _IncValue;

  00214	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00217	5e		 pop	 esi
  00218	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  0021e	01 48 50	 add	 DWORD PTR [eax+80], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00221	5d		 pop	 ebp
  00222	c2 0c 00	 ret	 12			; 0000000cH
$LN28@ApplyOptio:

; 828  : 		break;
; 829  : 	case 242:
; 830  : 	case 442:
; 831  : 		lpObj->m_ElementalOptions->m_DecreasePVE += _IncValue;

  00225	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00228	5e		 pop	 esi
  00229	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  0022f	01 48 54	 add	 DWORD PTR [eax+84], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00232	5d		 pop	 ebp
  00233	c2 0c 00	 ret	 12			; 0000000cH
$LN33@ApplyOptio:

; 844  : 		break;
; 845  : 	case 501:
; 846  : 		lpObj->m_ElementalOptions->m_DebuffRate += _IncValue;

  00236	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00239	5e		 pop	 esi
  0023a	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  00240	01 48 68	 add	 DWORD PTR [eax+104], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00243	5d		 pop	 ebp
  00244	c2 0c 00	 ret	 12			; 0000000cH
$LN34@ApplyOptio:

; 847  : 		break;
; 848  : 	case 511:
; 849  : 		lpObj->AddStrength += _IncValue;

  00247	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0024a	5e		 pop	 esi
  0024b	66 01 88 fc 00
	00 00		 add	 WORD PTR [eax+252], cx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00252	5d		 pop	 ebp
  00253	c2 0c 00	 ret	 12			; 0000000cH
$LN35@ApplyOptio:

; 850  : 		break;
; 851  : 	case 512:
; 852  : 		lpObj->AddDexterity += _IncValue;

  00256	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00259	5e		 pop	 esi
  0025a	66 01 88 fe 00
	00 00		 add	 WORD PTR [eax+254], cx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00261	5d		 pop	 ebp
  00262	c2 0c 00	 ret	 12			; 0000000cH
$LN36@ApplyOptio:

; 853  : 		break;
; 854  : 	case 513:
; 855  : 		lpObj->AddEnergy += _IncValue;

  00265	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00268	5e		 pop	 esi
  00269	66 01 88 02 01
	00 00		 add	 WORD PTR [eax+258], cx

; 880  : 		break;
; 881  : 	}
; 882  : }

  00270	5d		 pop	 ebp
  00271	c2 0c 00	 ret	 12			; 0000000cH
$LN37@ApplyOptio:

; 856  : 		break;
; 857  : 	case 514:
; 858  : 		lpObj->AddVitality += _IncValue;

  00274	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00277	5e		 pop	 esi
  00278	66 01 88 00 01
	00 00		 add	 WORD PTR [eax+256], cx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0027f	5d		 pop	 ebp
  00280	c2 0c 00	 ret	 12			; 0000000cH
$LN38@ApplyOptio:

; 859  : 		break;
; 860  : 	case 521:
; 861  : 		lpObj->AddLife += _IncValue;

  00283	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00286	5e		 pop	 esi
  00287	01 88 24 01 00
	00		 add	 DWORD PTR [eax+292], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0028d	5d		 pop	 ebp
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$LN39@ApplyOptio:

; 862  : 		break;
; 863  : 	case 522:
; 864  : 		lpObj->AddMana += _IncValue;

  00291	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00294	5e		 pop	 esi
  00295	01 88 28 01 00
	00		 add	 DWORD PTR [eax+296], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  0029b	5d		 pop	 ebp
  0029c	c2 0c 00	 ret	 12			; 0000000cH
$LN40@ApplyOptio:

; 865  : 		break;
; 866  : 	case 523:
; 867  : 		lpObj->AddBP += _IncValue;

  0029f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a2	5e		 pop	 esi
  002a3	01 88 0c 01 00
	00		 add	 DWORD PTR [eax+268], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  002a9	5d		 pop	 ebp
  002aa	c2 0c 00	 ret	 12			; 0000000cH
$LN41@ApplyOptio:

; 868  : 		break;
; 869  : 	case 524:
; 870  : 		lpObj->iAddShield += _IncValue;

  002ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b0	5e		 pop	 esi
  002b1	01 88 34 01 00
	00		 add	 DWORD PTR [eax+308], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  002b7	5d		 pop	 ebp
  002b8	c2 0c 00	 ret	 12			; 0000000cH
$LN42@ApplyOptio:

; 871  : 		break;
; 872  : 	case 531:
; 873  : 		lpObj->m_ElementalOptions->m_ExcRatePVP += _IncValue;

  002bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002be	5e		 pop	 esi
  002bf	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  002c5	01 48 6c	 add	 DWORD PTR [eax+108], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  002c8	5d		 pop	 ebp
  002c9	c2 0c 00	 ret	 12			; 0000000cH
$LN43@ApplyOptio:

; 874  : 		break;
; 875  : 	case 532:
; 876  : 		lpObj->m_ElementalOptions->m_ExcRatePVE += _IncValue;

  002cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cf	5e		 pop	 esi
  002d0	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  002d6	01 48 70	 add	 DWORD PTR [eax+112], ecx

; 880  : 		break;
; 881  : 	}
; 882  : }

  002d9	5d		 pop	 ebp
  002da	c2 0c 00	 ret	 12			; 0000000cH
$LN44@ApplyOptio:

; 877  : 		break;
; 878  : 	case 541:
; 879  : 		lpObj->m_ElementalOptions->m_ElementalRate += _IncValue;

  002dd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e0	8b 80 fc 26 00
	00		 mov	 eax, DWORD PTR [eax+9980]
  002e6	01 48 74	 add	 DWORD PTR [eax+116], ecx
$LN2@ApplyOptio:
  002e9	5e		 pop	 esi

; 880  : 		break;
; 881  : 	}
; 882  : }

  002ea	5d		 pop	 ebp
  002eb	c2 0c 00	 ret	 12			; 0000000cH
  002ee	66 90		 npad	 2
$LN50@ApplyOptio:
  002f0	00 00 00 00	 DD	 $LN5@ApplyOptio
  002f4	00 00 00 00	 DD	 $LN6@ApplyOptio
  002f8	00 00 00 00	 DD	 $LN7@ApplyOptio
  002fc	00 00 00 00	 DD	 $LN8@ApplyOptio
  00300	00 00 00 00	 DD	 $LN9@ApplyOptio
  00304	00 00 00 00	 DD	 $LN10@ApplyOptio
  00308	00 00 00 00	 DD	 $LN11@ApplyOptio
  0030c	00 00 00 00	 DD	 $LN12@ApplyOptio
  00310	00 00 00 00	 DD	 $LN13@ApplyOptio
  00314	00 00 00 00	 DD	 $LN14@ApplyOptio
  00318	00 00 00 00	 DD	 $LN15@ApplyOptio
  0031c	00 00 00 00	 DD	 $LN16@ApplyOptio
  00320	00 00 00 00	 DD	 $LN17@ApplyOptio
  00324	00 00 00 00	 DD	 $LN18@ApplyOptio
  00328	00 00 00 00	 DD	 $LN19@ApplyOptio
  0032c	00 00 00 00	 DD	 $LN20@ApplyOptio
  00330	00 00 00 00	 DD	 $LN21@ApplyOptio
  00334	00 00 00 00	 DD	 $LN22@ApplyOptio
  00338	00 00 00 00	 DD	 $LN23@ApplyOptio
  0033c	00 00 00 00	 DD	 $LN24@ApplyOptio
  00340	00 00 00 00	 DD	 $LN25@ApplyOptio
  00344	00 00 00 00	 DD	 $LN27@ApplyOptio
  00348	00 00 00 00	 DD	 $LN28@ApplyOptio
  0034c	00 00 00 00	 DD	 $LN29@ApplyOptio
  00350	00 00 00 00	 DD	 $LN30@ApplyOptio
  00354	00 00 00 00	 DD	 $LN31@ApplyOptio
  00358	00 00 00 00	 DD	 $LN2@ApplyOptio
$LN47@ApplyOptio:
  0035c	00		 DB	 0
  0035d	1a		 DB	 26			; 0000001aH
  0035e	1a		 DB	 26			; 0000001aH
  0035f	1a		 DB	 26			; 0000001aH
  00360	1a		 DB	 26			; 0000001aH
  00361	1a		 DB	 26			; 0000001aH
  00362	1a		 DB	 26			; 0000001aH
  00363	1a		 DB	 26			; 0000001aH
  00364	1a		 DB	 26			; 0000001aH
  00365	1a		 DB	 26			; 0000001aH
  00366	01		 DB	 1
  00367	02		 DB	 2
  00368	03		 DB	 3
  00369	04		 DB	 4
  0036a	05		 DB	 5
  0036b	1a		 DB	 26			; 0000001aH
  0036c	1a		 DB	 26			; 0000001aH
  0036d	1a		 DB	 26			; 0000001aH
  0036e	1a		 DB	 26			; 0000001aH
  0036f	1a		 DB	 26			; 0000001aH
  00370	06		 DB	 6
  00371	07		 DB	 7
  00372	1a		 DB	 26			; 0000001aH
  00373	1a		 DB	 26			; 0000001aH
  00374	1a		 DB	 26			; 0000001aH
  00375	1a		 DB	 26			; 0000001aH
  00376	1a		 DB	 26			; 0000001aH
  00377	1a		 DB	 26			; 0000001aH
  00378	1a		 DB	 26			; 0000001aH
  00379	1a		 DB	 26			; 0000001aH
  0037a	08		 DB	 8
  0037b	09		 DB	 9
  0037c	1a		 DB	 26			; 0000001aH
  0037d	1a		 DB	 26			; 0000001aH
  0037e	1a		 DB	 26			; 0000001aH
  0037f	1a		 DB	 26			; 0000001aH
  00380	1a		 DB	 26			; 0000001aH
  00381	1a		 DB	 26			; 0000001aH
  00382	1a		 DB	 26			; 0000001aH
  00383	1a		 DB	 26			; 0000001aH
  00384	0a		 DB	 10			; 0000000aH
  00385	0b		 DB	 11			; 0000000bH
  00386	1a		 DB	 26			; 0000001aH
  00387	1a		 DB	 26			; 0000001aH
  00388	1a		 DB	 26			; 0000001aH
  00389	1a		 DB	 26			; 0000001aH
  0038a	1a		 DB	 26			; 0000001aH
  0038b	1a		 DB	 26			; 0000001aH
  0038c	1a		 DB	 26			; 0000001aH
  0038d	1a		 DB	 26			; 0000001aH
  0038e	1a		 DB	 26			; 0000001aH
  0038f	1a		 DB	 26			; 0000001aH
  00390	1a		 DB	 26			; 0000001aH
  00391	1a		 DB	 26			; 0000001aH
  00392	1a		 DB	 26			; 0000001aH
  00393	1a		 DB	 26			; 0000001aH
  00394	1a		 DB	 26			; 0000001aH
  00395	1a		 DB	 26			; 0000001aH
  00396	1a		 DB	 26			; 0000001aH
  00397	1a		 DB	 26			; 0000001aH
  00398	1a		 DB	 26			; 0000001aH
  00399	1a		 DB	 26			; 0000001aH
  0039a	1a		 DB	 26			; 0000001aH
  0039b	1a		 DB	 26			; 0000001aH
  0039c	1a		 DB	 26			; 0000001aH
  0039d	1a		 DB	 26			; 0000001aH
  0039e	1a		 DB	 26			; 0000001aH
  0039f	1a		 DB	 26			; 0000001aH
  003a0	1a		 DB	 26			; 0000001aH
  003a1	1a		 DB	 26			; 0000001aH
  003a2	1a		 DB	 26			; 0000001aH
  003a3	1a		 DB	 26			; 0000001aH
  003a4	1a		 DB	 26			; 0000001aH
  003a5	1a		 DB	 26			; 0000001aH
  003a6	1a		 DB	 26			; 0000001aH
  003a7	1a		 DB	 26			; 0000001aH
  003a8	1a		 DB	 26			; 0000001aH
  003a9	1a		 DB	 26			; 0000001aH
  003aa	1a		 DB	 26			; 0000001aH
  003ab	1a		 DB	 26			; 0000001aH
  003ac	1a		 DB	 26			; 0000001aH
  003ad	1a		 DB	 26			; 0000001aH
  003ae	1a		 DB	 26			; 0000001aH
  003af	1a		 DB	 26			; 0000001aH
  003b0	1a		 DB	 26			; 0000001aH
  003b1	1a		 DB	 26			; 0000001aH
  003b2	1a		 DB	 26			; 0000001aH
  003b3	1a		 DB	 26			; 0000001aH
  003b4	1a		 DB	 26			; 0000001aH
  003b5	1a		 DB	 26			; 0000001aH
  003b6	1a		 DB	 26			; 0000001aH
  003b7	1a		 DB	 26			; 0000001aH
  003b8	1a		 DB	 26			; 0000001aH
  003b9	1a		 DB	 26			; 0000001aH
  003ba	1a		 DB	 26			; 0000001aH
  003bb	1a		 DB	 26			; 0000001aH
  003bc	1a		 DB	 26			; 0000001aH
  003bd	1a		 DB	 26			; 0000001aH
  003be	1a		 DB	 26			; 0000001aH
  003bf	1a		 DB	 26			; 0000001aH
  003c0	0c		 DB	 12			; 0000000cH
  003c1	1a		 DB	 26			; 0000001aH
  003c2	1a		 DB	 26			; 0000001aH
  003c3	1a		 DB	 26			; 0000001aH
  003c4	1a		 DB	 26			; 0000001aH
  003c5	1a		 DB	 26			; 0000001aH
  003c6	1a		 DB	 26			; 0000001aH
  003c7	1a		 DB	 26			; 0000001aH
  003c8	1a		 DB	 26			; 0000001aH
  003c9	1a		 DB	 26			; 0000001aH
  003ca	0d		 DB	 13			; 0000000dH
  003cb	0e		 DB	 14			; 0000000eH
  003cc	0f		 DB	 15			; 0000000fH
  003cd	10		 DB	 16			; 00000010H
  003ce	11		 DB	 17			; 00000011H
  003cf	1a		 DB	 26			; 0000001aH
  003d0	1a		 DB	 26			; 0000001aH
  003d1	1a		 DB	 26			; 0000001aH
  003d2	1a		 DB	 26			; 0000001aH
  003d3	1a		 DB	 26			; 0000001aH
  003d4	12		 DB	 18			; 00000012H
  003d5	13		 DB	 19			; 00000013H
  003d6	1a		 DB	 26			; 0000001aH
  003d7	1a		 DB	 26			; 0000001aH
  003d8	1a		 DB	 26			; 0000001aH
  003d9	1a		 DB	 26			; 0000001aH
  003da	1a		 DB	 26			; 0000001aH
  003db	1a		 DB	 26			; 0000001aH
  003dc	1a		 DB	 26			; 0000001aH
  003dd	1a		 DB	 26			; 0000001aH
  003de	14		 DB	 20			; 00000014H
  003df	14		 DB	 20			; 00000014H
  003e0	1a		 DB	 26			; 0000001aH
  003e1	1a		 DB	 26			; 0000001aH
  003e2	1a		 DB	 26			; 0000001aH
  003e3	1a		 DB	 26			; 0000001aH
  003e4	1a		 DB	 26			; 0000001aH
  003e5	1a		 DB	 26			; 0000001aH
  003e6	1a		 DB	 26			; 0000001aH
  003e7	1a		 DB	 26			; 0000001aH
  003e8	15		 DB	 21			; 00000015H
  003e9	16		 DB	 22			; 00000016H
  003ea	1a		 DB	 26			; 0000001aH
  003eb	1a		 DB	 26			; 0000001aH
  003ec	1a		 DB	 26			; 0000001aH
  003ed	1a		 DB	 26			; 0000001aH
  003ee	1a		 DB	 26			; 0000001aH
  003ef	1a		 DB	 26			; 0000001aH
  003f0	1a		 DB	 26			; 0000001aH
  003f1	1a		 DB	 26			; 0000001aH
  003f2	1a		 DB	 26			; 0000001aH
  003f3	1a		 DB	 26			; 0000001aH
  003f4	1a		 DB	 26			; 0000001aH
  003f5	1a		 DB	 26			; 0000001aH
  003f6	1a		 DB	 26			; 0000001aH
  003f7	1a		 DB	 26			; 0000001aH
  003f8	1a		 DB	 26			; 0000001aH
  003f9	1a		 DB	 26			; 0000001aH
  003fa	1a		 DB	 26			; 0000001aH
  003fb	1a		 DB	 26			; 0000001aH
  003fc	1a		 DB	 26			; 0000001aH
  003fd	1a		 DB	 26			; 0000001aH
  003fe	1a		 DB	 26			; 0000001aH
  003ff	1a		 DB	 26			; 0000001aH
  00400	1a		 DB	 26			; 0000001aH
  00401	1a		 DB	 26			; 0000001aH
  00402	1a		 DB	 26			; 0000001aH
  00403	1a		 DB	 26			; 0000001aH
  00404	1a		 DB	 26			; 0000001aH
  00405	1a		 DB	 26			; 0000001aH
  00406	1a		 DB	 26			; 0000001aH
  00407	1a		 DB	 26			; 0000001aH
  00408	1a		 DB	 26			; 0000001aH
  00409	1a		 DB	 26			; 0000001aH
  0040a	1a		 DB	 26			; 0000001aH
  0040b	1a		 DB	 26			; 0000001aH
  0040c	1a		 DB	 26			; 0000001aH
  0040d	1a		 DB	 26			; 0000001aH
  0040e	1a		 DB	 26			; 0000001aH
  0040f	1a		 DB	 26			; 0000001aH
  00410	1a		 DB	 26			; 0000001aH
  00411	1a		 DB	 26			; 0000001aH
  00412	1a		 DB	 26			; 0000001aH
  00413	1a		 DB	 26			; 0000001aH
  00414	1a		 DB	 26			; 0000001aH
  00415	1a		 DB	 26			; 0000001aH
  00416	1a		 DB	 26			; 0000001aH
  00417	1a		 DB	 26			; 0000001aH
  00418	1a		 DB	 26			; 0000001aH
  00419	1a		 DB	 26			; 0000001aH
  0041a	1a		 DB	 26			; 0000001aH
  0041b	1a		 DB	 26			; 0000001aH
  0041c	1a		 DB	 26			; 0000001aH
  0041d	1a		 DB	 26			; 0000001aH
  0041e	1a		 DB	 26			; 0000001aH
  0041f	1a		 DB	 26			; 0000001aH
  00420	1a		 DB	 26			; 0000001aH
  00421	1a		 DB	 26			; 0000001aH
  00422	1a		 DB	 26			; 0000001aH
  00423	1a		 DB	 26			; 0000001aH
  00424	17		 DB	 23			; 00000017H
  00425	1a		 DB	 26			; 0000001aH
  00426	1a		 DB	 26			; 0000001aH
  00427	1a		 DB	 26			; 0000001aH
  00428	1a		 DB	 26			; 0000001aH
  00429	1a		 DB	 26			; 0000001aH
  0042a	1a		 DB	 26			; 0000001aH
  0042b	1a		 DB	 26			; 0000001aH
  0042c	1a		 DB	 26			; 0000001aH
  0042d	1a		 DB	 26			; 0000001aH
  0042e	01		 DB	 1
  0042f	02		 DB	 2
  00430	03		 DB	 3
  00431	04		 DB	 4
  00432	05		 DB	 5
  00433	1a		 DB	 26			; 0000001aH
  00434	1a		 DB	 26			; 0000001aH
  00435	1a		 DB	 26			; 0000001aH
  00436	1a		 DB	 26			; 0000001aH
  00437	1a		 DB	 26			; 0000001aH
  00438	06		 DB	 6
  00439	07		 DB	 7
  0043a	1a		 DB	 26			; 0000001aH
  0043b	1a		 DB	 26			; 0000001aH
  0043c	1a		 DB	 26			; 0000001aH
  0043d	1a		 DB	 26			; 0000001aH
  0043e	1a		 DB	 26			; 0000001aH
  0043f	1a		 DB	 26			; 0000001aH
  00440	1a		 DB	 26			; 0000001aH
  00441	1a		 DB	 26			; 0000001aH
  00442	08		 DB	 8
  00443	09		 DB	 9
  00444	1a		 DB	 26			; 0000001aH
  00445	1a		 DB	 26			; 0000001aH
  00446	1a		 DB	 26			; 0000001aH
  00447	1a		 DB	 26			; 0000001aH
  00448	1a		 DB	 26			; 0000001aH
  00449	1a		 DB	 26			; 0000001aH
  0044a	1a		 DB	 26			; 0000001aH
  0044b	1a		 DB	 26			; 0000001aH
  0044c	18		 DB	 24			; 00000018H
  0044d	19		 DB	 25			; 00000019H
  0044e	66 90		 npad	 2
$LN51@ApplyOptio:
  00450	00 00 00 00	 DD	 $LN18@ApplyOptio
  00454	00 00 00 00	 DD	 $LN19@ApplyOptio
  00458	00 00 00 00	 DD	 $LN20@ApplyOptio
  0045c	00 00 00 00	 DD	 $LN21@ApplyOptio
  00460	00 00 00 00	 DD	 $LN22@ApplyOptio
  00464	00 00 00 00	 DD	 $LN23@ApplyOptio
  00468	00 00 00 00	 DD	 $LN24@ApplyOptio
  0046c	00 00 00 00	 DD	 $LN25@ApplyOptio
  00470	00 00 00 00	 DD	 $LN27@ApplyOptio
  00474	00 00 00 00	 DD	 $LN28@ApplyOptio
  00478	00 00 00 00	 DD	 $LN33@ApplyOptio
  0047c	00 00 00 00	 DD	 $LN34@ApplyOptio
  00480	00 00 00 00	 DD	 $LN35@ApplyOptio
  00484	00 00 00 00	 DD	 $LN36@ApplyOptio
  00488	00 00 00 00	 DD	 $LN37@ApplyOptio
  0048c	00 00 00 00	 DD	 $LN38@ApplyOptio
  00490	00 00 00 00	 DD	 $LN39@ApplyOptio
  00494	00 00 00 00	 DD	 $LN40@ApplyOptio
  00498	00 00 00 00	 DD	 $LN41@ApplyOptio
  0049c	00 00 00 00	 DD	 $LN42@ApplyOptio
  004a0	00 00 00 00	 DD	 $LN43@ApplyOptio
  004a4	00 00 00 00	 DD	 $LN44@ApplyOptio
  004a8	00 00 00 00	 DD	 $LN2@ApplyOptio
$LN48@ApplyOptio:
  004ac	00		 DB	 0
  004ad	01		 DB	 1
  004ae	02		 DB	 2
  004af	03		 DB	 3
  004b0	04		 DB	 4
  004b1	16		 DB	 22			; 00000016H
  004b2	16		 DB	 22			; 00000016H
  004b3	16		 DB	 22			; 00000016H
  004b4	16		 DB	 22			; 00000016H
  004b5	16		 DB	 22			; 00000016H
  004b6	05		 DB	 5
  004b7	06		 DB	 6
  004b8	16		 DB	 22			; 00000016H
  004b9	16		 DB	 22			; 00000016H
  004ba	16		 DB	 22			; 00000016H
  004bb	16		 DB	 22			; 00000016H
  004bc	16		 DB	 22			; 00000016H
  004bd	16		 DB	 22			; 00000016H
  004be	16		 DB	 22			; 00000016H
  004bf	16		 DB	 22			; 00000016H
  004c0	07		 DB	 7
  004c1	07		 DB	 7
  004c2	16		 DB	 22			; 00000016H
  004c3	16		 DB	 22			; 00000016H
  004c4	16		 DB	 22			; 00000016H
  004c5	16		 DB	 22			; 00000016H
  004c6	16		 DB	 22			; 00000016H
  004c7	16		 DB	 22			; 00000016H
  004c8	16		 DB	 22			; 00000016H
  004c9	16		 DB	 22			; 00000016H
  004ca	08		 DB	 8
  004cb	09		 DB	 9
  004cc	16		 DB	 22			; 00000016H
  004cd	16		 DB	 22			; 00000016H
  004ce	16		 DB	 22			; 00000016H
  004cf	16		 DB	 22			; 00000016H
  004d0	16		 DB	 22			; 00000016H
  004d1	16		 DB	 22			; 00000016H
  004d2	16		 DB	 22			; 00000016H
  004d3	16		 DB	 22			; 00000016H
  004d4	16		 DB	 22			; 00000016H
  004d5	16		 DB	 22			; 00000016H
  004d6	16		 DB	 22			; 00000016H
  004d7	16		 DB	 22			; 00000016H
  004d8	16		 DB	 22			; 00000016H
  004d9	16		 DB	 22			; 00000016H
  004da	16		 DB	 22			; 00000016H
  004db	16		 DB	 22			; 00000016H
  004dc	16		 DB	 22			; 00000016H
  004dd	16		 DB	 22			; 00000016H
  004de	16		 DB	 22			; 00000016H
  004df	16		 DB	 22			; 00000016H
  004e0	16		 DB	 22			; 00000016H
  004e1	16		 DB	 22			; 00000016H
  004e2	16		 DB	 22			; 00000016H
  004e3	16		 DB	 22			; 00000016H
  004e4	16		 DB	 22			; 00000016H
  004e5	16		 DB	 22			; 00000016H
  004e6	16		 DB	 22			; 00000016H
  004e7	16		 DB	 22			; 00000016H
  004e8	16		 DB	 22			; 00000016H
  004e9	16		 DB	 22			; 00000016H
  004ea	16		 DB	 22			; 00000016H
  004eb	16		 DB	 22			; 00000016H
  004ec	16		 DB	 22			; 00000016H
  004ed	16		 DB	 22			; 00000016H
  004ee	16		 DB	 22			; 00000016H
  004ef	16		 DB	 22			; 00000016H
  004f0	16		 DB	 22			; 00000016H
  004f1	16		 DB	 22			; 00000016H
  004f2	16		 DB	 22			; 00000016H
  004f3	16		 DB	 22			; 00000016H
  004f4	16		 DB	 22			; 00000016H
  004f5	16		 DB	 22			; 00000016H
  004f6	16		 DB	 22			; 00000016H
  004f7	16		 DB	 22			; 00000016H
  004f8	16		 DB	 22			; 00000016H
  004f9	16		 DB	 22			; 00000016H
  004fa	16		 DB	 22			; 00000016H
  004fb	16		 DB	 22			; 00000016H
  004fc	16		 DB	 22			; 00000016H
  004fd	16		 DB	 22			; 00000016H
  004fe	16		 DB	 22			; 00000016H
  004ff	16		 DB	 22			; 00000016H
  00500	16		 DB	 22			; 00000016H
  00501	16		 DB	 22			; 00000016H
  00502	16		 DB	 22			; 00000016H
  00503	16		 DB	 22			; 00000016H
  00504	16		 DB	 22			; 00000016H
  00505	16		 DB	 22			; 00000016H
  00506	0a		 DB	 10			; 0000000aH
  00507	16		 DB	 22			; 00000016H
  00508	16		 DB	 22			; 00000016H
  00509	16		 DB	 22			; 00000016H
  0050a	16		 DB	 22			; 00000016H
  0050b	16		 DB	 22			; 00000016H
  0050c	16		 DB	 22			; 00000016H
  0050d	16		 DB	 22			; 00000016H
  0050e	16		 DB	 22			; 00000016H
  0050f	16		 DB	 22			; 00000016H
  00510	0b		 DB	 11			; 0000000bH
  00511	0c		 DB	 12			; 0000000cH
  00512	0d		 DB	 13			; 0000000dH
  00513	0e		 DB	 14			; 0000000eH
  00514	16		 DB	 22			; 00000016H
  00515	16		 DB	 22			; 00000016H
  00516	16		 DB	 22			; 00000016H
  00517	16		 DB	 22			; 00000016H
  00518	16		 DB	 22			; 00000016H
  00519	16		 DB	 22			; 00000016H
  0051a	0f		 DB	 15			; 0000000fH
  0051b	10		 DB	 16			; 00000010H
  0051c	11		 DB	 17			; 00000011H
  0051d	12		 DB	 18			; 00000012H
  0051e	16		 DB	 22			; 00000016H
  0051f	16		 DB	 22			; 00000016H
  00520	16		 DB	 22			; 00000016H
  00521	16		 DB	 22			; 00000016H
  00522	16		 DB	 22			; 00000016H
  00523	16		 DB	 22			; 00000016H
  00524	13		 DB	 19			; 00000013H
  00525	14		 DB	 20			; 00000014H
  00526	16		 DB	 22			; 00000016H
  00527	16		 DB	 22			; 00000016H
  00528	16		 DB	 22			; 00000016H
  00529	16		 DB	 22			; 00000016H
  0052a	16		 DB	 22			; 00000016H
  0052b	16		 DB	 22			; 00000016H
  0052c	16		 DB	 22			; 00000016H
  0052d	16		 DB	 22			; 00000016H
  0052e	15		 DB	 21			; 00000015H
?ApplyOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ENDP ; CElementalSystem::ApplyOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ApplyErtelOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_iErtelID$ = 12						; size = 4
?ApplyErtelOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z PROC ; CElementalSystem::ApplyErtelOption, COMDAT
; _this$ = ecx

; 714  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 715  : 	if( iErtelID < 0 || iErtelID >= MAX_ERTEL )

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iErtelID$[ebp]
  00007	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000a	83 f8 63	 cmp	 eax, 99			; 00000063H
  0000d	77 41		 ja	 SHORT $LN6@ApplyErtel

; 716  : 		return;
; 717  : 
; 718  : 	ERTEL_USER* lpErtel = &lpObj->pErtelList1[iErtelID];

  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00015	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]

; 719  : 
; 720  : 	for(int i = 0; i < 5; i++)	{

  00018	33 f6		 xor	 esi, esi
  0001a	8b 87 dc 26 00
	00		 mov	 eax, DWORD PTR [edi+9948]
  00020	8d 1c 90	 lea	 ebx, DWORD PTR [eax+edx*4]
$LL4@ApplyErtel:

; 721  : 		int iOptionID = lpErtel->btType*100 + i*10 + lpErtel->Option[i];
; 722  : 		int Level = lpErtel->Level[i];

  00023	0f b6 44 33 07	 movzx	 eax, BYTE PTR [ebx+esi+7]

; 723  : 
; 724  : 		ApplyOption(lpObj,iOptionID,Level);

  00028	50		 push	 eax
  00029	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0002c	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0002f	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  00032	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00035	0f b6 44 33 02	 movzx	 eax, BYTE PTR [ebx+esi+2]
  0003a	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00040	50		 push	 eax
  00041	57		 push	 edi
  00042	e8 00 00 00 00	 call	 ?ApplyOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CElementalSystem::ApplyOption
  00047	46		 inc	 esi
  00048	83 fe 05	 cmp	 esi, 5
  0004b	7c d6		 jl	 SHORT $LL4@ApplyErtel
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
$LN6@ApplyErtel:

; 725  : 	}
; 726  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
?ApplyErtelOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ENDP ; CElementalSystem::ApplyErtelOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?ApplyElementItem@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv806 = 8						; size = 4
tv687 = 8						; size = 4
_Pentagram$1$ = 8					; size = 4
_lpObj$ = 8						; size = 4
?ApplyElementItem@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CElementalSystem::ApplyElementItem, COMDAT
; _this$ = ecx

; 644  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 645  : 	if( lpObj->Type != OBJ_USER || lpObj->Connected < PLAYER_PLAYING )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi
  0000e	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  00012	0f 85 7b 03 00
	00		 jne	 $LN6@ApplyEleme
  00018	83 7b 04 03	 cmp	 DWORD PTR [ebx+4], 3
  0001c	0f 8c 71 03 00
	00		 jl	 $LN6@ApplyEleme

; 646  : 		return;
; 647  : 
; 648  : 	ELEMENT_CLASS_INFO* classInfo = &this->m_classinfo[lpObj->Class];

  00022	0f b7 83 90 00
	00 00		 movzx	 eax, WORD PTR [ebx+144]
  00029	56		 push	 esi
  0002a	8b f0		 mov	 esi, eax
  0002c	c1 e6 04	 shl	 esi, 4
  0002f	2b f0		 sub	 esi, eax

; 649  : 
; 650  : 	InitElementOptions(lpObj);

  00031	53		 push	 ebx
  00032	89 75 08	 mov	 DWORD PTR tv687[ebp], esi
  00035	e8 00 00 00 00	 call	 ?InitElementOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CElementalSystem::InitElementOptions

; 651  : 
; 652  : 		if ( classInfo->strMin != 0 && classInfo->strMax != 0)	{

  0003a	0f b7 44 f7 04	 movzx	 eax, WORD PTR [edi+esi*8+4]
  0003f	66 85 c0	 test	 ax, ax
  00042	74 32		 je	 SHORT $LN7@ApplyEleme
  00044	66 83 7c f7 06
	00		 cmp	 WORD PTR [edi+esi*8+6], 0
  0004a	74 2a		 je	 SHORT $LN7@ApplyEleme

; 653  : 			lpObj->m_ElementalDamageMin += lpObj->Strength/classInfo->strMin;

  0004c	0f b7 b3 d0 00
	00 00		 movzx	 esi, WORD PTR [ebx+208]
  00053	8b c8		 mov	 ecx, eax
  00055	8b c6		 mov	 eax, esi
  00057	99		 cdq
  00058	f7 f9		 idiv	 ecx
  0005a	01 83 e8 26 00
	00		 add	 DWORD PTR [ebx+9960], eax

; 654  : 			lpObj->m_ElementalDamageMax += lpObj->Strength/classInfo->strMax;

  00060	8b 45 08	 mov	 eax, DWORD PTR tv687[ebp]
  00063	0f b7 4c c7 06	 movzx	 ecx, WORD PTR [edi+eax*8+6]
  00068	8b c6		 mov	 eax, esi
  0006a	99		 cdq
  0006b	f7 f9		 idiv	 ecx
  0006d	8b 75 08	 mov	 esi, DWORD PTR tv687[ebp]
  00070	01 83 ec 26 00
	00		 add	 DWORD PTR [ebx+9964], eax
$LN7@ApplyEleme:

; 655  : 		}
; 656  : 
; 657  : 		if ( classInfo->dexMin != 0 && classInfo->dexMax != 0)	{

  00076	0f b7 44 f7 08	 movzx	 eax, WORD PTR [edi+esi*8+8]
  0007b	66 85 c0	 test	 ax, ax
  0007e	74 32		 je	 SHORT $LN8@ApplyEleme
  00080	66 83 7c f7 0a
	00		 cmp	 WORD PTR [edi+esi*8+10], 0
  00086	74 2a		 je	 SHORT $LN8@ApplyEleme

; 658  : 			lpObj->m_ElementalDamageMin += lpObj->Dexterity/classInfo->dexMin;

  00088	0f b7 b3 d2 00
	00 00		 movzx	 esi, WORD PTR [ebx+210]
  0008f	8b c8		 mov	 ecx, eax
  00091	8b c6		 mov	 eax, esi
  00093	99		 cdq
  00094	f7 f9		 idiv	 ecx
  00096	01 83 e8 26 00
	00		 add	 DWORD PTR [ebx+9960], eax

; 659  : 			lpObj->m_ElementalDamageMax += lpObj->Dexterity/classInfo->dexMax;

  0009c	8b 45 08	 mov	 eax, DWORD PTR tv687[ebp]
  0009f	0f b7 4c c7 0a	 movzx	 ecx, WORD PTR [edi+eax*8+10]
  000a4	8b c6		 mov	 eax, esi
  000a6	99		 cdq
  000a7	f7 f9		 idiv	 ecx
  000a9	8b 75 08	 mov	 esi, DWORD PTR tv687[ebp]
  000ac	01 83 ec 26 00
	00		 add	 DWORD PTR [ebx+9964], eax
$LN8@ApplyEleme:

; 660  : 		}
; 661  : 
; 662  : 		if ( classInfo->vitMin != 0 && classInfo->vitMax != 0)	{

  000b2	0f b7 44 f7 0c	 movzx	 eax, WORD PTR [edi+esi*8+12]
  000b7	66 85 c0	 test	 ax, ax
  000ba	74 32		 je	 SHORT $LN9@ApplyEleme
  000bc	66 83 7c f7 0e
	00		 cmp	 WORD PTR [edi+esi*8+14], 0
  000c2	74 2a		 je	 SHORT $LN9@ApplyEleme

; 663  : 			lpObj->m_ElementalDamageMin += lpObj->Vitality/classInfo->vitMin;

  000c4	0f b7 b3 d4 00
	00 00		 movzx	 esi, WORD PTR [ebx+212]
  000cb	8b c8		 mov	 ecx, eax
  000cd	8b c6		 mov	 eax, esi
  000cf	99		 cdq
  000d0	f7 f9		 idiv	 ecx
  000d2	01 83 e8 26 00
	00		 add	 DWORD PTR [ebx+9960], eax

; 664  : 			lpObj->m_ElementalDamageMax += lpObj->Vitality/classInfo->vitMax;

  000d8	8b 45 08	 mov	 eax, DWORD PTR tv687[ebp]
  000db	0f b7 4c c7 0e	 movzx	 ecx, WORD PTR [edi+eax*8+14]
  000e0	8b c6		 mov	 eax, esi
  000e2	99		 cdq
  000e3	f7 f9		 idiv	 ecx
  000e5	8b 75 08	 mov	 esi, DWORD PTR tv687[ebp]
  000e8	01 83 ec 26 00
	00		 add	 DWORD PTR [ebx+9964], eax
$LN9@ApplyEleme:

; 665  : 		}
; 666  : 
; 667  : 		if ( classInfo->eneMin != 0 && classInfo->eneMax != 0)	{

  000ee	0f b7 44 f7 10	 movzx	 eax, WORD PTR [edi+esi*8+16]
  000f3	66 85 c0	 test	 ax, ax
  000f6	74 32		 je	 SHORT $LN10@ApplyEleme
  000f8	66 83 7c f7 12
	00		 cmp	 WORD PTR [edi+esi*8+18], 0
  000fe	74 2a		 je	 SHORT $LN10@ApplyEleme

; 668  : 			lpObj->m_ElementalDamageMin += lpObj->Energy/classInfo->eneMin;

  00100	0f b7 b3 d6 00
	00 00		 movzx	 esi, WORD PTR [ebx+214]
  00107	8b c8		 mov	 ecx, eax
  00109	8b c6		 mov	 eax, esi
  0010b	99		 cdq
  0010c	f7 f9		 idiv	 ecx
  0010e	01 83 e8 26 00
	00		 add	 DWORD PTR [ebx+9960], eax

; 669  : 			lpObj->m_ElementalDamageMax += lpObj->Energy/classInfo->eneMax;

  00114	8b 45 08	 mov	 eax, DWORD PTR tv687[ebp]
  00117	0f b7 4c c7 12	 movzx	 ecx, WORD PTR [edi+eax*8+18]
  0011c	8b c6		 mov	 eax, esi
  0011e	99		 cdq
  0011f	f7 f9		 idiv	 ecx
  00121	8b 75 08	 mov	 esi, DWORD PTR tv687[ebp]
  00124	01 83 ec 26 00
	00		 add	 DWORD PTR [ebx+9964], eax
$LN10@ApplyEleme:

; 670  : 		}
; 671  : 
; 672  : 		if ( classInfo->cmdMin != 0 && classInfo->cmdMax != 0)	{

  0012a	0f b7 44 f7 14	 movzx	 eax, WORD PTR [edi+esi*8+20]
  0012f	66 85 c0	 test	 ax, ax
  00132	74 32		 je	 SHORT $LN11@ApplyEleme
  00134	66 83 7c f7 16
	00		 cmp	 WORD PTR [edi+esi*8+22], 0
  0013a	74 2a		 je	 SHORT $LN11@ApplyEleme

; 673  : 			lpObj->m_ElementalDamageMin += lpObj->Leadership/classInfo->cmdMin;

  0013c	0f b7 b3 f4 00
	00 00		 movzx	 esi, WORD PTR [ebx+244]
  00143	8b c8		 mov	 ecx, eax
  00145	8b c6		 mov	 eax, esi
  00147	99		 cdq
  00148	f7 f9		 idiv	 ecx
  0014a	01 83 e8 26 00
	00		 add	 DWORD PTR [ebx+9960], eax

; 674  : 			lpObj->m_ElementalDamageMax += lpObj->Leadership/classInfo->cmdMax;

  00150	8b 45 08	 mov	 eax, DWORD PTR tv687[ebp]
  00153	0f b7 4c c7 16	 movzx	 ecx, WORD PTR [edi+eax*8+22]
  00158	8b c6		 mov	 eax, esi
  0015a	99		 cdq
  0015b	f7 f9		 idiv	 ecx
  0015d	8b 75 08	 mov	 esi, DWORD PTR tv687[ebp]
  00160	01 83 ec 26 00
	00		 add	 DWORD PTR [ebx+9964], eax
$LN11@ApplyEleme:

; 675  : 		}
; 676  : 
; 677  : 		if( classInfo->dexDef != 0 )

  00166	0f b7 4c f7 18	 movzx	 ecx, WORD PTR [edi+esi*8+24]
  0016b	66 85 c9	 test	 cx, cx
  0016e	74 10		 je	 SHORT $LN12@ApplyEleme

; 678  : 			lpObj->m_ElementalDefense += lpObj->Dexterity/classInfo->dexDef;

  00170	0f b7 83 d2 00
	00 00		 movzx	 eax, WORD PTR [ebx+210]
  00177	99		 cdq
  00178	f7 f9		 idiv	 ecx
  0017a	01 83 f0 26 00
	00		 add	 DWORD PTR [ebx+9968], eax
$LN12@ApplyEleme:

; 679  : 
; 680  : 		lpObj->m_ElementalDefenseRate = (lpObj->Level+lpObj->MasterLevel)*classInfo->DefRate_LEVELMUL;

  00180	0f bf 8b a8 00
	00 00		 movsx	 ecx, WORD PTR [ebx+168]
  00187	0f bf 83 96 00
	00 00		 movsx	 eax, WORD PTR [ebx+150]
  0018e	03 c8		 add	 ecx, eax
  00190	66 0f 6e c1	 movd	 xmm0, ecx
  00194	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00197	f3 0f 59 44 f7
	1c		 mulss	 xmm0, DWORD PTR [edi+esi*8+28]
  0019d	83 c7 20	 add	 edi, 32			; 00000020H
  001a0	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001a4	8d 14 f7	 lea	 edx, DWORD PTR [edi+esi*8]
  001a7	be 04 00 00 00	 mov	 esi, 4
  001ac	8d bb d0 00 00
	00		 lea	 edi, DWORD PTR [ebx+208]
  001b2	89 8b f8 26 00
	00		 mov	 DWORD PTR [ebx+9976], ecx
  001b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL19@ApplyEleme:

; 681  : 		lpObj->m_ElementalDefenseRate += lpObj->Strength*classInfo->DefRate_MUL[0];

  001c0	0f b7 07	 movzx	 eax, WORD PTR [edi]
  001c3	83 c7 02	 add	 edi, 2
  001c6	66 0f 6e c1	 movd	 xmm0, ecx
  001ca	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001cd	66 0f 6e c8	 movd	 xmm1, eax
  001d1	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001d4	f3 0f 59 0a	 mulss	 xmm1, DWORD PTR [edx]
  001d8	83 c2 04	 add	 edx, 4
  001db	f3 0f 58 c8	 addss	 xmm1, xmm0
  001df	f3 0f 2c c9	 cvttss2si ecx, xmm1
  001e3	89 8b f8 26 00
	00		 mov	 DWORD PTR [ebx+9976], ecx
  001e9	83 ee 01	 sub	 esi, 1
  001ec	75 d2		 jne	 SHORT $LL19@ApplyEleme

; 682  : 		lpObj->m_ElementalDefenseRate += lpObj->Dexterity*classInfo->DefRate_MUL[1];
; 683  : 		lpObj->m_ElementalDefenseRate += lpObj->Vitality*classInfo->DefRate_MUL[2];
; 684  : 		lpObj->m_ElementalDefenseRate += lpObj->Energy*classInfo->DefRate_MUL[3];
; 685  : 		lpObj->m_ElementalDefenseRate += lpObj->Leadership*classInfo->DefRate_MUL[4];

  001ee	0f b7 83 f4 00
	00 00		 movzx	 eax, WORD PTR [ebx+244]
  001f5	8b 75 08	 mov	 esi, DWORD PTR tv687[ebp]
  001f8	66 0f 6e 83 f8
	26 00 00	 movd	 xmm0, DWORD PTR [ebx+9976]
  00200	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  00203	66 0f 6e c8	 movd	 xmm1, eax
  00207	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0020a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0020d	f3 0f 59 4c f7
	30		 mulss	 xmm1, DWORD PTR [edi+esi*8+48]

; 686  : 
; 687  : 	CItem* Pentagram = &lpObj->pInventory[236];

  00213	8b b3 c0 11 00
	00		 mov	 esi, DWORD PTR [ebx+4544]
  00219	81 c6 70 c3 00
	00		 add	 esi, 50032		; 0000c370H

; 688  : 
; 689  : 	if( Pentagram->IsItem() && IsPentagram(Pentagram) )

  0021f	8b ce		 mov	 ecx, esi
  00221	89 75 08	 mov	 DWORD PTR _Pentagram$1$[ebp], esi
  00224	f3 0f 58 c8	 addss	 xmm1, xmm0
  00228	f3 0f 2c c1	 cvttss2si eax, xmm1
  0022c	89 83 f8 26 00
	00		 mov	 DWORD PTR [ebx+9976], eax
  00232	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00237	85 c0		 test	 eax, eax
  00239	0f 84 53 01 00
	00		 je	 $LN27@ApplyEleme
  0023f	56		 push	 esi
  00240	8b cf		 mov	 ecx, edi
  00242	e8 00 00 00 00	 call	 ?IsPentagram@CElementalSystem@@QAEHPAVCItem@@@Z ; CElementalSystem::IsPentagram
  00247	85 c0		 test	 eax, eax
  00249	0f 84 43 01 00
	00		 je	 $LN27@ApplyEleme

; 690  : 	{
; 691  : 		ApplyBonusOptions(lpObj,Pentagram);

  0024f	56		 push	 esi
  00250	53		 push	 ebx
  00251	8b cf		 mov	 ecx, edi
  00253	e8 00 00 00 00	 call	 ?ApplyBonusOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CElementalSystem::ApplyBonusOptions

; 692  : 
; 693  : 		lpObj->m_ElementalDefense += lpObj->m_ElementalDefense*lpObj->m_ElementalOptions->m_DefToElement/100;

  00258	8b bb fc 26 00
	00		 mov	 edi, DWORD PTR [ebx+9980]
  0025e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00263	8b b3 f0 26 00
	00		 mov	 esi, DWORD PTR [ebx+9968]
  00269	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  0026f	0f af ce	 imul	 ecx, esi
  00272	f7 e9		 imul	 ecx
  00274	c1 fa 05	 sar	 edx, 5
  00277	8b c2		 mov	 eax, edx
  00279	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0027c	03 c2		 add	 eax, edx
  0027e	03 c6		 add	 eax, esi

; 694  : 		lpObj->m_ElementalDamageMin += lpObj->m_ElementalDamageMin*lpObj->m_ElementalOptions->m_AttToElement/100;

  00280	8b b3 e8 26 00
	00		 mov	 esi, DWORD PTR [ebx+9960]
  00286	89 83 f0 26 00
	00		 mov	 DWORD PTR [ebx+9968], eax
  0028c	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00291	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00297	0f af ce	 imul	 ecx, esi
  0029a	f7 e9		 imul	 ecx
  0029c	c1 fa 05	 sar	 edx, 5
  0029f	8b c2		 mov	 eax, edx
  002a1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002a4	03 c2		 add	 eax, edx
  002a6	03 c6		 add	 eax, esi

; 695  : 		lpObj->m_ElementalDamageMax += lpObj->m_ElementalDamageMax*lpObj->m_ElementalOptions->m_AttToElement/100;

  002a8	8b b3 ec 26 00
	00		 mov	 esi, DWORD PTR [ebx+9964]
  002ae	89 83 e8 26 00
	00		 mov	 DWORD PTR [ebx+9960], eax
  002b4	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  002b9	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  002bf	0f af ce	 imul	 ecx, esi
  002c2	f7 e9		 imul	 ecx
  002c4	c1 fa 05	 sar	 edx, 5
  002c7	8b c2		 mov	 eax, edx
  002c9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002cc	03 c2		 add	 eax, edx
  002ce	03 c6		 add	 eax, esi

; 696  : 
; 697  : 		lpObj->m_btAttribute = Pentagram->m_SocketBonus&15;

  002d0	8b 75 08	 mov	 esi, DWORD PTR _Pentagram$1$[ebp]
  002d3	89 83 ec 26 00
	00		 mov	 DWORD PTR [ebx+9964], eax
  002d9	8a 86 c7 00 00
	00		 mov	 al, BYTE PTR [esi+199]
  002df	24 0f		 and	 al, 15			; 0000000fH
  002e1	88 83 e4 26 00
	00		 mov	 BYTE PTR [ebx+9956], al

; 698  : 		lpObj->m_ElementalDamageMin += ((Pentagram->m_DamageMin*(100+lpObj->m_ElementalOptions->m_AddPentagramDamage))/100);

  002e7	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  002ea	0f b7 4e 10	 movzx	 ecx, WORD PTR [esi+16]
  002ee	83 c0 64	 add	 eax, 100		; 00000064H
  002f1	0f af c8	 imul	 ecx, eax
  002f4	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  002f9	f7 e9		 imul	 ecx
  002fb	c1 fa 05	 sar	 edx, 5
  002fe	8b c2		 mov	 eax, edx
  00300	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00303	03 c2		 add	 eax, edx
  00305	01 83 e8 26 00
	00		 add	 DWORD PTR [ebx+9960], eax

; 699  : 		lpObj->m_ElementalDamageMax += ((Pentagram->m_DamageMax*(100+lpObj->m_ElementalOptions->m_AddPentagramDamage))/100);

  0030b	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  0030e	0f b7 4e 12	 movzx	 ecx, WORD PTR [esi+18]
  00312	83 c0 64	 add	 eax, 100		; 00000064H
  00315	0f af c8	 imul	 ecx, eax
  00318	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0031d	f7 e9		 imul	 ecx

; 700  : 		lpObj->m_ElementalDefense += ((Pentagram->m_Defense*(100+lpObj->m_ElementalOptions->m_AddPentagramDefense))/100);

  0031f	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00324	c1 fa 05	 sar	 edx, 5
  00327	8b ca		 mov	 ecx, edx
  00329	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0032c	03 ca		 add	 ecx, edx
  0032e	01 8b ec 26 00
	00		 add	 DWORD PTR [ebx+9964], ecx
  00334	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]
  00337	8d be c8 00 00
	00		 lea	 edi, DWORD PTR [esi+200]
  0033d	0f b7 4e 16	 movzx	 ecx, WORD PTR [esi+22]
  00341	83 c2 64	 add	 edx, 100		; 00000064H
  00344	0f af d1	 imul	 edx, ecx
  00347	b9 05 00 00 00	 mov	 ecx, 5
  0034c	f7 ea		 imul	 edx
  0034e	c1 fa 05	 sar	 edx, 5
  00351	8b c2		 mov	 eax, edx
  00353	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00356	03 c2		 add	 eax, edx
  00358	03 83 f0 26 00
	00		 add	 eax, DWORD PTR [ebx+9968]

; 701  : 		lpObj->m_ElementalDefense /= 2;

  0035e	99		 cdq
  0035f	2b c2		 sub	 eax, edx
  00361	d1 f8		 sar	 eax, 1
  00363	89 83 f0 26 00
	00		 mov	 DWORD PTR [ebx+9968], eax

; 690  : 	{
; 691  : 		ApplyBonusOptions(lpObj,Pentagram);

  00369	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  0036c	89 4d 08	 mov	 DWORD PTR tv806[ebp], ecx
  0036f	90		 npad	 1
$LL4@ApplyEleme:

; 704  : 			if( Pentagram->m_SocketOption[i] == (BYTE)-1 ||

  00370	8a 07		 mov	 al, BYTE PTR [edi]
  00372	3c ff		 cmp	 al, 255			; 000000ffH
  00374	74 13		 je	 SHORT $LN2@ApplyEleme
  00376	3c fe		 cmp	 al, 254			; 000000feH
  00378	74 0f		 je	 SHORT $LN2@ApplyEleme

; 705  : 				Pentagram->m_SocketOption[i] == (BYTE)-2 )
; 706  : 				continue;
; 707  : 
; 708  : 			ApplyErtelOption(lpObj,Pentagram->m_SocketOption[i]);

  0037a	0f b6 c0	 movzx	 eax, al
  0037d	8b ce		 mov	 ecx, esi
  0037f	50		 push	 eax
  00380	53		 push	 ebx
  00381	e8 00 00 00 00	 call	 ?ApplyErtelOption@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@H@Z ; CElementalSystem::ApplyErtelOption
  00386	8b 4d 08	 mov	 ecx, DWORD PTR tv806[ebp]
$LN2@ApplyEleme:

; 702  : 
; 703  : 		for(int i = 0; i < 5; i++)	{

  00389	47		 inc	 edi
  0038a	83 e9 01	 sub	 ecx, 1
  0038d	89 4d 08	 mov	 DWORD PTR tv806[ebp], ecx
  00390	75 de		 jne	 SHORT $LL4@ApplyEleme
$LN27@ApplyEleme:
  00392	5e		 pop	 esi
$LN6@ApplyEleme:
  00393	5f		 pop	 edi
  00394	5b		 pop	 ebx

; 709  : 		}
; 710  : 	}
; 711  : }

  00395	8b e5		 mov	 esp, ebp
  00397	5d		 pop	 ebp
  00398	c2 04 00	 ret	 4
?ApplyElementItem@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CElementalSystem::ApplyElementItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?InitElementOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?InitElementOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CElementalSystem::InitElementOptions, COMDAT
; _this$ = ecx

; 619  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 620  : 	lpObj->m_ElementalDamageMin = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]

; 621  : 	lpObj->m_ElementalDamageMax = 0;
; 622  : 	lpObj->m_ElementalDefense = 0;
; 623  : 
; 624  : 	lpObj->m_ElementalAttackRate = 0;
; 625  : 	lpObj->m_ElementalDefenseRate = 0;
; 626  : 	lpObj->m_btAttribute = ELEMENT_NONE;
; 627  : 
; 628  : 	memset(lpObj->m_ElementalOptions,0,sizeof(ELEMENTAL_OPTIONS));

  00006	68 94 00 00 00	 push	 148			; 00000094H
  0000b	6a 00		 push	 0
  0000d	ff b0 fc 26 00
	00		 push	 DWORD PTR [eax+9980]
  00013	c7 80 e8 26 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+9960], 0
  0001d	c7 80 ec 26 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+9964], 0
  00027	c7 80 f0 26 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+9968], 0
  00031	c7 80 f4 26 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+9972], 0
  0003b	c7 80 f8 26 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+9976], 0
  00045	c6 80 e4 26 00
	00 00		 mov	 BYTE PTR [eax+9956], 0
  0004c	e8 00 00 00 00	 call	 _memset
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 629  : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?InitElementOptions@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CElementalSystem::InitElementOptions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?Drop@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$GSCopy$1$ = -28					; size = 4
_iMaxHitUser$1$ = -24					; size = 4
_iMaxHitUser$1$ = -20					; size = 4
_SocketBonus$1 = -16					; size = 1
_SocketBonus$2 = -16					; size = 1
_SocketBonus$3 = -16					; size = 1
_SocketOption$4 = -12					; size = 5
_SocketOption$5 = -12					; size = 5
_SocketOption$6 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?Drop@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z PROC	; CElementalSystem::Drop, COMDAT
; _this$ = ecx

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 388  : 
; 389  : 	if( lpObj->Level >= m_iSpiritMap_DropLevel && rand()%10000 < m_iSpiritMap_DropRate )

  00015	bb 10 27 00 00	 mov	 ebx, 10000		; 00002710H
  0001a	57		 push	 edi
  0001b	8b f9		 mov	 edi, ecx
  0001d	89 75 e4	 mov	 DWORD PTR _lpObj$GSCopy$1$[ebp], esi
  00020	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  00027	3b 87 60 1a 00
	00		 cmp	 eax, DWORD PTR [edi+6752]
  0002d	7c 68		 jl	 SHORT $LN8@Drop
  0002f	e8 00 00 00 00	 call	 _rand
  00034	99		 cdq
  00035	f7 fb		 idiv	 ebx
  00037	3b 97 64 1a 00
	00		 cmp	 edx, DWORD PTR [edi+6756]
  0003d	7d 58		 jge	 SHORT $LN8@Drop

; 390  : 	{
; 391  : 		int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 392  : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y, ITEMGET(13, 145), 0, 1,

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	50		 push	 eax
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	6a 01		 push	 1
  00056	6a 00		 push	 0
  00058	68 91 1a 00 00	 push	 6801			; 00001a91H
$LN29@Drop:
  0005d	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00064	50		 push	 eax
  00065	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0006c	50		 push	 eax
  0006d	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00074	50		 push	 eax
  00075	ff 36		 push	 DWORD PTR [esi]
  00077	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0007c	83 c4 40	 add	 esp, 64			; 00000040H
$LN30@Drop:

; 393  : 			0, 0, 0, iMaxHitUser, 0, 0);
; 394  : 		return true;

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	5b		 pop	 ebx

; 479  : 		}
; 480  : 	}
; 481  : 
; 482  : 	return false;
; 483  : }

  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
$LN8@Drop:

; 395  : 	}
; 396  : 
; 397  : 	if( lpObj->MapNumber == MAP_INDEX_ACHERON )

  00097	80 be 23 01 00
	00 5b		 cmp	 BYTE PTR [esi+291], 91	; 0000005bH
  0009e	0f 85 1a 02 00
	00		 jne	 $LN14@Drop

; 398  : 	{
; 399  : 		if( rand()%10000 < m_iElixir_DropRate )

  000a4	e8 00 00 00 00	 call	 _rand
  000a9	99		 cdq
  000aa	f7 fb		 idiv	 ebx
  000ac	3b 97 6c 1a 00
	00		 cmp	 edx, DWORD PTR [edi+6764]
  000b2	7d 20		 jge	 SHORT $LN10@Drop

; 400  : 		{
; 401  : 			int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  000b4	56		 push	 esi
  000b5	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 402  : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y, ITEMGET(12,146), 0, 1,

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	50		 push	 eax
  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	6a 00		 push	 0
  000c9	6a 01		 push	 1
  000cb	6a 00		 push	 0
  000cd	68 92 18 00 00	 push	 6290			; 00001892H

; 403  : 				0, 0, 0, iMaxHitUser, 0, 0);
; 404  : 			return true;

  000d2	eb 89		 jmp	 SHORT $LN29@Drop
$LN10@Drop:

; 405  : 		}
; 406  : 
; 407  : 		if( rand()%10000 < m_iMithril_DropRate )

  000d4	e8 00 00 00 00	 call	 _rand
  000d9	99		 cdq
  000da	f7 fb		 idiv	 ebx
  000dc	3b 97 68 1a 00
	00		 cmp	 edx, DWORD PTR [edi+6760]
  000e2	7d 79		 jge	 SHORT $LN11@Drop

; 408  : 		{
; 409  : 			int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 410  : 
; 411  : 			BYTE SocketBonus = (lpObj->m_btAttribute==ELEMENT_NONE) ? (1+rand()%5) : lpObj->m_btAttribute;

  000ea	8a 8e e4 26 00
	00		 mov	 cl, BYTE PTR [esi+9956]
  000f0	83 c4 04	 add	 esp, 4
  000f3	8b f8		 mov	 edi, eax
  000f5	84 c9		 test	 cl, cl
  000f7	75 14		 jne	 SHORT $LN17@Drop
  000f9	e8 00 00 00 00	 call	 _rand
  000fe	99		 cdq
  000ff	b9 05 00 00 00	 mov	 ecx, 5
  00104	f7 f9		 idiv	 ecx
  00106	fe c2		 inc	 dl
  00108	88 55 f0	 mov	 BYTE PTR _SocketBonus$3[ebp], dl
  0010b	eb 03		 jmp	 SHORT $LN18@Drop
$LN17@Drop:
  0010d	88 4d f0	 mov	 BYTE PTR _SocketBonus$3[ebp], cl
$LN18@Drop:

; 412  : 			BYTE SocketOption[5] = {-1};
; 413  : 
; 414  : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y, ITEMGET(12,144), 0, 1,

  00110	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$6[ebp]
  00113	c6 45 f4 ff	 mov	 BYTE PTR _SocketOption$6[ebp], 255 ; 000000ffH
  00117	50		 push	 eax
  00118	ff 75 f0	 push	 DWORD PTR _SocketBonus$3[ebp]
  0011b	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _SocketOption$6[ebp+1], 0
  00122	6a 00		 push	 0
  00124	6a 00		 push	 0
  00126	57		 push	 edi
  00127	6a 00		 push	 0
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	6a 01		 push	 1
  0012f	6a 00		 push	 0
  00131	68 90 18 00 00	 push	 6288			; 00001890H
$LN31@Drop:
  00136	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0013d	50		 push	 eax
  0013e	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00145	50		 push	 eax
  00146	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0014d	50		 push	 eax
  0014e	ff 36		 push	 DWORD PTR [esi]
  00150	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00155	83 c4 3c	 add	 esp, 60			; 0000003cH

; 415  : 				0, 0, 0, iMaxHitUser, 0, 0,SocketBonus,SocketOption);
; 416  : 			return true;

  00158	e9 22 ff ff ff	 jmp	 $LN30@Drop
$LN11@Drop:

; 417  : 		}
; 418  : 
; 419  : 		if( lpObj->Level >= m_iMurenBook_DropLevel && rand()%10000 < m_iMurenBook_DropRate )

  0015d	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  00164	3b 87 70 1a 00
	00		 cmp	 eax, DWORD PTR [edi+6768]
  0016a	0f 8c 9e 00 00
	00		 jl	 $LN12@Drop
  00170	e8 00 00 00 00	 call	 _rand
  00175	99		 cdq
  00176	f7 fb		 idiv	 ebx
  00178	3b 97 74 1a 00
	00		 cmp	 edx, DWORD PTR [edi+6772]
  0017e	0f 8d 8a 00 00
	00		 jge	 $LN12@Drop

; 420  : 		{
; 421  : 			int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00184	56		 push	 esi
  00185	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 422  : 			BYTE SocketBonus = (lpObj->m_btAttribute==ELEMENT_NONE) ? (1+rand()%5) : lpObj->m_btAttribute;

  0018a	8a 8e e4 26 00
	00		 mov	 cl, BYTE PTR [esi+9956]
  00190	83 c4 04	 add	 esp, 4
  00193	89 45 e8	 mov	 DWORD PTR _iMaxHitUser$1$[ebp], eax
  00196	bb 05 00 00 00	 mov	 ebx, 5
  0019b	84 c9		 test	 cl, cl
  0019d	75 0f		 jne	 SHORT $LN19@Drop
  0019f	e8 00 00 00 00	 call	 _rand
  001a4	99		 cdq
  001a5	f7 fb		 idiv	 ebx
  001a7	fe c2		 inc	 dl
  001a9	88 55 f0	 mov	 BYTE PTR _SocketBonus$2[ebp], dl
  001ac	eb 03		 jmp	 SHORT $LN20@Drop
$LN19@Drop:
  001ae	88 4d f0	 mov	 BYTE PTR _SocketBonus$2[ebp], cl
$LN20@Drop:

; 423  : 			BYTE SocketOption[5];
; 424  : 
; 425  : 			SocketOption[0] = -1;
; 426  : 			SocketOption[1] = -1;
; 427  : 			SocketOption[2] = -1;
; 428  : 			SocketOption[3] = -1;
; 429  : 			SocketOption[4] = -1;
; 430  : 
; 431  : 			int scount = this->m_SlotCountRate.GetRandomValue(eRANDOMPOOL_BY_WEIGHT);

  001b1	6a 01		 push	 1
  001b3	8d 8f 50 1a 00
	00		 lea	 ecx, DWORD PTR [edi+6736]
  001b9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _SocketOption$5[ebp], -1
  001c0	c6 45 f8 ff	 mov	 BYTE PTR _SocketOption$5[ebp+4], 255 ; 000000ffH
  001c4	e8 00 00 00 00	 call	 ?GetRandomValue@TRandomPoolMgr@@QAEHW4eRandomPoolSelectType@@@Z ; TRandomPoolMgr::GetRandomValue

; 432  : 			int count = 0;

  001c9	33 ff		 xor	 edi, edi
  001cb	8b f0		 mov	 esi, eax
  001cd	0f 1f 00	 npad	 3
$LL4@Drop:

; 433  : 
; 434  : 			do
; 435  : 			{
; 436  : 				int slot = rand()%5;

  001d0	e8 00 00 00 00	 call	 _rand
  001d5	99		 cdq
  001d6	f7 fb		 idiv	 ebx

; 437  : 
; 438  : 				if( SocketOption[slot] == (BYTE)-1)

  001d8	80 7c 15 f4 ff	 cmp	 BYTE PTR _SocketOption$5[ebp+edx], 255 ; 000000ffH
  001dd	75 06		 jne	 SHORT $LN2@Drop

; 439  : 				{
; 440  : 					SocketOption[slot] = 0xFE;

  001df	c6 44 15 f4 fe	 mov	 BYTE PTR _SocketOption$5[ebp+edx], 254 ; 000000feH

; 441  : 					count++;

  001e4	47		 inc	 edi
$LN2@Drop:

; 442  : 				}
; 443  : 			}while( scount != count );

  001e5	3b fe		 cmp	 edi, esi
  001e7	75 e7		 jne	 SHORT $LL4@Drop

; 444  : 
; 445  : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y, ITEMGET(12,200), 0, 1,

  001e9	8b 75 e4	 mov	 esi, DWORD PTR _lpObj$GSCopy$1$[ebp]
  001ec	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$5[ebp]
  001ef	50		 push	 eax
  001f0	ff 75 f0	 push	 DWORD PTR _SocketBonus$2[ebp]
  001f3	6a 00		 push	 0
  001f5	6a 00		 push	 0
  001f7	ff 75 e8	 push	 DWORD PTR _iMaxHitUser$1$[ebp]
  001fa	6a 00		 push	 0
  001fc	6a 00		 push	 0
  001fe	6a 00		 push	 0
  00200	6a 01		 push	 1
  00202	6a 00		 push	 0
  00204	68 c8 18 00 00	 push	 6344			; 000018c8H

; 446  : 				0, 0, 0, iMaxHitUser, 0, 0,SocketBonus,SocketOption);
; 447  : 			return true;

  00209	e9 28 ff ff ff	 jmp	 $LN31@Drop
$LN12@Drop:

; 448  : 		}
; 449  : 
; 450  : 		if( lpObj->Level >= m_iEtramuScroll_DropLevel && rand()%10000 < m_iEtramuScroll_DropRate )

  0020e	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  00215	3b 87 78 1a 00
	00		 cmp	 eax, DWORD PTR [edi+6776]
  0021b	0f 8c 9d 00 00
	00		 jl	 $LN14@Drop
  00221	e8 00 00 00 00	 call	 _rand
  00226	99		 cdq
  00227	f7 fb		 idiv	 ebx
  00229	3b 97 7c 1a 00
	00		 cmp	 edx, DWORD PTR [edi+6780]
  0022f	0f 8d 89 00 00
	00		 jge	 $LN14@Drop

; 451  : 		{
; 452  : 			int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00235	56		 push	 esi
  00236	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 453  : 			BYTE SocketBonus = (lpObj->m_btAttribute==ELEMENT_NONE) ? (1+rand()%5) : lpObj->m_btAttribute;

  0023b	8a 8e e4 26 00
	00		 mov	 cl, BYTE PTR [esi+9956]
  00241	83 c4 04	 add	 esp, 4
  00244	89 45 ec	 mov	 DWORD PTR _iMaxHitUser$1$[ebp], eax
  00247	bb 05 00 00 00	 mov	 ebx, 5
  0024c	84 c9		 test	 cl, cl
  0024e	75 0f		 jne	 SHORT $LN21@Drop
  00250	e8 00 00 00 00	 call	 _rand
  00255	99		 cdq
  00256	f7 fb		 idiv	 ebx
  00258	fe c2		 inc	 dl
  0025a	88 55 f0	 mov	 BYTE PTR _SocketBonus$1[ebp], dl
  0025d	eb 03		 jmp	 SHORT $LN22@Drop
$LN21@Drop:
  0025f	88 4d f0	 mov	 BYTE PTR _SocketBonus$1[ebp], cl
$LN22@Drop:

; 454  : 			BYTE SocketOption[5];
; 455  : 
; 456  : 			SocketOption[0] = -1;
; 457  : 			SocketOption[1] = -1;
; 458  : 			SocketOption[2] = -1;
; 459  : 			SocketOption[3] = -1;
; 460  : 			SocketOption[4] = -1;
; 461  : 
; 462  : 			int scount = this->m_SlotCountRate.GetRandomValue(eRANDOMPOOL_BY_WEIGHT);

  00262	6a 01		 push	 1
  00264	8d 8f 50 1a 00
	00		 lea	 ecx, DWORD PTR [edi+6736]
  0026a	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _SocketOption$4[ebp], -1
  00271	c6 45 f8 ff	 mov	 BYTE PTR _SocketOption$4[ebp+4], 255 ; 000000ffH
  00275	e8 00 00 00 00	 call	 ?GetRandomValue@TRandomPoolMgr@@QAEHW4eRandomPoolSelectType@@@Z ; TRandomPoolMgr::GetRandomValue

; 463  : 			int count = 0;

  0027a	33 ff		 xor	 edi, edi
  0027c	8b f0		 mov	 esi, eax
  0027e	66 90		 npad	 2
$LL7@Drop:

; 464  : 
; 465  : 			do
; 466  : 			{
; 467  : 				int slot = rand()%5;

  00280	e8 00 00 00 00	 call	 _rand
  00285	99		 cdq
  00286	f7 fb		 idiv	 ebx

; 468  : 
; 469  : 				if( SocketOption[slot] == (BYTE)-1)

  00288	80 7c 15 f4 ff	 cmp	 BYTE PTR _SocketOption$4[ebp+edx], 255 ; 000000ffH
  0028d	75 06		 jne	 SHORT $LN5@Drop

; 470  : 				{
; 471  : 					SocketOption[slot] = 0xFE;

  0028f	c6 44 15 f4 fe	 mov	 BYTE PTR _SocketOption$4[ebp+edx], 254 ; 000000feH

; 472  : 					count++;

  00294	47		 inc	 edi
$LN5@Drop:

; 473  : 				}
; 474  : 			}while( scount != count );

  00295	3b fe		 cmp	 edi, esi
  00297	75 e7		 jne	 SHORT $LL7@Drop

; 475  : 
; 476  : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y, ITEMGET(12,201), 0, 1,

  00299	8b 75 e4	 mov	 esi, DWORD PTR _lpObj$GSCopy$1$[ebp]
  0029c	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$4[ebp]
  0029f	50		 push	 eax
  002a0	ff 75 f0	 push	 DWORD PTR _SocketBonus$1[ebp]
  002a3	6a 00		 push	 0
  002a5	6a 00		 push	 0
  002a7	ff 75 ec	 push	 DWORD PTR _iMaxHitUser$1$[ebp]
  002aa	6a 00		 push	 0
  002ac	6a 00		 push	 0
  002ae	6a 00		 push	 0
  002b0	6a 01		 push	 1
  002b2	6a 00		 push	 0
  002b4	68 c9 18 00 00	 push	 6345			; 000018c9H

; 477  : 				0, 0, 0, iMaxHitUser, 0, 0,SocketBonus,SocketOption);
; 478  : 			return true;

  002b9	e9 78 fe ff ff	 jmp	 $LN31@Drop
$LN14@Drop:

; 479  : 		}
; 480  : 	}
; 481  : 
; 482  : 	return false;
; 483  : }

  002be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c1	33 c0		 xor	 eax, eax
  002c3	5f		 pop	 edi
  002c4	5e		 pop	 esi
  002c5	33 cd		 xor	 ecx, ebp
  002c7	5b		 pop	 ebx
  002c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c2 08 00	 ret	 8
?Drop@CElementalSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP	; CElementalSystem::Drop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?IsErrtel@CElementalSystem@@QAEHPAVCItem@@@Z
_TEXT	SEGMENT
_lpItem$ = 8						; size = 4
?IsErrtel@CElementalSystem@@QAEHPAVCItem@@@Z PROC	; CElementalSystem::IsErrtel, COMDAT
; _this$ = ecx

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 576  : 	if( lpItem == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@IsErrtel

; 580  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@IsErrtel:

; 577  : 		return false;
; 578  : 
; 579  : 	return IsErrtel(lpItem->m_Type);

  0000e	0f bf 40 06	 movsx	 eax, WORD PTR [eax+6]
  00012	89 45 08	 mov	 DWORD PTR _lpItem$[ebp], eax

; 580  : }

  00015	5d		 pop	 ebp

; 577  : 		return false;
; 578  : 
; 579  : 	return IsErrtel(lpItem->m_Type);

  00016	e9 00 00 00 00	 jmp	 ?IsErrtel@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsErrtel
?IsErrtel@CElementalSystem@@QAEHPAVCItem@@@Z ENDP	; CElementalSystem::IsErrtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?IsErrtel@CElementalSystem@@QAEHH@Z
_TEXT	SEGMENT
_iType$ = 8						; size = 4
?IsErrtel@CElementalSystem@@QAEHH@Z PROC		; CElementalSystem::IsErrtel, COMDAT
; _this$ = ecx

; 560  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 561  : 	switch(iType)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iType$[ebp]
  00006	05 23 e7 ff ff	 add	 eax, -6365		; ffffe723H
  0000b	83 f8 28	 cmp	 eax, 40			; 00000028H
  0000e	77 17		 ja	 SHORT $LN5@IsErrtel
  00010	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN7@IsErrtel[eax]
  00017	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN9@IsErrtel[eax*4]
$LN4@IsErrtel:

; 562  : 	{
; 563  : 	case ITEMGET(12,221):
; 564  : 	case ITEMGET(12,231):
; 565  : 	case ITEMGET(12,241):
; 566  : 	case ITEMGET(12,251):
; 567  : 	case ITEMGET(12,261):
; 568  : 		return true;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 571  : 	}
; 572  : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN5@IsErrtel:

; 569  : 	default:
; 570  : 		return false;

  00027	33 c0		 xor	 eax, eax

; 571  : 	}
; 572  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
  0002d	0f 1f 00	 npad	 3
$LN9@IsErrtel:
  00030	00 00 00 00	 DD	 $LN4@IsErrtel
  00034	00 00 00 00	 DD	 $LN5@IsErrtel
$LN7@IsErrtel:
  00038	00		 DB	 0
  00039	01		 DB	 1
  0003a	01		 DB	 1
  0003b	01		 DB	 1
  0003c	01		 DB	 1
  0003d	01		 DB	 1
  0003e	01		 DB	 1
  0003f	01		 DB	 1
  00040	01		 DB	 1
  00041	01		 DB	 1
  00042	00		 DB	 0
  00043	01		 DB	 1
  00044	01		 DB	 1
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	01		 DB	 1
  0004c	00		 DB	 0
  0004d	01		 DB	 1
  0004e	01		 DB	 1
  0004f	01		 DB	 1
  00050	01		 DB	 1
  00051	01		 DB	 1
  00052	01		 DB	 1
  00053	01		 DB	 1
  00054	01		 DB	 1
  00055	01		 DB	 1
  00056	00		 DB	 0
  00057	01		 DB	 1
  00058	01		 DB	 1
  00059	01		 DB	 1
  0005a	01		 DB	 1
  0005b	01		 DB	 1
  0005c	01		 DB	 1
  0005d	01		 DB	 1
  0005e	01		 DB	 1
  0005f	01		 DB	 1
  00060	00		 DB	 0
?IsErrtel@CElementalSystem@@QAEHH@Z ENDP		; CElementalSystem::IsErrtel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?IsPentagram@CElementalSystem@@QAEHPAVCItem@@@Z
_TEXT	SEGMENT
_lpItem$ = 8						; size = 4
?IsPentagram@CElementalSystem@@QAEHPAVCItem@@@Z PROC	; CElementalSystem::IsPentagram, COMDAT
; _this$ = ecx

; 552  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 	if( lpItem == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@IsPentagra

; 557  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@IsPentagra:

; 554  : 		return false;
; 555  : 
; 556  : 	return IsPentagram(lpItem->m_Type);

  0000e	0f bf 40 06	 movsx	 eax, WORD PTR [eax+6]
  00012	89 45 08	 mov	 DWORD PTR _lpItem$[ebp], eax

; 557  : }

  00015	5d		 pop	 ebp

; 554  : 		return false;
; 555  : 
; 556  : 	return IsPentagram(lpItem->m_Type);

  00016	e9 00 00 00 00	 jmp	 ?IsPentagram@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsPentagram
?IsPentagram@CElementalSystem@@QAEHPAVCItem@@@Z ENDP	; CElementalSystem::IsPentagram
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?IsPentagram@CElementalSystem@@QAEHH@Z
_TEXT	SEGMENT
_iType$ = 8						; size = 4
?IsPentagram@CElementalSystem@@QAEHH@Z PROC		; CElementalSystem::IsPentagram, COMDAT
; _this$ = ecx

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 528  : 	switch(iType)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iType$[ebp]
  00006	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0000b	05 38 e7 ff ff	 add	 eax, -6344		; ffffe738H
  00010	3b c8		 cmp	 ecx, eax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax

; 529  : 	{
; 530  : 	case ITEMGET(12,200):
; 531  : 	case ITEMGET(12,201):
; 532  : 	case ITEMGET(12,202):
; 533  : 	case ITEMGET(12,203):
; 534  : 	case ITEMGET(12,204):
; 535  : 	case ITEMGET(12,205):
; 536  : 	case ITEMGET(12,206):
; 537  : 	case ITEMGET(12,207):
; 538  : 	case ITEMGET(12,208):
; 539  : 	case ITEMGET(12,209):
; 540  : 	case ITEMGET(12,210):
; 541  : 	case ITEMGET(12,211):
; 542  : 	case ITEMGET(12,212):
; 543  : 	case ITEMGET(12,213):
; 544  : 	case ITEMGET(12,214):
; 545  : 		return true;
; 546  : 	default:
; 547  : 		return false;
; 548  : 	}
; 549  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?IsPentagram@CElementalSystem@@QAEHH@Z ENDP		; CElementalSystem::IsPentagram
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?IsElementalItem@CElementalSystem@@QAEHPAVCItem@@@Z
_TEXT	SEGMENT
_lpItem$ = 8						; size = 4
?IsElementalItem@CElementalSystem@@QAEHPAVCItem@@@Z PROC ; CElementalSystem::IsElementalItem, COMDAT
; _this$ = ecx

; 519  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 520  : 	if( lpItem == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@IsElementa

; 524  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@IsElementa:

; 521  : 		return false;
; 522  : 
; 523  : 	return IsElementalItem(lpItem->m_Type);

  0000e	0f bf 40 06	 movsx	 eax, WORD PTR [eax+6]
  00012	89 45 08	 mov	 DWORD PTR _lpItem$[ebp], eax

; 524  : }

  00015	5d		 pop	 ebp

; 521  : 		return false;
; 522  : 
; 523  : 	return IsElementalItem(lpItem->m_Type);

  00016	e9 00 00 00 00	 jmp	 ?IsElementalItem@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsElementalItem
?IsElementalItem@CElementalSystem@@QAEHPAVCItem@@@Z ENDP ; CElementalSystem::IsElementalItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?IsElementalItem@CElementalSystem@@QAEHH@Z
_TEXT	SEGMENT
_iType$ = 8						; size = 4
?IsElementalItem@CElementalSystem@@QAEHH@Z PROC		; CElementalSystem::IsElementalItem, COMDAT
; _this$ = ecx

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 487  : 	switch(iType)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iType$[ebp]
  00006	05 70 e7 ff ff	 add	 eax, -6288		; ffffe770H
  0000b	83 f8 75	 cmp	 eax, 117		; 00000075H
  0000e	77 17		 ja	 SHORT $LN5@IsElementa
  00010	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN7@IsElementa[eax]
  00017	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN9@IsElementa[eax*4]
$LN4@IsElementa:

; 488  : 	{
; 489  : 	case ITEMGET(12,144):
; 490  : 	case ITEMGET(12,145):
; 491  : 	case ITEMGET(12,148):
; 492  : 	case ITEMGET(12,200):
; 493  : 	case ITEMGET(12,201):
; 494  : 	case ITEMGET(12,202):
; 495  : 	case ITEMGET(12,203):
; 496  : 	case ITEMGET(12,204):
; 497  : 	case ITEMGET(12,205):
; 498  : 	case ITEMGET(12,206):
; 499  : 	case ITEMGET(12,207):
; 500  : 	case ITEMGET(12,208):
; 501  : 	case ITEMGET(12,209):
; 502  : 	case ITEMGET(12,210):
; 503  : 	case ITEMGET(12,211):
; 504  : 	case ITEMGET(12,212):
; 505  : 	case ITEMGET(12,213):
; 506  : 	case ITEMGET(12,214):
; 507  : 	case ITEMGET(12,221):
; 508  : 	case ITEMGET(12,231):
; 509  : 	case ITEMGET(12,241):
; 510  : 	case ITEMGET(12,251):
; 511  : 	case ITEMGET(12,261):
; 512  : 		return true;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 515  : 	}
; 516  : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN5@IsElementa:

; 513  : 	default:
; 514  : 		return false;

  00027	33 c0		 xor	 eax, eax

; 515  : 	}
; 516  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
  0002d	0f 1f 00	 npad	 3
$LN9@IsElementa:
  00030	00 00 00 00	 DD	 $LN4@IsElementa
  00034	00 00 00 00	 DD	 $LN5@IsElementa
$LN7@IsElementa:
  00038	00		 DB	 0
  00039	00		 DB	 0
  0003a	01		 DB	 1
  0003b	01		 DB	 1
  0003c	00		 DB	 0
  0003d	01		 DB	 1
  0003e	01		 DB	 1
  0003f	01		 DB	 1
  00040	01		 DB	 1
  00041	01		 DB	 1
  00042	01		 DB	 1
  00043	01		 DB	 1
  00044	01		 DB	 1
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	01		 DB	 1
  0004c	01		 DB	 1
  0004d	01		 DB	 1
  0004e	01		 DB	 1
  0004f	01		 DB	 1
  00050	01		 DB	 1
  00051	01		 DB	 1
  00052	01		 DB	 1
  00053	01		 DB	 1
  00054	01		 DB	 1
  00055	01		 DB	 1
  00056	01		 DB	 1
  00057	01		 DB	 1
  00058	01		 DB	 1
  00059	01		 DB	 1
  0005a	01		 DB	 1
  0005b	01		 DB	 1
  0005c	01		 DB	 1
  0005d	01		 DB	 1
  0005e	01		 DB	 1
  0005f	01		 DB	 1
  00060	01		 DB	 1
  00061	01		 DB	 1
  00062	01		 DB	 1
  00063	01		 DB	 1
  00064	01		 DB	 1
  00065	01		 DB	 1
  00066	01		 DB	 1
  00067	01		 DB	 1
  00068	01		 DB	 1
  00069	01		 DB	 1
  0006a	01		 DB	 1
  0006b	01		 DB	 1
  0006c	01		 DB	 1
  0006d	01		 DB	 1
  0006e	01		 DB	 1
  0006f	01		 DB	 1
  00070	00		 DB	 0
  00071	00		 DB	 0
  00072	00		 DB	 0
  00073	00		 DB	 0
  00074	00		 DB	 0
  00075	00		 DB	 0
  00076	00		 DB	 0
  00077	00		 DB	 0
  00078	00		 DB	 0
  00079	00		 DB	 0
  0007a	00		 DB	 0
  0007b	00		 DB	 0
  0007c	00		 DB	 0
  0007d	00		 DB	 0
  0007e	00		 DB	 0
  0007f	01		 DB	 1
  00080	01		 DB	 1
  00081	01		 DB	 1
  00082	01		 DB	 1
  00083	01		 DB	 1
  00084	01		 DB	 1
  00085	00		 DB	 0
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
  0008b	01		 DB	 1
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	01		 DB	 1
  0008f	00		 DB	 0
  00090	01		 DB	 1
  00091	01		 DB	 1
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	01		 DB	 1
  00096	01		 DB	 1
  00097	01		 DB	 1
  00098	01		 DB	 1
  00099	00		 DB	 0
  0009a	01		 DB	 1
  0009b	01		 DB	 1
  0009c	01		 DB	 1
  0009d	01		 DB	 1
  0009e	01		 DB	 1
  0009f	01		 DB	 1
  000a0	01		 DB	 1
  000a1	01		 DB	 1
  000a2	01		 DB	 1
  000a3	00		 DB	 0
  000a4	01		 DB	 1
  000a5	01		 DB	 1
  000a6	01		 DB	 1
  000a7	01		 DB	 1
  000a8	01		 DB	 1
  000a9	01		 DB	 1
  000aa	01		 DB	 1
  000ab	01		 DB	 1
  000ac	01		 DB	 1
  000ad	00		 DB	 0
?IsElementalItem@CElementalSystem@@QAEHH@Z ENDP		; CElementalSystem::IsElementalItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?LoadOptions@CElementalSystem@@QAEXXZ
_TEXT	SEGMENT
?LoadOptions@CElementalSystem@@QAEXXZ PROC		; CElementalSystem::LoadOptions, COMDAT
; _this$ = ecx

; 355  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 356  : 	this->m_SlotCountRate.InitPool();

  00005	8d 9e 50 1a 00
	00		 lea	 ebx, DWORD PTR [esi+6736]
  0000b	8b cb		 mov	 ecx, ebx
  0000d	e8 00 00 00 00	 call	 ?InitPool@TRandomPoolMgr@@QAEXXZ ; TRandomPoolMgr::InitPool

; 357  : 
; 358  : 	m_iSpiritMap_DropLevel = GetPrivateProfileInt("GameServerInfo","SpiritMapFragment_DropLevel",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0001c	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00021	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00027	50		 push	 eax
  00028	6a 00		 push	 0
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BJLNEGJB@SpiritMapFragment_DropLevel?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00034	ff d7		 call	 edi

; 359  : 	m_iSpiritMap_DropRate = GetPrivateProfileInt("GameServerInfo","SpiritMapFragment_DropRate",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00040	89 86 60 1a 00
	00		 mov	 DWORD PTR [esi+6752], eax
  00046	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0004b	50		 push	 eax
  0004c	6a 00		 push	 0
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MGECKHDP@SpiritMapFragment_DropRate?$AA@
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00058	ff d7		 call	 edi

; 360  : 
; 361  : 	m_iMithril_DropRate = GetPrivateProfileInt("GameServerInfo","MithrilFragment_DropRate",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00064	89 86 64 1a 00
	00		 mov	 DWORD PTR [esi+6756], eax
  0006a	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0006f	50		 push	 eax
  00070	6a 00		 push	 0
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@NJKIAEP@MithrilFragment_DropRate?$AA@
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0007c	ff d7		 call	 edi

; 362  : 	m_iElixir_DropRate = GetPrivateProfileInt("GameServerInfo","ElixirFragment_DropRate",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00083	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00088	89 86 68 1a 00
	00		 mov	 DWORD PTR [esi+6760], eax
  0008e	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00093	50		 push	 eax
  00094	6a 00		 push	 0
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JLLDEOPN@ElixirFragment_DropRate?$AA@
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000a0	ff d7		 call	 edi

; 363  : 
; 364  : 	m_iMurenBook_DropLevel = GetPrivateProfileInt("GameServerInfo","MurenBook_DropLevel",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000ac	89 86 6c 1a 00
	00		 mov	 DWORD PTR [esi+6764], eax
  000b2	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000b7	50		 push	 eax
  000b8	6a 00		 push	 0
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ICNAACD@MurenBook_DropLevel?$AA@
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000c4	ff d7		 call	 edi

; 365  : 	m_iMurenBook_DropRate = GetPrivateProfileInt("GameServerInfo","MurenBook_DropRate",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000d0	89 86 70 1a 00
	00		 mov	 DWORD PTR [esi+6768], eax
  000d6	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000db	50		 push	 eax
  000dc	6a 00		 push	 0
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FHAPEJOE@MurenBook_DropRate?$AA@
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000e8	ff d7		 call	 edi

; 366  : 
; 367  : 	m_iEtramuScroll_DropLevel = GetPrivateProfileInt("GameServerInfo","EtramuScroll_DropLevel",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000f4	89 86 74 1a 00
	00		 mov	 DWORD PTR [esi+6772], eax
  000fa	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000ff	50		 push	 eax
  00100	6a 00		 push	 0
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DAENMFCN@EtramuScroll_DropLevel?$AA@
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0010c	ff d7		 call	 edi

; 368  : 	m_iEtramuScroll_DropRate = GetPrivateProfileInt("GameServerInfo","m_iEtramuScroll_DropRate",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00118	89 86 78 1a 00
	00		 mov	 DWORD PTR [esi+6776], eax
  0011e	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00123	50		 push	 eax
  00124	6a 00		 push	 0
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PBJHJCFF@m_iEtramuScroll_DropRate?$AA@
  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00130	ff d7		 call	 edi
  00132	89 86 7c 1a 00
	00		 mov	 DWORD PTR [esi+6780], eax

; 369  : 
; 370  : 	int tmpRate = GetPrivateProfileInt("GameServerInfo","ElementSlotCountRate1",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0013d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00142	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00147	50		 push	 eax
  00148	6a 00		 push	 0
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FGICCHGI@ElementSlotCountRate1?$AA@
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00154	ff d7		 call	 edi

; 371  : 	m_SlotCountRate.AddValue(1,tmpRate);

  00156	50		 push	 eax
  00157	6a 01		 push	 1
  00159	8b cb		 mov	 ecx, ebx
  0015b	e8 00 00 00 00	 call	 ?AddValue@TRandomPoolMgr@@QAE_NHH@Z ; TRandomPoolMgr::AddValue

; 372  : 
; 373  : 	tmpRate = GetPrivateProfileInt("GameServerInfo","ElementSlotCountRate2",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00165	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0016a	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0016f	50		 push	 eax
  00170	6a 00		 push	 0
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HNKPHEKL@ElementSlotCountRate2?$AA@
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0017c	ff d7		 call	 edi

; 374  : 	m_SlotCountRate.AddValue(2,tmpRate);

  0017e	50		 push	 eax
  0017f	6a 02		 push	 2
  00181	8b cb		 mov	 ecx, ebx
  00183	e8 00 00 00 00	 call	 ?AddValue@TRandomPoolMgr@@QAE_NHH@Z ; TRandomPoolMgr::AddValue

; 375  : 
; 376  : 	tmpRate = GetPrivateProfileInt("GameServerInfo","ElementSlotCountRate3",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0018d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00192	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00197	50		 push	 eax
  00198	6a 00		 push	 0
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GELEEFOK@ElementSlotCountRate3?$AA@
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001a4	ff d7		 call	 edi

; 377  : 	m_SlotCountRate.AddValue(3,tmpRate);

  001a6	50		 push	 eax
  001a7	6a 03		 push	 3
  001a9	8b cb		 mov	 ecx, ebx
  001ab	e8 00 00 00 00	 call	 ?AddValue@TRandomPoolMgr@@QAE_NHH@Z ; TRandomPoolMgr::AddValue

; 378  : 
; 379  : 	tmpRate = GetPrivateProfileInt("GameServerInfo","ElementSlotCountRate4",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001ba	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001bf	50		 push	 eax
  001c0	6a 00		 push	 0
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CLPFNDCN@ElementSlotCountRate4?$AA@
  001c7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001cc	ff d7		 call	 edi

; 380  : 	m_SlotCountRate.AddValue(4,tmpRate);

  001ce	50		 push	 eax
  001cf	6a 04		 push	 4
  001d1	8b cb		 mov	 ecx, ebx
  001d3	e8 00 00 00 00	 call	 ?AddValue@TRandomPoolMgr@@QAE_NHH@Z ; TRandomPoolMgr::AddValue

; 381  : 
; 382  : 	tmpRate = GetPrivateProfileInt("GameServerInfo","ElementSlotCountRate5",0,gDirPath.GetNewPath(FILE_SERVER_COMMON));

  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  001dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001e2	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001e7	50		 push	 eax
  001e8	6a 00		 push	 0
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DCOOOCGM@ElementSlotCountRate5?$AA@
  001ef	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001f4	ff d7		 call	 edi

; 383  : 	m_SlotCountRate.AddValue(5,tmpRate);

  001f6	50		 push	 eax
  001f7	6a 05		 push	 5
  001f9	8b cb		 mov	 ecx, ebx
  001fb	e8 00 00 00 00	 call	 ?AddValue@TRandomPoolMgr@@QAE_NHH@Z ; TRandomPoolMgr::AddValue
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx

; 384  : }

  00203	c3		 ret	 0
?LoadOptions@CElementalSystem@@QAEXXZ ENDP		; CElementalSystem::LoadOptions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?LoadPentagramOption@CElementalSystem@@QAEXPAD@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_Index$1$ = -20						; size = 4
tv782 = -16						; size = 4
_Count$1$ = -12						; size = 4
tv774 = -8						; size = 4
tv773 = -4						; size = 4
tv771 = 8						; size = 4
_szFileName$ = 8					; size = 4
?LoadPentagramOption@CElementalSystem@@QAEXPAD@Z PROC	; CElementalSystem::LoadPentagramOption, COMDAT
; _this$ = ecx

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 267  : 	SMDFile = fopen(szFileName,"r");

  00008	8b 75 08	 mov	 esi, DWORD PTR _szFileName$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00012	56		 push	 esi
  00013	89 5d e8	 mov	 DWORD PTR _this$1$[ebp], ebx
  00016	e8 00 00 00 00	 call	 _fopen
  0001b	83 c4 08	 add	 esp, 8
  0001e	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 268  : 
; 269  : 	if( SMDFile == NULL )

  00023	85 c0		 test	 eax, eax
  00025	75 16		 jne	 SHORT $LN18@LoadPentag

; 270  : 	{
; 271  : 		MsgBox("[Elemental System] Pentagram Option file load fail (%s)",szFileName);

  00027	56		 push	 esi
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@GIDECHPE@?$FLElemental?5System?$FN?5Pentagram?5Opt@
  0002d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00032	83 c4 08	 add	 esp, 8
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 352  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN18@LoadPentag:

; 272  : 		return;
; 273  : 	}
; 274  : 
; 275  : 	for (int n = 0; n < MAX_PENTAGRAM_ITEMS; n++)

  0003d	8d 83 46 19 00
	00		 lea	 eax, DWORD PTR [ebx+6470]
  00043	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00048	89 45 f0	 mov	 DWORD PTR tv782[ebp], eax
  0004b	83 ca ff	 or	 edx, -1
  0004e	66 90		 npad	 2
$LL4@LoadPentag:

; 276  : 	{
; 277  : 		this->m_PentagramItems[n].m_itemId = -1;

  00050	66 89 10	 mov	 WORD PTR [eax], dx
  00053	8d 40 0c	 lea	 eax, DWORD PTR [eax+12]
  00056	83 e9 01	 sub	 ecx, 1
  00059	75 f5		 jne	 SHORT $LL4@LoadPentag

; 278  : 	}
; 279  : 
; 280  : 	for (int n = 0; n < MAX_PENTAGRAM_OPTIONS; n++)
; 281  : 	{
; 282  : 		this->m_PentagramOptionInfo[n].m_btOptionID = -1;

  0005b	57		 push	 edi
  0005c	c6 83 fa 19 00
	00 ff		 mov	 BYTE PTR [ebx+6650], 255 ; 000000ffH
  00063	c6 83 04 1a 00
	00 ff		 mov	 BYTE PTR [ebx+6660], 255 ; 000000ffH
  0006a	c6 83 0e 1a 00
	00 ff		 mov	 BYTE PTR [ebx+6670], 255 ; 000000ffH
  00071	c6 83 18 1a 00
	00 ff		 mov	 BYTE PTR [ebx+6680], 255 ; 000000ffH
  00078	c6 83 22 1a 00
	00 ff		 mov	 BYTE PTR [ebx+6690], 255 ; 000000ffH
  0007f	c6 83 2c 1a 00
	00 ff		 mov	 BYTE PTR [ebx+6700], 255 ; 000000ffH
  00086	c6 83 36 1a 00
	00 ff		 mov	 BYTE PTR [ebx+6710], 255 ; 000000ffH

; 283  : 	}
; 284  : 
; 285  : 	int Token,Index,Count;
; 286  : 	
; 287  : 	while( TRUE )
; 288  : 	{
; 289  : 		Token = GetToken();

  0008d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 290  : 
; 291  : 		if( Token == END )

  00092	83 f8 02	 cmp	 eax, 2
  00095	0f 84 7e 01 00
	00		 je	 $LN38@LoadPentag
  0009b	0f 1f 44 00 00	 npad	 5
$LL8@LoadPentag:

; 292  : 			break;
; 293  : 
; 294  : 		Index = TokenNumber;

  000a0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA

; 295  : 		Count = 0;

  000a8	33 ff		 xor	 edi, edi
  000aa	89 7d f4	 mov	 DWORD PTR _Count$1$[ebp], edi
  000ad	89 45 ec	 mov	 DWORD PTR _Index$1$[ebp], eax

; 296  : 
; 297  : 		while( TRUE )
; 298  : 		{
; 299  : 			Token = GetToken();

  000b0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 300  : 
; 301  : 			if( !strcmp(TokenString,"end") )

  000b5	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  000ba	b8 00 00 00 00	 mov	 eax, OFFSET ?TokenString@@3PADA
  000bf	90		 npad	 1
$LL62@LoadPentag:
  000c0	8a 10		 mov	 dl, BYTE PTR [eax]
  000c2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000c4	75 1a		 jne	 SHORT $LN63@LoadPentag
  000c6	84 d2		 test	 dl, dl
  000c8	74 12		 je	 SHORT $LN64@LoadPentag
  000ca	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000cd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000d0	75 0e		 jne	 SHORT $LN63@LoadPentag
  000d2	83 c0 02	 add	 eax, 2
  000d5	83 c1 02	 add	 ecx, 2
  000d8	84 d2		 test	 dl, dl
  000da	75 e4		 jne	 SHORT $LL62@LoadPentag
$LN64@LoadPentag:
  000dc	33 c0		 xor	 eax, eax
  000de	eb 05		 jmp	 SHORT $LN65@LoadPentag
$LN63@LoadPentag:
  000e0	1b c0		 sbb	 eax, eax
  000e2	83 c8 01	 or	 eax, 1
$LN65@LoadPentag:
  000e5	85 c0		 test	 eax, eax
  000e7	0f 84 1e 01 00
	00		 je	 $LN35@LoadPentag

; 292  : 			break;
; 293  : 
; 294  : 		Index = TokenNumber;

  000ed	8b 45 f0	 mov	 eax, DWORD PTR tv782[ebp]
  000f0	8d b3 fc 19 00
	00		 lea	 esi, DWORD PTR [ebx+6652]
  000f6	8d 8b fa 19 00
	00		 lea	 ecx, DWORD PTR [ebx+6650]
  000fc	89 75 f8	 mov	 DWORD PTR tv774[ebp], esi
  000ff	89 4d fc	 mov	 DWORD PTR tv773[ebp], ecx
  00102	81 c3 48 19 00
	00		 add	 ebx, 6472		; 00001948H
  00108	89 45 08	 mov	 DWORD PTR tv771[ebp], eax
  0010b	0f 1f 44 00 00	 npad	 5
$LL10@LoadPentag:

; 302  : 				break;
; 303  : 
; 304  : 			if( Index == 0 )

  00110	8b 45 ec	 mov	 eax, DWORD PTR _Index$1$[ebp]
  00113	85 c0		 test	 eax, eax
  00115	75 43		 jne	 SHORT $LN21@LoadPentag

; 305  : 			{
; 306  : 				if( Count >= MAX_PENTAGRAM_ITEMS )

  00117	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  0011a	0f 8d 10 01 00
	00		 jge	 $LN36@LoadPentag

; 309  : 					return;
; 310  : 				}
; 311  : 
; 312  : 				int itemIndex = TokenNumber;

  00120	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 313  : 
; 314  : 				Token = GetToken();

  00128	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 315  : 				int itemNumber = TokenNumber;
; 316  : 
; 317  : 				this->m_PentagramItems[Count].m_itemId = ITEMGET(itemIndex,itemNumber);

  0012d	c1 e6 09	 shl	 esi, 9
  00130	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00138	03 f0		 add	 esi, eax
  0013a	8b 45 08	 mov	 eax, DWORD PTR tv771[ebp]
  0013d	66 89 30	 mov	 WORD PTR [eax], si

; 318  : 
; 319  : 				for(int i = 0; i < 9; i++)

  00140	33 f6		 xor	 esi, esi
$LL14@LoadPentag:

; 320  : 				{
; 321  : 					Token = GetToken();

  00142	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 322  : 					this->m_PentagramItems[Count].m_btOption[i] = TokenNumber;

  00147	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0014f	88 04 33	 mov	 BYTE PTR [ebx+esi], al
  00152	46		 inc	 esi
  00153	83 fe 09	 cmp	 esi, 9
  00156	7c ea		 jl	 SHORT $LL14@LoadPentag

; 323  : 				}
; 324  : 				Count++;

  00158	eb 57		 jmp	 SHORT $LN71@LoadPentag
$LN21@LoadPentag:

; 325  : 			}
; 326  : 			else if( Index == 1 )

  0015a	83 f8 01	 cmp	 eax, 1
  0015d	75 6a		 jne	 SHORT $LN24@LoadPentag

; 327  : 			{
; 328  : 				if( Count >= MAX_PENTAGRAM_OPTIONS )

  0015f	83 ff 07	 cmp	 edi, 7
  00162	0f 8d de 00 00
	00		 jge	 $LN37@LoadPentag

; 331  : 					return;
; 332  : 				}
; 333  : 
; 334  : 				this->m_PentagramOptionInfo[Count].m_btOptionID = TokenNumber;

  00168	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00170	bf 03 00 00 00	 mov	 edi, 3
  00175	88 01		 mov	 BYTE PTR [ecx], al
$LL17@LoadPentag:

; 335  : 
; 336  : 				for(int i = 0; i < 3; i++)
; 337  : 				{
; 338  : 					Token = GetToken();

  00177	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 339  : 					this->m_PentagramOptionInfo[Count].m_Reqs[i].m_btErtelType = TokenNumber;

  0017c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00184	88 46 ff	 mov	 BYTE PTR [esi-1], al

; 340  : 
; 341  : 					Token = GetToken();

  00187	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 342  : 					this->m_PentagramOptionInfo[Count].m_Reqs[i].m_btRankReq = TokenNumber;

  0018c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00194	88 06		 mov	 BYTE PTR [esi], al

; 343  : 
; 344  : 					Token = GetToken();

  00196	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0019b	8d 76 03	 lea	 esi, DWORD PTR [esi+3]

; 345  : 					this->m_PentagramOptionInfo[Count].m_Reqs[i].m_btLevelReq = TokenNumber;

  0019e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001a6	88 46 fe	 mov	 BYTE PTR [esi-2], al
  001a9	83 ef 01	 sub	 edi, 1
  001ac	75 c9		 jne	 SHORT $LL17@LoadPentag

; 346  : 				}
; 347  : 				Count++;

  001ae	8b 7d f4	 mov	 edi, DWORD PTR _Count$1$[ebp]
$LN71@LoadPentag:
  001b1	8b 75 f8	 mov	 esi, DWORD PTR tv774[ebp]
  001b4	47		 inc	 edi
  001b5	83 45 08 0c	 add	 DWORD PTR tv771[ebp], 12 ; 0000000cH
  001b9	83 c3 0c	 add	 ebx, 12			; 0000000cH
  001bc	83 45 fc 0a	 add	 DWORD PTR tv773[ebp], 10 ; 0000000aH
  001c0	83 c6 0a	 add	 esi, 10			; 0000000aH
  001c3	89 75 f8	 mov	 DWORD PTR tv774[ebp], esi
  001c6	89 7d f4	 mov	 DWORD PTR _Count$1$[ebp], edi
$LN24@LoadPentag:

; 300  : 
; 301  : 			if( !strcmp(TokenString,"end") )

  001c9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001ce	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  001d3	b8 00 00 00 00	 mov	 eax, OFFSET ?TokenString@@3PADA
$LL66@LoadPentag:
  001d8	8a 10		 mov	 dl, BYTE PTR [eax]
  001da	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001dc	75 1a		 jne	 SHORT $LN67@LoadPentag
  001de	84 d2		 test	 dl, dl
  001e0	74 12		 je	 SHORT $LN68@LoadPentag
  001e2	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001e5	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001e8	75 0e		 jne	 SHORT $LN67@LoadPentag
  001ea	83 c0 02	 add	 eax, 2
  001ed	83 c1 02	 add	 ecx, 2
  001f0	84 d2		 test	 dl, dl
  001f2	75 e4		 jne	 SHORT $LL66@LoadPentag
$LN68@LoadPentag:
  001f4	33 c0		 xor	 eax, eax
  001f6	eb 05		 jmp	 SHORT $LN69@LoadPentag
$LN67@LoadPentag:
  001f8	1b c0		 sbb	 eax, eax
  001fa	83 c8 01	 or	 eax, 1
$LN69@LoadPentag:
  001fd	8b 4d fc	 mov	 ecx, DWORD PTR tv773[ebp]
  00200	85 c0		 test	 eax, eax
  00202	0f 85 08 ff ff
	ff		 jne	 $LL10@LoadPentag
  00208	8b 5d e8	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN35@LoadPentag:

; 283  : 	}
; 284  : 
; 285  : 	int Token,Index,Count;
; 286  : 	
; 287  : 	while( TRUE )
; 288  : 	{
; 289  : 		Token = GetToken();

  0020b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 290  : 
; 291  : 		if( Token == END )

  00210	83 f8 02	 cmp	 eax, 2
  00213	0f 85 87 fe ff
	ff		 jne	 $LL8@LoadPentag
$LN38@LoadPentag:

; 348  : 			}
; 349  : 		}
; 350  : 	}
; 351  : 	fclose(SMDFile);

  00219	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021f	e8 00 00 00 00	 call	 _fclose
  00224	83 c4 04	 add	 esp, 4
  00227	5f		 pop	 edi
  00228	5e		 pop	 esi
  00229	5b		 pop	 ebx

; 352  : }

  0022a	8b e5		 mov	 esp, ebp
  0022c	5d		 pop	 ebp
  0022d	c2 04 00	 ret	 4
$LN36@LoadPentag:

; 307  : 				{
; 308  : 					MsgBox("[Elemental System] Pentagram Option Count >= MAX_PENTAGRAM_ITEMS");

  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NFJNMDPD@?$FLElemental?5System?$FN?5Pentagram?5Opt@
  00235	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 348  : 			}
; 349  : 		}
; 350  : 	}
; 351  : 	fclose(SMDFile);

  0023a	83 c4 04	 add	 esp, 4
  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx

; 352  : }

  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 04 00	 ret	 4
$LN37@LoadPentag:

; 329  : 				{
; 330  : 					MsgBox("[Elemental System] Pentagram Option Count >= MAX_PENTAGRAM_OPTIONS");

  00246	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MDILOIPJ@?$FLElemental?5System?$FN?5Pentagram?5Opt@
  0024b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 348  : 			}
; 349  : 		}
; 350  : 	}
; 351  : 	fclose(SMDFile);

  00250	83 c4 04	 add	 esp, 4
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi
  00255	5b		 pop	 ebx

; 352  : }

  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c2 04 00	 ret	 4
?LoadPentagramOption@CElementalSystem@@QAEXPAD@Z ENDP	; CElementalSystem::LoadPentagramOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?LoadElementalInfo@CElementalSystem@@QAEXPAD@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
_Index$1$ = -8						; size = 4
tv1131 = -4						; size = 4
_count$1$ = 8						; size = 4
_szFileName$ = 8					; size = 4
?LoadElementalInfo@CElementalSystem@@QAEXPAD@Z PROC	; CElementalSystem::LoadElementalInfo, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 72   : 	SMDFile = fopen(szFileName,"r");

  00008	8b 75 08	 mov	 esi, DWORD PTR _szFileName$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00012	56		 push	 esi
  00013	89 5d f4	 mov	 DWORD PTR _this$1$[ebp], ebx
  00016	e8 00 00 00 00	 call	 _fopen
  0001b	83 c4 08	 add	 esp, 8
  0001e	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 73   : 
; 74   : 	if( !SMDFile )

  00023	85 c0		 test	 eax, eax
  00025	75 16		 jne	 SHORT $LN24@LoadElemen

; 75   : 	{
; 76   : 		MsgBox("[Elemental System] Ertel file load fail (%s)",szFileName);

  00027	56		 push	 esi
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HOILEDFI@?$FLElemental?5System?$FN?5Ertel?5file?5lo@
  0002d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00032	83 c4 08	 add	 esp, 8
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 263  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN24@LoadElemen:
  0003d	57		 push	 edi

; 77   : 		return;
; 78   : 	}
; 79   : 
; 80   : 	int Token,Index,count = 0;

  0003e	33 ff		 xor	 edi, edi
  00040	89 7d 08	 mov	 DWORD PTR _count$1$[ebp], edi

; 81   : 
; 82   : 	while( TRUE )
; 83   : 	{
; 84   : 		Token = GetToken();

  00043	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 85   : 
; 86   : 		if( Token == END )

  00048	83 f8 02	 cmp	 eax, 2
  0004b	0f 84 bc 04 00
	00		 je	 $LN108@LoadElemen
$LL2@LoadElemen:

; 87   : 			break;
; 88   : 
; 89   : 		if( !strcmp(TokenString,"end") )

  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00056	b8 00 00 00 00	 mov	 eax, OFFSET ?TokenString@@3PADA
  0005b	0f 1f 44 00 00	 npad	 5
$LL96@LoadElemen:
  00060	8a 10		 mov	 dl, BYTE PTR [eax]
  00062	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00064	75 1a		 jne	 SHORT $LN97@LoadElemen
  00066	84 d2		 test	 dl, dl
  00068	74 12		 je	 SHORT $LN98@LoadElemen
  0006a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00070	75 0e		 jne	 SHORT $LN97@LoadElemen
  00072	83 c0 02	 add	 eax, 2
  00075	83 c1 02	 add	 ecx, 2
  00078	84 d2		 test	 dl, dl
  0007a	75 e4		 jne	 SHORT $LL96@LoadElemen
$LN98@LoadElemen:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN99@LoadElemen
$LN97@LoadElemen:
  00080	1b c0		 sbb	 eax, eax
  00082	83 c8 01	 or	 eax, 1
$LN99@LoadElemen:
  00085	85 c0		 test	 eax, eax
  00087	0f 84 80 04 00
	00		 je	 $LN108@LoadElemen

; 90   : 			break;
; 91   : 
; 92   : 		Index = (int)TokenNumber;

  0008d	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA
  00095	89 75 f8	 mov	 DWORD PTR _Index$1$[ebp], esi

; 93   : 
; 94   : 		while( TRUE )
; 95   : 		{
; 96   : 			Token = GetToken();

  00098	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 97   : 
; 98   : 			if( !strcmp(TokenString,"end") )

  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  000a2	b8 00 00 00 00	 mov	 eax, OFFSET ?TokenString@@3PADA
$LL100@LoadElemen:
  000a7	8a 10		 mov	 dl, BYTE PTR [eax]
  000a9	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000ab	75 1a		 jne	 SHORT $LN101@LoadElemen
  000ad	84 d2		 test	 dl, dl
  000af	74 12		 je	 SHORT $LN102@LoadElemen
  000b1	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000b4	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000b7	75 0e		 jne	 SHORT $LN101@LoadElemen
  000b9	83 c0 02	 add	 eax, 2
  000bc	83 c1 02	 add	 ecx, 2
  000bf	84 d2		 test	 dl, dl
  000c1	75 e4		 jne	 SHORT $LL100@LoadElemen
$LN102@LoadElemen:
  000c3	33 c0		 xor	 eax, eax
  000c5	eb 05		 jmp	 SHORT $LN103@LoadElemen
$LN101@LoadElemen:
  000c7	1b c0		 sbb	 eax, eax
  000c9	83 c8 01	 or	 eax, 1
$LN103@LoadElemen:
  000cc	85 c0		 test	 eax, eax
  000ce	0f 84 2b 04 00
	00		 je	 $LN95@LoadElemen

; 90   : 			break;
; 91   : 
; 92   : 		Index = (int)TokenNumber;

  000d4	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  000db	2b c7		 sub	 eax, edi
  000dd	8d 78 6d	 lea	 edi, DWORD PTR [eax+109]
  000e0	8d 3c fb	 lea	 edi, DWORD PTR [ebx+edi*8]
  000e3	89 7d fc	 mov	 DWORD PTR tv1131[ebp], edi
$LL4@LoadElemen:

; 99   : 				break;
; 100  : 
; 101  : 			if( Index == 0 )

  000e6	85 f6		 test	 esi, esi
  000e8	0f 85 ea 00 00
	00		 jne	 $LN28@LoadElemen

; 102  : 			{
; 103  : 				m_ErtelOption[count].btId = (BYTE)TokenNumber;

  000ee	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000f6	88 47 fe	 mov	 BYTE PTR [edi-2], al

; 104  : 
; 105  : 				Token = GetToken();

  000f9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 106  : 				BYTE btIndex = (BYTE)TokenNumber;

  000fe	f3 0f 2c 1d 00
	00 00 00	 cvttss2si ebx, DWORD PTR ?TokenNumber@@3MA

; 107  : 
; 108  : 				Token = GetToken();

  00106	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 109  : 				WORD wNumber = (WORD)TokenNumber;
; 110  : 
; 111  : 				m_ErtelOption[count].ItemID = ITEMGET(btIndex,wNumber);

  0010b	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00110	0f b6 cb	 movzx	 ecx, bl
  00113	0f af c8	 imul	 ecx, eax
  00116	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0011e	66 03 c8	 add	 cx, ax
  00121	66 89 0f	 mov	 WORD PTR [edi], cx

; 112  : 
; 113  : 				Token = GetToken();

  00124	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 114  : 				m_ErtelOption[count].btRank = (BYTE)TokenNumber;

  00129	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00131	88 47 02	 mov	 BYTE PTR [edi+2], al

; 115  : 
; 116  : 				Token = GetToken();

  00134	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 117  : 				m_ErtelOption[count].btOption = (BYTE)TokenNumber;

  00139	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00141	88 47 03	 mov	 BYTE PTR [edi+3], al

; 118  : 
; 119  : 				Token = GetToken();

  00144	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 120  : 				m_ErtelOption[count].OptionRate = (BYTE)TokenNumber;

  00149	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00151	0f b6 c0	 movzx	 eax, al
  00154	66 89 47 04	 mov	 WORD PTR [edi+4], ax

; 121  : 
; 122  : 				Token = GetToken();

  00158	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 123  : 				m_ErtelOption[count].wType = (WORD)TokenNumber;

  0015d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00165	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00168	66 89 47 06	 mov	 WORD PTR [edi+6], ax
  0016c	bf 0b 00 00 00	 mov	 edi, 11			; 0000000bH
$LL8@LoadElemen:

; 124  : 
; 125  : 				int i;
; 126  : 				for(i = 0; i < MAX_ERTEL_LEVEL; i++)	{
; 127  : 					Token = GetToken();

  00171	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00176	8d 76 02	 lea	 esi, DWORD PTR [esi+2]

; 128  : 					m_ErtelOption[count].Option[i] = (BYTE)TokenNumber;

  00179	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00181	0f b6 c0	 movzx	 eax, al
  00184	66 89 46 fe	 mov	 WORD PTR [esi-2], ax
  00188	83 ef 01	 sub	 edi, 1
  0018b	75 e4		 jne	 SHORT $LL8@LoadElemen

; 129  : 				}
; 130  : 
; 131  : 				for(i = 0; i < MAX_ERTEL_LEVEL; i++)	{

  0018d	8b 75 fc	 mov	 esi, DWORD PTR tv1131[ebp]
  00190	bf 0b 00 00 00	 mov	 edi, 11			; 0000000bH
  00195	83 c6 1e	 add	 esi, 30			; 0000001eH
$LL11@LoadElemen:

; 132  : 					Token = GetToken();

  00198	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0019d	8d 76 02	 lea	 esi, DWORD PTR [esi+2]

; 133  : 					m_ErtelOption[count].Rate[i] = (BYTE)TokenNumber;

  001a0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001a8	0f b6 c0	 movzx	 eax, al
  001ab	66 89 46 fe	 mov	 WORD PTR [esi-2], ax
  001af	83 ef 01	 sub	 edi, 1
  001b2	75 e4		 jne	 SHORT $LL11@LoadElemen

; 134  : 				}
; 135  : 
; 136  : 				Token = GetToken();

  001b4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 137  : 				m_ErtelOption[count].btIncType = (BYTE)TokenNumber;

  001b9	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001c1	8b 7d fc	 mov	 edi, DWORD PTR tv1131[ebp]

; 138  : 				count++;

  001c4	ff 45 08	 inc	 DWORD PTR _count$1$[ebp]
  001c7	8b 5d f4	 mov	 ebx, DWORD PTR _this$1$[ebp]
  001ca	88 47 34	 mov	 BYTE PTR [edi+52], al
  001cd	83 c7 38	 add	 edi, 56			; 00000038H
  001d0	89 7d fc	 mov	 DWORD PTR tv1131[ebp], edi
  001d3	e9 cf 02 00 00	 jmp	 $LN110@LoadElemen
$LN28@LoadElemen:

; 139  : 			}
; 140  : 			else if( Index == 1 )

  001d8	83 fe 01	 cmp	 esi, 1
  001db	0f 85 d1 00 00
	00		 jne	 $LN30@LoadElemen

; 141  : 			{
; 142  : 				int playerClass = (int)TokenNumber;

  001e1	f3 0f 2c 3d 00
	00 00 00	 cvttss2si edi, DWORD PTR ?TokenNumber@@3MA

; 143  : 
; 144  : 				if( playerClass < 0 || playerClass >= MAX_TYPE_PLAYER )	{

  001e9	83 ff 06	 cmp	 edi, 6
  001ec	0f 87 fd 02 00
	00		 ja	 $LN70@LoadElemen

; 145  : 					MsgBox("[Elemental System] Damage player class out of bounds!");
; 146  : 					break;
; 147  : 				}
; 148  : 
; 149  : 				Token = GetToken();

  001f2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 150  : 				this->m_classinfo[playerClass].strMin = (WORD)TokenNumber;

  001f7	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001ff	8b f7		 mov	 esi, edi
  00201	c1 e6 04	 shl	 esi, 4
  00204	2b f7		 sub	 esi, edi
  00206	66 89 44 f3 04	 mov	 WORD PTR [ebx+esi*8+4], ax

; 151  : 
; 152  : 				Token = GetToken();

  0020b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 153  : 				this->m_classinfo[playerClass].strMax = (WORD)TokenNumber;

  00210	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00218	66 89 44 f3 06	 mov	 WORD PTR [ebx+esi*8+6], ax

; 154  : 
; 155  : 				Token = GetToken();

  0021d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 156  : 				this->m_classinfo[playerClass].dexMin = (WORD)TokenNumber;

  00222	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0022a	66 89 44 f3 08	 mov	 WORD PTR [ebx+esi*8+8], ax

; 157  : 
; 158  : 				Token = GetToken();

  0022f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 159  : 				this->m_classinfo[playerClass].dexMax = (WORD)TokenNumber;

  00234	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0023c	66 89 44 f3 0a	 mov	 WORD PTR [ebx+esi*8+10], ax

; 160  : 
; 161  : 				Token = GetToken();

  00241	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 162  : 				this->m_classinfo[playerClass].vitMin = (WORD)TokenNumber;

  00246	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0024e	66 89 44 f3 0c	 mov	 WORD PTR [ebx+esi*8+12], ax

; 163  : 
; 164  : 				Token = GetToken();

  00253	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 165  : 				this->m_classinfo[playerClass].vitMax = (WORD)TokenNumber;

  00258	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00260	66 89 44 f3 0e	 mov	 WORD PTR [ebx+esi*8+14], ax

; 166  : 
; 167  : 				Token = GetToken();

  00265	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 168  : 				this->m_classinfo[playerClass].eneMin = (WORD)TokenNumber;

  0026a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00272	66 89 44 f3 10	 mov	 WORD PTR [ebx+esi*8+16], ax

; 169  : 
; 170  : 				Token = GetToken();

  00277	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 171  : 				this->m_classinfo[playerClass].eneMax = (WORD)TokenNumber;

  0027c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00284	66 89 44 f3 12	 mov	 WORD PTR [ebx+esi*8+18], ax

; 172  : 
; 173  : 				Token = GetToken();

  00289	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 174  : 				this->m_classinfo[playerClass].cmdMin = (WORD)TokenNumber;

  0028e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00296	66 89 44 f3 14	 mov	 WORD PTR [ebx+esi*8+20], ax

; 175  : 
; 176  : 				Token = GetToken();

  0029b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 177  : 				this->m_classinfo[playerClass].cmdMax = (WORD)TokenNumber;

  002a0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002a8	66 89 44 f3 16	 mov	 WORD PTR [ebx+esi*8+22], ax
  002ad	e9 f2 01 00 00	 jmp	 $LN111@LoadElemen
$LN30@LoadElemen:

; 178  : 			}
; 179  : 			else if( Index == 2 )

  002b2	83 fe 02	 cmp	 esi, 2
  002b5	75 2f		 jne	 SHORT $LN34@LoadElemen

; 180  : 			{
; 181  : 				int playerClass = (int)TokenNumber;

  002b7	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 182  : 
; 183  : 				if( playerClass < 0 || playerClass >= MAX_TYPE_PLAYER )	{

  002bf	83 fe 06	 cmp	 esi, 6
  002c2	0f 87 27 02 00
	00		 ja	 $LN70@LoadElemen

; 184  : 					MsgBox("[Elemental System] Damage player class out of bounds!");
; 185  : 					break;
; 186  : 				}
; 187  : 
; 188  : 				Token = GetToken();

  002c8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 189  : 				this->m_classinfo[playerClass].dexDef = (WORD)TokenNumber;

  002cd	f3 0f 2c 0d 00
	00 00 00	 cvttss2si ecx, DWORD PTR ?TokenNumber@@3MA
  002d5	8b c6		 mov	 eax, esi
  002d7	c1 e0 04	 shl	 eax, 4
  002da	2b c6		 sub	 eax, esi
  002dc	66 89 4c c3 18	 mov	 WORD PTR [ebx+eax*8+24], cx
  002e1	e9 c1 01 00 00	 jmp	 $LN110@LoadElemen
$LN34@LoadElemen:

; 190  : 			}
; 191  : 			else if( Index == 3 )

  002e6	83 fe 03	 cmp	 esi, 3
  002e9	75 6e		 jne	 SHORT $LN38@LoadElemen

; 192  : 			{
; 193  : 				int playerClass = (int)TokenNumber;

  002eb	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 194  : 
; 195  : 				if( playerClass < 0 || playerClass >= MAX_TYPE_PLAYER )	{

  002f3	83 fe 06	 cmp	 esi, 6
  002f6	0f 87 f3 01 00
	00		 ja	 $LN70@LoadElemen

; 196  : 					MsgBox("[Elemental System] Damage player class out of bounds!");
; 197  : 					break;
; 198  : 				}
; 199  : 
; 200  : 				Token = GetToken();

  002fc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 201  : 				this->m_classinfo[playerClass].DefRate_LEVELMUL = (WORD)TokenNumber;

  00301	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00309	8b ce		 mov	 ecx, esi
  0030b	bf 05 00 00 00	 mov	 edi, 5
  00310	c1 e1 04	 shl	 ecx, 4
  00313	2b ce		 sub	 ecx, esi
  00315	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00318	8d 34 f3	 lea	 esi, DWORD PTR [ebx+esi*8]
  0031b	0f b7 c0	 movzx	 eax, ax
  0031e	66 0f 6e c0	 movd	 xmm0, eax
  00322	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00325	f3 0f 11 44 cb
	1c		 movss	 DWORD PTR [ebx+ecx*8+28], xmm0
  0032b	0f 1f 44 00 00	 npad	 5
$LL14@LoadElemen:

; 202  : 
; 203  : 				for(int i = 0; i < 5; i++)	{
; 204  : 					Token = GetToken();

  00330	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00335	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 205  : 					this->m_classinfo[playerClass].DefRate_MUL[i] = (WORD)TokenNumber;

  00338	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00340	0f b7 c0	 movzx	 eax, ax
  00343	66 0f 6e c0	 movd	 xmm0, eax
  00347	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0034a	f3 0f 11 46 fc	 movss	 DWORD PTR [esi-4], xmm0
  0034f	83 ef 01	 sub	 edi, 1
  00352	75 dc		 jne	 SHORT $LL14@LoadElemen

; 206  : 				}
; 207  : 			}
; 208  : 			else if( Index == 4 )

  00354	e9 4b 01 00 00	 jmp	 $LN111@LoadElemen
$LN38@LoadElemen:
  00359	83 fe 04	 cmp	 esi, 4
  0035c	75 6b		 jne	 SHORT $LN42@LoadElemen

; 209  : 			{
; 210  : 				int playerClass = (int)TokenNumber;

  0035e	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 211  : 
; 212  : 				if( playerClass < 0 || playerClass >= MAX_TYPE_PLAYER )	{

  00366	83 fe 06	 cmp	 esi, 6
  00369	0f 87 80 01 00
	00		 ja	 $LN70@LoadElemen

; 213  : 					MsgBox("[Elemental System] Damage player class out of bounds!");
; 214  : 					break;
; 215  : 				}
; 216  : 
; 217  : 				Token = GetToken();

  0036f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 218  : 				this->m_classinfo[playerClass].AttRate_LEVELMUL = (WORD)TokenNumber;

  00374	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0037c	8b ce		 mov	 ecx, esi
  0037e	bf 05 00 00 00	 mov	 edi, 5
  00383	c1 e1 04	 shl	 ecx, 4
  00386	2b ce		 sub	 ecx, esi
  00388	8d 71 07	 lea	 esi, DWORD PTR [ecx+7]
  0038b	8d 34 f3	 lea	 esi, DWORD PTR [ebx+esi*8]
  0038e	0f b7 c0	 movzx	 eax, ax
  00391	66 0f 6e c0	 movd	 xmm0, eax
  00395	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00398	f3 0f 11 44 cb
	34		 movss	 DWORD PTR [ebx+ecx*8+52], xmm0
  0039e	66 90		 npad	 2
$LL17@LoadElemen:

; 219  : 
; 220  : 				for(int i = 0; i < 5; i++)	{
; 221  : 					Token = GetToken();

  003a0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003a5	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 222  : 					this->m_classinfo[playerClass].AttRate_MUL[i] = (WORD)TokenNumber;

  003a8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003b0	0f b7 c0	 movzx	 eax, ax
  003b3	66 0f 6e c0	 movd	 xmm0, eax
  003b7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  003ba	f3 0f 11 46 fc	 movss	 DWORD PTR [esi-4], xmm0
  003bf	83 ef 01	 sub	 edi, 1
  003c2	75 dc		 jne	 SHORT $LL17@LoadElemen

; 223  : 				}
; 224  : 			}
; 225  : 			else if( Index == 5 )

  003c4	e9 db 00 00 00	 jmp	 $LN111@LoadElemen
$LN42@LoadElemen:
  003c9	83 fe 05	 cmp	 esi, 5
  003cc	75 68		 jne	 SHORT $LN46@LoadElemen

; 226  : 			{
; 227  : 				int playerClass = (int)TokenNumber;

  003ce	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 228  : 
; 229  : 				if( playerClass < 0 || playerClass >= MAX_TYPE_PLAYER )	{

  003d6	83 fe 06	 cmp	 esi, 6
  003d9	0f 87 10 01 00
	00		 ja	 $LN70@LoadElemen

; 230  : 					MsgBox("[Elemental System] Damage player class out of bounds!");
; 231  : 					break;
; 232  : 				}
; 233  : 
; 234  : 				Token = GetToken();

  003df	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 235  : 				this->m_classinfo[playerClass].DefRate_LEVELMUL_PVP = (WORD)TokenNumber;

  003e4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003ec	8b ce		 mov	 ecx, esi
  003ee	bf 05 00 00 00	 mov	 edi, 5
  003f3	c1 e1 04	 shl	 ecx, 4
  003f6	2b ce		 sub	 ecx, esi
  003f8	8d 71 0a	 lea	 esi, DWORD PTR [ecx+10]
  003fb	8d 34 f3	 lea	 esi, DWORD PTR [ebx+esi*8]
  003fe	0f b7 c0	 movzx	 eax, ax
  00401	66 0f 6e c0	 movd	 xmm0, eax
  00405	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00408	f3 0f 11 44 cb
	4c		 movss	 DWORD PTR [ebx+ecx*8+76], xmm0
  0040e	66 90		 npad	 2
$LL20@LoadElemen:

; 236  : 
; 237  : 				for(int i = 0; i < 5; i++)	{
; 238  : 					Token = GetToken();

  00410	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00415	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 239  : 					this->m_classinfo[playerClass].DefRate_MUL_PVP[i] = (WORD)TokenNumber;

  00418	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00420	0f b7 c0	 movzx	 eax, ax
  00423	66 0f 6e c0	 movd	 xmm0, eax
  00427	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0042a	f3 0f 11 46 fc	 movss	 DWORD PTR [esi-4], xmm0
  0042f	83 ef 01	 sub	 edi, 1
  00432	75 dc		 jne	 SHORT $LL20@LoadElemen

; 240  : 				}
; 241  : 			}
; 242  : 			else if( Index == 6 )

  00434	eb 6e		 jmp	 SHORT $LN111@LoadElemen
$LN46@LoadElemen:
  00436	83 fe 06	 cmp	 esi, 6
  00439	75 6f		 jne	 SHORT $LN22@LoadElemen

; 243  : 			{
; 244  : 				int playerClass = (int)TokenNumber;

  0043b	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 245  : 
; 246  : 				if( playerClass < 0 || playerClass >= MAX_TYPE_PLAYER )	{

  00443	83 fe 06	 cmp	 esi, 6
  00446	0f 87 a3 00 00
	00		 ja	 $LN70@LoadElemen

; 248  : 					break;
; 249  : 				}
; 250  : 
; 251  : 				Token = GetToken();

  0044c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 252  : 				this->m_classinfo[playerClass].AttRate_LEVELMUL_PVP = (WORD)TokenNumber;

  00451	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00459	8b ce		 mov	 ecx, esi
  0045b	bf 05 00 00 00	 mov	 edi, 5
  00460	c1 e1 04	 shl	 ecx, 4
  00463	2b ce		 sub	 ecx, esi
  00465	8d 71 0d	 lea	 esi, DWORD PTR [ecx+13]
  00468	8d 34 f3	 lea	 esi, DWORD PTR [ebx+esi*8]
  0046b	0f b7 c0	 movzx	 eax, ax
  0046e	66 0f 6e c0	 movd	 xmm0, eax
  00472	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00475	f3 0f 11 44 cb
	64		 movss	 DWORD PTR [ebx+ecx*8+100], xmm0
  0047b	0f 1f 44 00 00	 npad	 5
$LL23@LoadElemen:

; 253  : 
; 254  : 				for(int i = 0; i < 5; i++)	{
; 255  : 					Token = GetToken();

  00480	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00485	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 256  : 					this->m_classinfo[playerClass].AttRate_MUL_PVP[i] = (WORD)TokenNumber;

  00488	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00490	0f b7 c0	 movzx	 eax, ax
  00493	66 0f 6e c0	 movd	 xmm0, eax
  00497	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0049a	f3 0f 11 46 fc	 movss	 DWORD PTR [esi-4], xmm0
  0049f	83 ef 01	 sub	 edi, 1
  004a2	75 dc		 jne	 SHORT $LL23@LoadElemen
$LN111@LoadElemen:
  004a4	8b 7d fc	 mov	 edi, DWORD PTR tv1131[ebp]
$LN110@LoadElemen:
  004a7	8b 75 f8	 mov	 esi, DWORD PTR _Index$1$[ebp]
$LN22@LoadElemen:

; 93   : 
; 94   : 		while( TRUE )
; 95   : 		{
; 96   : 			Token = GetToken();

  004aa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 97   : 
; 98   : 			if( !strcmp(TokenString,"end") )

  004af	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  004b4	b8 00 00 00 00	 mov	 eax, OFFSET ?TokenString@@3PADA
  004b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL104@LoadElemen:
  004c0	8a 10		 mov	 dl, BYTE PTR [eax]
  004c2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  004c4	75 1a		 jne	 SHORT $LN105@LoadElemen
  004c6	84 d2		 test	 dl, dl
  004c8	74 12		 je	 SHORT $LN106@LoadElemen
  004ca	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  004cd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  004d0	75 0e		 jne	 SHORT $LN105@LoadElemen
  004d2	83 c0 02	 add	 eax, 2
  004d5	83 c1 02	 add	 ecx, 2
  004d8	84 d2		 test	 dl, dl
  004da	75 e4		 jne	 SHORT $LL104@LoadElemen
$LN106@LoadElemen:
  004dc	33 c0		 xor	 eax, eax
  004de	eb 05		 jmp	 SHORT $LN107@LoadElemen
$LN105@LoadElemen:
  004e0	1b c0		 sbb	 eax, eax
  004e2	83 c8 01	 or	 eax, 1
$LN107@LoadElemen:
  004e5	85 c0		 test	 eax, eax
  004e7	0f 85 f9 fb ff
	ff		 jne	 $LL4@LoadElemen
  004ed	eb 0d		 jmp	 SHORT $LN109@LoadElemen
$LN70@LoadElemen:

; 247  : 					MsgBox("[Elemental System] Damage player class out of bounds!");

  004ef	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@PKADJNLH@?$FLElemental?5System?$FN?5Damage?5player@
  004f4	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  004f9	83 c4 04	 add	 esp, 4
$LN109@LoadElemen:
  004fc	8b 7d 08	 mov	 edi, DWORD PTR _count$1$[ebp]
$LN95@LoadElemen:

; 81   : 
; 82   : 	while( TRUE )
; 83   : 	{
; 84   : 		Token = GetToken();

  004ff	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 85   : 
; 86   : 		if( Token == END )

  00504	83 f8 02	 cmp	 eax, 2
  00507	0f 85 44 fb ff
	ff		 jne	 $LL2@LoadElemen
$LN108@LoadElemen:

; 257  : 				}
; 258  : 			}
; 259  : 		}
; 260  : 	}
; 261  : 	fclose(SMDFile);

  0050d	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00513	e8 00 00 00 00	 call	 _fclose
  00518	83 c4 04	 add	 esp, 4

; 262  : 	LoadOptions();

  0051b	8b cb		 mov	 ecx, ebx
  0051d	e8 00 00 00 00	 call	 ?LoadOptions@CElementalSystem@@QAEXXZ ; CElementalSystem::LoadOptions
  00522	5f		 pop	 edi
  00523	5e		 pop	 esi
  00524	5b		 pop	 ebx

; 263  : }

  00525	8b e5		 mov	 esp, ebp
  00527	5d		 pop	 ebp
  00528	c2 04 00	 ret	 4
?LoadElementalInfo@CElementalSystem@@QAEXPAD@Z ENDP	; CElementalSystem::LoadElementalInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ??1CElementalSystem@@UAE@XZ
_TEXT	SEGMENT
??1CElementalSystem@@UAE@XZ PROC			; CElementalSystem::~CElementalSystem, COMDAT
; _this$ = ecx

; 66   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 67   : 
; 68   : }

  00003	8d 8e 50 1a 00
	00		 lea	 ecx, DWORD PTR [esi+6736]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CElementalSystem@@6B@
  0000f	e8 00 00 00 00	 call	 ??1TRandomPoolMgr@@UAE@XZ ; TRandomPoolMgr::~TRandomPoolMgr
  00014	8d 8e 40 1a 00
	00		 lea	 ecx, DWORD PTR [esi+6720]
  0001a	e8 00 00 00 00	 call	 ??1TRandomPoolMgr@@UAE@XZ ; TRandomPoolMgr::~TRandomPoolMgr
  0001f	8b ce		 mov	 ecx, esi
  00021	5e		 pop	 esi
  00022	e9 00 00 00 00	 jmp	 ??1CObjBaseAttack@@UAE@XZ ; CObjBaseAttack::~CObjBaseAttack
??1CElementalSystem@@UAE@XZ ENDP			; CElementalSystem::~CElementalSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ??0CElementalSystem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CElementalSystem@@QAE@XZ PROC			; CElementalSystem::CElementalSystem, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CElementalSystem@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	e8 00 00 00 00	 call	 ??0CObjBaseAttack@@QAE@XZ ; CObjBaseAttack::CObjBaseAttack
  0002e	8d 8e 40 1a 00
	00		 lea	 ecx, DWORD PTR [esi+6720]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CElementalSystem@@6B@
  00041	e8 00 00 00 00	 call	 ??0TRandomPoolMgr@@QAE@XZ ; TRandomPoolMgr::TRandomPoolMgr
  00046	8d 8e 50 1a 00
	00		 lea	 ecx, DWORD PTR [esi+6736]
  0004c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00050	e8 00 00 00 00	 call	 ??0TRandomPoolMgr@@QAE@XZ ; TRandomPoolMgr::TRandomPoolMgr

; 30   : 
; 31   : 	m_DamageTable[ELEMENT_FIRE][ELEMENT_FIRE] = 100;
; 32   : 	m_DamageTable[ELEMENT_FIRE][ELEMENT_WATER] = 80;
; 33   : 	m_DamageTable[ELEMENT_FIRE][ELEMENT_EARTH] = 90;
; 34   : 	m_DamageTable[ELEMENT_FIRE][ELEMENT_WIND] = 110;
; 35   : 	m_DamageTable[ELEMENT_FIRE][ELEMENT_DARK] = 120;
; 36   : 
; 37   : 	m_DamageTable[ELEMENT_WATER][ELEMENT_FIRE] = 120;
; 38   : 	m_DamageTable[ELEMENT_WATER][ELEMENT_WATER] = 100;
; 39   : 	m_DamageTable[ELEMENT_WATER][ELEMENT_EARTH] = 80;
; 40   : 	m_DamageTable[ELEMENT_WATER][ELEMENT_WIND] = 90;
; 41   : 	m_DamageTable[ELEMENT_WATER][ELEMENT_DARK] = 110;
; 42   : 
; 43   : 	m_DamageTable[ELEMENT_EARTH][ELEMENT_FIRE] = 110;
; 44   : 	m_DamageTable[ELEMENT_EARTH][ELEMENT_WATER] = 120;
; 45   : 	m_DamageTable[ELEMENT_EARTH][ELEMENT_EARTH] = 100;
; 46   : 	m_DamageTable[ELEMENT_EARTH][ELEMENT_WIND] = 80;
; 47   : 	m_DamageTable[ELEMENT_EARTH][ELEMENT_DARK] = 90;
; 48   : 
; 49   : 	m_DamageTable[ELEMENT_WIND][ELEMENT_FIRE] = 90;
; 50   : 	m_DamageTable[ELEMENT_WIND][ELEMENT_WATER] = 110;
; 51   : 	m_DamageTable[ELEMENT_WIND][ELEMENT_EARTH] = 120;
; 52   : 	m_DamageTable[ELEMENT_WIND][ELEMENT_WIND] = 100;
; 53   : 	m_DamageTable[ELEMENT_WIND][ELEMENT_DARK] = 80;
; 54   : 
; 55   : 	m_DamageTable[ELEMENT_DARK][ELEMENT_FIRE] = 80;
; 56   : 	m_DamageTable[ELEMENT_DARK][ELEMENT_WATER] = 90;
; 57   : 	m_DamageTable[ELEMENT_DARK][ELEMENT_EARTH] = 110;
; 58   : 	m_DamageTable[ELEMENT_DARK][ELEMENT_WIND] = 120;
; 59   : 	m_DamageTable[ELEMENT_DARK][ELEMENT_DARK] = 100;
; 60   : 
; 61   : 	memset(this->m_ErtelOption,-1,sizeof(m_ErtelOption));

  00055	68 e0 15 00 00	 push	 5600			; 000015e0H
  0005a	8d 86 66 03 00
	00		 lea	 eax, DWORD PTR [esi+870]
  00060	c7 86 52 03 00
	00 64 50 5a 6e	 mov	 DWORD PTR [esi+850], 1851412580 ; 6e5a5064H
  0006a	6a ff		 push	 -1
  0006c	50		 push	 eax
  0006d	c7 86 56 03 00
	00 78 78 64 50	 mov	 DWORD PTR [esi+854], 1348761720 ; 50647878H
  00077	c7 86 5a 03 00
	00 5a 6e 6e 78	 mov	 DWORD PTR [esi+858], 2020503130 ; 786e6e5aH
  00081	c7 86 5e 03 00
	00 64 50 5a 5a	 mov	 DWORD PTR [esi+862], 1515868260 ; 5a5a5064H
  0008b	c7 86 62 03 00
	00 6e 78 64 50	 mov	 DWORD PTR [esi+866], 1348761710 ; 5064786eH
  00095	c6 00 50	 mov	 BYTE PTR [eax], 80	; 00000050H
  00098	c7 86 67 03 00
	00 5a 6e 78 64	 mov	 DWORD PTR [esi+871], 1685614170 ; 64786e5aH
  000a2	e8 00 00 00 00	 call	 _memset

; 62   : 	memset(this->m_classinfo,0,sizeof(this->m_classinfo));

  000a7	68 48 03 00 00	 push	 840			; 00000348H
  000ac	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000af	6a 00		 push	 0
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _memset
  000b7	83 c4 18	 add	 esp, 24			; 00000018H

; 63   : }

  000ba	8b c6		 mov	 eax, esi
  000bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c6	59		 pop	 ecx
  000c7	5e		 pop	 esi
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CElementalSystem@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CObjBaseAttack@@UAE@XZ ; CObjBaseAttack::~CObjBaseAttack
__unwindfunclet$??0CElementalSystem@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 40 1a 00
	00		 add	 ecx, 6720		; 00001a40H
  00011	e9 00 00 00 00	 jmp	 ??1TRandomPoolMgr@@UAE@XZ ; TRandomPoolMgr::~TRandomPoolMgr
__ehhandler$??0CElementalSystem@@QAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CElementalSystem@@QAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CElementalSystem@@QAE@XZ ENDP			; CElementalSystem::CElementalSystem
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\user.h
;	COMDAT ?Clear@ERTEL_USER@@QAEXXZ
_TEXT	SEGMENT
?Clear@ERTEL_USER@@QAEXXZ PROC				; ERTEL_USER::Clear, COMDAT
; _this$ = ecx

; 600  : 		btType = -1;

  00000	66 c7 01 ff ff	 mov	 WORD PTR [ecx], 65535	; 0000ffffH

; 601  : 		btAttribute = -1;
; 602  : 
; 603  : 		for(int i = 0; i < 5; i++)	{

  00005	33 c0		 xor	 eax, eax
  00007	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@Clear:

; 604  : 			Option[i] = 0x0F;

  00010	c6 44 01 02 0f	 mov	 BYTE PTR [ecx+eax+2], 15 ; 0000000fH
  00015	40		 inc	 eax

; 605  : 			Level[1] = 0x0F;

  00016	c6 41 08 0f	 mov	 BYTE PTR [ecx+8], 15	; 0000000fH
  0001a	83 f8 05	 cmp	 eax, 5
  0001d	7c f1		 jl	 SHORT $LL4@Clear

; 606  : 		}
; 607  : 	};

  0001f	c3		 ret	 0
?Clear@ERTEL_USER@@QAEXXZ ENDP				; ERTEL_USER::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\guildclass.h
;	COMDAT ?GetFriendlyFire@CGensSystem@@QAEHXZ
_TEXT	SEGMENT
?GetFriendlyFire@CGensSystem@@QAEHXZ PROC		; CGensSystem::GetFriendlyFire, COMDAT
; _this$ = ecx

; 276  : 	int GetFriendlyFire(){ return this->m_FriendlyFire; };

  00000	0f b6 41 38	 movzx	 eax, BYTE PTR [ecx+56]
  00004	c3		 ret	 0
?GetFriendlyFire@CGensSystem@@QAEHXZ ENDP		; CGensSystem::GetFriendlyFire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\comboattack.h
;	COMDAT ?Init@ComboSkillData@@QAEXXZ
_TEXT	SEGMENT
?Init@ComboSkillData@@QAEXXZ PROC			; ComboSkillData::Init, COMDAT
; _this$ = ecx

; 19   : 		this->dwTime = 0;
; 20   : 		this->Skill[0] = -1;

  00000	83 c8 ff	 or	 eax, -1
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00009	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 21   : 		this->Skill[1] = -1;

  0000d	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 22   : 		this->Skill[2] = -1;

  00011	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 23   : 		this->ProgressIndex = -1;

  00015	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 24   : 	};	// line : 23

  00018	c3		 ret	 0
?Init@ComboSkillData@@QAEXXZ ENDP			; ComboSkillData::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\elementalsystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
