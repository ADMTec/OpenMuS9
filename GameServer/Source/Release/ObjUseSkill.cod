; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\ObjUseSkill.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??0CObjUseSkill@@QAE@XZ				; CObjUseSkill::CObjUseSkill
PUBLIC	??1CObjUseSkill@@UAE@XZ				; CObjUseSkill::~CObjUseSkill
PUBLIC	?SpeedHackCheck@CObjUseSkill@@QAEHH@Z		; CObjUseSkill::SpeedHackCheck
PUBLIC	?EnableSkill@CObjUseSkill@@QAEHH@Z		; CObjUseSkill::EnableSkill
PUBLIC	?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ; CObjUseSkill::CheckWeapon
PUBLIC	?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z	; CObjUseSkill::GetUseMana
PUBLIC	?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; CObjUseSkill::GetAddUseMana
PUBLIC	?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z	; CObjUseSkill::GetUseBP
PUBLIC	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z	; CObjUseSkill::UseSkill
PUBLIC	?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill
PUBLIC	?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
PUBLIC	?SkillFrustrum3@CObjUseSkill@@QAEXHEMMMM@Z	; CObjUseSkill::SkillFrustrum3
PUBLIC	?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::MaGumSkillDefenseDown
PUBLIC	?KnightSkillAddLife@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::KnightSkillAddLife
PUBLIC	?WizardMagicDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::WizardMagicDefense
PUBLIC	?SkillDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDefense
PUBLIC	?SkillAttack@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAttack
PUBLIC	?SkillChangeUse@CObjUseSkill@@QAEHH@Z		; CObjUseSkill::SkillChangeUse
PUBLIC	?SkillHealing@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHealing
PUBLIC	?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z	; CObjUseSkill::SkillMonsterCall
PUBLIC	?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillDeathPoison
PUBLIC	?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillSuddenIce
PUBLIC	?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2Start
PUBLIC	?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2
PUBLIC	?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z ; CObjUseSkill::SkillBlowOfFury
PUBLIC	?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z ; CObjUseSkill::SkillWheel
PUBLIC	?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillKnightBlow
PUBLIC	?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillPowerSlash
PUBLIC	?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z		; CObjUseSkill::SkillFrustrum
PUBLIC	?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z ; CObjUseSkill::GetTargetLinePath
PUBLIC	?GetAngle@CObjUseSkill@@QAEHHHHH@Z		; CObjUseSkill::GetAngle
PUBLIC	?CalDistance@CObjUseSkill@@QAEHHHHH@Z		; CObjUseSkill::CalDistance
PUBLIC	?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z	; CObjUseSkill::SkillFrustrum2
PUBLIC	?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z	; CObjUseSkill::SkillAreaCheck
PUBLIC	?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSpear
PUBLIC	?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireBurst
PUBLIC	?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarkHorseAttack
PUBLIC	?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z	; CObjUseSkill::RecallPartyCheck
PUBLIC	?SkillRecallParty@CObjUseSkill@@QAEXHH@Z	; CObjUseSkill::SkillRecallParty
PUBLIC	?SkillAddCriticalDamage@CObjUseSkill@@QAEXHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAddCriticalDamage
PUBLIC	?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillElectricSpark
PUBLIC	?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSummon
PUBLIC	?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToMagic
PUBLIC	?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToHarm
PUBLIC	?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillKnightRush
PUBLIC	?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillWizardJavalin
PUBLIC	?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillElfRush
PUBLIC	?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumOneFlash
PUBLIC	?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumDeathCannon
PUBLIC	?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarklordSpaceSplit
PUBLIC	?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillBrandOfSkill
PUBLIC	?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveStun
PUBLIC	?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAddMana
PUBLIC	?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillCloaking
PUBLIC	?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveCloaking
PUBLIC	?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveMagic
PUBLIC	?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z	; CObjUseSkill::RemoveCloakingEffect
PUBLIC	?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z ; CObjUseSkill::SkillStun
PUBLIC	?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState
PUBLIC	?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ; CObjUseSkill::RemoveSpecificSkillState
PUBLIC	?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFenrirAttack
PUBLIC	?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillInfinityArrow
PUBLIC	?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireScream
PUBLIC	?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjUseSkill::FireScreamExplosionAttack
PUBLIC	?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z ; CObjUseSkill::SpecificSkillAdditionTreat
PUBLIC	?SkillDrainLife@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDrainLife
PUBLIC	?SkillChainLightning@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillChainLightning
PUBLIC	?SkillLightExplode@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillLightExplode
PUBLIC	?SkillLightExplode@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0HHHH@Z ; CObjUseSkill::SkillLightExplode
PUBLIC	?SkillCurse@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillCurse
PUBLIC	?SkillDamageReflect@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDamageReflect
PUBLIC	?SkillSleep@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSleep
PUBLIC	?SkillWeakness@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillWeakness
PUBLIC	?SkillInnovation@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillInnovation
PUBLIC	?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z ; CObjUseSkill::SkillAreaMonsterAttack
PUBLIC	?SkillLagle@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHH@Z ; CObjUseSkill::SkillLagle
PUBLIC	?SkillBerserker@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillBerserker
PUBLIC	?SkillRecovery@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRecovery
PUBLIC	?SkillExpWizard@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillExpWizard
PUBLIC	?SkillDestruct@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillDestruct
PUBLIC	?SkillLightShock@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillLightShock
PUBLIC	?SkillFlameStrike@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ; CObjUseSkill::SkillFlameStrike
PUBLIC	?SkillGiganticStorm@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillGiganticStorm
PUBLIC	?SkillMultiShot@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ; CObjUseSkill::SkillMultiShot
PUBLIC	?SkillChaoticDesier@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ; CObjUseSkill::SkillChaoticDesier
PUBLIC	?SkillEvilMonster@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillEvilMonster
PUBLIC	?SkillDeathPoisonForMeDusa@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillDeathPoisonForMeDusa
PUBLIC	?SkillMonkBarrageJustOneTarget@CObjUseSkill@@QAEXHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillMonkBarrageJustOneTarget
PUBLIC	?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
PUBLIC	?SkillMonkBuff@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMonkBuff
PUBLIC	?SkillMonkBuffApplyParty@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMonkBuffApplyParty
PUBLIC	?SkillCharge@CObjUseSkill@@QAEHHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillCharge
PUBLIC	?SkillBloodStorm@CObjUseSkill@@QAEXHHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillBloodStorm
PUBLIC	?BloodStormExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjUseSkill::BloodStormExplosionAttack
PUBLIC	??_GCObjUseSkill@@UAEPAXI@Z			; CObjUseSkill::`scalar deleting destructor'
PUBLIC	?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z	; DecPartyMemberHPandMP
PUBLIC	??_7CObjUseSkill@@6B@				; CObjUseSkill::`vftable'
PUBLIC	?gObjUseSkill@@3VCObjUseSkill@@A		; gObjUseSkill
PUBLIC	??_C@_0BI@LPGINHLP@?$FL?$CFd?$FN?5Skill?5delay?5error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BI@HDEGKDLO@?$FL?$CFs?$FN?5Skill?5delay?5error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0FO@IFELCABO@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@ ; `string'
PUBLIC	??_C@_0FO@JAMLMINI@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@ ; `string'
PUBLIC	??_C@_0CH@FEMHONHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5SkillHellFire2?5error?5on@ ; `string'
PUBLIC	??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@	; `string'
PUBLIC	??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@ ; `string'
PUBLIC	??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@ ; `string'
PUBLIC	??_C@_0FA@JGPGPLCI@?$FLInvalidTargetIndex?$FN?$FLSkillMonkBa@ ; `string'
PUBLIC	??_C@_0EM@PCLLIACM@?$FLInvalidTargetIndex?$FN?$FLSkillDeathP@ ; `string'
PUBLIC	??_R4CObjUseSkill@@6B@				; CObjUseSkill::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCObjUseSkill@@@8			; CObjUseSkill `RTTI Type Descriptor'
PUBLIC	??_R3CObjUseSkill@@8				; CObjUseSkill::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjUseSkill@@8				; CObjUseSkill::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObjUseSkill@@8			; CObjUseSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
PUBLIC	__real@400921fb5fffffff
PUBLIC	__real@4024000000000000
PUBLIC	__real@4056800000000000
PUBLIC	__real@4066800000000000
PUBLIC	__real@40a00000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@c0a00000
PUBLIC	__xmm@00000000000000003f80000000000000
PUBLIC	__xmm@000000000000000041a0000000000000
PUBLIC	__xmm@00000000422000000000000000000000
PUBLIC	__xmm@43a00000000000000000000043aa0000
PUBLIC	__xmm@80000000800000008000000080000000
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_rand:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?SkillGet@CMagicDamage@@QAEHH@Z:PROC		; CMagicDamage::SkillGet
EXTRN	?SkillGetMana@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::SkillGetMana
EXTRN	?SkillGetBP@CMagicDamage@@QAEHH@Z:PROC		; CMagicDamage::SkillGetBP
EXTRN	?GetSkillDistance@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillDistance
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?Check@CSkillDelay@@QAEHE@Z:PROC		; CSkillDelay::Check
EXTRN	?CheckCombo@CComboAttack@@QAEHHH@Z:PROC		; CComboAttack::CheckCombo
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?IncAgro@TMonsterAIAgro@@QAEHHH@Z:PROC		; TMonsterAIAgro::IncAgro
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCRecallMonLife@@YAXHHH@Z:PROC			; GCRecallMonLife
EXTRN	?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z:PROC	; GCActionSend
EXTRN	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z:PROC	; GCStateInfoSend
EXTRN	?GCReFillSend@@YAXHGEEG@Z:PROC			; GCReFillSend
EXTRN	?GCManaSend@@YAXHFEEG@Z:PROC			; GCManaSend
EXTRN	?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z:PROC ; GCMonkDarkSideTargetSelect
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjAddCallMon@@YAFXZ:PROC			; gObjAddCallMon
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z:PROC ; gObjAddAttackProcMsgSendDelay
EXTRN	?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; retResistance
EXTRN	?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z:PROC ; retCalcSkillResistance
EXTRN	?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjAttackQ
EXTRN	?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagicSearch
EXTRN	?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicBPUse
EXTRN	?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjTargetGuildWarCheck
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?gObjCheckTeleportArea@@YAHHEE@Z:PROC		; gObjCheckTeleportArea
EXTRN	?gObjSetPosition@@YAXHHH@Z:PROC			; gObjSetPosition
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjDuelCheck
EXTRN	?SkillFrustrum@@YAXEH@Z:PROC			; SkillFrustrum
EXTRN	?SkillTestFrustrum@@YAHHHH@Z:PROC		; SkillTestFrustrum
EXTRN	?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z:PROC	; gObjGetRandomFreeLocation
EXTRN	?gObjSetKillCount@@YAXHH@Z:PROC			; gObjSetKillCount
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?gCheckSkillDistance@@YAHHHH@Z:PROC		; gCheckSkillDistance
EXTRN	??_ECObjUseSkill@@UAEPAXI@Z:PROC		; CObjUseSkill::`vector deleting destructor'
EXTRN	?VectorRotate@@YAXQBM0QAM@Z:PROC		; VectorRotate
EXTRN	?AngleMatrix@@YAXPBMPAY03M@Z:PROC		; AngleMatrix
EXTRN	?HitCheck@CSkillHitBox@@QAEHHHHHH@Z:PROC	; CSkillHitBox::HitCheck
EXTRN	?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z:PROC	; CMoveCommand::GetMoveLevel
EXTRN	?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckMainToMove
EXTRN	?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::CheckEquipmentToMove
EXTRN	?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckInterfaceToMove
EXTRN	?GetCastleState@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetCastleState
EXTRN	?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifySelfCsJoinSide
EXTRN	?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z:PROC ; gObjAddBuffEffect
EXTRN	?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
EXTRN	?gObjCheckPowerfulEffect@@YA_NPAUOBJECTSTRUCT@@HHH@Z:PROC ; gObjCheckPowerfulEffect
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?GetState@CIllusionTempleEvent@@QAEEE@Z:PROC	; CIllusionTempleEvent::GetState
EXTRN	?GetTeam@CIllusionTempleEvent@@QAEEEH@Z:PROC	; CIllusionTempleEvent::GetTeam
EXTRN	?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
EXTRN	?RunningSkill_MLS@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@HPAVCMagicInf@@HEEEE@Z:PROC ; CMasterLevelSkillTreeSystem::RunningSkill_MLS
EXTRN	?GetMasterSkillValue@CMasterLevelSkillTreeSystem@@QAEMHH@Z:PROC ; CMasterLevelSkillTreeSystem::GetMasterSkillValue
EXTRN	?GetMasterSkillManaIncRate@CMasterLevelSkillTreeSystem@@QAEMH@Z:PROC ; CMasterLevelSkillTreeSystem::GetMasterSkillManaIncRate
EXTRN	?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z:PROC ; BuffSkillEffect::GetEffect
EXTRN	?GetRaklionState@CRaklion@@QAEHXZ:PROC		; CRaklion::GetRaklionState
EXTRN	?AddUserData@CRaklionBattleUserMng@@QAEHH@Z:PROC ; CRaklionBattleUserMng::AddUserData
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIatan2:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?gComboAttack@@3VCComboAttack@@A:DWORD		; gComboAttack
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?SkillSpearHitBox@@3VCSkillHitBox@@A:BYTE	; SkillSpearHitBox
EXTRN	?SkillElectricSparkHitBox@@3VCSkillHitBox@@A:BYTE ; SkillElectricSparkHitBox
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A:BYTE ; g_SkillAdditionInfo
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A:BYTE ; g_MasterSkillSystem
EXTRN	?g_BuffSkillEffect@@3VBuffSkillEffect@@A:BYTE	; g_BuffSkillEffect
EXTRN	?g_Raklion@@3VCRaklion@@A:BYTE			; g_Raklion
EXTRN	?g_RaklionBattleUserMng@@3VCRaklionBattleUserMng@@A:BYTE ; g_RaklionBattleUserMng
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?gObjUseSkill@@3VCObjUseSkill@@A DD 01H DUP (?)		; gObjUseSkill
_BSS	ENDS
CRT$XCU	SEGMENT
?gObjUseSkill$initializer$@@3P6AXXZA DD FLAT:??__EgObjUseSkill@@YAXXZ ; gObjUseSkill$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@43a00000000000000000000043aa0000
CONST	SEGMENT
__xmm@43a00000000000000000000043aa0000 DB 00H, 00H, 0aaH, 'C', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0a0H, 'C'
CONST	ENDS
;	COMDAT __xmm@00000000422000000000000000000000
CONST	SEGMENT
__xmm@00000000422000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, ' B', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000000000000041a0000000000000
CONST	SEGMENT
__xmm@000000000000000041a0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0a0H
	DB	'A', 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000003f80000000000000
CONST	SEGMENT
__xmm@00000000000000003f80000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 080H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@4056800000000000
CONST	SEGMENT
__real@4056800000000000 DQ 04056800000000000r	; 90
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@400921fb5fffffff
CONST	SEGMENT
__real@400921fb5fffffff DQ 0400921fb5fffffffr	; 3.14159
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CObjUseSkill@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjUseSkill@@8 DD FLAT:??_R0?AVCObjUseSkill@@@8 ; CObjUseSkill::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjUseSkill@@8
rdata$r	ENDS
;	COMDAT ??_R2CObjUseSkill@@8
rdata$r	SEGMENT
??_R2CObjUseSkill@@8 DD FLAT:??_R1A@?0A@EA@CObjUseSkill@@8 ; CObjUseSkill::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjUseSkill@@8
rdata$r	SEGMENT
??_R3CObjUseSkill@@8 DD 00H				; CObjUseSkill::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjUseSkill@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjUseSkill@@@8
data$r	SEGMENT
??_R0?AVCObjUseSkill@@@8 DD FLAT:??_7type_info@@6B@	; CObjUseSkill `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjUseSkill@@', 00H
data$r	ENDS
;	COMDAT ??_R4CObjUseSkill@@6B@
rdata$r	SEGMENT
??_R4CObjUseSkill@@6B@ DD 00H				; CObjUseSkill::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCObjUseSkill@@@8
	DD	FLAT:??_R3CObjUseSkill@@8
rdata$r	ENDS
;	COMDAT ??_C@_0EM@PCLLIACM@?$FLInvalidTargetIndex?$FN?$FLSkillDeathP@
CONST	SEGMENT
??_C@_0EM@PCLLIACM@?$FLInvalidTargetIndex?$FN?$FLSkillDeathP@ DB '[Invali'
	DB	'dTargetIndex][SkillDeathPoisonForMeDusa] Index :%d , AccountI'
	DB	'D : %s ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@JGPGPLCI@?$FLInvalidTargetIndex?$FN?$FLSkillMonkBa@
CONST	SEGMENT
??_C@_0FA@JGPGPLCI@?$FLInvalidTargetIndex?$FN?$FLSkillMonkBa@ DB '[Invali'
	DB	'dTargetIndex][SkillMonkBarrageJustOneTarget] Index :%d , Acco'
	DB	'untID : %s ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@
CONST	SEGMENT
??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@ DB '['
	DB	'%s][%s] Use Infinity Arrow Skill (Time:%d)(Character Level : '
	DB	'%d)(ChangeUp: %d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@ DB '['
	DB	'ANTI-HACK][Cloaking Skill] [%s][%s] Invalid Targeting  Target'
	DB	'Type [%d] TargetClass [%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@
CONST	SEGMENT
??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@ DB 'error : De'
	DB	'cPartyMemberHPandMP %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@
CONST	SEGMENT
??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@ DB 'ObjUseSkill.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FEMHONHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5SkillHellFire2?5error?5on@
CONST	SEGMENT
??_C@_0CH@FEMHONHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5SkillHellFire2?5error?5on@ DB '['
	DB	'%s][%s] SkillHellFire2 error on start', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@JAMLMINI@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@
CONST	SEGMENT
??_C@_0FO@JAMLMINI@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@ DB '[Invali'
	DB	'dTargetIndex][CObjUseSkill.UseSkill][AT_SKILL_PHOENIXSHOT] In'
	DB	'dex :%d , AccountID : %s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@IFELCABO@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@
CONST	SEGMENT
??_C@_0FO@IFELCABO@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@ DB '[Invali'
	DB	'dTargetIndex][CObjUseSkill.UseSkill][AT_SKILL_DRAGON_ROAR] In'
	DB	'dex :%d , AccountID : %s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDEGKDLO@?$FL?$CFs?$FN?5Skill?5delay?5error?$CB?$AA@
CONST	SEGMENT
??_C@_0BI@HDEGKDLO@?$FL?$CFs?$FN?5Skill?5delay?5error?$CB?$AA@ DB '[%s] S'
	DB	'kill delay error!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LPGINHLP@?$FL?$CFd?$FN?5Skill?5delay?5error?$CB?$AA@
CONST	SEGMENT
??_C@_0BI@LPGINHLP@?$FL?$CFd?$FN?5Skill?5delay?5error?$CB?$AA@ DB '[%d] S'
	DB	'kill delay error!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CObjUseSkill@@6B@
CONST	SEGMENT
??_7CObjUseSkill@@6B@ DD FLAT:??_R4CObjUseSkill@@6B@	; CObjUseSkill::`vftable'
	DD	FLAT:??_ECObjUseSkill@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FgObjUseSkill@@YAXXZ
text$yd	SEGMENT
??__FgObjUseSkill@@YAXXZ PROC				; `dynamic atexit destructor for 'gObjUseSkill'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00005	e9 00 00 00 00	 jmp	 ??1CObjUseSkill@@UAE@XZ	; CObjUseSkill::~CObjUseSkill
??__FgObjUseSkill@@YAXXZ ENDP				; `dynamic atexit destructor for 'gObjUseSkill''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ??__EgObjUseSkill@@YAXXZ
text$di	SEGMENT
??__EgObjUseSkill@@YAXXZ PROC				; `dynamic initializer for 'gObjUseSkill'', COMDAT

; 26   : CObjUseSkill gObjUseSkill;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00005	e8 00 00 00 00	 call	 ??0CObjUseSkill@@QAE@XZ	; CObjUseSkill::CObjUseSkill
  0000a	68 00 00 00 00	 push	 OFFSET ??__FgObjUseSkill@@YAXXZ ; `dynamic atexit destructor for 'gObjUseSkill''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EgObjUseSkill@@YAXXZ ENDP				; `dynamic initializer for 'gObjUseSkill''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
;	COMDAT ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::IsDuel, COMDAT
; _this$ = ecx

; 296  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	8b 88 50 12 00
	00		 mov	 ecx, DWORD PTR [eax+4688]
  0000c	33 c0		 xor	 eax, eax
  0000e	85 c9		 test	 ecx, ecx
  00010	78 09		 js	 SHORT $LN4@IsDuel
  00012	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00018	0f 9e c0	 setle	 al
$LN4@IsDuel:

; 298  : 	}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::IsDuel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetBloodStormExplosionDamage@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetBloodStormExplosionDamage@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetBloodStormExplosionDamage, COMDAT
; _this$ = ecx

; 51   : 	int GetBloodStormExplosionDamage() { return this->m_iBloodStormExplosionDamage; }

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00003	c3		 ret	 0
?GetBloodStormExplosionDamage@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetBloodStormExplosionDamage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetBloodStormExplosionDistance@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetBloodStormExplosionDistance@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetBloodStormExplosionDistance, COMDAT
; _this$ = ecx

; 50   : 	int GetBloodStormExplosionDistance() { return this->m_iBloodStormExplosionAttackDistance; }

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	c3		 ret	 0
?GetBloodStormExplosionDistance@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetBloodStormExplosionDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetBloodStormExplosionRate@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetBloodStormExplosionRate@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetBloodStormExplosionRate, COMDAT
; _this$ = ecx

; 49   : 	int GetBloodStormExplosionRate() { return this->m_iBloodStormExplosionRate; }

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	c3		 ret	 0
?GetBloodStormExplosionRate@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetBloodStormExplosionRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetFireScreamExplosionRate@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamExplosionRate@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamExplosionRate, COMDAT
; _this$ = ecx

; 39   : 	int GetFireScreamExplosionRate(){return this->m_iFireScreamExplosionRate;}

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	c3		 ret	 0
?GetFireScreamExplosionRate@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamExplosionRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetFireScreamExplosionAttackDistance@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamExplosionAttackDistance@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamExplosionAttackDistance, COMDAT
; _this$ = ecx

; 37   : 	int GetFireScreamExplosionAttackDistance(){return this->m_iFireScreamExplosionAttackDistance;}

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	c3		 ret	 0
?GetFireScreamExplosionAttackDistance@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamExplosionAttackDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetFireScreamSkill@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamSkill@CSkillAdditionInfo@@QAEHXZ PROC	; CSkillAdditionInfo::GetFireScreamSkill, COMDAT
; _this$ = ecx

; 35   : 	BOOL GetFireScreamSkill(){return this->m_bFireScreamSkill;}

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	c3		 ret	 0
?GetFireScreamSkill@CSkillAdditionInfo@@QAEHXZ ENDP	; CSkillAdditionInfo::GetFireScreamSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetInfinityArrowMPConsumptionPlus3@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowMPConsumptionPlus3@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus3, COMDAT
; _this$ = ecx

; 33   : 	int GetInfinityArrowMPConsumptionPlus3(){return this->m_iInfinityArrowMPConsumptionPlus3;}

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetInfinityArrowMPConsumptionPlus3@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetInfinityArrowMPConsumptionPlus2@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowMPConsumptionPlus2@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus2, COMDAT
; _this$ = ecx

; 31   : 	int GetInfinityArrowMPConsumptionPlus2(){return this->m_iInfinityArrowMPConsumptionPlus2;}

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	c3		 ret	 0
?GetInfinityArrowMPConsumptionPlus2@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetInfinityArrowMPConsumptionPlus1@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowMPConsumptionPlus1@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus1, COMDAT
; _this$ = ecx

; 29   : 	int GetInfinityArrowMPConsumptionPlus1(){return this->m_iInfinityArrowMPConsumptionPlus1;}

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetInfinityArrowMPConsumptionPlus1@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetInfinityArrowMPConsumptionPlus0@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowMPConsumptionPlus0@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus0, COMDAT
; _this$ = ecx

; 27   : 	int GetInfinityArrowMPConsumptionPlus0(){return this->m_iInfinityArrowMPConsumptionPlus0;}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetInfinityArrowMPConsumptionPlus0@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowMPConsumptionPlus0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
;	COMDAT ?GetInfinityArrowSkillTime@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetInfinityArrowSkillTime@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetInfinityArrowSkillTime, COMDAT
; _this$ = ecx

; 23   : 	int GetInfinityArrowSkillTime(){return this->m_iInfinityArrowSkillTime;}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetInfinityArrowSkillTime@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetInfinityArrowSkillTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv293 = -8						; size = 4
tv292 = -4						; size = 4
_retcount$1$ = 8					; size = 4
_lpObj$ = 8						; size = 4
?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z PROC	; DecPartyMemberHPandMP, COMDAT

; 3269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 3270 : 	LPOBJ lpPartyObj;
; 3271 : 	int partynum = lpObj->PartyNumber;

  00007	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000a	8b 8f 0c 06 00
	00		 mov	 ecx, DWORD PTR [edi+1548]

; 3272 : 
; 3273 : 	if(OBJMAX_RANGE(partynum)==false)

  00010	85 c9		 test	 ecx, ecx
  00012	0f 88 67 01 00
	00		 js	 $LN16@DecPartyMe
  00018	33 c0		 xor	 eax, eax
  0001a	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00020	0f 9e c0	 setle	 al
  00023	85 c0		 test	 eax, eax
  00025	0f 84 54 01 00
	00		 je	 $LN16@DecPartyMe

; 3277 : 	}
; 3278 : 
; 3279 : 	int partycount = gParty.m_PartyS[partynum].Count;
; 3280 : 	int retcount = 0;

  0002b	8b c1		 mov	 eax, ecx
  0002d	33 d2		 xor	 edx, edx
  0002f	c1 e0 04	 shl	 eax, 4
  00032	53		 push	 ebx
  00033	2b c1		 sub	 eax, ecx
  00035	89 55 08	 mov	 DWORD PTR _retcount$1$[ebp], edx
  00038	56		 push	 esi
  00039	be 05 00 00 00	 mov	 esi, 5
  0003e	89 75 f8	 mov	 DWORD PTR tv293[ebp], esi
  00041	8d 1c 85 0c 00
	00 00		 lea	 ebx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@DecPartyMe:

; 3283 : 	{
; 3284 : 		int number = gParty.m_PartyS[partynum].Number[n];

  00050	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 3285 : 
; 3286 : 		if(number >= 0)

  00052	85 c9		 test	 ecx, ecx
  00054	0f 88 0d 01 00
	00		 js	 $LN2@DecPartyMe

; 3287 : 		{
; 3288 : 			lpPartyObj = &gObj[number];
; 3289 : 
; 3290 : 			if(lpObj->MapNumber == lpPartyObj->MapNumber && lpObj->m_Index != number)

  0005a	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  00060	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  00066	89 55 fc	 mov	 DWORD PTR tv292[ebp], edx
  00069	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	3a 82 23 01 00
	00		 cmp	 al, BYTE PTR [edx+291]
  00075	0f 85 e9 00 00
	00		 jne	 $LN20@DecPartyMe
  0007b	39 0f		 cmp	 DWORD PTR [edi], ecx
  0007d	0f 84 e1 00 00
	00		 je	 $LN20@DecPartyMe

; 3291 : 			{
; 3292 : 				int dis = gObjCalDistance(lpObj,&gObj[number]);

  00083	52		 push	 edx
  00084	57		 push	 edi
  00085	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0008a	83 c4 08	 add	 esp, 8

; 3293 : 				if(dis < 10)

  0008d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00090	0f 8d ce 00 00
	00		 jge	 $LN20@DecPartyMe

; 3294 : 				{
; 3295 : 					lpPartyObj = &gObj[number];

  00096	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3296 : 
; 3297 : 					int declife = (int)(lpPartyObj->Life * 20.0f / 100.0f);

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR tv292[ebp]
  0009f	f3 0f 10 84 31
	d8 00 00 00	 movss	 xmm0, DWORD PTR [ecx+esi+216]
  000a8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41a00000

; 3298 : 					int decmana = (int)(lpPartyObj->Mana * 5.0f / 100.0f);
; 3299 : 
; 3300 : 					lpPartyObj->Life = lpPartyObj->Life - declife;

  000b0	f3 0f 10 94 31
	d8 00 00 00	 movss	 xmm2, DWORD PTR [ecx+esi+216]
  000b9	f3 0f 10 8c 31
	ec 00 00 00	 movss	 xmm1, DWORD PTR [ecx+esi+236]
  000c2	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  000ca	f3 0f 2c c0	 cvttss2si eax, xmm0
  000ce	66 0f 6e c0	 movd	 xmm0, eax
  000d2	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000d5	f3 0f 5c d0	 subss	 xmm2, xmm0
  000d9	0f 28 c1	 movaps	 xmm0, xmm1
  000dc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40a00000
  000e4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  000ec	f3 0f 11 94 31
	d8 00 00 00	 movss	 DWORD PTR [ecx+esi+216], xmm2
  000f5	f3 0f 2c c0	 cvttss2si eax, xmm0
  000f9	66 0f 6e c0	 movd	 xmm0, eax

; 3301 : 					lpPartyObj->Mana = lpPartyObj->Mana - decmana;
; 3302 : 
; 3303 : 					GCReFillSend(lpPartyObj->m_Index,(WORD)lpPartyObj->Life,0xFF,0,lpPartyObj->iShield);

  000fd	0f b7 84 31 2c
	01 00 00	 movzx	 eax, WORD PTR [ecx+esi+300]
  00105	50		 push	 eax
  00106	f3 0f 2c c2	 cvttss2si eax, xmm2
  0010a	6a 00		 push	 0
  0010c	68 ff 00 00 00	 push	 255			; 000000ffH
  00111	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00114	0f b7 c0	 movzx	 eax, ax
  00117	50		 push	 eax
  00118	ff 34 31	 push	 DWORD PTR [ecx+esi]
  0011b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0011f	f3 0f 11 8c 31
	ec 00 00 00	 movss	 DWORD PTR [ecx+esi+236], xmm1
  00128	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 3304 : 					GCManaSend(lpPartyObj->m_Index,(WORD)lpPartyObj->Mana,0xFF,0,lpPartyObj->BP);

  0012d	8b 55 fc	 mov	 edx, DWORD PTR tv292[ebp]
  00130	0f b7 84 32 04
	01 00 00	 movzx	 eax, WORD PTR [edx+esi+260]
  00138	50		 push	 eax
  00139	f3 0f 2c 84 32
	ec 00 00 00	 cvttss2si eax, DWORD PTR [edx+esi+236]
  00142	6a 00		 push	 0
  00144	68 ff 00 00 00	 push	 255			; 000000ffH
  00149	0f b7 c0	 movzx	 eax, ax
  0014c	50		 push	 eax
  0014d	ff 34 32	 push	 DWORD PTR [edx+esi]
  00150	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend

; 3305 : 
; 3306 : 					retcount++;

  00155	8b 55 08	 mov	 edx, DWORD PTR _retcount$1$[ebp]
  00158	83 c4 28	 add	 esp, 40			; 00000028H
  0015b	8b 75 f8	 mov	 esi, DWORD PTR tv293[ebp]
  0015e	42		 inc	 edx
  0015f	89 55 08	 mov	 DWORD PTR _retcount$1$[ebp], edx
  00162	eb 03		 jmp	 SHORT $LN2@DecPartyMe
$LN20@DecPartyMe:
  00164	8b 55 08	 mov	 edx, DWORD PTR _retcount$1$[ebp]
$LN2@DecPartyMe:

; 3281 : 
; 3282 : 	for(int n = 0; n < MAX_USER_IN_PARTY;n++)

  00167	83 c3 04	 add	 ebx, 4
  0016a	83 ee 01	 sub	 esi, 1
  0016d	89 75 f8	 mov	 DWORD PTR tv293[ebp], esi
  00170	0f 85 da fe ff
	ff		 jne	 $LL4@DecPartyMe

; 3307 : 				}
; 3308 : 			}
; 3309 : 		}
; 3310 : 	}
; 3311 : 
; 3312 : 	return retcount;

  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	8b c2		 mov	 eax, edx
  0017a	5f		 pop	 edi

; 3313 : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
$LN16@DecPartyMe:

; 3274 : 	{
; 3275 : 		LogAdd("error : DecPartyMemberHPandMP %s %d",__FILE__,__LINE__);

  0017f	68 cb 0c 00 00	 push	 3275			; 00000ccbH
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DNENMBIK@ObjUseSkill?4cpp?$AA@
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3276 : 		return false;

  00197	33 c0		 xor	 eax, eax
  00199	5f		 pop	 edi

; 3313 : }

  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; DecPartyMemberHPandMP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCObjUseSkill@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCObjUseSkill@@UAEPAXI@Z PROC			; CObjUseSkill::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CObjUseSkill@@UAE@XZ	; CObjUseSkill::~CObjUseSkill
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 04		 push	 4
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCObjUseSkill@@UAEPAXI@Z ENDP			; CObjUseSkill::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?BloodStormExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_iExplosionDamage$1$ = -4				; size = 4
tv397 = 8						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
tv402 = 16						; size = 4
_iAttackDamage$ = 16					; size = 4
?BloodStormExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z PROC ; CObjUseSkill::BloodStormExplosionAttack, COMDAT
; _this$ = ecx

; 6052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 6053 : 
; 6054 : 	if(gObjIsConnected(lpObj->m_Index) == false && gObjIsConnected(lpTargetObj->m_Index) == false)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	ff 37		 push	 DWORD PTR [edi]
  0000a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	75 18		 jne	 SHORT $LN4@BloodStorm
  00016	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	75 07		 jne	 SHORT $LN4@BloodStorm
  00027	5f		 pop	 edi

; 6127 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
$LN4@BloodStorm:
  0002e	56		 push	 esi
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h

; 49   : 	int GetBloodStormExplosionRate() { return this->m_iBloodStormExplosionRate; }

  0002f	8b 35 38 00 00
	00		 mov	 esi, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+56
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 6059 : 	if(rand()%10000 > g_SkillAdditionInfo.GetBloodStormExplosionRate())

  00035	e8 00 00 00 00	 call	 _rand
  0003a	99		 cdq
  0003b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00040	f7 f9		 idiv	 ecx
  00042	3b d6		 cmp	 edx, esi
  00044	7e 0a		 jle	 SHORT $LN5@BloodStorm

; 6060 : 	{
; 6061 : 		return false;

  00046	5e		 pop	 esi
  00047	33 c0		 xor	 eax, eax
  00049	5f		 pop	 edi

; 6127 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@BloodStorm:

; 6062 : 	}
; 6063 : 
; 6064 : 	int iExplosionDamage = iAttackDamage*g_SkillAdditionInfo.GetBloodStormExplosionDamage() / 100;

  00050	8b 0d 3c 00 00
	00		 mov	 ecx, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+60
  00056	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0005b	0f af 4d 10	 imul	 ecx, DWORD PTR _iAttackDamage$[ebp]
  0005f	f7 e9		 imul	 ecx
  00061	c1 fa 05	 sar	 edx, 5
  00064	8b c2		 mov	 eax, edx
  00066	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00069	03 c2		 add	 eax, edx
  0006b	89 45 fc	 mov	 DWORD PTR _iExplosionDamage$1$[ebp], eax

; 6065 : 	int iTarObjNum;
; 6066 : 
; 6067 : 	if(iExplosionDamage < 1)

  0006e	83 f8 01	 cmp	 eax, 1
  00071	0f 8c e0 00 00
	00		 jl	 $LN44@BloodStorm

; 6068 : 	{
; 6069 : 		return true;
; 6070 : 	}
; 6071 : 
; 6072 : 	int iCount = 0;

  00077	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0007c	8d b7 4a 0c 00
	00		 lea	 esi, DWORD PTR [edi+3146]
  00082	89 45 08	 mov	 DWORD PTR tv397[ebp], eax
  00085	53		 push	 ebx
$LL2@BloodStorm:

; 6073 : 	int bEnableAttack;
; 6074 : 
; 6075 : 	while( true )
; 6076 : 	{
; 6077 : 		if(lpObj->VpPlayer2[iCount].state != 0)

  00086	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  0008a	0f 84 b7 00 00
	00		 je	 $LN35@BloodStorm

; 6078 : 		{
; 6079 : 			iTarObjNum = lpObj->VpPlayer2[iCount].number;

  00090	0f bf 1e	 movsx	 ebx, WORD PTR [esi]

; 6080 : 
; 6081 : 			if(iTarObjNum >= 0)

  00093	85 db		 test	 ebx, ebx
  00095	0f 88 ac 00 00
	00		 js	 $LN35@BloodStorm

; 6082 : 			{
; 6083 : 				bEnableAttack = 0;
; 6084 : 
; 6085 : 				if(gObj[iTarObjNum].Type == OBJ_MONSTER && gObj[iTarObjNum].m_RecallMon < 0)

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  000a6	89 4d 10	 mov	 DWORD PTR tv402[ebp], ecx
  000a9	03 c8		 add	 ecx, eax
  000ab	8a 41 50	 mov	 al, BYTE PTR [ecx+80]
  000ae	3c 02		 cmp	 al, 2
  000b0	75 09		 jne	 SHORT $LN9@BloodStorm
  000b2	83 b9 30 06 00
	00 00		 cmp	 DWORD PTR [ecx+1584], 0
  000b9	7c 5a		 jl	 SHORT $LN36@BloodStorm
$LN9@BloodStorm:

; 6086 : 				{
; 6087 : 					bEnableAttack = 1;
; 6088 : 				}
; 6089 : 				else if(lpTargetObj->Type == OBJ_USER && lpObj->Type == OBJ_USER && gObj[iTarObjNum].Type != OBJ_NPC)

  000bb	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000be	80 7a 50 01	 cmp	 BYTE PTR [edx+80], 1
  000c2	75 0a		 jne	 SHORT $LN11@BloodStorm
  000c4	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  000c8	75 04		 jne	 SHORT $LN11@BloodStorm
  000ca	3c 03		 cmp	 al, 3
  000cc	75 4a		 jne	 SHORT $LN34@BloodStorm
$LN11@BloodStorm:

; 6090 : 				{
; 6091 : 					bEnableAttack = 1;
; 6092 : 				}
; 6093 : 				else if(lpTargetObj->m_cChaosCastleIndex == gObj[iTarObjNum].m_cChaosCastleIndex && lpTargetObj->m_cChaosCastleIndex != -1)

  000ce	8a 82 3d 12 00
	00		 mov	 al, BYTE PTR [edx+4669]
  000d4	3a 81 3d 12 00
	00		 cmp	 al, BYTE PTR [ecx+4669]
  000da	75 04		 jne	 SHORT $LN13@BloodStorm
  000dc	3c ff		 cmp	 al, -1
  000de	75 38		 jne	 SHORT $LN34@BloodStorm
$LN13@BloodStorm:

; 6094 : 				{
; 6095 : 					bEnableAttack = 1;
; 6096 : 				}
; 6097 : #if (GS_CASTLE == 1)
; 6098 : 				else if(lpObj->VpPlayer2[iCount].type != OBJ_NPC && gObj[iTarObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000e0	80 7e 02 03	 cmp	 BYTE PTR [esi+2], 3
  000e4	74 5e		 je	 SHORT $LN42@BloodStorm
  000e6	80 b9 23 01 00
	00 1e		 cmp	 BYTE PTR [ecx+291], 30	; 0000001eH
  000ed	75 55		 jne	 SHORT $LN42@BloodStorm
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000f4	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  000f9	83 f8 07	 cmp	 eax, 7
  000fc	75 46		 jne	 SHORT $LN42@BloodStorm

; 6099 : 				{
; 6100 : 					if( lpObj->m_btCsJoinSide != gObj[iTarObjNum].m_btCsJoinSide )

  000fe	8b 4d 10	 mov	 ecx, DWORD PTR tv402[ebp]
  00101	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00107	8a 87 5a 20 00
	00		 mov	 al, BYTE PTR [edi+8282]
  0010d	3a 81 5a 20 00
	00		 cmp	 al, BYTE PTR [ecx+8282]
  00113	74 2f		 je	 SHORT $LN42@BloodStorm
$LN36@BloodStorm:
  00115	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
$LN34@BloodStorm:

; 6101 : 						bEnableAttack = 1;
; 6102 : 				}
; 6103 : #endif
; 6104 : 				if(bEnableAttack != 0)
; 6105 : 				{
; 6106 : 					if(lpObj->m_Index != gObj[iTarObjNum].m_Index)

  00118	8b 07		 mov	 eax, DWORD PTR [edi]
  0011a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0011c	74 26		 je	 SHORT $LN42@BloodStorm

; 6107 : 					{
; 6108 : 						int iSkillDistance = gObjCalDistance(lpTargetObj,&gObj[iTarObjNum]);

  0011e	51		 push	 ecx
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00125	83 c4 08	 add	 esp, 8

; 6109 : 
; 6110 : 						if(iSkillDistance <= g_SkillAdditionInfo.GetBloodStormExplosionDistance())

  00128	3b 05 34 00 00
	00		 cmp	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+52
  0012e	7f 14		 jg	 SHORT $LN42@BloodStorm

; 6111 : 						{
; 6112 : 							gObjAddMsgSendDelay(lpObj,54,iTarObjNum,800,iExplosionDamage);

  00130	ff 75 fc	 push	 DWORD PTR _iExplosionDamage$1$[ebp]
  00133	68 20 03 00 00	 push	 800			; 00000320H
  00138	53		 push	 ebx
  00139	6a 36		 push	 54			; 00000036H
  0013b	57		 push	 edi
  0013c	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00141	83 c4 14	 add	 esp, 20			; 00000014H
$LN42@BloodStorm:
  00144	8b 45 08	 mov	 eax, DWORD PTR tv397[ebp]
$LN35@BloodStorm:

; 6113 : 						}
; 6114 : 					}
; 6115 : 				}
; 6116 : 			}
; 6117 : 		}
; 6118 : 
; 6119 : 		iCount++;

  00147	83 c6 0c	 add	 esi, 12			; 0000000cH

; 6120 : 
; 6121 : 		if(iCount > MAX_VIEWPORT -1)

  0014a	83 e8 01	 sub	 eax, 1
  0014d	89 45 08	 mov	 DWORD PTR tv397[ebp], eax
  00150	0f 85 30 ff ff
	ff		 jne	 $LL2@BloodStorm
  00156	5b		 pop	 ebx
$LN44@BloodStorm:
  00157	5e		 pop	 esi

; 6122 : 		{
; 6123 : 			break;
; 6124 : 		}
; 6125 : 	}
; 6126 : 	return true;

  00158	b8 01 00 00 00	 mov	 eax, 1
  0015d	5f		 pop	 edi

; 6127 : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 0c 00	 ret	 12			; 0000000cH
?BloodStormExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ENDP ; CObjUseSkill::BloodStormExplosionAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillBloodStorm@CObjUseSkill@@QAEXHHPAVCMagicInf@@H@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -20					; size = 4
_HitCount$1$ = -16					; size = 4
_bAttack$1$ = -12					; size = 4
tv492 = -8						; size = 4
tv491 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_isCombo$ = 20						; size = 4
?SkillBloodStorm@CObjUseSkill@@QAEXHHPAVCMagicInf@@H@Z PROC ; CObjUseSkill::SkillBloodStorm, COMDAT
; _this$ = ecx

; 5948 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 5949 : 	LPOBJ lpObj = &gObj[aIndex];
; 5950 : 	int tmpvar = 0;
; 5951 : 	int bAttack = 0;

  00008	33 c0		 xor	 eax, eax

; 5952 : 	int tObjNum;
; 5953 : 	int count = 0;
; 5954 : 	int HitCount = 0;

  0000a	33 c9		 xor	 ecx, ecx
  0000c	57		 push	 edi
  0000d	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00014	89 45 f4	 mov	 DWORD PTR _bAttack$1$[ebp], eax

; 5955 : 
; 5956 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00017	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0001a	6a 01		 push	 1
  0001c	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0001f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	89 7d 08	 mov	 DWORD PTR _lpObj$1$[ebp], edi
  0002e	89 4d f0	 mov	 DWORD PTR _HitCount$1$[ebp], ecx
  00031	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 5957 : 
; 5958 : 	int EnableAttack;
; 5959 : 	int bForceAttack = TRUE;
; 5960 : 	int DuelIndex = lpObj->m_iDuelUser;

  00036	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  0004a	89 45 ec	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  0004d	8d 87 4c 0c 00
	00		 lea	 eax, DWORD PTR [edi+3148]
  00053	89 45 fc	 mov	 DWORD PTR tv491[ebp], eax
  00056	c7 45 f8 4b 00
	00 00		 mov	 DWORD PTR tv492[ebp], 75 ; 0000004bH
  0005d	0f 1f 00	 npad	 3
$LL2@SkillBlood:

; 5961 : 
; 5962 : 	while ( true )
; 5963 : 	{
; 5964 : 		if(lpObj->VpPlayer2[count].state != 0)

  00060	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  00064	0f 84 b4 00 00
	00		 je	 $LN27@SkillBlood

; 5965 : 		{
; 5966 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0006a	0f bf 70 fe	 movsx	 esi, WORD PTR [eax-2]

; 5967 : 
; 5968 : 			if(tObjNum >= 0)

  0006e	85 f6		 test	 esi, esi
  00070	0f 88 a8 00 00
	00		 js	 $LN27@SkillBlood

; 5969 : 			{
; 5970 : 				EnableAttack = 0;
; 5971 : 
; 5972 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00076	8a 18		 mov	 bl, BYTE PTR [eax]
  00078	80 fb 02	 cmp	 bl, 2
  0007b	75 14		 jne	 SHORT $LN6@SkillBlood
  0007d	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00083	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0008b	0f 8c f0 00 00
	00		 jl	 $LN52@SkillBlood
$LN6@SkillBlood:

; 5973 : 				{
; 5974 : 					EnableAttack = 1;
; 5975 : 				}
; 5976 : 				else if( CC_MAP_RANGE( lpObj->MapNumber ) || IT_MAP_RANGE( lpObj->MapNumber ) )

  00091	8a 97 23 01 00
	00		 mov	 dl, BYTE PTR [edi+291]
  00097	80 fa 35	 cmp	 dl, 53			; 00000035H
  0009a	0f 84 e1 00 00
	00		 je	 $LN52@SkillBlood
  000a0	80 fa 12	 cmp	 dl, 18			; 00000012H
  000a3	72 0f		 jb	 SHORT $LN43@SkillBlood
  000a5	b0 17		 mov	 al, 23			; 00000017H
  000a7	3a c2		 cmp	 al, dl
  000a9	1b c0		 sbb	 eax, eax
  000ab	83 c0 01	 add	 eax, 1
  000ae	0f 85 cd 00 00
	00		 jne	 $LN52@SkillBlood
$LN43@SkillBlood:
  000b4	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  000b7	72 0f		 jb	 SHORT $LN44@SkillBlood
  000b9	b0 32		 mov	 al, 50			; 00000032H
  000bb	3a c2		 cmp	 al, dl
  000bd	1b c0		 sbb	 eax, eax
  000bf	83 c0 01	 add	 eax, 1
  000c2	0f 85 b9 00 00
	00		 jne	 $LN52@SkillBlood
$LN44@SkillBlood:

; 5977 : 				{
; 5978 : 					EnableAttack = 1;
; 5979 : 				}
; 5980 : 				else if( (tObjNum == aTargetIndex && bForceAttack == TRUE ) || DuelIndex == tObjNum)

  000c8	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  000cb	0f 84 b0 00 00
	00		 je	 $LN52@SkillBlood
  000d1	39 75 ec	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000d4	0f 84 a7 00 00
	00		 je	 $LN52@SkillBlood

; 5981 : 				{
; 5982 : 					EnableAttack = 1;
; 5983 : 				}
; 5984 : #if (GS_CASTLE == 1)
; 5985 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000da	80 fb 03	 cmp	 bl, 3
  000dd	74 5d		 je	 SHORT $LN15@SkillBlood
  000df	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000e5	80 bc 0f 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+ecx+291], 30 ; 0000001eH
  000ed	75 4a		 jne	 SHORT $LN57@SkillBlood
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000f4	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 5986 : 				{
; 5987 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	83 f8 07	 cmp	 eax, 7
  00102	75 35		 jne	 SHORT $LN57@SkillBlood
  00104	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  00107	8a 83 5a 20 00
	00		 mov	 al, BYTE PTR [ebx+8282]
  0010d	3a 84 0f 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+ecx+8282]
  00114	75 6e		 jne	 SHORT $LN10@SkillBlood
  00116	8b fb		 mov	 edi, ebx
$LN60@SkillBlood:
  00118	8b 55 f8	 mov	 edx, DWORD PTR tv492[ebp]
  0011b	8b 45 fc	 mov	 eax, DWORD PTR tv491[ebp]
$LN27@SkillBlood:

; 6036 : 							}
; 6037 : 						}
; 6038 : 					}
; 6039 : 				}
; 6040 : 			}
; 6041 : 		}
; 6042 : 
; 6043 : 		count++;

  0011e	83 c0 0c	 add	 eax, 12			; 0000000cH

; 6044 : 		if(count > MAX_VIEWPORT -1)

  00121	83 ea 01	 sub	 edx, 1
  00124	89 45 fc	 mov	 DWORD PTR tv491[ebp], eax
  00127	89 55 f8	 mov	 DWORD PTR tv492[ebp], edx
  0012a	0f 85 30 ff ff
	ff		 jne	 $LL2@SkillBlood
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx

; 6045 : 		{
; 6046 : 			break;
; 6047 : 		}
; 6048 : 	}
; 6049 : }

  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 10 00	 ret	 16			; 00000010H
$LN57@SkillBlood:
  00139	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN15@SkillBlood:

; 5988 : 						EnableAttack = 1;
; 5989 : 				}
; 5990 : #endif
; 5991 : 				else
; 5992 : 				{
; 5993 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0013c	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 5994 : 
; 5995 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00142	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00147	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  0014a	75 14		 jne	 SHORT $LN18@SkillBlood
  0014c	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  00153	85 c0		 test	 eax, eax
  00155	78 09		 js	 SHORT $LN18@SkillBlood

; 5996 : 					{
; 5997 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00157	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0015d	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN18@SkillBlood:

; 5998 : 					}
; 5999 : 
; 6000 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00160	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00166	03 c1		 add	 eax, ecx
  00168	50		 push	 eax
  00169	57		 push	 edi
  0016a	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0016f	83 c4 08	 add	 esp, 8
  00172	83 f8 01	 cmp	 eax, 1
  00175	0f 85 b5 00 00
	00		 jne	 $LN46@SkillBlood
  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN52@SkillBlood:
  00181	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
$LN10@SkillBlood:

; 6001 : 					{
; 6002 : 						EnableAttack = 1;
; 6003 : 					}
; 6004 : 				}
; 6005 : 
; 6006 : 				if(EnableAttack != 0)
; 6007 : 				{
; 6008 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) <= 3)

  00184	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0018a	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0018d	50		 push	 eax
  0018e	53		 push	 ebx
  0018f	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00194	83 c4 08	 add	 esp, 8
  00197	83 f8 03	 cmp	 eax, 3
  0019a	0f 8f 8d 00 00
	00		 jg	 $LN56@SkillBlood

; 6009 : 					{
; 6010 : 						HitCount++;

  001a0	8b 45 f0	 mov	 eax, DWORD PTR _HitCount$1$[ebp]
  001a3	40		 inc	 eax
  001a4	89 45 f0	 mov	 DWORD PTR _HitCount$1$[ebp], eax

; 6011 : 
; 6012 : 						if(HitCount > 5)

  001a7	83 f8 05	 cmp	 eax, 5
  001aa	7e 13		 jle	 SHORT $LN22@SkillBlood

; 6013 : 						{
; 6014 : 							if( rand()%2 )

  001ac	e8 00 00 00 00	 call	 _rand
  001b1	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001b6	79 05		 jns	 SHORT $LN59@SkillBlood
  001b8	48		 dec	 eax
  001b9	83 c8 fe	 or	 eax, -2			; fffffffeH
  001bc	40		 inc	 eax
$LN59@SkillBlood:
  001bd	74 0a		 je	 SHORT $LN58@SkillBlood
$LN22@SkillBlood:

; 6015 : 							{
; 6016 : 								bAttack = TRUE;

  001bf	b8 01 00 00 00	 mov	 eax, 1
  001c4	89 45 f4	 mov	 DWORD PTR _bAttack$1$[ebp], eax

; 6017 : 							}
; 6018 : 						}
; 6019 : 						else

  001c7	eb 03		 jmp	 SHORT $LN23@SkillBlood
$LN58@SkillBlood:
  001c9	8b 45 f4	 mov	 eax, DWORD PTR _bAttack$1$[ebp]
$LN23@SkillBlood:

; 6020 : 						{
; 6021 : 							bAttack = TRUE;
; 6022 : 						}
; 6023 : 
; 6024 : 						if(HitCount > 12)

  001cc	83 7d f0 0c	 cmp	 DWORD PTR _HitCount$1$[ebp], 12 ; 0000000cH
  001d0	7e 13		 jle	 SHORT $LN25@SkillBlood

; 6025 : 						{
; 6026 : 							bAttack = FALSE;
; 6027 : 						}
; 6028 : 
; 6029 : 						if(bAttack == TRUE)

  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d8	33 c0		 xor	 eax, eax
  001da	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  001dd	89 45 f4	 mov	 DWORD PTR _bAttack$1$[ebp], eax
  001e0	e9 33 ff ff ff	 jmp	 $LN60@SkillBlood
$LN25@SkillBlood:
  001e5	83 f8 01	 cmp	 eax, 1
  001e8	75 43		 jne	 SHORT $LN56@SkillBlood

; 6030 : 						{
; 6031 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,500,lpMagic->m_Skill,isCombo);

  001ea	ff 75 14	 push	 DWORD PTR _isCombo$[ebp]
  001ed	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001f0	ff 70 08	 push	 DWORD PTR [eax+8]
  001f3	68 f4 01 00 00	 push	 500			; 000001f4H
  001f8	56		 push	 esi
  001f9	6a 32		 push	 50			; 00000032H
  001fb	53		 push	 ebx
  001fc	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00201	83 c4 18	 add	 esp, 24			; 00000018H

; 6032 : 
; 6033 : 							if(isCombo != 0)

  00204	83 7d 14 00	 cmp	 DWORD PTR _isCombo$[ebp], 0
  00208	74 23		 je	 SHORT $LN56@SkillBlood

; 6034 : 							{
; 6035 : 								GCMagicAttackNumberSend(lpObj,AT_SKILL_COMBO,gObj[tObjNum].m_Index,1);

  0020a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020f	6a 01		 push	 1
  00211	ff 34 07	 push	 DWORD PTR [edi+eax]
  00214	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  00217	6a 3b		 push	 59			; 0000003bH
  00219	57		 push	 edi
  0021a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0021f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00225	83 c4 10	 add	 esp, 16			; 00000010H
  00228	e9 eb fe ff ff	 jmp	 $LN60@SkillBlood
$LN56@SkillBlood:
  0022d	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN46@SkillBlood:
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00236	e9 dd fe ff ff	 jmp	 $LN60@SkillBlood
?SkillBloodStorm@CObjUseSkill@@QAEXHHPAVCMagicInf@@H@Z ENDP ; CObjUseSkill::SkillBloodStorm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillCharge@CObjUseSkill@@QAEHHPAVCMagicInf@@H@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_aTargetIndex$ = 16					; size = 4
?SkillCharge@CObjUseSkill@@QAEHHPAVCMagicInf@@H@Z PROC	; CObjUseSkill::SkillCharge, COMDAT
; _this$ = ecx

; 6567 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6568 : 	if( !OBJMAX_RANGE(aIndex) )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 61		 js	 SHORT $LN6@SkillCharg
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 52		 je	 SHORT $LN6@SkillCharg

; 6570 : 
; 6571 : 	LPOBJ lpObj = &gObj[aIndex];
; 6572 : 
; 6573 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,TRUE);

  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 10	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00022	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00028	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0002c	6a 01		 push	 1
  0002e	57		 push	 edi
  0002f	50		 push	 eax
  00030	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 6574 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,FALSE,TRUE,0,0,0,0);

  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  0004c	6a 00		 push	 0
  0004e	56		 push	 esi
  0004f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	50		 push	 eax
  00056	53		 push	 ebx
  00057	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0005c	83 c4 34	 add	 esp, 52			; 00000034H

; 6575 : 
; 6576 : return true;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx

; 6577 : 
; 6578 : }

  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillCharg:

; 6569 : 		return false;

  0006b	33 c0		 xor	 eax, eax

; 6577 : 
; 6578 : }

  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
?SkillCharge@CObjUseSkill@@QAEHHPAVCMagicInf@@H@Z ENDP	; CObjUseSkill::SkillCharge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMonkBuffApplyParty@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_partynum$1$ = -36					; size = 4
_lpMagic$GSCopy$1$ = -32				; size = 4
_nEffectValue$1$ = -28					; size = 4
_lpPartyObj$1$ = -28					; size = 4
_ApplyPartyIndex$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillMonkBuffApplyParty@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillMonkBuffApplyParty, COMDAT
; _this$ = ecx

; 6439 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00017	56		 push	 esi

; 6440 : 	int skillSuccess = TRUE;
; 6441 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  0001e	89 5d e0	 mov	 DWORD PTR _lpMagic$GSCopy$1$[ebp], ebx
  00021	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6442 : 	int number;
; 6443 : 
; 6444 : 	if( lpObj->Type != OBJ_USER && lpObj->m_RecallMon == -1 )

  00027	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0002b	74 1d		 je	 SHORT $LN8@SkillMonkB
  0002d	83 be 30 06 00
	00 ff		 cmp	 DWORD PTR [esi+1584], -1
  00034	75 14		 jne	 SHORT $LN8@SkillMonkB
$LN47@SkillMonkB:
  00036	5e		 pop	 esi

; 6445 : 		return FALSE;

  00037	33 c0		 xor	 eax, eax
  00039	5b		 pop	 ebx

; 6564 : }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003d	33 cd		 xor	 ecx, ebp
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
$LN8@SkillMonkB:

; 6446 : 
; 6447 : 	if( lpObj->Class != CLASS_FIGHTER )

  0004a	66 83 be 90 00
	00 00 06	 cmp	 WORD PTR [esi+144], 6
  00052	75 e2		 jne	 SHORT $LN47@SkillMonkB

; 6448 : 		return FALSE;
; 6449 : 
; 6450 : 	int partynum = 0;
; 6451 : 	int partycount;
; 6452 : 	int dis;
; 6453 : 	int ApplyPartyIndex[MAX_USER_IN_PARTY];
; 6454 : 	int nEffectValue;
; 6455 : 	memset(ApplyPartyIndex,-1,sizeof(ApplyPartyIndex));
; 6456 : 	LPOBJ lpPartyObj;
; 6457 : 
; 6458 : 	partynum = lpObj->PartyNumber;

  00054	8b 8e 0c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1548]
  0005a	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  00061	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _ApplyPartyIndex$[ebp+16], -1
  00068	89 4d dc	 mov	 DWORD PTR _partynum$1$[ebp], ecx
  0006b	57		 push	 edi
  0006c	0f 11 45 e8	 movups	 XMMWORD PTR _ApplyPartyIndex$[ebp], xmm0

; 6459 : 
; 6460 : 	if( partynum != -1 )

  00070	83 f9 ff	 cmp	 ecx, -1
  00073	74 57		 je	 SHORT $LN3@SkillMonkB

; 6461 : 	{
; 6462 : 		partycount = gParty.m_PartyS[partynum].Count;
; 6463 : 
; 6464 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00075	8b c1		 mov	 eax, ecx
  00077	33 ff		 xor	 edi, edi
  00079	c1 e0 04	 shl	 eax, 4
  0007c	2b c1		 sub	 eax, ecx
  0007e	8d 1c 85 0c 00
	00 00		 lea	 ebx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
$LL4@SkillMonkB:

; 6465 : 		{
; 6466 : 			number = gParty.m_PartyS[partynum].Number[n];

  00085	8b 03		 mov	 eax, DWORD PTR [ebx]

; 6467 : 
; 6468 : 			if( number >= 0 )

  00087	85 c0		 test	 eax, eax
  00089	78 35		 js	 SHORT $LN2@SkillMonkB

; 6469 : 			{
; 6470 : 				lpPartyObj = &gObj[number];

  0008b	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00091	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00097	89 4d e4	 mov	 DWORD PTR _lpPartyObj$1$[ebp], ecx

; 6471 : 
; 6472 : 
; 6473 : 				if( lpPartyObj->MapNumber == lpObj->MapNumber )

  0009a	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  000a0	3a 86 23 01 00
	00		 cmp	 al, BYTE PTR [esi+291]
  000a6	75 18		 jne	 SHORT $LN2@SkillMonkB

; 6474 : 				{
; 6475 : 					dis = gObjCalDistance(lpObj,&gObj[number]);

  000a8	51		 push	 ecx
  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000af	83 c4 08	 add	 esp, 8

; 6476 : 					if( dis < 4 )

  000b2	83 f8 04	 cmp	 eax, 4
  000b5	7d 09		 jge	 SHORT $LN2@SkillMonkB

; 6477 : 					{
; 6478 : 						ApplyPartyIndex[n] = lpPartyObj->m_Index;

  000b7	8b 45 e4	 mov	 eax, DWORD PTR _lpPartyObj$1$[ebp]
  000ba	8b 00		 mov	 eax, DWORD PTR [eax]
  000bc	89 44 bd e8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+edi*4], eax
$LN2@SkillMonkB:

; 6461 : 	{
; 6462 : 		partycount = gParty.m_PartyS[partynum].Count;
; 6463 : 
; 6464 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  000c0	47		 inc	 edi
  000c1	83 c3 04	 add	 ebx, 4
  000c4	83 ff 05	 cmp	 edi, 5
  000c7	7c bc		 jl	 SHORT $LL4@SkillMonkB
  000c9	8b 5d e0	 mov	 ebx, DWORD PTR _lpMagic$GSCopy$1$[ebp]
$LN3@SkillMonkB:

; 6479 : 					}
; 6480 : 				}
; 6481 : 			}
; 6482 : 		}
; 6483 : 	}
; 6484 : 
; 6485 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  000cc	ff 73 08	 push	 DWORD PTR [ebx+8]
  000cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  000d4	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  000d9	8b c8		 mov	 ecx, eax

; 6486 : 
; 6487 : 	if( !lpInfo )

  000db	85 c9		 test	 ecx, ecx
  000dd	0f 84 df 01 00
	00		 je	 $LN19@SkillMonkB

; 6488 : 	{
; 6489 : 		return 0;
; 6490 : 	}
; 6491 : 	
; 6492 : 	int Duration;
; 6493 : 
; 6494 : 	if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_FITNESS )

  000e3	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e6	81 fa 0b 01 00
	00		 cmp	 edx, 267		; 0000010bH
  000ec	74 0c		 je	 SHORT $LN46@SkillMonkB

; 6495 : 	{
; 6496 : 		nEffectValue = lpInfo->m_Arg1 + (lpObj->Energy+lpObj->AddEnergy-lpInfo->m_Arg2)/10.0;
; 6497 : 
; 6498 : 		if( nEffectValue > lpInfo->m_Arg3 )
; 6499 : 			nEffectValue = lpInfo->m_Arg3;
; 6500 : 
; 6501 : 		Duration = lpInfo->m_Arg4+lpObj->Energy/lpInfo->m_Arg5;
; 6502 : 
; 6503 : 		if( Duration > lpInfo->m_Arg6 )
; 6504 : 		{
; 6505 : 			Duration = lpInfo->m_Arg6;
; 6506 : 		}
; 6507 : 
; 6508 : 	}
; 6509 : 	else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DEFRATE )

  000ee	81 fa 0c 01 00
	00		 cmp	 edx, 268		; 0000010cH
  000f4	0f 85 c8 01 00
	00		 jne	 $LN19@SkillMonkB
$LN46@SkillMonkB:

; 6510 : 	{
; 6511 : 		nEffectValue = lpInfo->m_Arg1 + (lpObj->Energy+lpObj->AddEnergy-lpInfo->m_Arg2)/10.0;

  000fa	0f b7 be d6 00
	00 00		 movzx	 edi, WORD PTR [esi+214]
  00101	0f b7 86 02 01
	00 00		 movzx	 eax, WORD PTR [esi+258]
  00108	03 c7		 add	 eax, edi
  0010a	66 0f 6e c0	 movd	 xmm0, eax
  0010e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00111	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00116	0f 5a c8	 cvtps2pd xmm1, xmm0
  00119	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0011e	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@4024000000000000
  00126	0f 5a c0	 cvtps2pd xmm0, xmm0
  00129	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0012d	f2 0f 2c c1	 cvttsd2si eax, xmm1

; 6512 : 
; 6513 : 		if( nEffectValue > lpInfo->m_Arg3 )

  00131	f3 0f 10 49 0c	 movss	 xmm1, DWORD PTR [ecx+12]
  00136	89 45 e4	 mov	 DWORD PTR _nEffectValue$1$[ebp], eax
  00139	66 0f 6e c0	 movd	 xmm0, eax
  0013d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00140	0f 2f c1	 comiss	 xmm0, xmm1
  00143	76 07		 jbe	 SHORT $LN21@SkillMonkB

; 6514 : 			nEffectValue = lpInfo->m_Arg3;

  00145	f3 0f 2c c1	 cvttss2si eax, xmm1
  00149	89 45 e4	 mov	 DWORD PTR _nEffectValue$1$[ebp], eax
$LN21@SkillMonkB:

; 6515 : 
; 6516 : 		Duration = lpInfo->m_Arg4+lpObj->Energy/lpInfo->m_Arg5;

  0014c	66 0f 6e c7	 movd	 xmm0, edi
  00150	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 6517 : 
; 6518 : 		if( Duration > lpInfo->m_Arg6 )

  00153	f3 0f 10 49 18	 movss	 xmm1, DWORD PTR [ecx+24]
  00158	f3 0f 5e 41 14	 divss	 xmm0, DWORD PTR [ecx+20]
  0015d	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  00162	f3 0f 2c d8	 cvttss2si ebx, xmm0
  00166	66 0f 6e c3	 movd	 xmm0, ebx
  0016a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0016d	0f 2f c1	 comiss	 xmm0, xmm1
  00170	76 04		 jbe	 SHORT $LN22@SkillMonkB

; 6519 : 		{
; 6520 : 			Duration = lpInfo->m_Arg6;

  00172	f3 0f 2c d9	 cvttss2si ebx, xmm1
$LN22@SkillMonkB:

; 6521 : 		}
; 6522 : 	}
; 6523 : 	else
; 6524 : 	{
; 6525 : 		return FALSE;
; 6526 : 	}
; 6527 : 
; 6528 : 	if( partynum == -1 )

  00176	83 7d dc ff	 cmp	 DWORD PTR _partynum$1$[ebp], -1
  0017a	0f 85 99 00 00
	00		 jne	 $LN23@SkillMonkB

; 6529 : 	{
; 6530 : 		if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_FITNESS )

  00180	81 fa 0b 01 00
	00		 cmp	 edx, 267		; 0000010bH
  00186	75 46		 jne	 SHORT $LN25@SkillMonkB

; 6531 : 		{
; 6532 : 			gObjAddBuffEffect(lpObj,BUFF_INCREASE_VIT,ADD_OPTION_INCRVITALITY,nEffectValue,0,0,Duration);

  00188	53		 push	 ebx
  00189	6a 00		 push	 0
  0018b	6a 00		 push	 0
  0018d	ff 75 e4	 push	 DWORD PTR _nEffectValue$1$[ebp]
  00190	6a 49		 push	 73			; 00000049H
  00192	68 82 00 00 00	 push	 130			; 00000082H
  00197	56		 push	 esi
  00198	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 6533 : 			GCMagicAttackNumberSend(lpObj,AT_SKILL_RAGEFIGHTER_FITNESS,lpObj->m_Index,TRUE);

  0019d	6a 01		 push	 1
  0019f	ff 36		 push	 DWORD PTR [esi]
  001a1	68 0b 01 00 00	 push	 267			; 0000010bH
  001a6	56		 push	 esi
  001a7	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 6534 : 			gObjCalCharacter(lpObj->m_Index);

  001ac	ff 36		 push	 DWORD PTR [esi]
  001ae	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001b3	83 c4 30	 add	 esp, 48			; 00000030H

; 6559 : 				}
; 6560 : 			}
; 6561 : 		}
; 6562 : 	}
; 6563 : 	return TRUE;

  001b6	b8 01 00 00 00	 mov	 eax, 1
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx

; 6564 : }

  001be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c1	33 cd		 xor	 ecx, ebp
  001c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c2 08 00	 ret	 8
$LN25@SkillMonkB:

; 6535 : 		}
; 6536 : 		else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DEFRATE )

  001ce	81 fa 0c 01 00
	00		 cmp	 edx, 268		; 0000010cH
  001d4	0f 85 d0 00 00
	00		 jne	 $LN6@SkillMonkB

; 6537 : 		{
; 6538 : 			gObjAddBuffEffect(lpObj,BUFF_INCREASE_DEFRATE,ADD_OPTION_DEFRATE,nEffectValue,0,0,Duration);

  001da	53		 push	 ebx
  001db	6a 00		 push	 0
  001dd	6a 00		 push	 0
  001df	ff 75 e4	 push	 DWORD PTR _nEffectValue$1$[ebp]
  001e2	6a 4a		 push	 74			; 0000004aH
  001e4	68 83 00 00 00	 push	 131			; 00000083H
  001e9	56		 push	 esi
  001ea	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 6539 : 			GCMagicAttackNumberSend(lpObj,AT_SKILL_RAGEFIGHTER_DEFRATE,lpObj->m_Index,TRUE);

  001ef	6a 01		 push	 1
  001f1	ff 36		 push	 DWORD PTR [esi]
  001f3	68 0c 01 00 00	 push	 268			; 0000010cH
  001f8	56		 push	 esi
  001f9	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  001fe	83 c4 2c	 add	 esp, 44			; 0000002cH

; 6559 : 				}
; 6560 : 			}
; 6561 : 		}
; 6562 : 	}
; 6563 : 	return TRUE;

  00201	b8 01 00 00 00	 mov	 eax, 1
  00206	5f		 pop	 edi
  00207	5e		 pop	 esi
  00208	5b		 pop	 ebx

; 6564 : }

  00209	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020c	33 cd		 xor	 ecx, ebp
  0020e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c2 08 00	 ret	 8
$LN23@SkillMonkB:

; 6540 : 		}
; 6541 : 	}
; 6542 : 	else
; 6543 : 	{
; 6544 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00219	33 ff		 xor	 edi, edi
  0021b	0f 1f 44 00 00	 npad	 5
$LL7@SkillMonkB:

; 6545 : 		{
; 6546 : 			if( ApplyPartyIndex[n] != -1 )

  00220	8b 44 bd e8	 mov	 eax, DWORD PTR _ApplyPartyIndex$[ebp+edi*4]
  00224	83 f8 ff	 cmp	 eax, -1
  00227	74 77		 je	 SHORT $LN5@SkillMonkB

; 6547 : 			{
; 6548 : 				lpPartyObj = &gObj[ApplyPartyIndex[n]];

  00229	69 f0 40 27 00
	00		 imul	 esi, eax, 10048

; 6549 : 				if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_FITNESS )

  0022f	8b 45 e0	 mov	 eax, DWORD PTR _lpMagic$GSCopy$1$[ebp]
  00232	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00238	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0023b	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  00240	75 30		 jne	 SHORT $LN29@SkillMonkB

; 6550 : 				{
; 6551 : 					gObjAddBuffEffect(lpPartyObj,BUFF_INCREASE_VIT,ADD_OPTION_INCRVITALITY,nEffectValue,0,0,Duration);

  00242	53		 push	 ebx
  00243	6a 00		 push	 0
  00245	6a 00		 push	 0
  00247	ff 75 e4	 push	 DWORD PTR _nEffectValue$1$[ebp]
  0024a	6a 49		 push	 73			; 00000049H
  0024c	68 82 00 00 00	 push	 130			; 00000082H
  00251	56		 push	 esi
  00252	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 6552 : 					GCMagicAttackNumberSend(lpPartyObj,AT_SKILL_RAGEFIGHTER_FITNESS,lpPartyObj->m_Index,TRUE);

  00257	6a 01		 push	 1
  00259	ff 36		 push	 DWORD PTR [esi]
  0025b	68 0b 01 00 00	 push	 267			; 0000010bH
  00260	56		 push	 esi
  00261	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 6553 : 					gObjCalCharacter(lpPartyObj->m_Index);

  00266	ff 36		 push	 DWORD PTR [esi]
  00268	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  0026d	83 c4 30	 add	 esp, 48			; 00000030H
  00270	eb 2e		 jmp	 SHORT $LN5@SkillMonkB
$LN29@SkillMonkB:

; 6554 : 				}
; 6555 : 				else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DEFRATE )

  00272	3d 0c 01 00 00	 cmp	 eax, 268		; 0000010cH
  00277	75 27		 jne	 SHORT $LN5@SkillMonkB

; 6556 : 				{
; 6557 : 					gObjAddBuffEffect(lpPartyObj,BUFF_INCREASE_DEFRATE,ADD_OPTION_DEFRATE,nEffectValue,0,0,Duration);

  00279	53		 push	 ebx
  0027a	6a 00		 push	 0
  0027c	6a 00		 push	 0
  0027e	ff 75 e4	 push	 DWORD PTR _nEffectValue$1$[ebp]
  00281	6a 4a		 push	 74			; 0000004aH
  00283	68 83 00 00 00	 push	 131			; 00000083H
  00288	56		 push	 esi
  00289	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 6558 : 					GCMagicAttackNumberSend(lpPartyObj,AT_SKILL_RAGEFIGHTER_DEFRATE,lpPartyObj->m_Index,TRUE);

  0028e	6a 01		 push	 1
  00290	ff 36		 push	 DWORD PTR [esi]
  00292	68 0c 01 00 00	 push	 268			; 0000010cH
  00297	56		 push	 esi
  00298	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0029d	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN5@SkillMonkB:

; 6540 : 		}
; 6541 : 	}
; 6542 : 	else
; 6543 : 	{
; 6544 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  002a0	47		 inc	 edi
  002a1	83 ff 05	 cmp	 edi, 5
  002a4	0f 8c 76 ff ff
	ff		 jl	 $LL7@SkillMonkB
$LN6@SkillMonkB:
  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi

; 6559 : 				}
; 6560 : 			}
; 6561 : 		}
; 6562 : 	}
; 6563 : 	return TRUE;

  002ac	b8 01 00 00 00	 mov	 eax, 1
  002b1	5b		 pop	 ebx

; 6564 : }

  002b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b5	33 cd		 xor	 ecx, ebp
  002b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bc	8b e5		 mov	 esp, ebp
  002be	5d		 pop	 ebp
  002bf	c2 08 00	 ret	 8
$LN19@SkillMonkB:
  002c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c5	33 c0		 xor	 eax, eax
  002c7	5f		 pop	 edi
  002c8	5e		 pop	 esi
  002c9	33 cd		 xor	 ecx, ebp
  002cb	5b		 pop	 ebx
  002cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c2 08 00	 ret	 8
?SkillMonkBuffApplyParty@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillMonkBuffApplyParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMonkBuff@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillMonkBuff@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillMonkBuff, COMDAT
; _this$ = ecx

; 6392 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 6393 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0000b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6394 : 
; 6395 : 	if( lpObj->Type != OBJ_USER )

  00011	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00015	74 07		 je	 SHORT $LN2@SkillMonkB
$LN12@SkillMonkB:

; 6396 : 		return false;

  00017	33 c0		 xor	 eax, eax
  00019	5e		 pop	 esi

; 6436 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN2@SkillMonkB:

; 6397 : 
; 6398 : 	if( lpObj->Class != CLASS_FIGHTER )

  0001e	66 83 be 90 00
	00 00 06	 cmp	 WORD PTR [esi+144], 6
  00026	75 ef		 jne	 SHORT $LN12@SkillMonkB

; 6399 : 		return false;
; 6400 : 
; 6401 : 	if( lpMagic == NULL )

  00028	57		 push	 edi
  00029	8b 7d 0c	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  0002c	85 ff		 test	 edi, edi
  0002e	0f 84 c0 00 00
	00		 je	 $LN6@SkillMonkB

; 6402 : 		return false;
; 6403 : 
; 6404 : 	int nEffectValue = 0;
; 6405 : 
; 6406 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00034	ff 77 08	 push	 DWORD PTR [edi+8]
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  0003c	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  00041	8b c8		 mov	 ecx, eax

; 6407 : 
; 6408 : 	if( !lpInfo )

  00043	85 c9		 test	 ecx, ecx
  00045	0f 84 a9 00 00
	00		 je	 $LN6@SkillMonkB

; 6409 : 	{
; 6410 : 		return 0;
; 6411 : 	}
; 6412 : 
; 6413 : 	if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_REDARMOR )

  0004b	81 7f 08 0a 01
	00 00		 cmp	 DWORD PTR [edi+8], 266	; 0000010aH
  00052	0f 85 9c 00 00
	00		 jne	 $LN6@SkillMonkB

; 6414 : 	{
; 6415 : 		nEffectValue = lpInfo->m_Arg1 + (lpObj->Energy+lpObj->AddEnergy-lpInfo->m_Arg2)/100.0f;

  00058	0f b7 be d6 00
	00 00		 movzx	 edi, WORD PTR [esi+214]
  0005f	0f b7 86 02 01
	00 00		 movzx	 eax, WORD PTR [esi+258]
  00066	03 c7		 add	 eax, edi

; 6416 : 
; 6417 : 		if( nEffectValue > lpInfo->m_Arg3 )

  00068	f3 0f 10 49 0c	 movss	 xmm1, DWORD PTR [ecx+12]
  0006d	66 0f 6e c0	 movd	 xmm0, eax
  00071	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00074	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00079	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00081	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00086	f3 0f 2c d0	 cvttss2si edx, xmm0
  0008a	66 0f 6e c2	 movd	 xmm0, edx
  0008e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00091	0f 2f c1	 comiss	 xmm0, xmm1
  00094	76 04		 jbe	 SHORT $LN8@SkillMonkB

; 6418 : 			nEffectValue = lpInfo->m_Arg3;

  00096	f3 0f 2c d1	 cvttss2si edx, xmm1
$LN8@SkillMonkB:
  0009a	66 0f 6e c7	 movd	 xmm0, edi

; 6419 : 
; 6420 : 		int Duration = lpInfo->m_Arg4+lpObj->Energy/lpInfo->m_Arg5;

  0009e	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 6421 : 
; 6422 : 		if( Duration > lpInfo->m_Arg6 )

  000a1	f3 0f 10 49 18	 movss	 xmm1, DWORD PTR [ecx+24]
  000a6	f3 0f 5e 41 14	 divss	 xmm0, DWORD PTR [ecx+20]
  000ab	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  000b0	f3 0f 2c c0	 cvttss2si eax, xmm0
  000b4	66 0f 6e c0	 movd	 xmm0, eax
  000b8	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000bb	0f 2f c1	 comiss	 xmm0, xmm1
  000be	76 04		 jbe	 SHORT $LN9@SkillMonkB

; 6423 : 		{
; 6424 : 			Duration = lpInfo->m_Arg6;

  000c0	f3 0f 2c c1	 cvttss2si eax, xmm1
$LN9@SkillMonkB:

; 6425 : 		}
; 6426 : 
; 6427 : 		gObjAddBuffEffect(lpObj,BUFF_IGNORE_DEFENSE,ADD_OPTION_DEFENSEIGNORE,nEffectValue,0,0, Duration);

  000c4	50		 push	 eax
  000c5	6a 00		 push	 0
  000c7	6a 00		 push	 0
  000c9	52		 push	 edx
  000ca	6a 48		 push	 72			; 00000048H
  000cc	68 81 00 00 00	 push	 129			; 00000081H
  000d1	56		 push	 esi
  000d2	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 6428 : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_RAGEFIGHTER_REDARMOR,lpObj->m_Index,TRUE);

  000d7	6a 01		 push	 1
  000d9	ff 36		 push	 DWORD PTR [esi]
  000db	68 0a 01 00 00	 push	 266			; 0000010aH
  000e0	56		 push	 esi
  000e1	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000e6	83 c4 2c	 add	 esp, 44			; 0000002cH

; 6433 : 	}
; 6434 : 
; 6435 : 	return true;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi

; 6436 : }

  000f0	5d		 pop	 ebp
  000f1	c2 08 00	 ret	 8
$LN6@SkillMonkB:
  000f4	5f		 pop	 edi

; 6429 : 	}
; 6430 : 	else
; 6431 : 	{
; 6432 : 		return false;

  000f5	33 c0		 xor	 eax, eax
  000f7	5e		 pop	 esi

; 6436 : }

  000f8	5d		 pop	 ebp
  000f9	c2 08 00	 ret	 8
?SkillMonkBuff@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillMonkBuff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -20					; size = 4
tv662 = -16						; size = 4
_nTargetObjNum$1$ = -16					; size = 4
_this$1$ = -12						; size = 4
_nHitTargetCount$1$ = -8				; size = 4
_lpObj$1$ = -4						; size = 4
_nAttackRange$1$ = 8					; size = 4
_nViewPortObjectCount$1$ = 8				; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_wTargetList$ = 20					; size = 4
?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z PROC ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex, COMDAT
; _this$ = ecx

; 6257 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6258 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	69 55 08 40 27
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 10048

; 6259 : 	int nTargetObjNum = 0;
; 6260 : 	int nViewPortObjectCount = 0;
; 6261 : 	int nHitTargetCount = 0;

  0000d	33 c0		 xor	 eax, eax
  0000f	89 4d f4	 mov	 DWORD PTR _this$1$[ebp], ecx
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	03 d1		 add	 edx, ecx
  0001a	89 45 f8	 mov	 DWORD PTR _nHitTargetCount$1$[ebp], eax
  0001d	57		 push	 edi
  0001e	33 ff		 xor	 edi, edi
  00020	89 55 fc	 mov	 DWORD PTR _lpObj$1$[ebp], edx
  00023	89 7d 08	 mov	 DWORD PTR _nViewPortObjectCount$1$[ebp], edi

; 6262 : 	int DuelIndex = lpObj->m_iDuelUser;

  00026	8b 82 50 12 00
	00		 mov	 eax, DWORD PTR [edx+4688]
  0002c	89 45 ec	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax

; 6263 : 	int EnableAttack = 0;
; 6264 : 
; 6265 :     if( wTargetList == NULL)

  0002f	39 7d 14	 cmp	 DWORD PTR _wTargetList$[ebp], edi
  00032	75 09		 jne	 SHORT $LN6@SkillMonkD

; 6266 :         return false;

  00034	33 c0		 xor	 eax, eax
  00036	5f		 pop	 edi

; 6389 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 10 00	 ret	 16			; 00000010H
$LN6@SkillMonkD:
  0003d	53		 push	 ebx

; 6267 : 
; 6268 :     if( lpMagic->m_Skill != AT_SKILL_RAGEFIGHTER_DARKSIDE &&
; 6269 : 		lpMagic->m_Skill != AT_MSKILL_RF_DARKSIDE1 &&

  0003e	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00041	8b 5b 08	 mov	 ebx, DWORD PTR [ebx+8]
  00044	81 fb 07 01 00
	00		 cmp	 ebx, 263		; 00000107H
  0004a	74 1a		 je	 SHORT $LN7@SkillMonkD
  0004c	81 fb 2f 02 00
	00		 cmp	 ebx, 559		; 0000022fH
  00052	74 12		 je	 SHORT $LN7@SkillMonkD
  00054	81 fb 33 02 00
	00		 cmp	 ebx, 563		; 00000233H
  0005a	74 0a		 je	 SHORT $LN7@SkillMonkD

; 6270 : 		lpMagic->m_Skill != AT_MSKILL_RF_DARKSIDE2 )
; 6271 :         return false;

  0005c	5b		 pop	 ebx
  0005d	33 c0		 xor	 eax, eax
  0005f	5f		 pop	 edi

; 6389 : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 10 00	 ret	 16			; 00000010H
$LN7@SkillMonkD:
  00066	56		 push	 esi

; 6272 : 
; 6273 :     if( aTargetIndex != 0 )

  00067	39 7d 0c	 cmp	 DWORD PTR _aTargetIndex$[ebp], edi
  0006a	0f 84 b5 00 00
	00		 je	 $LN52@SkillMonkD

; 6286 : 						nTargetObjNum == aTargetIndex )
; 6287 : 					{
; 6288 : 						int nAttackRange = 0;
; 6289 : 
; 6290 : 						if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DARKSIDE ||
; 6291 : 							lpMagic->m_Skill == AT_MSKILL_RF_DARKSIDE1 ||

  00070	8d b2 4a 0c 00
	00		 lea	 esi, DWORD PTR [edx+3146]
$LL2@SkillMonkD:

; 6274 :     {
; 6275 :         while(true)
; 6276 :         {
; 6277 :             if( lpObj->VpPlayer2[nViewPortObjectCount].state != 0 )

  00076	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  0007a	74 7c		 je	 SHORT $LN15@SkillMonkD

; 6278 :             {
; 6279 : 				nTargetObjNum = lpObj->VpPlayer2[nViewPortObjectCount].number;

  0007c	0f bf 06	 movsx	 eax, WORD PTR [esi]
  0007f	89 45 f0	 mov	 DWORD PTR _nTargetObjNum$1$[ebp], eax

; 6280 : 
; 6281 : 				if( nTargetObjNum >= 0 && nTargetObjNum < OBJMAX )

  00082	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00087	77 6f		 ja	 SHORT $LN15@SkillMonkD

; 6282 : 				{
; 6283 : 					LPOBJ lpTargetObj = &gObj[nTargetObjNum];
; 6284 : 
; 6285 : 					if( lpObj->VpPlayer2[nViewPortObjectCount].type == OBJ_USER &&

  00089	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  0008d	75 69		 jne	 SHORT $LN15@SkillMonkD
  0008f	3b 45 0c	 cmp	 eax, DWORD PTR _aTargetIndex$[ebp]
  00092	75 64		 jne	 SHORT $LN15@SkillMonkD

; 6286 : 						nTargetObjNum == aTargetIndex )
; 6287 : 					{
; 6288 : 						int nAttackRange = 0;
; 6289 : 
; 6290 : 						if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DARKSIDE ||
; 6291 : 							lpMagic->m_Skill == AT_MSKILL_RF_DARKSIDE1 ||

  00094	81 fb 07 01 00
	00		 cmp	 ebx, 263		; 00000107H
  0009a	74 17		 je	 SHORT $LN14@SkillMonkD
  0009c	81 fb 2f 02 00
	00		 cmp	 ebx, 559		; 0000022fH
  000a2	74 0f		 je	 SHORT $LN14@SkillMonkD

; 6294 : 						else
; 6295 : 							nAttackRange = 0;

  000a4	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _nAttackRange$1$[ebp], 0
  000ab	81 fb 33 02 00
	00		 cmp	 ebx, 563		; 00000233H
  000b1	75 07		 jne	 SHORT $LN13@SkillMonkD
$LN14@SkillMonkD:

; 6292 : 							lpMagic->m_Skill == AT_MSKILL_RF_DARKSIDE2 )
; 6293 : 							nAttackRange = 5;

  000b3	c7 45 08 05 00
	00 00		 mov	 DWORD PTR _nAttackRange$1$[ebp], 5
$LN13@SkillMonkD:

; 6296 : 
; 6297 : 						if( CalDistance(lpObj->X,lpObj->Y,gObj[nTargetObjNum].X,gObj[nTargetObjNum].Y) < nAttackRange )

  000ba	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000c0	03 c8		 add	 ecx, eax
  000c2	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000c9	50		 push	 eax
  000ca	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000d4	50		 push	 eax
  000d5	0f b6 82 21 01
	00 00		 movzx	 eax, BYTE PTR [edx+289]
  000dc	50		 push	 eax
  000dd	0f b6 82 20 01
	00 00		 movzx	 eax, BYTE PTR [edx+288]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  000ea	3b 45 08	 cmp	 eax, DWORD PTR _nAttackRange$1$[ebp]
  000ed	7c 18		 jl	 SHORT $LN39@SkillMonkD
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
$LN15@SkillMonkD:

; 6301 : 							break;
; 6302 : 						}
; 6303 : 					}
; 6304 : 				}
; 6305 :             }
; 6306 : 
; 6307 : 			nViewPortObjectCount++;

  000f8	47		 inc	 edi
  000f9	83 c6 0c	 add	 esi, 12			; 0000000cH

; 6308 : 
; 6309 : 			if( nViewPortObjectCount > MAX_VIEWPORT-1 )

  000fc	83 ff 4a	 cmp	 edi, 74			; 0000004aH
  000ff	0f 8e 71 ff ff
	ff		 jle	 $LL2@SkillMonkD

; 6310 : 				break;
; 6311 : 		}

  00105	eb 10		 jmp	 SHORT $LN40@SkillMonkD
$LN39@SkillMonkD:

; 6298 : 						{
; 6299 : 							wTargetList[nHitTargetCount] = nTargetObjNum;

  00107	8b 4d 14	 mov	 ecx, DWORD PTR _wTargetList$[ebp]
  0010a	8b 45 f0	 mov	 eax, DWORD PTR _nTargetObjNum$1$[ebp]

; 6300 : 							nHitTargetCount++;

  0010d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _nHitTargetCount$1$[ebp], 1
  00114	66 89 01	 mov	 WORD PTR [ecx], ax
$LN40@SkillMonkD:

; 6312 : 
; 6313 : 		nViewPortObjectCount = 0;

  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011d	33 ff		 xor	 edi, edi
  0011f	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  00122	89 7d 08	 mov	 DWORD PTR _nViewPortObjectCount$1$[ebp], edi
$LN52@SkillMonkD:
  00125	8d 9a 4a 0c 00
	00		 lea	 ebx, DWORD PTR [edx+3146]
  0012b	0f 1f 44 00 00	 npad	 5
$LL4@SkillMonkD:

; 6314 : 	}
; 6315 : 
; 6316 : 	while(true)
; 6317 : 	{
; 6318 : 		if( lpObj->VpPlayer2[nViewPortObjectCount].state != 0 )

  00130	80 7b fe 00	 cmp	 BYTE PTR [ebx-2], 0
  00134	0f 84 ef 00 00
	00		 je	 $LN33@SkillMonkD

; 6319 : 		{
; 6320 : 			nTargetObjNum = lpObj->VpPlayer2[nViewPortObjectCount].number;

  0013a	0f bf 3b	 movsx	 edi, WORD PTR [ebx]

; 6321 : 
; 6322 : 			if( nTargetObjNum >= 0 && nTargetObjNum < OBJMAX )

  0013d	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00143	0f 87 dd 00 00
	00		 ja	 $LN55@SkillMonkD

; 6323 : 			{
; 6324 : 				EnableAttack = FALSE;
; 6325 : 
; 6326 : 				LPOBJ lpTargetObj = &gObj[nTargetObjNum];

  00149	69 c7 40 27 00
	00		 imul	 eax, edi, 10048

; 6327 : 
; 6328 : 				if( lpObj->VpPlayer2[nViewPortObjectCount].type == OBJ_USER &&

  0014f	80 7b 02 01	 cmp	 BYTE PTR [ebx+2], 1
  00153	89 45 f0	 mov	 DWORD PTR tv662[ebp], eax
  00156	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00159	75 05		 jne	 SHORT $LN19@SkillMonkD
  0015b	3b 7d 0c	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  0015e	74 48		 je	 SHORT $LN50@SkillMonkD
$LN19@SkillMonkD:

; 6329 : 						nTargetObjNum == aTargetIndex )
; 6330 : 					// here we need to add gens battle zone check )
; 6331 : 				{
; 6332 : 					EnableAttack = TRUE;
; 6333 : 				}
; 6334 : 				else if( lpTargetObj->Type == OBJ_MONSTER && lpTargetObj->m_RecallMon < 0 )

  00160	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  00164	75 09		 jne	 SHORT $LN21@SkillMonkD
  00166	83 be 30 06 00
	00 00		 cmp	 DWORD PTR [esi+1584], 0
  0016d	7c 39		 jl	 SHORT $LN50@SkillMonkD
$LN21@SkillMonkD:

; 6335 : 				{
; 6336 : 					EnableAttack = TRUE;
; 6337 : 				}
; 6338 : 				else if( DuelIndex == nTargetObjNum )

  0016f	39 7d ec	 cmp	 DWORD PTR _DuelIndex$1$[ebp], edi
  00172	74 34		 je	 SHORT $LN50@SkillMonkD

; 6339 : 				{
; 6340 : 					EnableAttack = TRUE;
; 6341 : 				}
; 6342 : 				else
; 6343 : 				{
; 6344 : 					int CallMonIndex = gObj[nTargetObjNum].m_Index;
; 6345 : 
; 6346 : 					if(gObj[nTargetObjNum].Type == OBJ_MONSTER && gObj[nTargetObjNum].m_RecallMon >= 0)

  00174	80 7e 50 02	 cmp	 BYTE PTR [esi+80], 2
  00178	8b 16		 mov	 edx, DWORD PTR [esi]
  0017a	75 13		 jne	 SHORT $LN25@SkillMonkD
  0017c	8b 86 30 06 00
	00		 mov	 eax, DWORD PTR [esi+1584]
  00182	85 c0		 test	 eax, eax
  00184	78 09		 js	 SHORT $LN25@SkillMonkD

; 6347 : 					{
; 6348 : 						CallMonIndex = gObj[gObj[nTargetObjNum].m_RecallMon].m_Index;

  00186	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0018c	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN25@SkillMonkD:

; 6349 : 					}
; 6350 : 
; 6351 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  0018f	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00195	03 c1		 add	 eax, ecx
  00197	50		 push	 eax
  00198	ff 75 fc	 push	 DWORD PTR _lpObj$1$[ebp]
  0019b	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  001a0	83 c4 08	 add	 esp, 8
  001a3	83 f8 01	 cmp	 eax, 1
  001a6	75 7e		 jne	 SHORT $LN55@SkillMonkD
$LN50@SkillMonkD:

; 6352 : 					{
; 6353 : 						EnableAttack = TRUE;
; 6354 : 					}
; 6355 : 				}
; 6356 : 
; 6357 : 				if( EnableAttack != FALSE && !gObjAttackQ(lpTargetObj) )

  001a8	56		 push	 esi
  001a9	e8 00 00 00 00	 call	 ?gObjAttackQ@@YAHPAUOBJECTSTRUCT@@@Z ; gObjAttackQ
  001ae	83 c4 04	 add	 esp, 4
  001b1	85 c0		 test	 eax, eax
  001b3	74 71		 je	 SHORT $LN55@SkillMonkD

; 6358 : 					EnableAttack = FALSE;
; 6359 : 
; 6360 : 				if( EnableAttack != FALSE )
; 6361 : 				{
; 6362 : 					int nAttackRange = 0;
; 6363 : 
; 6364 : 					if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DARKSIDE ||
; 6365 : 						lpMagic->m_Skill == AT_MSKILL_RF_DARKSIDE1 ||

  001b5	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001b8	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001bb	3d 07 01 00 00	 cmp	 eax, 263		; 00000107H
  001c0	74 12		 je	 SHORT $LN31@SkillMonkD
  001c2	3d 2f 02 00 00	 cmp	 eax, 559		; 0000022fH
  001c7	74 0b		 je	 SHORT $LN31@SkillMonkD
  001c9	3d 33 02 00 00	 cmp	 eax, 563		; 00000233H
  001ce	74 04		 je	 SHORT $LN31@SkillMonkD

; 6368 : 					else
; 6369 : 						nAttackRange = 0;

  001d0	33 f6		 xor	 esi, esi
  001d2	eb 05		 jmp	 SHORT $LN30@SkillMonkD
$LN31@SkillMonkD:

; 6366 : 						lpMagic->m_Skill == AT_MSKILL_RF_DARKSIDE2 )
; 6367 : 						nAttackRange = 5;

  001d4	be 05 00 00 00	 mov	 esi, 5
$LN30@SkillMonkD:

; 6370 : 
; 6371 : 					if( CalDistance(lpObj->X,lpObj->Y,gObj[nTargetObjNum].X,gObj[nTargetObjNum].Y) < nAttackRange )

  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001df	8b 55 f0	 mov	 edx, DWORD PTR tv662[ebp]
  001e2	0f b6 84 0a 21
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+289]
  001ea	50		 push	 eax
  001eb	0f b6 84 0a 20
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+288]
  001f3	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  001f6	50		 push	 eax
  001f7	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  001fe	50		 push	 eax
  001ff	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00206	8b 4d f4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  0020f	3b c6		 cmp	 eax, esi
  00211	7d 13		 jge	 SHORT $LN55@SkillMonkD

; 6372 : 					{
; 6373 : 						wTargetList[nHitTargetCount] = nTargetObjNum;

  00213	8b 45 f8	 mov	 eax, DWORD PTR _nHitTargetCount$1$[ebp]
  00216	8b 4d 14	 mov	 ecx, DWORD PTR _wTargetList$[ebp]
  00219	66 89 3c 41	 mov	 WORD PTR [ecx+eax*2], di

; 6374 : 						nHitTargetCount++;

  0021d	40		 inc	 eax
  0021e	89 45 f8	 mov	 DWORD PTR _nHitTargetCount$1$[ebp], eax

; 6375 : 
; 6376 : 						if( nHitTargetCount >= 5 )

  00221	83 f8 05	 cmp	 eax, 5
  00224	7d 19		 jge	 SHORT $LN41@SkillMonkD
$LN55@SkillMonkD:
  00226	8b 7d 08	 mov	 edi, DWORD PTR _nViewPortObjectCount$1$[ebp]
$LN33@SkillMonkD:

; 6377 : 							break;
; 6378 : 					}
; 6379 : 				}
; 6380 : 
; 6381 : 			}
; 6382 : 		}
; 6383 : 		nViewPortObjectCount++;
; 6384 : 
; 6385 : 		if( nViewPortObjectCount > MAX_VIEWPORT-1 )

  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022f	47		 inc	 edi
  00230	83 c3 0c	 add	 ebx, 12			; 0000000cH
  00233	89 7d 08	 mov	 DWORD PTR _nViewPortObjectCount$1$[ebp], edi
  00236	83 ff 4a	 cmp	 edi, 74			; 0000004aH
  00239	0f 8e f1 fe ff
	ff		 jle	 $LL4@SkillMonkD
$LN41@SkillMonkD:
  0023f	5e		 pop	 esi
  00240	5b		 pop	 ebx

; 6386 : 			break;
; 6387 : 	}
; 6388 :     return true;

  00241	b8 01 00 00 00	 mov	 eax, 1
  00246	5f		 pop	 edi

; 6389 : }

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 10 00	 ret	 16			; 00000010H
?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z ENDP ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMonkBarrageJustOneTarget@CObjUseSkill@@QAEXHPAVCMagicInf@@H@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
tv500 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
tv493 = 12						; size = 4
_lpMagic$ = 12						; size = 4
_nMaxBarrageCount$1$ = 16				; size = 4
_aTargetIndex$ = 16					; size = 4
?SkillMonkBarrageJustOneTarget@CObjUseSkill@@QAEXHPAVCMagicInf@@H@Z PROC ; CObjUseSkill::SkillMonkBarrageJustOneTarget, COMDAT
; _this$ = ecx

; 6130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 6131 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6132 : 	int nTargetObjNum = 0;
; 6133 : 	int nViewPortObjectCount = 0;

  0000d	33 d2		 xor	 edx, edx
  0000f	56		 push	 esi

; 6134 : 	int DuelIndex = lpObj->m_iDuelUser;
; 6135 : 
; 6136 : 	if( !OBJMAX_RANGE(aTargetIndex) )

  00010	8b 75 10	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00017	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0001a	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00020	03 cb		 add	 ecx, ebx
  00022	89 4d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ecx
  00025	85 f6		 test	 esi, esi
  00027	0f 88 1d 02 00
	00		 js	 $LN48@SkillMonkB
  0002d	33 c0		 xor	 eax, eax
  0002f	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00035	0f 9e c0	 setle	 al
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 0a 02 00
	00		 je	 $LN48@SkillMonkB

; 6139 : 			aIndex,gObj[aIndex].AccountID);
; 6140 : 		return;
; 6141 : 	}
; 6142 : 
; 6143 : 	int EnableAttack;
; 6144 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00040	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00046	89 45 fc	 mov	 DWORD PTR tv500[ebp], eax
  00049	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  0004c	8d 81 4a 0c 00
	00		 lea	 eax, DWORD PTR [ecx+3146]
$LL2@SkillMonkB:

; 6145 : 
; 6146 : 	while( TRUE )
; 6147 : 	{
; 6148 : 		if( lpObj->VpPlayer2[nViewPortObjectCount].state != 0 )

  00052	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00056	74 0c		 je	 SHORT $LN9@SkillMonkB

; 6149 : 		{
; 6150 : 			nTargetObjNum = lpObj->VpPlayer2[nViewPortObjectCount].number;

  00058	0f bf 30	 movsx	 esi, WORD PTR [eax]

; 6151 : 
; 6152 : 			if( nTargetObjNum >= 0 && 

  0005b	85 f6		 test	 esi, esi
  0005d	78 05		 js	 SHORT $LN9@SkillMonkB
  0005f	3b 75 10	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00062	74 12		 je	 SHORT $LN41@SkillMonkB
$LN9@SkillMonkB:

; 6240 : 						}
; 6241 : 					}
; 6242 : 				}
; 6243 : 				break;
; 6244 : 			}
; 6245 : 		}
; 6246 : 
; 6247 : 		nViewPortObjectCount++;

  00064	42		 inc	 edx
  00065	83 c0 0c	 add	 eax, 12			; 0000000cH

; 6248 : 
; 6249 : 		if(nViewPortObjectCount > MAX_VIEWPORT -1)

  00068	83 fa 4a	 cmp	 edx, 74			; 0000004aH
  0006b	7e e5		 jle	 SHORT $LL2@SkillMonkB
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx

; 6250 : 		{
; 6251 : 			break;
; 6252 : 		}
; 6253 : 	}
; 6254 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 0c 00	 ret	 12			; 0000000cH
$LN41@SkillMonkB:

; 6153 : 				nTargetObjNum == aTargetIndex )
; 6154 : 			{
; 6155 : 				EnableAttack = FALSE;
; 6156 : 
; 6157 : 				
; 6158 : 				if(lpObj->VpPlayer2[nViewPortObjectCount].type == OBJ_USER && nTargetObjNum == aTargetIndex)

  00076	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00079	80 bc 81 4c 0c
	00 00 01	 cmp	 BYTE PTR [ecx+eax*4+3148], 1
  00081	74 63		 je	 SHORT $LN49@SkillMonkB

; 6159 : 				{
; 6160 : 					EnableAttack = TRUE;
; 6161 : 				}
; 6162 : 				else if( lpTargetObj->Type == OBJ_MONSTER && gObj[nTargetObjNum].m_RecallMon < 0 )

  00083	80 7f 50 02	 cmp	 BYTE PTR [edi+80], 2
  00087	75 10		 jne	 SHORT $LN12@SkillMonkB
  00089	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  0008f	83 bc 18 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ebx+1584], 0
  00097	7c 4d		 jl	 SHORT $LN49@SkillMonkB
$LN12@SkillMonkB:

; 6163 : 				{
; 6164 : 					EnableAttack = TRUE;
; 6165 : 				}
; 6166 : 				else if( nTargetObjNum == DuelIndex )

  00099	3b b1 50 12 00
	00		 cmp	 esi, DWORD PTR [ecx+4688]
  0009f	74 45		 je	 SHORT $LN49@SkillMonkB

; 6167 : 				{
; 6168 : 					EnableAttack = TRUE;
; 6169 : 				}
; 6170 : 				else
; 6171 : 				{
; 6172 : 					int CallMonIndex = gObj[nTargetObjNum].m_Index;

  000a1	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 6173 : 
; 6174 : 					if(gObj[nTargetObjNum].Type == OBJ_MONSTER && gObj[nTargetObjNum].m_RecallMon >= 0)

  000a7	80 7c 18 50 02	 cmp	 BYTE PTR [eax+ebx+80], 2
  000ac	8b 14 18	 mov	 edx, DWORD PTR [eax+ebx]
  000af	75 14		 jne	 SHORT $LN16@SkillMonkB
  000b1	8b 84 18 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ebx+1584]
  000b8	85 c0		 test	 eax, eax
  000ba	78 09		 js	 SHORT $LN16@SkillMonkB

; 6175 : 					{
; 6176 : 						CallMonIndex = gObj[gObj[nTargetObjNum].m_RecallMon].m_Index;

  000bc	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000c2	8b 14 18	 mov	 edx, DWORD PTR [eax+ebx]
$LN16@SkillMonkB:

; 6177 : 					}
; 6178 : 
; 6179 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000c5	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  000cb	03 c3		 add	 eax, ebx
  000cd	50		 push	 eax
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000d4	83 c4 08	 add	 esp, 8
  000d7	83 f8 01	 cmp	 eax, 1
  000da	0f 85 7d 01 00
	00		 jne	 $LN5@SkillMonkB
  000e0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN49@SkillMonkB:

; 6180 : 					{
; 6181 : 						EnableAttack = TRUE;
; 6182 : 					}
; 6183 : 				}
; 6184 : 
; 6185 : 				if( EnableAttack != FALSE && 

  000e6	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000ec	0f b6 84 19 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+289]
  000f4	50		 push	 eax
  000f5	0f b6 84 19 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+288]
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR tv500[ebp]
  00100	50		 push	 eax
  00101	0f b6 84 19 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+289]
  00109	50		 push	 eax
  0010a	0f b6 84 19 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+288]
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  0011b	83 f8 04	 cmp	 eax, 4
  0011e	0f 8d 39 01 00
	00		 jge	 $LN5@SkillMonkB

; 6186 : 					CalDistance(gObj[aTargetIndex].X,gObj[aTargetIndex].Y,gObj[nTargetObjNum].X,gObj[nTargetObjNum].Y) < 4 )
; 6187 : 				{
; 6188 : 					int nMaxBarrageCount = 0;
; 6189 : 
; 6190 : 					if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_WEAPON1 )

  00124	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00127	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0012a	81 f9 04 01 00
	00		 cmp	 ecx, 260		; 00000104H
  00130	75 09		 jne	 SHORT $LN19@SkillMonkB

; 6191 : 					{
; 6192 : 						nMaxBarrageCount = 5;

  00132	c7 45 10 05 00
	00 00		 mov	 DWORD PTR _nMaxBarrageCount$1$[ebp], 5
  00139	eb 35		 jmp	 SHORT $LN25@SkillMonkB
$LN19@SkillMonkB:

; 6193 : 					}
; 6194 : 					else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_WEAPON2 )

  0013b	81 f9 05 01 00
	00		 cmp	 ecx, 261		; 00000105H
  00141	75 09		 jne	 SHORT $LN21@SkillMonkB

; 6195 : 					{
; 6196 : 						nMaxBarrageCount = 3;

  00143	c7 45 10 03 00
	00 00		 mov	 DWORD PTR _nMaxBarrageCount$1$[ebp], 3
  0014a	eb 24		 jmp	 SHORT $LN25@SkillMonkB
$LN21@SkillMonkB:

; 6197 : 					}
; 6198 : 					else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_CHAINDRIVE )

  0014c	81 f9 06 01 00
	00		 cmp	 ecx, 262		; 00000106H
  00152	75 09		 jne	 SHORT $LN23@SkillMonkB

; 6199 : 					{
; 6200 : 						nMaxBarrageCount = 5;

  00154	c7 45 10 05 00
	00 00		 mov	 DWORD PTR _nMaxBarrageCount$1$[ebp], 5
  0015b	eb 13		 jmp	 SHORT $LN25@SkillMonkB
$LN23@SkillMonkB:

; 6201 : 					}
; 6202 : 					else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DARKSIDE )

  0015d	33 c0		 xor	 eax, eax
  0015f	ba 03 00 00 00	 mov	 edx, 3
  00164	81 f9 07 01 00
	00		 cmp	 ecx, 263		; 00000107H
  0016a	0f 44 c2	 cmove	 eax, edx
  0016d	89 45 10	 mov	 DWORD PTR _nMaxBarrageCount$1$[ebp], eax
$LN25@SkillMonkB:

; 6203 : 					{
; 6204 : 						nMaxBarrageCount = 3;
; 6205 : 					}
; 6206 : 					else
; 6207 : 					{
; 6208 : 						nMaxBarrageCount = 0;
; 6209 : 					}
; 6210 : 
; 6211 : 					if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_WEAPON1 && 

  00170	be 64 00 00 00	 mov	 esi, 100		; 00000064H
  00175	81 f9 04 01 00
	00		 cmp	 ecx, 260		; 00000104H
  0017b	75 1b		 jne	 SHORT $LN27@SkillMonkB
  0017d	e8 00 00 00 00	 call	 _rand
  00182	99		 cdq
  00183	f7 fe		 idiv	 esi
  00185	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00188	7d 0e		 jge	 SHORT $LN27@SkillMonkB

; 6212 : 						rand()%100 < 10 )
; 6213 : 					{
; 6214 : 						gObjAddBuffEffect(lpTargetObj,BUFF_WEAKNESS,ADD_OPTION_WEAKNESS,5,0,0,10);

  0018a	6a 0a		 push	 10			; 0000000aH
  0018c	6a 00		 push	 0
  0018e	6a 00		 push	 0
  00190	6a 05		 push	 5
  00192	6a 1d		 push	 29			; 0000001dH
  00194	6a 4c		 push	 76			; 0000004cH
  00196	eb 60		 jmp	 SHORT $LN50@SkillMonkB
$LN27@SkillMonkB:

; 6215 : 					}
; 6216 : 					else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_WEAPON2 &&

  00198	81 7b 08 05 01
	00 00		 cmp	 DWORD PTR [ebx+8], 261	; 00000105H
  0019f	75 1b		 jne	 SHORT $LN29@SkillMonkB
  001a1	e8 00 00 00 00	 call	 _rand
  001a6	99		 cdq
  001a7	f7 fe		 idiv	 esi
  001a9	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  001ac	7d 0e		 jge	 SHORT $LN29@SkillMonkB

; 6217 : 						rand()%100 < 10 )
; 6218 : 					{
; 6219 : 						gObjAddBuffEffect(lpTargetObj,BUFF_DEFENSEDOWN,ADD_OPTION_DEFENSEDOWN,10,0,0,10);

  001ae	6a 0a		 push	 10			; 0000000aH
  001b0	6a 00		 push	 0
  001b2	6a 00		 push	 0
  001b4	6a 0a		 push	 10			; 0000000aH
  001b6	6a 17		 push	 23			; 00000017H
  001b8	6a 3a		 push	 58			; 0000003aH
  001ba	eb 3c		 jmp	 SHORT $LN50@SkillMonkB
$LN29@SkillMonkB:

; 6220 : 					}
; 6221 : 					else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_CHAINDRIVE &&

  001bc	81 7b 08 06 01
	00 00		 cmp	 DWORD PTR [ebx+8], 262	; 00000106H
  001c3	75 3c		 jne	 SHORT $LN31@SkillMonkB
  001c5	e8 00 00 00 00	 call	 _rand
  001ca	99		 cdq
  001cb	f7 fe		 idiv	 esi
  001cd	83 fa 28	 cmp	 edx, 40			; 00000028H
  001d0	7d 2f		 jge	 SHORT $LN31@SkillMonkB

; 6222 : 						rand()%100 < 40 )
; 6223 : 					{
; 6224 : 						lpTargetObj->lpAttackObj = lpObj;

  001d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]

; 6225 : 						lpTargetObj->DelayActionTime = 1000;
; 6226 : 						lpTargetObj->DelayLevel = 1;
; 6227 : 
; 6228 : 						gObjAddBuffEffect(lpTargetObj,BUFF_COLD,ADD_OPTION_REDUCEMOVEMENT,0,0,0,10);

  001d5	6a 0a		 push	 10			; 0000000aH
  001d7	6a 00		 push	 0
  001d9	6a 00		 push	 0
  001db	6a 00		 push	 0
  001dd	6a 14		 push	 20			; 00000014H
  001df	89 87 b4 05 00
	00		 mov	 DWORD PTR [edi+1460], eax
  001e5	c7 87 a4 05 00
	00 e8 03 00 00	 mov	 DWORD PTR [edi+1444], 1000 ; 000003e8H
  001ef	c6 87 a8 05 00
	00 01		 mov	 BYTE PTR [edi+1448], 1
  001f6	6a 56		 push	 86			; 00000056H
$LN50@SkillMonkB:
  001f8	57		 push	 edi
  001f9	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  001fe	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN31@SkillMonkB:

; 6229 : 					}
; 6230 : 
; 6231 : 					for(int i = 1; i < nMaxBarrageCount; i++)

  00201	8b 45 10	 mov	 eax, DWORD PTR _nMaxBarrageCount$1$[ebp]
  00204	be 01 00 00 00	 mov	 esi, 1
  00209	3b c6		 cmp	 eax, esi
  0020b	7e 50		 jle	 SHORT $LN5@SkillMonkB
  0020d	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00210	89 4d 0c	 mov	 DWORD PTR tv493[ebp], ecx
$LL6@SkillMonkB:

; 6232 : 					{
; 6233 : 						if( (i%(nMaxBarrageCount-1)) == TRUE  )

  00213	8b c6		 mov	 eax, esi
  00215	99		 cdq
  00216	f7 f9		 idiv	 ecx

; 6234 : 						{
; 6235 : 							gObjAttack(lpObj,lpTargetObj,lpMagic,TRUE,TRUE,0,0,i,0);

  00218	6a 00		 push	 0
  0021a	56		 push	 esi
  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	6a 01		 push	 1
  00221	83 fa 01	 cmp	 edx, 1
  00224	75 03		 jne	 SHORT $LN32@SkillMonkB
  00226	52		 push	 edx

; 6236 : 						}
; 6237 : 						else

  00227	eb 02		 jmp	 SHORT $LN51@SkillMonkB
$LN32@SkillMonkB:

; 6238 : 						{
; 6239 : 							gObjAttack(lpObj,lpTargetObj,lpMagic,FALSE,TRUE,0,0,i,0);

  00229	6a 00		 push	 0
$LN51@SkillMonkB:
  0022b	53		 push	 ebx
  0022c	57		 push	 edi
  0022d	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  00230	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00235	8b 4d 0c	 mov	 ecx, DWORD PTR tv493[ebp]
  00238	46		 inc	 esi
  00239	83 c4 24	 add	 esp, 36			; 00000024H
  0023c	3b 75 10	 cmp	 esi, DWORD PTR _nMaxBarrageCount$1$[ebp]
  0023f	7c d2		 jl	 SHORT $LL6@SkillMonkB
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx

; 6250 : 		{
; 6251 : 			break;
; 6252 : 		}
; 6253 : 	}
; 6254 : }

  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c2 0c 00	 ret	 12			; 0000000cH
$LN48@SkillMonkB:

; 6137 : 	{
; 6138 : 		LogAddTD("[InvalidTargetIndex][SkillMonkBarrageJustOneTarget] Index :%d , AccountID : %s ",

  0024a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0024d	50		 push	 eax
  0024e	57		 push	 edi
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@JGPGPLCI@?$FLInvalidTargetIndex?$FN?$FLSkillMonkBa@
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0025a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SkillMonkB:
  0025d	5f		 pop	 edi
  0025e	5e		 pop	 esi
  0025f	5b		 pop	 ebx

; 6250 : 		{
; 6251 : 			break;
; 6252 : 		}
; 6253 : 	}
; 6254 : }

  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c2 0c 00	 ret	 12			; 0000000cH
?SkillMonkBarrageJustOneTarget@CObjUseSkill@@QAEXHPAVCMagicInf@@H@Z ENDP ; CObjUseSkill::SkillMonkBarrageJustOneTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDeathPoisonForMeDusa@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z
_TEXT	SEGMENT
_tObjNum$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
_lpObj$1$ = -4						; size = 4
tv405 = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_lpTargetObj$1$ = 24					; size = 4
_aTargetIndex$ = 24					; size = 4
?SkillDeathPoisonForMeDusa@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z PROC ; CObjUseSkill::SkillDeathPoisonForMeDusa, COMDAT
; _this$ = ecx

; 6581 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 6582 : 	LPOBJ lpObj		= &gObj[aIndex];
; 6583 : 	int tObjNum;
; 6584 : 	int count		= 0;
; 6585 : 	int FirstHit	= 0;
; 6586 : 	int HitCount	= 0;
; 6587 : 	int DuelIndex	= lpObj->m_iDuelUser;
; 6588 : 	int EnableAttack;
; 6589 : 	// ----
; 6590 : 	if( !OBJMAX_RANGE(aTargetIndex) )

  00006	8b 55 18	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000d	57		 push	 edi
  0000e	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00014	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	03 f9		 add	 edi, ecx
  0001f	89 7d fc	 mov	 DWORD PTR _lpObj$1$[ebp], edi
  00022	85 d2		 test	 edx, edx
  00024	0f 88 54 01 00
	00		 js	 $LN24@SkillDeath
  0002a	33 c0		 xor	 eax, eax
  0002c	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00032	0f 9e c0	 setle	 al
  00035	85 c0		 test	 eax, eax
  00037	0f 84 41 01 00
	00		 je	 $LN24@SkillDeath

; 6595 : 	}
; 6596 : 	// ----
; 6597 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0003d	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00043	8d b7 4a 0c 00
	00		 lea	 esi, DWORD PTR [edi+3146]
  00049	53		 push	 ebx
  0004a	03 c1		 add	 eax, ecx
  0004c	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00051	89 45 18	 mov	 DWORD PTR _lpTargetObj$1$[ebp], eax
  00054	89 4d 08	 mov	 DWORD PTR tv405[ebp], ecx
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@SkillDeath:

; 6598 : 	// ----
; 6599 : 	while(true)
; 6600 : 	{
; 6601 : 		if( lpObj->VpPlayer2[count].state != 0 )

  00060	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00064	0f 84 f7 00 00
	00		 je	 $LN26@SkillDeath

; 6602 : 		{
; 6603 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0006a	0f bf 06	 movsx	 eax, WORD PTR [esi]
  0006d	89 45 f4	 mov	 DWORD PTR _tObjNum$1$[ebp], eax

; 6604 : 			// ----
; 6605 : 			if( tObjNum >= 0 )

  00070	85 c0		 test	 eax, eax
  00072	0f 88 e9 00 00
	00		 js	 $LN26@SkillDeath

; 6606 : 			{
; 6607 : 				EnableAttack = 0;
; 6608 : 				// ----
; 6609 : 				if( lpObj->VpPlayer2[count].type == OBJ_USER && gObj[tObjNum].m_RecallMon < 0 )

  00078	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  0007c	0f 85 df 00 00
	00		 jne	 $LN26@SkillDeath
  00082	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00088	69 d8 40 27 00
	00		 imul	 ebx, eax, 10048
  0008e	03 fb		 add	 edi, ebx
  00090	83 bf 30 06 00
	00 00		 cmp	 DWORD PTR [edi+1584], 0
  00097	0f 8d c4 00 00
	00		 jge	 $LN26@SkillDeath

; 6610 : 				{
; 6611 : 					EnableAttack = 1;
; 6612 : 				}
; 6613 : 				// ----
; 6614 : 				if( EnableAttack )
; 6615 : 				{
; 6616 : 					if( this->CalDistance(x, y, gObj[tObjNum].X, gObj[tObjNum].Y) < 8 )

  0009d	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000a7	50		 push	 eax
  000a8	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  000af	50		 push	 eax
  000b0	0f b6 45 14	 movzx	 eax, BYTE PTR _y$[ebp]
  000b4	50		 push	 eax
  000b5	0f b6 45 10	 movzx	 eax, BYTE PTR _x$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  000bf	83 f8 08	 cmp	 eax, 8
  000c2	0f 8d 96 00 00
	00		 jge	 $LN31@SkillDeath

; 6617 : 					{
; 6618 : 						if( lpObj->m_Index != gObj[tObjNum].m_Index )

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	3b 07		 cmp	 eax, DWORD PTR [edi]
  000cf	0f 84 89 00 00
	00		 je	 $LN31@SkillDeath

; 6619 : 						{
; 6620 : 							int iSkillDistance = gObjCalDistance(lpTargetObj, &gObj[tObjNum]);

  000d5	57		 push	 edi
  000d6	ff 75 18	 push	 DWORD PTR _lpTargetObj$1$[ebp]
  000d9	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000de	83 c4 08	 add	 esp, 8

; 6621 : 							// ----
; 6622 : 							if( iSkillDistance <= 3 )

  000e1	83 f8 03	 cmp	 eax, 3
  000e4	7f 78		 jg	 SHORT $LN31@SkillDeath

; 6623 : 							{
; 6624 : 								int delay = rand() % 500;

  000e6	e8 00 00 00 00	 call	 _rand
  000eb	99		 cdq
  000ec	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  000f1	f7 f9		 idiv	 ecx

; 6625 : 								gObjAddAttackProcMsgSendDelay(lpObj, 50, tObjNum, delay, lpMagic->m_Skill, 0);

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000f6	8b 7d fc	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  000f9	6a 00		 push	 0
  000fb	ff 70 08	 push	 DWORD PTR [eax+8]
  000fe	52		 push	 edx
  000ff	ff 75 f4	 push	 DWORD PTR _tObjNum$1$[ebp]
  00102	6a 32		 push	 50			; 00000032H
  00104	57		 push	 edi
  00105	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 6626 : 								// ----
; 6627 : 								if( gObjCheckUsedBuffEffect(&gObj[tObjNum], 55) )

  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010f	03 c3		 add	 eax, ebx
  00111	6a 37		 push	 55			; 00000037H
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00119	83 c4 20	 add	 esp, 32			; 00000020H
  0011c	84 c0		 test	 al, al
  0011e	74 3e		 je	 SHORT $LN31@SkillDeath

; 6628 : 								{
; 6629 : 									if( !retResistance(&gObj[tObjNum], 1) )

  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00125	03 c3		 add	 eax, ebx
  00127	6a 01		 push	 1
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  0012f	83 c4 08	 add	 esp, 8
  00132	85 c0		 test	 eax, eax
  00134	75 28		 jne	 SHORT $LN31@SkillDeath

; 6630 : 									{
; 6631 : 										gObj[tObjNum].lpAttackObj = lpObj;

  00136	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6632 : 										gObjAddBuffEffect(&gObj[tObjNum], 55, 19, 3, 0, 0, 20);

  0013b	6a 14		 push	 20			; 00000014H
  0013d	6a 00		 push	 0
  0013f	6a 00		 push	 0
  00141	6a 03		 push	 3
  00143	89 bc 03 b4 05
	00 00		 mov	 DWORD PTR [ebx+eax+1460], edi
  0014a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014f	6a 13		 push	 19			; 00000013H
  00151	03 c3		 add	 eax, ebx
  00153	6a 37		 push	 55			; 00000037H
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  0015b	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN31@SkillDeath:
  0015e	8b 4d 08	 mov	 ecx, DWORD PTR tv405[ebp]
$LN26@SkillDeath:

; 6633 : 									}
; 6634 : 								}
; 6635 : 							}
; 6636 : 						}
; 6637 : 					}
; 6638 : 				}
; 6639 : 			}
; 6640 : 		}
; 6641 : 		// ----
; 6642 : 		count++;

  00161	83 c6 0c	 add	 esi, 12			; 0000000cH

; 6643 : 		// ----
; 6644 : 		if( count > MAX_VIEWPORT -1 )

  00164	83 e9 01	 sub	 ecx, 1
  00167	89 4d 08	 mov	 DWORD PTR tv405[ebp], ecx
  0016a	0f 85 f0 fe ff
	ff		 jne	 $LL2@SkillDeath

; 6645 : 		{
; 6646 : 			break;
; 6647 : 		}
; 6648 : 	}
; 6649 : 	// ----
; 6650 : 	return 1;

  00170	5b		 pop	 ebx
  00171	5f		 pop	 edi
  00172	b8 01 00 00 00	 mov	 eax, 1
  00177	5e		 pop	 esi

; 6651 : }

  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c2 14 00	 ret	 20			; 00000014H
$LN24@SkillDeath:

; 6591 : 	{
; 6592 : 		LogAddTD("[InvalidTargetIndex][SkillDeathPoisonForMeDusa] Index :%d , AccountID : %s ",

  0017e	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00181	50		 push	 eax
  00182	56		 push	 esi
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@PCLLIACM@?$FLInvalidTargetIndex?$FN?$FLSkillDeathP@
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6593 : 			aIndex, gObj[aIndex].AccountID);
; 6594 : 		return 0;

  00191	33 c0		 xor	 eax, eax
  00193	5f		 pop	 edi
  00194	5e		 pop	 esi

; 6651 : }

  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c2 14 00	 ret	 20			; 00000014H
?SkillDeathPoisonForMeDusa@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ENDP ; CObjUseSkill::SkillDeathPoisonForMeDusa
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillEvilMonster@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv381 = -8						; size = 4
_HitCount$1$ = -4					; size = 4
tv378 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillEvilMonster@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillEvilMonster, COMDAT
; _this$ = ecx

; 6654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 6655 : 	LPOBJ lpObj		= &gObj[aIndex];

  00007	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  0000e	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  00013	56		 push	 esi
  00014	57		 push	 edi

; 6656 : 	int tObjNum;
; 6657 : 	int count		= 0;
; 6658 : 	int HitCount	= 0;

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _HitCount$1$[ebp], 0
  0001c	89 55 08	 mov	 DWORD PTR tv378[ebp], edx
  0001f	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	8d b3 4a 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3146]
  0002b	0f 1f 44 00 00	 npad	 5
$LL2@SkillEvilM:

; 6659 : 	int bAttack;
; 6660 : 	int DuelIndex	= lpObj->m_iDuelUser;
; 6661 : 	// ----
; 6662 : 	while(true)
; 6663 : 	{
; 6664 : 		if( lpObj->VpPlayer2[count].state )

  00030	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00034	0f 84 b9 00 00
	00		 je	 $LN27@SkillEvilM

; 6665 : 		{
; 6666 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003a	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 6667 : 			// ----
; 6668 : 			if( tObjNum >= 0 )

  0003d	85 ff		 test	 edi, edi
  0003f	0f 88 ae 00 00
	00		 js	 $LN27@SkillEvilM

; 6669 : 			{
; 6670 : 				int EnableAttack = false;
; 6671 : 				// ----
; 6672 : 				if( lpObj->VpPlayer2[count].type == 1 )

  00045	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  00049	0f 85 a4 00 00
	00		 jne	 $LN27@SkillEvilM

; 6673 : 				{
; 6674 : 					EnableAttack = true;
; 6675 : 					// ----
; 6676 : 					if( gObj[tObjNum].m_RecallMon >= 0 )

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00054	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  0005a	03 c1		 add	 eax, ecx
  0005c	89 4d f8	 mov	 DWORD PTR tv381[ebp], ecx
  0005f	83 b8 30 06 00
	00 00		 cmp	 DWORD PTR [eax+1584], 0
  00066	7c 09		 jl	 SHORT $LN25@SkillEvilM

; 6677 : 					{
; 6678 : 						if( tObjNum != aTargetIndex )

  00068	3b 7d 0c	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  0006b	0f 85 82 00 00
	00		 jne	 $LN27@SkillEvilM
$LN25@SkillEvilM:

; 6679 : 						{
; 6680 : 							EnableAttack = false;
; 6681 : 						}
; 6682 : 					}
; 6683 : 				}
; 6684 : 				// ----
; 6685 : 				if( EnableAttack )
; 6686 : 				{
; 6687 : 					if( gObjCalDistance(lpObj, &gObj[tObjNum]) < 6 )

  00071	50		 push	 eax
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00078	83 c4 08	 add	 esp, 8
  0007b	83 f8 06	 cmp	 eax, 6
  0007e	7d 70		 jge	 SHORT $LN31@SkillEvilM

; 6688 : 					{
; 6689 : 						bAttack = false;
; 6690 : 						// ----
; 6691 : 						if( HitCount >= 5 )

  00080	33 c0		 xor	 eax, eax
  00082	83 7d fc 05	 cmp	 DWORD PTR _HitCount$1$[ebp], 5
  00086	0f 9c c0	 setl	 al

; 6692 : 						{
; 6693 : 							bAttack = false;
; 6694 : 						}
; 6695 : 						else
; 6696 : 						{
; 6697 : 							bAttack = true;
; 6698 : 						}
; 6699 : 						// ----
; 6700 : 						if( tObjNum == aTargetIndex )

  00089	3b 7d 0c	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  0008c	74 04		 je	 SHORT $LN26@SkillEvilM

; 6701 : 						{
; 6702 : 							bAttack = true;
; 6703 : 						}
; 6704 : 						// ----
; 6705 : 						if( bAttack )

  0008e	85 c0		 test	 eax, eax
  00090	74 5e		 je	 SHORT $LN31@SkillEvilM
$LN26@SkillEvilM:

; 6706 : 						{
; 6707 : 							int delay = rand() % 2000;

  00092	e8 00 00 00 00	 call	 _rand

; 6708 : 							// ----
; 6709 : 							gObjAddAttackProcMsgSendDelay(lpObj, 50, tObjNum, 300, lpMagic->m_Skill, 0);

  00097	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0009a	6a 00		 push	 0
  0009c	ff 70 08	 push	 DWORD PTR [eax+8]
  0009f	68 2c 01 00 00	 push	 300			; 0000012cH
  000a4	57		 push	 edi
  000a5	6a 32		 push	 50			; 00000032H
  000a7	53		 push	 ebx
  000a8	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 6710 : 							HitCount++;
; 6711 : 							// ----
; 6712 : 							LPOBJ lpTargetObj = &gObj[tObjNum];

  000ad	8b 7d f8	 mov	 edi, DWORD PTR tv381[ebp]
  000b0	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b6	ff 45 fc	 inc	 DWORD PTR _HitCount$1$[ebp]

; 6713 : 							// ----
; 6714 : 							if( !gObjCheckUsedBuffEffect(lpTargetObj, 55) )

  000b9	6a 37		 push	 55			; 00000037H
  000bb	57		 push	 edi
  000bc	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000c1	83 c4 20	 add	 esp, 32			; 00000020H
  000c4	84 c0		 test	 al, al
  000c6	75 28		 jne	 SHORT $LN31@SkillEvilM

; 6715 : 							{
; 6716 : 								if( !retResistance(lpTargetObj, 1) )

  000c8	6a 01		 push	 1
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  000d0	83 c4 08	 add	 esp, 8
  000d3	85 c0		 test	 eax, eax
  000d5	75 19		 jne	 SHORT $LN31@SkillEvilM

; 6717 : 								{
; 6718 : 									lpTargetObj->lpAttackObj = lpObj;
; 6719 : 									gObjAddBuffEffect(lpTargetObj, 55, 19, 3, 0, 0, 20);

  000d7	6a 14		 push	 20			; 00000014H
  000d9	50		 push	 eax
  000da	50		 push	 eax
  000db	6a 03		 push	 3
  000dd	6a 13		 push	 19			; 00000013H
  000df	6a 37		 push	 55			; 00000037H
  000e1	57		 push	 edi
  000e2	89 9f b4 05 00
	00		 mov	 DWORD PTR [edi+1460], ebx
  000e8	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  000ed	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN31@SkillEvilM:
  000f0	8b 55 08	 mov	 edx, DWORD PTR tv378[ebp]
$LN27@SkillEvilM:

; 6720 : 								}
; 6721 : 							}
; 6722 : 						}
; 6723 : 					}
; 6724 : 				}
; 6725 : 			}
; 6726 : 		}
; 6727 : 		// ----
; 6728 : 		count++;

  000f3	83 c6 0c	 add	 esi, 12			; 0000000cH

; 6729 : 		// ----
; 6730 : 		if( count > MAX_VIEWPORT-1 )

  000f6	83 ea 01	 sub	 edx, 1
  000f9	89 55 08	 mov	 DWORD PTR tv378[ebp], edx
  000fc	0f 85 2e ff ff
	ff		 jne	 $LL2@SkillEvilM

; 6731 : 		{
; 6732 : 			break;
; 6733 : 		}
; 6734 : 	}
; 6735 : 	// ----
; 6736 : 	return true;

  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	5b		 pop	 ebx

; 6737 : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 0c 00	 ret	 12			; 0000000cH
?SkillEvilMonster@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillEvilMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillChaoticDesier@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -12					; size = 4
_HitCount$1$ = -8					; size = 4
_lpObj$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
tv478 = 16						; size = 4
_TargetPos$ = 16					; size = 1
_aTargetIndex$ = 20					; size = 4
?SkillChaoticDesier@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z PROC ; CObjUseSkill::SkillChaoticDesier, COMDAT
; _this$ = ecx

; 5490 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 5491 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 5492 : 	int bSuccess = TRUE;
; 5493 : 
; 5494 : 	SkillFrustrum3(aIndex,TargetPos,1.5f,6.0f,1.5f,0);

  0000c	83 ec 10	 sub	 esp, 16			; 00000010H
  0000f	69 d8 40 27 00
	00		 imul	 ebx, eax, 10048
  00015	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR [esp+12], 0
  0001d	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	c7 44 24 08 00
	00 c0 3f	 mov	 DWORD PTR [esp+8], 1069547520 ; 3fc00000H
  0002b	c7 44 24 04 00
	00 c0 40	 mov	 DWORD PTR [esp+4], 1086324736 ; 40c00000H
  00033	c7 04 24 00 00
	c0 3f		 mov	 DWORD PTR [esp], 1069547520 ; 3fc00000H
  0003a	ff 75 10	 push	 DWORD PTR _TargetPos$[ebp]
  0003d	89 5d fc	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?SkillFrustrum3@CObjUseSkill@@QAEXHEMMMM@Z ; CObjUseSkill::SkillFrustrum3

; 5495 : 
; 5496 : 	int tObjNum;
; 5497 : 	int count = 0;
; 5498 : 	int HitCount = 0;
; 5499 : 	int bAttack;
; 5500 : 	int DuelIndex = lpObj->m_iDuelUser;

  00046	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  0004c	81 c3 4c 0c 00
	00		 add	 ebx, 3148		; 00000c4cH
  00052	8b 7d 14	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  0005e	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00063	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _HitCount$1$[ebp], 0
  0006a	c7 45 10 4b 00
	00 00		 mov	 DWORD PTR tv478[ebp], 75 ; 0000004bH
$LL2@SkillChaot:

; 5501 : 	int EnableAttack;
; 5502 : 
; 5503 : 	while ( true )
; 5504 : 	{
; 5505 : 		if(lpObj->VpPlayer2[count].state != 0)

  00071	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00075	0f 84 6d 01 00
	00		 je	 $LN16@SkillChaot

; 5506 : 		{
; 5507 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007b	0f bf 73 fe	 movsx	 esi, WORD PTR [ebx-2]

; 5508 : 
; 5509 : 			if(tObjNum >= 0)

  0007f	85 f6		 test	 esi, esi
  00081	0f 88 61 01 00
	00		 js	 $LN16@SkillChaot

; 5510 : 			{
; 5511 : 				EnableAttack = 0;
; 5512 : 
; 5513 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00087	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00089	80 f9 02	 cmp	 cl, 2
  0008c	75 10		 jne	 SHORT $LN6@SkillChaot
  0008e	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00094	83 bc 10 30 06
	00 00 00	 cmp	 DWORD PTR [eax+edx+1584], 0
  0009c	7c 55		 jl	 SHORT $LN39@SkillChaot
$LN6@SkillChaot:

; 5514 : 				{
; 5515 : 					EnableAttack = 1;
; 5516 : 				}
; 5517 : 				else if( tObjNum == aTargetIndex || DuelIndex == tObjNum)

  0009e	3b f7		 cmp	 esi, edi
  000a0	74 51		 je	 SHORT $LN39@SkillChaot
  000a2	39 75 f4	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000a5	74 4c		 je	 SHORT $LN39@SkillChaot

; 5518 : 				{
; 5519 : 					EnableAttack = 1;
; 5520 : 				}
; 5521 : #if (GS_CASTLE == 1)
; 5522 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000a7	80 f9 03	 cmp	 cl, 3
  000aa	0f 84 e3 00 00
	00		 je	 $LN11@SkillChaot
  000b0	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000b6	80 bc 17 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+edx+291], 30 ; 0000001eH
  000be	0f 85 cf 00 00
	00		 jne	 $LN11@SkillChaot
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000c9	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 5523 : 				{
; 5524 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d4	83 f8 07	 cmp	 eax, 7
  000d7	0f 85 b6 00 00
	00		 jne	 $LN11@SkillChaot
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000e0	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  000e6	3a 84 17 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+edx+8282]
  000ed	0f 84 ef 00 00
	00		 je	 $LN36@SkillChaot
$LN39@SkillChaot:
  000f3	8b 7d fc	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN10@SkillChaot:

; 5538 : 					{
; 5539 : 						EnableAttack = 1;
; 5540 : 					}
; 5541 : 				}
; 5542 : 
; 5543 : 				if( EnableAttack != FALSE && SkillTestFrustrum(gObj[tObjNum].X,gObj[tObjNum].Y,aIndex) )

  000f6	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  000f9	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000ff	0f b6 84 11 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edx+289]
  00107	50		 push	 eax
  00108	0f b6 84 11 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edx+288]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?SkillTestFrustrum@@YAHHHH@Z ; SkillTestFrustrum
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
  00119	85 c0		 test	 eax, eax
  0011b	0f 84 bb 00 00
	00		 je	 $LN35@SkillChaot

; 5544 : 				{
; 5545 : 					bAttack = FALSE;
; 5546 : 
; 5547 : 					if( HitCount > 8 )

  00121	83 7d f8 08	 cmp	 DWORD PTR _HitCount$1$[ebp], 8
  00125	7e 13		 jle	 SHORT $LN17@SkillChaot

; 5548 : 					{
; 5549 : 						if(rand()%2)

  00127	e8 00 00 00 00	 call	 _rand
  0012c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00131	79 05		 jns	 SHORT $LN40@SkillChaot
  00133	48		 dec	 eax
  00134	83 c8 fe	 or	 eax, -2			; fffffffeH
  00137	40		 inc	 eax
$LN40@SkillChaot:
  00138	74 19		 je	 SHORT $LN20@SkillChaot
$LN17@SkillChaot:

; 5550 : 						{
; 5551 : 							bAttack = TRUE;
; 5552 : 						}
; 5553 : 					}
; 5554 : 					else
; 5555 : 					{
; 5556 : 						bAttack = TRUE;
; 5557 : 					}
; 5558 : 
; 5559 : 					if( bAttack != FALSE )
; 5560 : 					{
; 5561 : 						gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,250,lpMagic->m_Skill,0);

  0013a	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0013d	6a 00		 push	 0
  0013f	ff 70 08	 push	 DWORD PTR [eax+8]
  00142	68 fa 00 00 00	 push	 250			; 000000faH
  00147	56		 push	 esi
  00148	6a 32		 push	 50			; 00000032H
  0014a	57		 push	 edi
  0014b	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00150	83 c4 18	 add	 esp, 24			; 00000018H
$LN20@SkillChaot:

; 5562 : 					}
; 5563 : 
; 5564 : 					if( OBJMAX_RANGE(aTargetIndex) && aTargetIndex == tObjNum)

  00153	8b 7d 14	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00156	85 ff		 test	 edi, edi
  00158	78 2e		 js	 SHORT $LN21@SkillChaot
  0015a	33 c0		 xor	 eax, eax
  0015c	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00162	0f 9e c0	 setle	 al
  00165	85 c0		 test	 eax, eax
  00167	74 1f		 je	 SHORT $LN21@SkillChaot
  00169	3b fe		 cmp	 edi, esi
  0016b	75 1b		 jne	 SHORT $LN21@SkillChaot

; 5565 : 					{
; 5566 : 						gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,300,lpMagic->m_Skill,0);

  0016d	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00170	6a 00		 push	 0
  00172	ff 70 08	 push	 DWORD PTR [eax+8]
  00175	68 2c 01 00 00	 push	 300			; 0000012cH
  0017a	56		 push	 esi
  0017b	6a 32		 push	 50			; 00000032H
  0017d	ff 75 fc	 push	 DWORD PTR _lpObj$1$[ebp]
  00180	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00185	83 c4 18	 add	 esp, 24			; 00000018H
$LN21@SkillChaot:

; 5567 : 					}
; 5568 : 
; 5569 : 					HitCount++;

  00188	ff 45 f8	 inc	 DWORD PTR _HitCount$1$[ebp]
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00191	eb 52		 jmp	 SHORT $LN42@SkillChaot
$LN11@SkillChaot:

; 5525 : 						EnableAttack = 1;
; 5526 : 				}
; 5527 : #endif
; 5528 : 				else
; 5529 : 				{
; 5530 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  00193	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 5531 : 
; 5532 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00199	80 7c 10 50 02	 cmp	 BYTE PTR [eax+edx+80], 2
  0019e	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001a1	75 14		 jne	 SHORT $LN14@SkillChaot
  001a3	8b 84 10 30 06
	00 00		 mov	 eax, DWORD PTR [eax+edx+1584]
  001aa	85 c0		 test	 eax, eax
  001ac	78 09		 js	 SHORT $LN14@SkillChaot

; 5533 : 					{
; 5534 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  001ae	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  001b4	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
$LN14@SkillChaot:

; 5535 : 					}
; 5536 : 
; 5537 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  001b7	8b 7d fc	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  001ba	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  001c0	03 c2		 add	 eax, edx
  001c2	50		 push	 eax
  001c3	57		 push	 edi
  001c4	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  001c9	83 c4 08	 add	 esp, 8
  001cc	83 f8 01	 cmp	 eax, 1
  001cf	75 0b		 jne	 SHORT $LN35@SkillChaot
  001d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d7	e9 1a ff ff ff	 jmp	 $LN10@SkillChaot
$LN35@SkillChaot:

; 5567 : 					}
; 5568 : 
; 5569 : 					HitCount++;

  001dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN36@SkillChaot:
  001e2	8b 7d 14	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
$LN42@SkillChaot:
  001e5	8b 45 10	 mov	 eax, DWORD PTR tv478[ebp]
$LN16@SkillChaot:

; 5570 : 				}
; 5571 : 			}
; 5572 : 		}
; 5573 : 
; 5574 : 		count++;

  001e8	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 5575 : 		if(count > MAX_VIEWPORT -1)

  001eb	83 e8 01	 sub	 eax, 1
  001ee	89 45 10	 mov	 DWORD PTR tv478[ebp], eax
  001f1	0f 85 7a fe ff
	ff		 jne	 $LL2@SkillChaot
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5b		 pop	 ebx

; 5576 : 		{
; 5577 : 			break;
; 5578 : 		}
; 5579 : 	}
; 5580 : }

  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c2 10 00	 ret	 16			; 00000010H
?SkillChaoticDesier@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ENDP ; CObjUseSkill::SkillChaoticDesier
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMultiShot@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z
_TEXT	SEGMENT
_lpMagic$GSCopy$1$ = -304				; size = 4
_tObjNum$1$ = -300					; size = 4
_aIndex$GSCopy$1$ = -296				; size = 4
_DuelIndex$1$ = -292					; size = 4
tv813 = -288						; size = 4
_lpObj$1$ = -284					; size = 4
tv812 = -280						; size = 4
tv828 = -276						; size = 4
_vFrustrum2$ = -272					; size = 60
_fSkillFrustrumY$ = -212				; size = 20
_fSkillFrustrumX$ = -192				; size = 20
_vFrustrum$ = -172					; size = 60
_Matrix$ = -112						; size = 48
_p$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_targetpos$ = 16					; size = 1
_aTargetIndex$ = 20					; size = 4
?SkillMultiShot@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z PROC ; CObjUseSkill::SkillMultiShot, COMDAT
; _this$ = ecx

; 5810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00016	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00019	53		 push	 ebx

; 5811 : LPOBJ lpObj = &gObj[aIndex];
; 5812 : 
; 5813 : 	SkillFrustrum3(aIndex,targetpos,6.0f,7.0f,1.0f,0);

  0001a	8b 5d 10	 mov	 ebx, DWORD PTR _targetpos$[ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	83 ec 10	 sub	 esp, 16			; 00000010H
  00022	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _lpMagic$GSCopy$1$[ebp], eax
  00028	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  0002e	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], edx
  00034	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR [esp+12], 0
  0003c	c7 44 24 08 00
	00 80 3f	 mov	 DWORD PTR [esp+8], 1065353216 ; 3f800000H
  00044	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	c7 44 24 04 00
	00 e0 40	 mov	 DWORD PTR [esp+4], 1088421888 ; 40e00000H
  00052	c7 04 24 00 00
	c0 40		 mov	 DWORD PTR [esp], 1086324736 ; 40c00000H
  00059	53		 push	 ebx
  0005a	52		 push	 edx
  0005b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], eax
  00061	e8 00 00 00 00	 call	 ?SkillFrustrum3@CObjUseSkill@@QAEXHEMMMM@Z ; CObjUseSkill::SkillFrustrum3
  00066	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000000422000000000000000000000

; 5814 : 
; 5815 : 	float p[5][3];
; 5816 : 	float Matrix[3][MAX_ARRAY_FRUSTRUM];
; 5817 : 	float vFrustrum[5][3];
; 5818 : 
; 5819 : 	p[4][0] = 0;
; 5820 : 	p[4][1] = 6.0f;
; 5821 : 	p[4][2] = 0;
; 5822 : 
; 5823 : 	p[0][0] = 0;
; 5824 : 	p[0][1] = 0;
; 5825 : 	p[0][2] = 40.0f;
; 5826 : 
; 5827 : 	p[1][0] = 0;
; 5828 : 	p[1][1] = 0;
; 5829 : 	p[1][2] = 20.0f;
; 5830 : 
; 5831 : 	p[2][0] = 0;
; 5832 : 	p[2][1] = 0;
; 5833 : 	p[2][2] = 340.0f;
; 5834 : 
; 5835 : 	p[3][0] = 0;
; 5836 : 	p[3][1] = 0;
; 5837 : 	p[3][2] = 320.0f;
; 5838 : 
; 5839 : 	AngleMatrix((const float *)&p[0],Matrix);

  0006d	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  00070	0f 11 45 c0	 movups	 XMMWORD PTR _p$[ebp], xmm0
  00074	50		 push	 eax
  00075	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000000000000041a0000000000000
  0007c	8d 45 c0	 lea	 eax, DWORD PTR _p$[ebp]
  0007f	0f 11 45 d0	 movups	 XMMWORD PTR _p$[ebp+16], xmm0
  00083	50		 push	 eax
  00084	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@43a00000000000000000000043aa0000
  0008b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+48], 0
  00092	c7 45 f4 00 00
	c0 40		 mov	 DWORD PTR _p$[ebp+52], 1086324736 ; 40c00000H
  00099	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+56], 0
  000a0	0f 11 45 e0	 movups	 XMMWORD PTR _p$[ebp+32], xmm0
  000a4	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix

; 5840 : 	VectorRotate((const float *)&p[4],(const float *)&Matrix[0],(float *)&vFrustrum[0]);

  000a9	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _vFrustrum$[ebp]
  000af	50		 push	 eax
  000b0	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000b3	50		 push	 eax
  000b4	8d 45 f0	 lea	 eax, DWORD PTR _p$[ebp+48]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 5841 : 
; 5842 : 	AngleMatrix((const float *)&p[1],Matrix);

  000bd	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000c0	50		 push	 eax
  000c1	8d 45 cc	 lea	 eax, DWORD PTR _p$[ebp+12]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix

; 5843 : 	VectorRotate((const float *)&p[4],(const float *)&Matrix[0],(float *)&vFrustrum[1]);

  000ca	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _vFrustrum$[ebp+12]
  000d0	50		 push	 eax
  000d1	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000d4	50		 push	 eax
  000d5	8d 45 f0	 lea	 eax, DWORD PTR _p$[ebp+48]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 5844 : 
; 5845 : 	vFrustrum[2][0] = 0;
; 5846 : 	vFrustrum[2][1] = 6.0f;
; 5847 : 	vFrustrum[2][2] = 0;
; 5848 : 
; 5849 : 	AngleMatrix((const float *)&p[2],Matrix);

  000de	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000e1	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _vFrustrum$[ebp+24], 0
  000eb	50		 push	 eax
  000ec	8d 45 d8	 lea	 eax, DWORD PTR _p$[ebp+24]
  000ef	c7 85 70 ff ff
	ff 00 00 c0 40	 mov	 DWORD PTR _vFrustrum$[ebp+28], 1086324736 ; 40c00000H
  000f9	50		 push	 eax
  000fa	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _vFrustrum$[ebp+32], 0
  00104	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix

; 5850 : 	VectorRotate((const float *)&p[4],(const float *)&Matrix[0],(float *)&vFrustrum[3]);

  00109	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _vFrustrum$[ebp+36]
  0010f	50		 push	 eax
  00110	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  00113	50		 push	 eax
  00114	8d 45 f0	 lea	 eax, DWORD PTR _p$[ebp+48]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 5851 : 
; 5852 : 	AngleMatrix((const float *)&p[3],Matrix);

  0011d	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  00120	50		 push	 eax
  00121	8d 45 e4	 lea	 eax, DWORD PTR _p$[ebp+36]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  0012a	83 c4 44	 add	 esp, 68			; 00000044H

; 5853 : 	VectorRotate((const float *)&p[4],(const float *)&Matrix[0],(float *)&vFrustrum[4]);

  0012d	8d 45 84	 lea	 eax, DWORD PTR _vFrustrum$[ebp+48]
  00130	50		 push	 eax
  00131	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  00134	50		 push	 eax
  00135	8d 45 f0	 lea	 eax, DWORD PTR _p$[ebp+48]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 5854 : 
; 5855 : 	p[0][0] = 0;

  0013e	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 5856 : 	p[0][1] = 0;
; 5857 : 	p[0][2] = targetpos*360/255;

  00145	0f b6 c3	 movzx	 eax, bl
  00148	69 c8 68 01 00
	00		 imul	 ecx, eax, 360
  0014e	b8 81 80 80 80	 mov	 eax, -2139062143	; 80808081H
  00153	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+4], 0
  0015a	f7 e9		 imul	 ecx
  0015c	03 d1		 add	 edx, ecx
  0015e	c1 fa 07	 sar	 edx, 7
  00161	8b c2		 mov	 eax, edx
  00163	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00166	03 c2		 add	 eax, edx
  00168	66 0f 6e c0	 movd	 xmm0, eax

; 5858 : 
; 5859 : 	AngleMatrix((const float *)&p[0],Matrix);

  0016c	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  0016f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00172	50		 push	 eax
  00173	8d 45 c0	 lea	 eax, DWORD PTR _p$[ebp]
  00176	50		 push	 eax
  00177	f3 0f 11 45 c8	 movss	 DWORD PTR _p$[ebp+8], xmm0
  0017c	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  00181	83 c4 14	 add	 esp, 20			; 00000014H

; 5860 : 
; 5861 : 	int fSkillFrustrumX[5];
; 5862 : 	int fSkillFrustrumY[5];
; 5863 : 
; 5864 : 	float vFrustrum2[5][3];
; 5865 : 
; 5866 : 	for(int i = 0; i < 5; i++)

  00184	33 ff		 xor	 edi, edi
  00186	33 db		 xor	 ebx, ebx
  00188	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@SkillMulti:

; 5867 : 	{
; 5868 : 		VectorRotate(vFrustrum[i],(const float *)&Matrix[0],vFrustrum2[i]);

  00190	8d b5 f0 fe ff
	ff		 lea	 esi, DWORD PTR _vFrustrum2$[ebp]
  00196	03 f7		 add	 esi, edi
  00198	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  0019b	56		 push	 esi
  0019c	50		 push	 eax
  0019d	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _vFrustrum$[ebp]
  001a3	03 c7		 add	 eax, edi
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 5869 : 
; 5870 : 		fSkillFrustrumX[i] = int(vFrustrum2[i][0]) + lpObj->X;

  001ab	f3 0f 2c 0e	 cvttss2si ecx, DWORD PTR [esi]
  001af	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  001b5	8d 5b 04	 lea	 ebx, DWORD PTR [ebx+4]
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bb	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  001c2	03 c8		 add	 ecx, eax

; 5871 : 		fSkillFrustrumY[i] = int(vFrustrum2[i][1]) + lpObj->Y;

  001c4	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  001cb	89 8c 1d 3c ff
	ff ff		 mov	 DWORD PTR _fSkillFrustrumX$[ebp+ebx-4], ecx
  001d2	f3 0f 2c 8c 3d
	f4 fe ff ff	 cvttss2si ecx, DWORD PTR _vFrustrum2$[ebp+edi+4]
  001db	83 c7 0c	 add	 edi, 12			; 0000000cH
  001de	03 c8		 add	 ecx, eax
  001e0	89 8c 1d 28 ff
	ff ff		 mov	 DWORD PTR _fSkillFrustrumY$[ebp+ebx-4], ecx
  001e7	83 ff 3c	 cmp	 edi, 60			; 0000003cH
  001ea	7c a4		 jl	 SHORT $LL4@SkillMulti

; 5872 : 	}
; 5873 : 
; 5874 : 	int tObjNum;
; 5875 : 	int count = 0;
; 5876 : 	int tmpvar = 0;
; 5877 : 	int DuelIndex = lpObj->m_iDuelUser;

  001ec	8b 96 50 12 00
	00		 mov	 edx, DWORD PTR [esi+4688]
  001f2	8d 8e 4c 0c 00
	00		 lea	 ecx, DWORD PTR [esi+3148]
  001f8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fe	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00203	89 95 dc fe ff
	ff		 mov	 DWORD PTR _DuelIndex$1$[ebp], edx
  00209	89 8d e8 fe ff
	ff		 mov	 DWORD PTR tv812[ebp], ecx
  0020f	c7 85 ec fe ff
	ff 4b 00 00 00	 mov	 DWORD PTR tv828[ebp], 75 ; 0000004bH
  00219	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@SkillMulti:

; 5878 : 	int EnableAttack;
; 5879 : 
; 5880 : 	while ( true )
; 5881 : 	{
; 5882 : 		if(lpObj->VpPlayer2[count].state != 0)

  00220	80 79 fc 00	 cmp	 BYTE PTR [ecx-4], 0
  00224	0f 84 c5 01 00
	00		 je	 $LN8@SkillMulti

; 5883 : 		{
; 5884 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0022a	0f bf 41 fe	 movsx	 eax, WORD PTR [ecx-2]
  0022e	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _tObjNum$1$[ebp], eax

; 5885 : 
; 5886 : 			if(tObjNum >= 0 && gObj[tObjNum].Live)

  00234	85 c0		 test	 eax, eax
  00236	0f 88 ad 01 00
	00		 js	 $LN49@SkillMulti
  0023c	69 d8 40 27 00
	00		 imul	 ebx, eax, 10048
  00242	80 7c 3b 51 00	 cmp	 BYTE PTR [ebx+edi+81], 0
  00247	0f 84 9c 01 00
	00		 je	 $LN49@SkillMulti

; 5887 : 			{
; 5888 : 				EnableAttack = 0;
; 5889 : 
; 5890 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0024d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0024f	80 f9 02	 cmp	 cl, 2
  00252	75 0e		 jne	 SHORT $LN12@SkillMulti
  00254	83 bc 3b 30 06
	00 00 00	 cmp	 DWORD PTR [ebx+edi+1584], 0
  0025c	0f 8c 81 00 00
	00		 jl	 $LN16@SkillMulti
$LN12@SkillMulti:

; 5891 : 				{
; 5892 : 					EnableAttack = 1;
; 5893 : 				}
; 5894 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00262	3b 45 14	 cmp	 eax, DWORD PTR _aTargetIndex$[ebp]
  00265	74 7c		 je	 SHORT $LN16@SkillMulti
  00267	3b d0		 cmp	 edx, eax
  00269	74 78		 je	 SHORT $LN16@SkillMulti

; 5895 : 				{
; 5896 : 					EnableAttack = 1;
; 5897 : 				}
; 5898 : #if (GS_CASTLE == 1)
; 5899 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  0026b	80 f9 03	 cmp	 cl, 3
  0026e	74 34		 je	 SHORT $LN17@SkillMulti
  00270	80 bc 3b 23 01
	00 00 1e	 cmp	 BYTE PTR [ebx+edi+291], 30 ; 0000001eH
  00278	75 2a		 jne	 SHORT $LN17@SkillMulti
  0027a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0027f	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 5900 : 				{
; 5901 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  00284	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028a	83 f8 07	 cmp	 eax, 7
  0028d	75 15		 jne	 SHORT $LN17@SkillMulti
  0028f	8a 86 5a 20 00
	00		 mov	 al, BYTE PTR [esi+8282]
  00295	3a 84 3b 5a 20
	00 00		 cmp	 al, BYTE PTR [ebx+edi+8282]
  0029c	0f 84 3b 01 00
	00		 je	 $LN47@SkillMulti

; 5902 : 						EnableAttack = 1;
; 5903 : 				}
; 5904 : #endif
; 5905 : 				else

  002a2	eb 3f		 jmp	 SHORT $LN16@SkillMulti
$LN17@SkillMulti:

; 5906 : 				{
; 5907 : 					int CallMonIndex = gObj[tObjNum].m_Index;
; 5908 : 
; 5909 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  002a4	80 7c 3b 50 02	 cmp	 BYTE PTR [ebx+edi+80], 2
  002a9	8b 0c 3b	 mov	 ecx, DWORD PTR [ebx+edi]
  002ac	75 14		 jne	 SHORT $LN20@SkillMulti
  002ae	8b 84 3b 30 06
	00 00		 mov	 eax, DWORD PTR [ebx+edi+1584]
  002b5	85 c0		 test	 eax, eax
  002b7	78 09		 js	 SHORT $LN20@SkillMulti

; 5910 : 					{
; 5911 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  002b9	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  002bf	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
$LN20@SkillMulti:

; 5912 : 					}
; 5913 : 
; 5914 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  002c2	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  002c8	03 c7		 add	 eax, edi
  002ca	50		 push	 eax
  002cb	56		 push	 esi
  002cc	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  002d1	83 c4 08	 add	 esp, 8
  002d4	83 f8 01	 cmp	 eax, 1
  002d7	0f 85 fa 00 00
	00		 jne	 $LN45@SkillMulti
  002dd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN16@SkillMulti:

; 5915 : 					{
; 5916 : 						EnableAttack = 1;
; 5917 : 					}
; 5918 : 				}
; 5919 : 
; 5920 : 				if( EnableAttack != FALSE )
; 5921 : 				{
; 5922 : 					if( SkillTestFrustrum(gObj[tObjNum].X,gObj[tObjNum].Y,aIndex) )

  002e3	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  002e9	0f b6 84 3b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+edi+289]
  002f1	50		 push	 eax
  002f2	0f b6 84 3b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+edi+288]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 ?SkillTestFrustrum@@YAHHHH@Z ; SkillTestFrustrum
  00300	83 c4 0c	 add	 esp, 12			; 0000000cH
  00303	85 c0		 test	 eax, eax
  00305	0f 84 cc 00 00
	00		 je	 $LN45@SkillMulti

; 5923 : 					{
; 5924 : 						for(int i = 0; i < 5; i++)

  0030b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00311	33 c0		 xor	 eax, eax
  00313	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv813[ebp], eax
  00319	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@SkillMulti:

; 5925 : 						{
; 5926 : 							float Dis = (fSkillFrustrumY[i] - lpObj->Y)*(gObj[tObjNum].Y - lpObj->Y) - (fSkillFrustrumX[i] - lpObj->X)*(gObj[tObjNum].X - lpObj->X);

  00320	0f b6 96 21 01
	00 00		 movzx	 edx, BYTE PTR [esi+289]
  00327	0f b6 8e 20 01
	00 00		 movzx	 ecx, BYTE PTR [esi+288]
  0032e	8b 84 05 40 ff
	ff ff		 mov	 eax, DWORD PTR _fSkillFrustrumX$[ebp+eax]
  00335	0f b6 b4 3b 20
	01 00 00	 movzx	 esi, BYTE PTR [ebx+edi+288]
  0033d	2b c1		 sub	 eax, ecx
  0033f	2b f1		 sub	 esi, ecx
  00341	0f b6 8c 3b 21
	01 00 00	 movzx	 ecx, BYTE PTR [ebx+edi+289]
  00349	0f af f0	 imul	 esi, eax
  0034c	2b ca		 sub	 ecx, edx
  0034e	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv813[ebp]
  00354	8b 84 05 2c ff
	ff ff		 mov	 eax, DWORD PTR _fSkillFrustrumY$[ebp+eax]
  0035b	2b c2		 sub	 eax, edx
  0035d	0f af c8	 imul	 ecx, eax
  00360	2b ce		 sub	 ecx, esi
  00362	66 0f 6e c1	 movd	 xmm0, ecx
  00366	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 5927 : 						
; 5928 : 							if( (Dis >= -5 && Dis <= 5) || tObjNum == aTargetIndex )

  00369	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@c0a00000
  00370	72 0d		 jb	 SHORT $LN26@SkillMulti
  00372	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40a00000
  0037a	0f 2f c8	 comiss	 xmm1, xmm0
  0037d	73 0b		 jae	 SHORT $LN25@SkillMulti
$LN26@SkillMulti:
  0037f	8b 45 14	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00382	39 85 d4 fe ff
	ff		 cmp	 DWORD PTR _tObjNum$1$[ebp], eax
  00388	75 2d		 jne	 SHORT $LN46@SkillMulti
$LN25@SkillMulti:

; 5929 : 							{
; 5930 : 								gObjAttack(lpObj,&gObj[tObjNum],lpMagic,TRUE,0,0,0,0,0);

  0038a	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  00390	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  00393	6a 00		 push	 0
  00395	6a 00		 push	 0
  00397	6a 00		 push	 0
  00399	6a 00		 push	 0
  0039b	6a 00		 push	 0
  0039d	6a 01		 push	 1
  0039f	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _lpMagic$GSCopy$1$[ebp]
  003a5	50		 push	 eax
  003a6	56		 push	 esi
  003a7	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  003ac	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b2	83 c4 24	 add	 esp, 36			; 00000024H
  003b5	eb 06		 jmp	 SHORT $LN7@SkillMulti
$LN46@SkillMulti:
  003b7	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
$LN7@SkillMulti:
  003bd	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv813[ebp]
  003c3	83 c0 04	 add	 eax, 4
  003c6	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv813[ebp], eax

; 5923 : 					{
; 5924 : 						for(int i = 0; i < 5; i++)

  003cc	83 f8 14	 cmp	 eax, 20			; 00000014H
  003cf	0f 8c 4b ff ff
	ff		 jl	 $LL9@SkillMulti
  003d5	eb 06		 jmp	 SHORT $LN47@SkillMulti
$LN45@SkillMulti:
  003d7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN47@SkillMulti:
  003dd	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv812[ebp]
  003e3	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _DuelIndex$1$[ebp]
$LN49@SkillMulti:
  003e9	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv828[ebp]
$LN8@SkillMulti:

; 5931 : 							}
; 5932 : 						}
; 5933 : 					}
; 5934 : 				}
; 5935 : 			}
; 5936 : 		}
; 5937 : 
; 5938 : 		count++;

  003ef	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 5939 : 
; 5940 : 		if( count > (MAX_VIEWPORT-1) )

  003f2	83 e8 01	 sub	 eax, 1
  003f5	89 8d e8 fe ff
	ff		 mov	 DWORD PTR tv812[ebp], ecx
  003fb	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv828[ebp], eax
  00401	0f 85 19 fe ff
	ff		 jne	 $LL5@SkillMulti

; 5941 : 		{
; 5942 : 			break;
; 5943 : 		}
; 5944 : 	}
; 5945 : }

  00407	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040a	5f		 pop	 edi
  0040b	5e		 pop	 esi
  0040c	33 cd		 xor	 ecx, ebp
  0040e	5b		 pop	 ebx
  0040f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00414	8b e5		 mov	 esp, ebp
  00416	5d		 pop	 ebp
  00417	c2 10 00	 ret	 16			; 00000010H
?SkillMultiShot@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ENDP ; CObjUseSkill::SkillMultiShot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillGiganticStorm@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_aTargetIndex$ = 24					; size = 4
?SkillGiganticStorm@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z PROC ; CObjUseSkill::SkillGiganticStorm, COMDAT
; _this$ = ecx

; 5485 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5486 : 	SkillAreaMonsterAttack(aIndex,lpMagic,x,y,aTargetIndex,6,1,400);

  00003	68 90 01 00 00	 push	 400			; 00000190H
  00008	6a 01		 push	 1
  0000a	6a 06		 push	 6
  0000c	ff 75 18	 push	 DWORD PTR _aTargetIndex$[ebp]
  0000f	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00012	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00015	ff 75 0c	 push	 DWORD PTR _lpMagic$[ebp]
  00018	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0001b	e8 00 00 00 00	 call	 ?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z ; CObjUseSkill::SkillAreaMonsterAttack

; 5487 : }

  00020	5d		 pop	 ebp
  00021	c2 14 00	 ret	 20			; 00000014H
?SkillGiganticStorm@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z ENDP ; CObjUseSkill::SkillGiganticStorm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillFlameStrike@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -12					; size = 4
tv469 = -8						; size = 4
_lpObj$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_HitCount$1$ = 16					; size = 4
_targetangle$ = 16					; size = 1
_aTargetIndex$ = 20					; size = 4
?SkillFlameStrike@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z PROC ; CObjUseSkill::SkillFlameStrike, COMDAT
; _this$ = ecx

; 5391 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 5392 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 5393 : 	int bSuccess = TRUE;
; 5394 : 	int tObjNum;
; 5395 : 
; 5396 : 	SkillFrustrum3(aIndex,targetangle,2.0f,4.0f,5.0f,0);

  0000c	83 ec 10	 sub	 esp, 16			; 00000010H
  0000f	69 d8 40 27 00
	00		 imul	 ebx, eax, 10048
  00015	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR [esp+12], 0
  0001d	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	c7 44 24 08 00
	00 a0 40	 mov	 DWORD PTR [esp+8], 1084227584 ; 40a00000H
  0002b	c7 44 24 04 00
	00 80 40	 mov	 DWORD PTR [esp+4], 1082130432 ; 40800000H
  00033	c7 04 24 00 00
	00 40		 mov	 DWORD PTR [esp], 1073741824 ; 40000000H
  0003a	ff 75 10	 push	 DWORD PTR _targetangle$[ebp]
  0003d	89 5d fc	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?SkillFrustrum3@CObjUseSkill@@QAEXHEMMMM@Z ; CObjUseSkill::SkillFrustrum3

; 5397 : 
; 5398 : 	int count = 0;
; 5399 : 	int HitCount = 0;
; 5400 : 	int bAttack;
; 5401 : 	int DuelIndex = lpObj->m_iDuelUser;

  00046	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  0004c	8d bb 4c 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3148]
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _HitCount$1$[ebp], 0
  0005f	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00062	c7 45 f8 4b 00
	00 00		 mov	 DWORD PTR tv469[ebp], 75 ; 0000004bH
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@SkillFlame:

; 5402 : 	int EnableAttack;
; 5403 : 
; 5404 : 	while ( true )
; 5405 : 	{
; 5406 : 		if(lpObj->VpPlayer2[count].state != 0)

  00070	80 7f fc 00	 cmp	 BYTE PTR [edi-4], 0
  00074	0f 84 4c 01 00
	00		 je	 $LN17@SkillFlame

; 5407 : 		{
; 5408 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007a	0f bf 77 fe	 movsx	 esi, WORD PTR [edi-2]

; 5409 : 
; 5410 : 			if(tObjNum >= 0)

  0007e	85 f6		 test	 esi, esi
  00080	0f 88 40 01 00
	00		 js	 $LN17@SkillFlame

; 5411 : 			{
; 5412 : 				EnableAttack = 0;
; 5413 : 
; 5414 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00086	8a 17		 mov	 dl, BYTE PTR [edi]
  00088	80 fa 02	 cmp	 dl, 2
  0008b	75 14		 jne	 SHORT $LN6@SkillFlame
  0008d	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00093	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0009b	0f 8c 9f 00 00
	00		 jl	 $LN10@SkillFlame
$LN6@SkillFlame:

; 5415 : 				{
; 5416 : 					EnableAttack = 1;
; 5417 : 				}
; 5418 : 				else if( tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000a1	3b 75 14	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  000a4	0f 84 96 00 00
	00		 je	 $LN10@SkillFlame
  000aa	39 75 f4	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000ad	0f 84 8d 00 00
	00		 je	 $LN10@SkillFlame

; 5419 : 				{
; 5420 : 					EnableAttack = 1;
; 5421 : 				}
; 5422 : #if (GS_CASTLE == 1)
; 5423 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000b3	80 fa 03	 cmp	 dl, 3
  000b6	74 43		 je	 SHORT $LN11@SkillFlame
  000b8	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  000be	80 bc 0b 23 01
	00 00 1e	 cmp	 BYTE PTR [ebx+ecx+291], 30 ; 0000001eH
  000c6	75 30		 jne	 SHORT $LN34@SkillFlame
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000cd	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 5424 : 				{
; 5425 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d8	83 f8 07	 cmp	 eax, 7
  000db	75 1b		 jne	 SHORT $LN34@SkillFlame
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000e0	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  000e6	3a 84 0b 5a 20
	00 00		 cmp	 al, BYTE PTR [ebx+ecx+8282]
  000ed	0f 84 d3 00 00
	00		 je	 $LN17@SkillFlame

; 5426 : 						EnableAttack = 1;
; 5427 : 				}
; 5428 : #endif
; 5429 : 				else

  000f3	8b 5d fc	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  000f6	eb 48		 jmp	 SHORT $LN10@SkillFlame
$LN34@SkillFlame:
  000f8	8b 5d fc	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
$LN11@SkillFlame:

; 5430 : 				{
; 5431 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000fb	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 5432 : 
; 5433 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00101	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00106	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00109	75 14		 jne	 SHORT $LN14@SkillFlame
  0010b	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  00112	85 c0		 test	 eax, eax
  00114	78 09		 js	 SHORT $LN14@SkillFlame

; 5434 : 					{
; 5435 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00116	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0011c	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN14@SkillFlame:

; 5436 : 					}
; 5437 : 
; 5438 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  0011f	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00125	03 c1		 add	 eax, ecx
  00127	50		 push	 eax
  00128	53		 push	 ebx
  00129	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0012e	83 c4 08	 add	 esp, 8
  00131	83 f8 01	 cmp	 eax, 1
  00134	0f 85 86 00 00
	00		 jne	 $LN33@SkillFlame
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillFlame:

; 5439 : 					{
; 5440 : 						EnableAttack = 1;
; 5441 : 					}
; 5442 : 				}
; 5443 : 
; 5444 : 				if(EnableAttack != 0)
; 5445 : 				{
; 5446 : 					if( SkillTestFrustrum(gObj[tObjNum].X,gObj[tObjNum].Y,aIndex) )

  00140	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00143	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  00149	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  00151	50		 push	 eax
  00152	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ?SkillTestFrustrum@@YAHHHH@Z ; SkillTestFrustrum
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
  00163	85 c0		 test	 eax, eax
  00165	74 59		 je	 SHORT $LN33@SkillFlame

; 5447 : 					{
; 5448 : 						bAttack = FALSE;
; 5449 : 
; 5450 : 						if(HitCount > 8)

  00167	83 7d 10 08	 cmp	 DWORD PTR _HitCount$1$[ebp], 8
  0016b	7e 13		 jle	 SHORT $LN18@SkillFlame

; 5451 : 						{
; 5452 : 							if( rand()%2 )

  0016d	e8 00 00 00 00	 call	 _rand
  00172	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00177	79 05		 jns	 SHORT $LN35@SkillFlame
  00179	48		 dec	 eax
  0017a	83 c8 fe	 or	 eax, -2			; fffffffeH
  0017d	40		 inc	 eax
$LN35@SkillFlame:
  0017e	74 3d		 je	 SHORT $LN21@SkillFlame
$LN18@SkillFlame:

; 5453 : 							{
; 5454 : 								bAttack = TRUE;
; 5455 : 							}
; 5456 : 						}
; 5457 : 						else
; 5458 : 						{
; 5459 : 							bAttack = TRUE;
; 5460 : 						}
; 5461 : 
; 5462 : 						if(bAttack != FALSE)
; 5463 : 						{
; 5464 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,TRUE,0,0,0,0,0);

  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00185	6a 00		 push	 0
  00187	6a 00		 push	 0
  00189	6a 00		 push	 0
  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	6a 01		 push	 1
  00191	ff 75 0c	 push	 DWORD PTR _lpMagic$[ebp]
  00194	03 c6		 add	 eax, esi
  00196	50		 push	 eax
  00197	53		 push	 ebx
  00198	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack

; 5465 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,TRUE,0,0,0,0,0);

  0019d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	6a 00		 push	 0
  001a8	6a 00		 push	 0
  001aa	6a 00		 push	 0
  001ac	6a 01		 push	 1
  001ae	ff 75 0c	 push	 DWORD PTR _lpMagic$[ebp]
  001b1	03 c6		 add	 eax, esi
  001b3	50		 push	 eax
  001b4	53		 push	 ebx
  001b5	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  001ba	83 c4 48	 add	 esp, 72			; 00000048H
$LN21@SkillFlame:

; 5466 : 						}
; 5467 : 
; 5468 : 						HitCount++;

  001bd	ff 45 10	 inc	 DWORD PTR _HitCount$1$[ebp]
$LN33@SkillFlame:
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN17@SkillFlame:

; 5469 : 					}
; 5470 : 				}
; 5471 : 			}
; 5472 : 		}
; 5473 : 
; 5474 : 		count++;
; 5475 : 		if(count > MAX_VIEWPORT -1)

  001c6	8b 5d fc	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  001c9	83 c7 0c	 add	 edi, 12			; 0000000cH
  001cc	83 6d f8 01	 sub	 DWORD PTR tv469[ebp], 1
  001d0	0f 85 9a fe ff
	ff		 jne	 $LL2@SkillFlame
  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx

; 5476 : 		{
; 5477 : 			break;
; 5478 : 		}
; 5479 : 	}
; 5480 : 
; 5481 : }

  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c2 10 00	 ret	 16			; 00000010H
?SkillFlameStrike@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ENDP ; CObjUseSkill::SkillFlameStrike
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillLightShock@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -16					; size = 4
_HitCount$1$ = -12					; size = 4
_bAttack$1$ = -8					; size = 4
tv498 = -4						; size = 4
tv503 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillLightShock@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillLightShock, COMDAT
; _this$ = ecx

; 5286 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 5287 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048

; 5288 : 	int tmpvar = 0;
; 5289 : 	int bAttack = 0;

  0000e	33 c0		 xor	 eax, eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 45 f8	 mov	 DWORD PTR _bAttack$1$[ebp], eax

; 5290 : 	int tObjNum;
; 5291 : 	int count = 0;
; 5292 : 	int tmpvar2 = 0;
; 5293 : 	int tmpvar3 = 7;
; 5294 : 	int HitCount = 0;

  00015	33 c9		 xor	 ecx, ecx

; 5295 : 
; 5296 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00017	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0001a	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	6a 01		 push	 1
  00022	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00025	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00029	50		 push	 eax
  0002a	53		 push	 ebx
  0002b	89 4d f4	 mov	 DWORD PTR _HitCount$1$[ebp], ecx
  0002e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 5297 : 
; 5298 : 	int EnableAttack;
; 5299 : 	int bForceAttack = TRUE;
; 5300 : 	int DuelIndex = lpObj->m_iDuelUser;

  00033	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00039	8d bb 4c 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3148]
  0003f	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00044	89 45 f0	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	89 4d fc	 mov	 DWORD PTR tv498[ebp], ecx
  0004d	0f 1f 00	 npad	 3
$LL2@SkillLight:

; 5301 : 
; 5302 : 	while ( true )
; 5303 : 	{
; 5304 : 		if(lpObj->VpPlayer2[count].state != 0)

  00050	80 7f fc 00	 cmp	 BYTE PTR [edi-4], 0
  00054	0f 84 6d 01 00
	00		 je	 $LN45@SkillLight

; 5305 : 		{
; 5306 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0005a	0f bf 77 fe	 movsx	 esi, WORD PTR [edi-2]

; 5307 : 
; 5308 : 			if(tObjNum >= 0 && gObj[tObjNum].Live )

  0005e	85 f6		 test	 esi, esi
  00060	0f 88 61 01 00
	00		 js	 $LN45@SkillLight
  00066	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  0006c	89 55 08	 mov	 DWORD PTR tv503[ebp], edx
  0006f	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00075	80 7a 51 00	 cmp	 BYTE PTR [edx+81], 0
  00079	0f 84 48 01 00
	00		 je	 $LN45@SkillLight

; 5309 : 			{
; 5310 : 				EnableAttack = 0;
; 5311 : 
; 5312 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0007f	8a 2f		 mov	 ch, BYTE PTR [edi]
  00081	80 fd 02	 cmp	 ch, 2
  00084	75 0d		 jne	 SHORT $LN6@SkillLight
  00086	83 ba 30 06 00
	00 00		 cmp	 DWORD PTR [edx+1584], 0
  0008d	0f 8c c1 00 00
	00		 jl	 $LN51@SkillLight
$LN6@SkillLight:

; 5313 : 				{
; 5314 : 					EnableAttack = 1;
; 5315 : 				}
; 5316 : 				else if( CC_MAP_RANGE( lpObj->MapNumber ) || IT_MAP_RANGE( lpObj->MapNumber ) 

  00093	8a 8b 23 01 00
	00		 mov	 cl, BYTE PTR [ebx+291]
  00099	80 f9 35	 cmp	 cl, 53			; 00000035H
  0009c	0f 84 b2 00 00
	00		 je	 $LN51@SkillLight
  000a2	80 f9 12	 cmp	 cl, 18			; 00000012H
  000a5	72 0f		 jb	 SHORT $LN42@SkillLight
  000a7	b0 17		 mov	 al, 23			; 00000017H
  000a9	3a c1		 cmp	 al, cl
  000ab	1b c0		 sbb	 eax, eax
  000ad	83 c0 01	 add	 eax, 1
  000b0	0f 85 9e 00 00
	00		 jne	 $LN51@SkillLight
$LN42@SkillLight:
  000b6	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000b9	72 0f		 jb	 SHORT $LN43@SkillLight
  000bb	b0 32		 mov	 al, 50			; 00000032H
  000bd	3a c1		 cmp	 al, cl
  000bf	1b c0		 sbb	 eax, eax
  000c1	83 c0 01	 add	 eax, 1
  000c4	0f 85 8a 00 00
	00		 jne	 $LN51@SkillLight
$LN43@SkillLight:

; 5317 : //					|| lpObj->MapNumber == MAP_INDEX_VULCANUS
; 5318 : 					)
; 5319 : 				{
; 5320 : 					EnableAttack = 1;
; 5321 : 				}
; 5322 : 				else if( (tObjNum == aTargetIndex && bForceAttack == TRUE ) || DuelIndex == tObjNum)

  000ca	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  000cd	0f 84 81 00 00
	00		 je	 $LN51@SkillLight
  000d3	39 75 f0	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000d6	74 7c		 je	 SHORT $LN51@SkillLight

; 5323 : 				{
; 5324 : 					EnableAttack = 1;
; 5325 : 				}
; 5326 : #if (GS_CASTLE == 1)
; 5327 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000d8	80 fd 03	 cmp	 ch, 3
  000db	74 35		 je	 SHORT $LN44@SkillLight
  000dd	80 ba 23 01 00
	00 1e		 cmp	 BYTE PTR [edx+291], 30	; 0000001eH
  000e4	75 2c		 jne	 SHORT $LN44@SkillLight
  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000eb	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  000f0	83 f8 07	 cmp	 eax, 7
  000f3	75 1d		 jne	 SHORT $LN44@SkillLight

; 5328 : 				{
; 5329 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fa	8b 55 08	 mov	 edx, DWORD PTR tv503[ebp]
  000fd	8a 8b 5a 20 00
	00		 mov	 cl, BYTE PTR [ebx+8282]
  00103	3a 8c 02 5a 20
	00 00		 cmp	 cl, BYTE PTR [edx+eax+8282]
  0010a	0f 84 b4 00 00
	00		 je	 $LN56@SkillLight

; 5330 : 						EnableAttack = 1;
; 5331 : 				}
; 5332 : #endif
; 5333 : 				else

  00110	eb 45		 jmp	 SHORT $LN10@SkillLight
$LN44@SkillLight:

; 5334 : 				{
; 5335 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	8b 55 08	 mov	 edx, DWORD PTR tv503[ebp]

; 5336 : 
; 5337 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0011b	80 7c 0a 50 02	 cmp	 BYTE PTR [edx+ecx+80], 2
  00120	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00123	75 14		 jne	 SHORT $LN18@SkillLight
  00125	8b 94 0a 30 06
	00 00		 mov	 edx, DWORD PTR [edx+ecx+1584]
  0012c	85 d2		 test	 edx, edx
  0012e	78 09		 js	 SHORT $LN18@SkillLight

; 5338 : 					{
; 5339 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00130	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00136	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
$LN18@SkillLight:

; 5340 : 					}
; 5341 : 
; 5342 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00139	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0013f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00145	50		 push	 eax
  00146	53		 push	 ebx
  00147	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0014c	83 c4 08	 add	 esp, 8
  0014f	83 f8 01	 cmp	 eax, 1
  00152	75 70		 jne	 SHORT $LN56@SkillLight
$LN51@SkillLight:
  00154	8b 55 08	 mov	 edx, DWORD PTR tv503[ebp]
$LN10@SkillLight:

; 5343 : 					{
; 5344 : 						EnableAttack = 1;
; 5345 : 					}
; 5346 : 				}
; 5347 : 
; 5348 : 				if(EnableAttack != 0)
; 5349 : 				{
; 5350 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 7)

  00157	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015c	03 c2		 add	 eax, edx
  0015e	50		 push	 eax
  0015f	53		 push	 ebx
  00160	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00165	83 c4 08	 add	 esp, 8
  00168	83 f8 07	 cmp	 eax, 7
  0016b	7d 57		 jge	 SHORT $LN56@SkillLight

; 5351 : 					{
; 5352 : 						HitCount++;

  0016d	8b 45 f4	 mov	 eax, DWORD PTR _HitCount$1$[ebp]
  00170	40		 inc	 eax
  00171	89 45 f4	 mov	 DWORD PTR _HitCount$1$[ebp], eax

; 5353 : 
; 5354 : 						if(HitCount > 5)

  00174	83 f8 05	 cmp	 eax, 5
  00177	7e 13		 jle	 SHORT $LN22@SkillLight

; 5355 : 						{
; 5356 : 							if( rand()%2 )

  00179	e8 00 00 00 00	 call	 _rand
  0017e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00183	79 05		 jns	 SHORT $LN57@SkillLight
  00185	48		 dec	 eax
  00186	83 c8 fe	 or	 eax, -2			; fffffffeH
  00189	40		 inc	 eax
$LN57@SkillLight:
  0018a	74 0a		 je	 SHORT $LN52@SkillLight
$LN22@SkillLight:

; 5357 : 							{
; 5358 : 								bAttack = TRUE;

  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	89 45 f8	 mov	 DWORD PTR _bAttack$1$[ebp], eax

; 5359 : 							}
; 5360 : 						}
; 5361 : 						else

  00194	eb 03		 jmp	 SHORT $LN23@SkillLight
$LN52@SkillLight:
  00196	8b 45 f8	 mov	 eax, DWORD PTR _bAttack$1$[ebp]
$LN23@SkillLight:

; 5362 : 						{
; 5363 : 							bAttack = TRUE;
; 5364 : 						}
; 5365 : 
; 5366 : 						if(HitCount > 12)

  00199	83 7d f4 0c	 cmp	 DWORD PTR _HitCount$1$[ebp], 12 ; 0000000cH
  0019d	7e 07		 jle	 SHORT $LN25@SkillLight

; 5367 : 						{
; 5368 : 							bAttack = FALSE;

  0019f	33 c0		 xor	 eax, eax
  001a1	89 45 f8	 mov	 DWORD PTR _bAttack$1$[ebp], eax

; 5369 : 						}
; 5370 : 
; 5371 : 						if(bAttack == TRUE)

  001a4	eb 1e		 jmp	 SHORT $LN56@SkillLight
$LN25@SkillLight:
  001a6	83 f8 01	 cmp	 eax, 1
  001a9	75 19		 jne	 SHORT $LN56@SkillLight

; 5372 : 						{
; 5373 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,250,lpMagic->m_Skill,0);

  001ab	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001ae	6a 00		 push	 0
  001b0	ff 70 08	 push	 DWORD PTR [eax+8]
  001b3	68 fa 00 00 00	 push	 250			; 000000faH
  001b8	56		 push	 esi
  001b9	6a 32		 push	 50			; 00000032H
  001bb	53		 push	 ebx
  001bc	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  001c1	83 c4 18	 add	 esp, 24			; 00000018H
$LN56@SkillLight:
  001c4	8b 4d fc	 mov	 ecx, DWORD PTR tv498[ebp]
$LN45@SkillLight:

; 5374 : 						}
; 5375 : 					}
; 5376 : 				}
; 5377 : 			}
; 5378 : 		}
; 5379 : 
; 5380 : 		count++;

  001c7	83 c7 0c	 add	 edi, 12			; 0000000cH

; 5381 : 		if(count > MAX_VIEWPORT -1)

  001ca	83 e9 01	 sub	 ecx, 1
  001cd	89 4d fc	 mov	 DWORD PTR tv498[ebp], ecx
  001d0	0f 85 7a fe ff
	ff		 jne	 $LL2@SkillLight

; 5382 : 		{
; 5383 : 			break;
; 5384 : 		}
; 5385 : 	}
; 5386 : return TRUE;

  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	b8 01 00 00 00	 mov	 eax, 1
  001dd	5b		 pop	 ebx

; 5387 : }

  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c2 0c 00	 ret	 12			; 0000000cH
?SkillLightShock@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillLightShock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDestruct@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_X$ = 16						; size = 1
_Y$ = 20						; size = 1
_aTargetIndex$ = 24					; size = 4
?SkillDestruct@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z PROC ; CObjUseSkill::SkillDestruct, COMDAT
; _this$ = ecx

; 5241 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5242 : 	SkillAreaMonsterAttack(aIndex,lpMagic,X,Y,aTargetIndex,3,1,500);

  00003	68 f4 01 00 00	 push	 500			; 000001f4H
  00008	6a 01		 push	 1
  0000a	6a 03		 push	 3
  0000c	ff 75 18	 push	 DWORD PTR _aTargetIndex$[ebp]
  0000f	ff 75 14	 push	 DWORD PTR _Y$[ebp]
  00012	ff 75 10	 push	 DWORD PTR _X$[ebp]
  00015	ff 75 0c	 push	 DWORD PTR _lpMagic$[ebp]
  00018	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0001b	e8 00 00 00 00	 call	 ?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z ; CObjUseSkill::SkillAreaMonsterAttack

; 5243 : }

  00020	5d		 pop	 ebp
  00021	c2 14 00	 ret	 20			; 00000014H
?SkillDestruct@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z ENDP ; CObjUseSkill::SkillDestruct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillExpWizard@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillExpWizard@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillExpWizard, COMDAT
; _this$ = ecx

; 5246 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 5247 : 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0000e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 5248 : 
; 5249 : 	if( lpObj->Type != OBJ_USER )

  00014	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00018	74 08		 je	 SHORT $LN2@SkillExpWi
$LN10@SkillExpWi:
  0001a	5f		 pop	 edi

; 5250 : 	{
; 5251 : 		return false;

  0001b	33 c0		 xor	 eax, eax
  0001d	5e		 pop	 esi

; 5283 : }

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillExpWi:

; 5252 : 	}
; 5253 : 
; 5254 : 	if( lpObj->Class != CLASS_WIZARD )

  00022	66 83 be 90 00
	00 00 00	 cmp	 WORD PTR [esi+144], 0
  0002a	75 ee		 jne	 SHORT $LN10@SkillExpWi

; 5255 : 	{
; 5256 : 		return false;
; 5257 : 	}
; 5258 : 
; 5259 : 	if( gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY) == TRUE ||
; 5260 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY2) == TRUE ||

  0002c	6a 52		 push	 82			; 00000052H
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00034	83 c4 08	 add	 esp, 8
  00037	3c 01		 cmp	 al, 1
  00039	74 df		 je	 SHORT $LN10@SkillExpWi
  0003b	68 8a 00 00 00	 push	 138			; 0000008aH
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00046	83 c4 08	 add	 esp, 8
  00049	3c 01		 cmp	 al, 1
  0004b	74 cd		 je	 SHORT $LN10@SkillExpWi
  0004d	68 8b 00 00 00	 push	 139			; 0000008bH
  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00058	83 c4 08	 add	 esp, 8
  0005b	3c 01		 cmp	 al, 1
  0005d	74 bb		 je	 SHORT $LN10@SkillExpWi

; 5261 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY3) == TRUE )
; 5262 : 	{
; 5263 : 		return false;
; 5264 : 	}
; 5265 : 
; 5266 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  0005f	53		 push	 ebx
  00060	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00063	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  00068	ff 73 08	 push	 DWORD PTR [ebx+8]
  0006b	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  00070	8b c8		 mov	 ecx, eax

; 5267 : 
; 5268 : 	if( !lpInfo )

  00072	85 c9		 test	 ecx, ecx
  00074	75 07		 jne	 SHORT $LN6@SkillExpWi
  00076	5b		 pop	 ebx
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi

; 5283 : }

  00079	5d		 pop	 ebp
  0007a	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillExpWi:

; 5269 : 	{
; 5270 : 		return 0;
; 5271 : 	}
; 5272 : 
; 5273 : 	int AddMinDmg = (lpObj->Energy/lpInfo->m_Arg1)*lpInfo->m_Arg2;

  0007d	0f b7 86 d6 00
	00 00		 movzx	 eax, WORD PTR [esi+214]

; 5274 : 
; 5275 : 	if( AddMinDmg > lpInfo->m_Arg3 )

  00084	f3 0f 10 49 0c	 movss	 xmm1, DWORD PTR [ecx+12]
  00089	66 0f 6e c0	 movd	 xmm0, eax
  0008d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00090	f3 0f 5e 41 04	 divss	 xmm0, DWORD PTR [ecx+4]
  00095	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  0009a	f3 0f 2c d0	 cvttss2si edx, xmm0
  0009e	66 0f 6e c2	 movd	 xmm0, edx
  000a2	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a5	0f 2f c1	 comiss	 xmm0, xmm1
  000a8	76 04		 jbe	 SHORT $LN7@SkillExpWi

; 5276 : 	{
; 5277 : 		AddMinDmg = lpInfo->m_Arg3;

  000aa	f3 0f 2c d1	 cvttss2si edx, xmm1
$LN7@SkillExpWi:

; 5278 : 	}
; 5279 : 
; 5280 : 	gObjAddBuffEffect(lpObj,BUFF_EXP_WIZARDRY,ADD_OPTION_MAGICDAMAGEMIN,AddMinDmg,0,0,lpInfo->m_Arg4);

  000ae	f3 0f 2c 41 10	 cvttss2si eax, DWORD PTR [ecx+16]
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	6a 00		 push	 0
  000b8	52		 push	 edx
  000b9	6a 21		 push	 33			; 00000021H
  000bb	6a 52		 push	 82			; 00000052H
  000bd	56		 push	 esi
  000be	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 5281 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aIndex,TRUE);

  000c3	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  000c7	6a 01		 push	 1
  000c9	57		 push	 edi
  000ca	50		 push	 eax
  000cb	56		 push	 esi
  000cc	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000d1	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5282 : 	return true;

  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	5b		 pop	 ebx
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi

; 5283 : }

  000dc	5d		 pop	 ebp
  000dd	c2 0c 00	 ret	 12			; 0000000cH
?SkillExpWizard@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillExpWizard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillRecovery@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv441 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillRecovery@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillRecovery, COMDAT
; _this$ = ecx

; 5182 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5183 : 	int skillSuccess = true;
; 5184 : 	LPOBJ lpObj = &gObj[aIndex];

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  00010	56		 push	 esi

; 5185 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00011	69 75 0c 40 27
	00 00		 imul	 esi, DWORD PTR _aTargetIndex$[ebp], 10048
  00018	03 d8		 add	 ebx, eax
  0001a	03 f0		 add	 esi, eax

; 5186 : 
; 5187 : 	if(lpTargetObj->Type != OBJ_USER && lpTargetObj->m_RecallMon == -1)

  0001c	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00020	74 0d		 je	 SHORT $LN5@SkillRecov
  00022	83 be 30 06 00
	00 ff		 cmp	 DWORD PTR [esi+1584], -1
  00029	0f 84 40 01 00
	00		 je	 $LN3@SkillRecov
$LN5@SkillRecov:

; 5188 : 	{
; 5189 : 		return;
; 5190 : 	}
; 5191 : 
; 5192 : 	if(lpObj->Class != CLASS_ELF)

  0002f	66 83 bb 90 00
	00 00 02	 cmp	 WORD PTR [ebx+144], 2
  00037	0f 85 32 01 00
	00		 jne	 $LN3@SkillRecov

; 5193 : 	{
; 5194 : 		return;
; 5195 : 	}
; 5196 : 
; 5197 : 	if(CC_MAP_RANGE(lpObj->MapNumber) && lpObj->m_Index != lpTargetObj->m_Index)

  0003d	8a 83 23 01 00
	00		 mov	 al, BYTE PTR [ebx+291]
  00043	3c 35		 cmp	 al, 53			; 00000035H
  00045	74 0f		 je	 SHORT $LN23@SkillRecov
  00047	3c 12		 cmp	 al, 18			; 00000012H
  00049	72 15		 jb	 SHORT $LN7@SkillRecov
  0004b	b1 17		 mov	 cl, 23			; 00000017H
  0004d	3a c8		 cmp	 cl, al
  0004f	1b c0		 sbb	 eax, eax
  00051	83 c0 01	 add	 eax, 1
  00054	74 0a		 je	 SHORT $LN7@SkillRecov
$LN23@SkillRecov:
  00056	8b 03		 mov	 eax, DWORD PTR [ebx]
  00058	3b 06		 cmp	 eax, DWORD PTR [esi]
  0005a	0f 85 0f 01 00
	00		 jne	 $LN3@SkillRecov
$LN7@SkillRecov:
  00060	57		 push	 edi

; 5198 : 	{
; 5199 : 		return;
; 5200 : 	}
; 5201 : 
; 5202 : 	if(gObjDuelCheck(lpTargetObj) )

  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDuelCheck
  00067	83 c4 04	 add	 esp, 4
  0006a	85 c0		 test	 eax, eax
  0006c	0f 45 f3	 cmovne	 esi, ebx

; 5203 : 	{
; 5204 : 		lpTargetObj = lpObj;
; 5205 : 	}
; 5206 : 
; 5207 : 	if( lpTargetObj->iShield >= lpTargetObj->iMaxShield+lpTargetObj->iAddShield )

  0006f	8b 96 34 01 00
	00		 mov	 edx, DWORD PTR [esi+308]
  00075	03 96 30 01 00
	00		 add	 edx, DWORD PTR [esi+304]
  0007b	8b be 2c 01 00
	00		 mov	 edi, DWORD PTR [esi+300]
  00081	3b fa		 cmp	 edi, edx
  00083	7c 19		 jl	 SHORT $LN9@SkillRecov

; 5208 : 	{
; 5209 : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_RECOVERY,lpTargetObj->m_Index,FALSE);

  00085	6a 00		 push	 0
  00087	ff 36		 push	 DWORD PTR [esi]
  00089	68 ea 00 00 00	 push	 234			; 000000eaH
  0008e	53		 push	 ebx
  0008f	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00094	83 c4 10	 add	 esp, 16			; 00000010H
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx

; 5234 : 				}
; 5235 : 			}
; 5236 : 		}
; 5237 : 	}
; 5238 : }

  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
$LN9@SkillRecov:

; 5210 : 		return;
; 5211 : 	}
; 5212 : 
; 5213 : 	lpTargetObj->iShield += (lpObj->Energy / 4)+lpObj->Level;

  0009e	0f b7 8b d6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+214]
  000a5	0f bf 83 96 00
	00 00		 movsx	 eax, WORD PTR [ebx+150]
  000ac	c1 e9 02	 shr	 ecx, 2
  000af	03 cf		 add	 ecx, edi
  000b1	03 c1		 add	 eax, ecx

; 5214 : 
; 5215 : 	if( lpTargetObj->iShield > lpTargetObj->iMaxShield+lpTargetObj->iAddShield )

  000b3	3b c2		 cmp	 eax, edx
  000b5	0f 4f c2	 cmovg	 eax, edx

; 5216 : 	{
; 5217 : 		lpTargetObj->iShield = lpTargetObj->iMaxShield+lpTargetObj->iAddShield;
; 5218 : 	}
; 5219 : 
; 5220 : 	if( lpTargetObj->Type == OBJ_USER )

  000b8	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  000bc	89 86 2c 01 00
	00		 mov	 DWORD PTR [esi+300], eax
  000c2	0f 85 a6 00 00
	00		 jne	 $LN24@SkillRecov

; 5221 : 	{
; 5222 : 
; 5223 : 		GCReFillSend(lpTargetObj->m_Index,(WORD)lpTargetObj->Life,0xFF,0,lpTargetObj->iShield);

  000c8	0f b7 c0	 movzx	 eax, ax
  000cb	50		 push	 eax
  000cc	f3 0f 2c 86 d8
	00 00 00	 cvttss2si eax, DWORD PTR [esi+216]
  000d4	6a 00		 push	 0
  000d6	68 ff 00 00 00	 push	 255			; 000000ffH
  000db	0f b7 c0	 movzx	 eax, ax
  000de	50		 push	 eax
  000df	ff 36		 push	 DWORD PTR [esi]
  000e1	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 5224 : 		GCMagicAttackNumberSend(lpObj,AT_SKILL_RECOVERY,lpTargetObj->m_Index,skillSuccess);

  000e6	6a 01		 push	 1
  000e8	ff 36		 push	 DWORD PTR [esi]
  000ea	68 ea 00 00 00	 push	 234			; 000000eaH
  000ef	53		 push	 ebx
  000f0	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000f5	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  000fa	8d b3 48 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3144]
  00100	83 c4 24	 add	 esp, 36			; 00000024H
  00103	89 4d 08	 mov	 DWORD PTR tv441[ebp], ecx
$LL4@SkillRecov:

; 5227 : 		{
; 5228 : 			if(lpObj->VpPlayer2[n].type == OBJ_MONSTER && lpObj->VpPlayer2[n].state != 0)

  00106	80 7e 04 02	 cmp	 BYTE PTR [esi+4], 2
  0010a	75 57		 jne	 SHORT $LN2@SkillRecov
  0010c	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0010f	74 52		 je	 SHORT $LN2@SkillRecov

; 5229 : 			{
; 5230 : 				LPOBJ lpMonster = &gObj[lpObj->VpPlayer2[n].number];

  00111	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  00115	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  0011b	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 5231 : 				if(lpMonster->m_iCurrentAI != 0)

  00121	83 bf d0 20 00
	00 00		 cmp	 DWORD PTR [edi+8400], 0
  00128	74 39		 je	 SHORT $LN2@SkillRecov

; 5232 : 				{
; 5233 : 					lpMonster->m_Agro.IncAgro(lpObj->m_Index,(lpObj->Energy / 5)/40);

  0012a	0f b7 8b d6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+214]
  00131	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00136	f7 e9		 imul	 ecx
  00138	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0013d	d1 fa		 sar	 edx, 1
  0013f	8b ca		 mov	 ecx, edx
  00141	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00144	03 ca		 add	 ecx, edx
  00146	f7 e9		 imul	 ecx
  00148	8d 8f ec 20 00
	00		 lea	 ecx, DWORD PTR [edi+8428]
  0014e	c1 fa 04	 sar	 edx, 4
  00151	8b c2		 mov	 eax, edx
  00153	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00156	03 c2		 add	 eax, edx
  00158	50		 push	 eax
  00159	ff 33		 push	 DWORD PTR [ebx]
  0015b	e8 00 00 00 00	 call	 ?IncAgro@TMonsterAIAgro@@QAEHHH@Z ; TMonsterAIAgro::IncAgro
  00160	8b 4d 08	 mov	 ecx, DWORD PTR tv441[ebp]
$LN2@SkillRecov:

; 5225 : 
; 5226 : 		for(int n = 0; n < MAX_VIEWPORT; n++)

  00163	83 c6 0c	 add	 esi, 12			; 0000000cH
  00166	83 e9 01	 sub	 ecx, 1
  00169	89 4d 08	 mov	 DWORD PTR tv441[ebp], ecx
  0016c	75 98		 jne	 SHORT $LL4@SkillRecov
$LN24@SkillRecov:
  0016e	5f		 pop	 edi
$LN3@SkillRecov:
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx

; 5234 : 				}
; 5235 : 			}
; 5236 : 		}
; 5237 : 	}
; 5238 : }

  00171	5d		 pop	 ebp
  00172	c2 0c 00	 ret	 12			; 0000000cH
?SkillRecovery@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillRecovery
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillBerserker@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillBerserker@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillBerserker, COMDAT
; _this$ = ecx

; 5145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5146 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 88 c4 00 00
	00		 js	 $LN9@SkillBerse
  0000e	33 c0		 xor	 eax, eax
  00010	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 b1 00 00
	00		 je	 $LN9@SkillBerse

; 5149 : 	}
; 5150 : 
; 5151 : 	LPOBJ lpObj = &gObj[aIndex];
; 5152 : 
; 5153 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00021	53		 push	 ebx
  00022	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00025	56		 push	 esi
  00026	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048
  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  00031	ff 73 08	 push	 DWORD PTR [ebx+8]
  00034	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003a	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  0003f	8b c8		 mov	 ecx, eax

; 5154 : 
; 5155 : 	if( !lpInfo )

  00041	85 c9		 test	 ecx, ecx
  00043	75 06		 jne	 SHORT $LN3@SkillBerse
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx

; 5180 : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN3@SkillBerse:

; 5156 : 	{
; 5157 : 		return 0;
; 5158 : 	}
; 5159 : 
; 5160 : 	int iTime = lpInfo->m_Arg3 + lpObj->Energy / lpInfo->m_Arg4;

  0004b	0f b7 86 d6 00
	00 00		 movzx	 eax, WORD PTR [esi+214]

; 5161 : 
; 5162 : 	if( iTime > lpInfo->m_Arg5 )

  00052	f3 0f 10 51 14	 movss	 xmm2, DWORD PTR [ecx+20]
  00057	66 0f 6e c8	 movd	 xmm1, eax
  0005b	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0005e	0f 28 c1	 movaps	 xmm0, xmm1
  00061	f3 0f 5e 41 10	 divss	 xmm0, DWORD PTR [ecx+16]
  00066	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  0006b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0006f	66 0f 6e c0	 movd	 xmm0, eax
  00073	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00076	0f 2f c2	 comiss	 xmm0, xmm2
  00079	76 04		 jbe	 SHORT $LN4@SkillBerse

; 5163 : 	{
; 5164 : 		iTime = lpInfo->m_Arg5;

  0007b	f3 0f 2c c2	 cvttss2si eax, xmm2
$LN4@SkillBerse:

; 5165 : 	}
; 5166 : 
; 5167 : 	int iIncDmg = lpObj->Energy / lpInfo->m_Arg1;

  0007f	f3 0f 5e 49 04	 divss	 xmm1, DWORD PTR [ecx+4]
  00084	57		 push	 edi
  00085	f3 0f 2c f9	 cvttss2si edi, xmm1

; 5168 : 
; 5169 : 	if( iIncDmg > lpInfo->m_Arg2 )

  00089	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0008e	66 0f 6e c7	 movd	 xmm0, edi
  00092	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00095	0f 2f c1	 comiss	 xmm0, xmm1
  00098	76 04		 jbe	 SHORT $LN5@SkillBerse

; 5170 : 	{
; 5171 : 		iIncDmg = lpInfo->m_Arg2;

  0009a	f3 0f 2c f9	 cvttss2si edi, xmm1
$LN5@SkillBerse:

; 5172 : 	}
; 5173 : 
; 5174 : 	int iDecDef = iIncDmg / 2;
; 5175 : 
; 5176 : 	gObjAddBuffEffect(lpObj,BUFF_BERSERKER,ADD_OPTION_BERSERKMANA_PERC,iIncDmg,ADD_OPTION_BERSERKLIFE_PERC,iDecDef,iTime);

  0009e	50		 push	 eax
  0009f	8b c7		 mov	 eax, edi
  000a1	99		 cdq
  000a2	2b c2		 sub	 eax, edx
  000a4	d1 f8		 sar	 eax, 1
  000a6	50		 push	 eax
  000a7	6a 20		 push	 32			; 00000020H
  000a9	57		 push	 edi
  000aa	6a 1f		 push	 31			; 0000001fH
  000ac	6a 51		 push	 81			; 00000051H
  000ae	56		 push	 esi
  000af	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 5177 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpObj->m_Index,TRUE);

  000b4	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  000b8	6a 01		 push	 1
  000ba	ff 36		 push	 DWORD PTR [esi]
  000bc	50		 push	 eax
  000bd	56		 push	 esi
  000be	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000c3	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5178 : 
; 5179 : return true;

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx

; 5180 : }

  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8
$LN9@SkillBerse:

; 5147 : 	{
; 5148 : 		return false;

  000d2	33 c0		 xor	 eax, eax

; 5180 : }

  000d4	5d		 pop	 ebp
  000d5	c2 08 00	 ret	 8
?SkillBerserker@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillBerserker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillLagle@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_aTargetIndex$ = 24					; size = 4
_type$ = 28						; size = 4
?SkillLagle@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHH@Z PROC ; CObjUseSkill::SkillLagle, COMDAT
; _this$ = ecx

; 5583 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5584 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00007	53		 push	 ebx
  00008	69 d8 40 27 00
	00		 imul	 ebx, eax, 10048
  0000e	56		 push	 esi

; 5585 : 	int bSuccess = FALSE;
; 5586 : 
; 5587 : 	if( type == 59 )

  0000f	8b 75 0c	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  00012	57		 push	 edi
  00013	8b 7d 18	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00016	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001c	83 7d 1c 3b	 cmp	 DWORD PTR _type$[ebp], 59 ; 0000003bH
  00020	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00023	75 14		 jne	 SHORT $LN2@SkillLagle

; 5588 : 	{
; 5589 : 		GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,TRUE);

  00025	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00029	6a 01		 push	 1
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	53		 push	 ebx
  0002e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00033	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00036	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@SkillLagle:

; 5590 : 	}
; 5591 : 
; 5592 : 	bSuccess = SkillAreaMonsterAttack(aIndex,lpMagic,x,y,aTargetIndex,3,1,0);

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0003c	6a 00		 push	 0
  0003e	6a 01		 push	 1
  00040	6a 03		 push	 3
  00042	57		 push	 edi
  00043	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00046	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00049	56		 push	 esi
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z ; CObjUseSkill::SkillAreaMonsterAttack
  00050	8b f0		 mov	 esi, eax

; 5593 : 
; 5594 : 	if( type >= 59 && type < 64 && OBJMAX_RANGE(aTargetIndex) )

  00052	8b 45 1c	 mov	 eax, DWORD PTR _type$[ebp]
  00055	8d 48 c5	 lea	 ecx, DWORD PTR [eax-59]
  00058	83 f9 04	 cmp	 ecx, 4
  0005b	77 44		 ja	 SHORT $LN7@SkillLagle
  0005d	85 ff		 test	 edi, edi
  0005f	78 40		 js	 SHORT $LN7@SkillLagle
  00061	33 c9		 xor	 ecx, ecx
  00063	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00069	0f 9e c1	 setle	 cl
  0006c	85 c9		 test	 ecx, ecx
  0006e	74 31		 je	 SHORT $LN7@SkillLagle

; 5595 : 	{
; 5596 : 		gObjAddMsgSendDelay(lpObj,59,aTargetIndex,1000,((((x&0xFF)&0xFF | ((y&0xFF)&0xFF)<<8)&0xFFFF)&0xFFFF)&0xFFFF | (((type+1)&0xFFFF)&0xFFFF)<<16);

  00070	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00073	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00076	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00079	0f b6 c0	 movzx	 eax, al
  0007c	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00082	c1 e0 08	 shl	 eax, 8
  00085	0b c8		 or	 ecx, eax
  00087	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  0008a	0f b6 c0	 movzx	 eax, al
  0008d	0b c8		 or	 ecx, eax
  0008f	51		 push	 ecx
  00090	68 e8 03 00 00	 push	 1000			; 000003e8H
  00095	57		 push	 edi
  00096	6a 3b		 push	 59			; 0000003bH
  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0009e	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@SkillLagle:

; 5597 : 	}
; 5598 : 
; 5599 : return bSuccess;

  000a1	5f		 pop	 edi
  000a2	8b c6		 mov	 eax, esi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx

; 5600 : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 18 00	 ret	 24			; 00000018H
?SkillLagle@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHH@Z ENDP ; CObjUseSkill::SkillLagle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -32					; size = 4
_nMaxCount$1$ = -28					; size = 4
_nMinCount$1$ = -24					; size = 4
tv646 = -20						; size = 4
tv645 = -16						; size = 4
_nHitCount$1$ = -12					; size = 4
_bAttack$1$ = -8					; size = 4
_bRet$1$ = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
tv635 = 16						; size = 4
_x$ = 16						; size = 1
tv650 = 20						; size = 4
_y$ = 20						; size = 1
_aTargetIndex$ = 24					; size = 4
_aDistance$ = 28					; size = 4
_bPVP$ = 32						; size = 4
_nDelay$ = 36						; size = 4
?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z PROC ; CObjUseSkill::SkillAreaMonsterAttack, COMDAT
; _this$ = ecx

; 5603 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx

; 5604 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx

; 5605 : 	int bRet = FALSE;

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bRet$1$[ebp], 0

; 5606 : 	int count = 0;
; 5607 : 	int tObjNum;
; 5608 : 	int DuelIndex = lpObj->m_iDuelUser;
; 5609 : 	int nHitCount = 0;
; 5610 : 	int bAttack = FALSE;
; 5611 : 	int nMinCount = 4;

  00019	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _nMinCount$1$[ebp], 4
  00020	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	89 5d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ebx

; 5612 : 	int nMaxCount = 8;

  00029	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR _nMaxCount$1$[ebp], 8
  00030	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00036	89 45 e0	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00039	33 c0		 xor	 eax, eax
  0003b	89 45 f4	 mov	 DWORD PTR _nHitCount$1$[ebp], eax
  0003e	89 45 f8	 mov	 DWORD PTR _bAttack$1$[ebp], eax

; 5613 : 
; 5614 : 	if( lpMagic->m_Skill == AT_SKILL_GIGANTICSTORM )

  00041	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00044	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00047	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  0004c	75 0e		 jne	 SHORT $LN7@SkillAreaM

; 5615 : 	{
; 5616 : 		nMinCount = 8;

  0004e	c7 45 e8 08 00
	00 00		 mov	 DWORD PTR _nMinCount$1$[ebp], 8

; 5617 : 		nMaxCount = 12;

  00055	c7 45 e4 0c 00
	00 00		 mov	 DWORD PTR _nMaxCount$1$[ebp], 12 ; 0000000cH
$LN7@SkillAreaM:

; 5618 : 	}
; 5619 : 
; 5620 : 	int iSkillDistance = MagicDamageC.GetSkillDistance(lpMagic->m_Skill);

  0005c	50		 push	 eax
  0005d	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00062	e8 00 00 00 00	 call	 ?GetSkillDistance@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillDistance

; 5621 : 
; 5622 : 	if( CalDistance(lpObj->X,lpObj->Y,x,y) <= iSkillDistance )

  00067	0f b6 4d 10	 movzx	 ecx, BYTE PTR _x$[ebp]
  0006b	8b f0		 mov	 esi, eax
  0006d	0f b6 45 14	 movzx	 eax, BYTE PTR _y$[ebp]
  00071	50		 push	 eax
  00072	89 45 ec	 mov	 DWORD PTR tv646[ebp], eax
  00075	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00085	89 4d f0	 mov	 DWORD PTR tv645[ebp], ecx
  00088	8b cf		 mov	 ecx, edi
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  00090	3b c6		 cmp	 eax, esi
  00092	0f 8f 28 03 00
	00		 jg	 $LN55@SkillAreaM

; 5618 : 	}
; 5619 : 
; 5620 : 	int iSkillDistance = MagicDamageC.GetSkillDistance(lpMagic->m_Skill);

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009e	8b f3		 mov	 esi, ebx
  000a0	c7 45 14 4b 00
	00 00		 mov	 DWORD PTR tv650[ebp], 75 ; 0000004bH
  000a7	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  000ac	8d 86 4c 0c 00
	00		 lea	 eax, DWORD PTR [esi+3148]
  000b2	89 45 10	 mov	 DWORD PTR tv635[ebp], eax
  000b5	eb 03		 jmp	 SHORT $LN2@SkillAreaM
$LL67@SkillAreaM:
  000b7	8b 45 10	 mov	 eax, DWORD PTR tv635[ebp]
$LN2@SkillAreaM:

; 5623 : 	{
; 5624 : 		while( TRUE )
; 5625 : 		{
; 5626 : 			if(lpObj->VpPlayer2[count].state != 0)

  000ba	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  000be	74 7d		 je	 SHORT $LN65@SkillAreaM

; 5627 : 			{
; 5628 : 				tObjNum = lpObj->VpPlayer2[count].number;

  000c0	0f bf 58 fe	 movsx	 ebx, WORD PTR [eax-2]

; 5629 : 
; 5630 : 				if( tObjNum >= 0 )

  000c4	85 db		 test	 ebx, ebx
  000c6	78 75		 js	 SHORT $LN65@SkillAreaM

; 5631 : 				{
; 5632 : 					int EnableAttack = 0;
; 5633 : 
; 5634 : 					if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  000c8	8a 10		 mov	 dl, BYTE PTR [eax]
  000ca	80 fa 02	 cmp	 dl, 2
  000cd	75 14		 jne	 SHORT $LN11@SkillAreaM
  000cf	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048
  000d5	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  000dd	0f 8c ba 00 00
	00		 jl	 $LN53@SkillAreaM
$LN11@SkillAreaM:

; 5635 : 					{
; 5636 : 						EnableAttack = 1;
; 5637 : 					}
; 5638 : 					else if( (tObjNum == aTargetIndex && bPVP == 1) || DuelIndex ==tObjNum )

  000e3	3b 5d 18	 cmp	 ebx, DWORD PTR _aTargetIndex$[ebp]
  000e6	75 0a		 jne	 SHORT $LN16@SkillAreaM
  000e8	83 7d 20 01	 cmp	 DWORD PTR _bPVP$[ebp], 1
  000ec	0f 84 ab 00 00
	00		 je	 $LN53@SkillAreaM
$LN16@SkillAreaM:
  000f2	39 5d e0	 cmp	 DWORD PTR _DuelIndex$1$[ebp], ebx
  000f5	0f 84 a2 00 00
	00		 je	 $LN53@SkillAreaM

; 5639 : 					{
; 5640 : 						EnableAttack = 1;
; 5641 : 					}
; 5642 : #if (GS_CASTLE == 1)
; 5643 : 					else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000fb	80 fa 03	 cmp	 dl, 3
  000fe	74 5c		 je	 SHORT $LN17@SkillAreaM
  00100	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00106	80 bc 0e 23 01
	00 00 1e	 cmp	 BYTE PTR [esi+ecx+291], 30 ; 0000001eH
  0010e	75 49		 jne	 SHORT $LN63@SkillAreaM
  00110	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00115	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 5644 : 					{
; 5645 : 						if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00120	83 f8 07	 cmp	 eax, 7
  00123	75 34		 jne	 SHORT $LN63@SkillAreaM
  00125	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  00128	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  0012e	3a 84 0e 5a 20
	00 00		 cmp	 al, BYTE PTR [esi+ecx+8282]
  00135	75 66		 jne	 SHORT $LN53@SkillAreaM
$LN62@SkillAreaM:
  00137	8b 75 08	 mov	 esi, DWORD PTR _lpObj$1$[ebp]
$LN59@SkillAreaM:
  0013a	8b 55 14	 mov	 edx, DWORD PTR tv650[ebp]
$LN65@SkillAreaM:
  0013d	8b 45 fc	 mov	 eax, DWORD PTR _bRet$1$[ebp]
$LN23@SkillAreaM:

; 5754 : 						}
; 5755 : 					}
; 5756 : 				}
; 5757 : 			}
; 5758 : 
; 5759 : 			count++;

  00140	83 45 10 0c	 add	 DWORD PTR tv635[ebp], 12 ; 0000000cH

; 5760 : 
; 5761 : 			if( count > (MAX_VIEWPORT-1) )

  00144	83 ea 01	 sub	 edx, 1
  00147	89 55 14	 mov	 DWORD PTR tv650[ebp], edx
  0014a	0f 85 67 ff ff
	ff		 jne	 $LL67@SkillAreaM
  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx

; 5768 : }

  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 20 00	 ret	 32			; 00000020H
$LN63@SkillAreaM:
  00159	8b 75 08	 mov	 esi, DWORD PTR _lpObj$1$[ebp]
$LN17@SkillAreaM:

; 5646 : 							EnableAttack = 1;
; 5647 : 					}	
; 5648 : #endif
; 5649 : 					else
; 5650 : 					{
; 5651 : 						int CallMonIndex = gObj[tObjNum].m_Index;

  0015c	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048

; 5652 : 	
; 5653 : 						if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00162	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00167	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  0016a	75 14		 jne	 SHORT $LN20@SkillAreaM
  0016c	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  00173	85 c0		 test	 eax, eax
  00175	78 09		 js	 SHORT $LN20@SkillAreaM

; 5654 : 						{
; 5655 : 							CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00177	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0017d	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN20@SkillAreaM:

; 5656 : 						}
; 5657 : 	
; 5658 : 						if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00180	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00186	03 c1		 add	 eax, ecx
  00188	50		 push	 eax
  00189	56		 push	 esi
  0018a	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00195	83 c4 08	 add	 esp, 8
  00198	83 f8 01	 cmp	 eax, 1
  0019b	75 9d		 jne	 SHORT $LN59@SkillAreaM
$LN53@SkillAreaM:

; 5659 : 						{
; 5660 : 							EnableAttack = 1;
; 5661 : 						}
; 5662 : 					}
; 5663 : 
; 5664 : 					if( EnableAttack != 0 )
; 5665 : 					{
; 5666 : 						if( gObj[tObjNum].X >= (x -aDistance) &&
; 5667 : 							gObj[tObjNum].X <= (x +aDistance) &&
; 5668 : 							gObj[tObjNum].Y >= (y -aDistance) &&

  0019d	8b 45 f0	 mov	 eax, DWORD PTR tv645[ebp]
  001a0	2b 45 1c	 sub	 eax, DWORD PTR _aDistance$[ebp]
  001a3	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  001a9	0f b6 b4 0f 20
	01 00 00	 movzx	 esi, BYTE PTR [edi+ecx+288]
  001b1	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  001b4	3b f0		 cmp	 esi, eax
  001b6	0f 8c 7b ff ff
	ff		 jl	 $LN62@SkillAreaM
  001bc	8b 45 1c	 mov	 eax, DWORD PTR _aDistance$[ebp]
  001bf	03 45 f0	 add	 eax, DWORD PTR tv645[ebp]
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c8	3b f0		 cmp	 esi, eax
  001ca	0f 8f 67 ff ff
	ff		 jg	 $LN62@SkillAreaM
  001d0	8b 45 ec	 mov	 eax, DWORD PTR tv646[ebp]
  001d3	0f b6 b2 21 01
	00 00		 movzx	 esi, BYTE PTR [edx+289]
  001da	2b 45 1c	 sub	 eax, DWORD PTR _aDistance$[ebp]
  001dd	3b f0		 cmp	 esi, eax
  001df	0f 8c 52 ff ff
	ff		 jl	 $LN62@SkillAreaM
  001e5	8b 45 1c	 mov	 eax, DWORD PTR _aDistance$[ebp]
  001e8	03 45 ec	 add	 eax, DWORD PTR tv646[ebp]
  001eb	3b f0		 cmp	 esi, eax

; 5669 : 							gObj[tObjNum].Y <= (y +aDistance) )
; 5670 : 						{
; 5671 : 							gObj[tObjNum].lpAttackObj = lpObj;

  001ed	8b 75 08	 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  001f0	0f 8f 44 ff ff
	ff		 jg	 $LN59@SkillAreaM
  001f6	89 b2 b4 05 00
	00		 mov	 DWORD PTR [edx+1460], esi

; 5672 : 							nHitCount++;

  001fc	8b 55 f4	 mov	 edx, DWORD PTR _nHitCount$1$[ebp]
  001ff	42		 inc	 edx
  00200	89 55 f4	 mov	 DWORD PTR _nHitCount$1$[ebp], edx

; 5673 : 	
; 5674 : 							if( nHitCount > nMinCount )

  00203	3b 55 e8	 cmp	 edx, DWORD PTR _nMinCount$1$[ebp]
  00206	7e 13		 jle	 SHORT $LN24@SkillAreaM

; 5675 : 							{
; 5676 : 								if(rand()%2)

  00208	e8 00 00 00 00	 call	 _rand
  0020d	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00212	79 05		 jns	 SHORT $LN69@SkillAreaM
  00214	48		 dec	 eax
  00215	83 c8 fe	 or	 eax, -2			; fffffffeH
  00218	40		 inc	 eax
$LN69@SkillAreaM:
  00219	74 0a		 je	 SHORT $LN68@SkillAreaM
$LN24@SkillAreaM:

; 5677 : 								{
; 5678 : 									bAttack = TRUE;

  0021b	ba 01 00 00 00	 mov	 edx, 1
  00220	89 55 f8	 mov	 DWORD PTR _bAttack$1$[ebp], edx

; 5679 : 								}
; 5680 : 							}
; 5681 : 							else

  00223	eb 03		 jmp	 SHORT $LN25@SkillAreaM
$LN68@SkillAreaM:
  00225	8b 55 f8	 mov	 edx, DWORD PTR _bAttack$1$[ebp]
$LN25@SkillAreaM:

; 5682 : 							{
; 5683 : 								bAttack = TRUE;
; 5684 : 							}
; 5685 : 	
; 5686 : 							if( nHitCount > nMaxCount )

  00228	8b 45 f4	 mov	 eax, DWORD PTR _nHitCount$1$[ebp]
  0022b	3b 45 e4	 cmp	 eax, DWORD PTR _nMaxCount$1$[ebp]
  0022e	7e 0a		 jle	 SHORT $LN27@SkillAreaM

; 5687 : 							{
; 5688 : 								bAttack = FALSE;

  00230	33 c0		 xor	 eax, eax
  00232	89 45 f8	 mov	 DWORD PTR _bAttack$1$[ebp], eax

; 5689 : 							}
; 5690 : 
; 5691 : 							if( bAttack == TRUE )

  00235	e9 70 01 00 00	 jmp	 $LN30@SkillAreaM
$LN27@SkillAreaM:
  0023a	83 fa 01	 cmp	 edx, 1
  0023d	0f 85 67 01 00
	00		 jne	 $LN30@SkillAreaM

; 5692 : 							{
; 5693 : 								if( nDelay == 0 )

  00243	83 7d 24 00	 cmp	 DWORD PTR _nDelay$[ebp], 0
  00247	0f 85 d1 00 00
	00		 jne	 $LN29@SkillAreaM

; 5694 : 								{
; 5695 : 									if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DRAGONLORE ||

  0024d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00250	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00253	3d 08 01 00 00	 cmp	 eax, 264		; 00000108H
  00258	74 29		 je	 SHORT $LN33@SkillAreaM
  0025a	3d 0e 01 00 00	 cmp	 eax, 270		; 0000010eH
  0025f	74 29		 je	 SHORT $LN54@SkillAreaM

; 5727 : 											}
; 5728 : 										}
; 5729 : 									}
; 5730 : 									else
; 5731 : 									{
; 5732 : 										gObjAttack(lpObj,&gObj[tObjNum],lpMagic,TRUE,FALSE,0,0,0,0);

  00261	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00266	6a 00		 push	 0
  00268	6a 00		 push	 0
  0026a	6a 00		 push	 0
  0026c	6a 00		 push	 0
  0026e	6a 00		 push	 0
  00270	52		 push	 edx
  00271	51		 push	 ecx
  00272	03 c7		 add	 eax, edi
  00274	50		 push	 eax
  00275	56		 push	 esi
  00276	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0027b	83 c4 24	 add	 esp, 36			; 00000024H
  0027e	e9 27 01 00 00	 jmp	 $LN30@SkillAreaM
$LN33@SkillAreaM:

; 5696 : 										lpMagic->m_Skill == AT_SKILL_PHOENIXSHOT )
; 5697 : 									{
; 5698 : 										if( lpMagic->m_Skill == AT_SKILL_PHOENIXSHOT && rand()%100 < 10 )

  00283	3d 0e 01 00 00	 cmp	 eax, 270		; 0000010eH
  00288	75 50		 jne	 SHORT $LN34@SkillAreaM
$LN54@SkillAreaM:
  0028a	e8 00 00 00 00	 call	 _rand
  0028f	99		 cdq
  00290	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00295	f7 f9		 idiv	 ecx
  00297	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0029a	7d 3b		 jge	 SHORT $LN66@SkillAreaM

; 5699 : 										{
; 5700 : 											int nEffectValue = 0;
; 5701 : 
; 5702 : 											if( gObj[tObjNum].Type == OBJ_MONSTER )

  0029c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a2	03 d7		 add	 edx, edi
  002a4	8a 4a 50	 mov	 cl, BYTE PTR [edx+80]
  002a7	80 f9 02	 cmp	 cl, 2
  002aa	75 07		 jne	 SHORT $LN35@SkillAreaM

; 5703 : 											{
; 5704 : 												nEffectValue = 50;

  002ac	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  002b1	eb 0d		 jmp	 SHORT $LN37@SkillAreaM
$LN35@SkillAreaM:

; 5705 : 											}
; 5706 : 											else if( gObj[tObjNum].Type == OBJ_USER )

  002b3	33 c0		 xor	 eax, eax
  002b5	80 f9 01	 cmp	 cl, 1
  002b8	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  002bd	0f 44 c1	 cmove	 eax, ecx
$LN37@SkillAreaM:

; 5707 : 											{
; 5708 : 												nEffectValue = 20;
; 5709 : 											}
; 5710 : 											else
; 5711 : 											{
; 5712 : 												nEffectValue = 0;
; 5713 : 											}
; 5714 : 
; 5715 : 											gObjAddBuffEffect(&gObj[tObjNum],BUFF_DECREASE_DEFRATE,SUB_OPTION_SUCCESSFULBLOCKING,nEffectValue,0,0,10);

  002c0	6a 0a		 push	 10			; 0000000aH
  002c2	6a 00		 push	 0
  002c4	6a 00		 push	 0
  002c6	50		 push	 eax
  002c7	6a 4b		 push	 75			; 0000004bH
  002c9	68 84 00 00 00	 push	 132			; 00000084H
  002ce	52		 push	 edx
  002cf	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  002d4	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN66@SkillAreaM:
  002d7	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
$LN34@SkillAreaM:

; 5716 : 										}
; 5717 : 
; 5718 : 										for(int i = 1; i <= 4; i++)

  002da	be 01 00 00 00	 mov	 esi, 1
  002df	90		 npad	 1
$LL6@SkillAreaM:

; 5719 : 										{
; 5720 : 											if( i == 1 )
; 5721 : 											{
; 5722 : 												gObjAttack(lpObj,&gObj[tObjNum],lpMagic,TRUE,TRUE,0,0,i,0);

  002e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e5	03 c7		 add	 eax, edi
  002e7	6a 00		 push	 0
  002e9	83 fe 01	 cmp	 esi, 1
  002ec	75 09		 jne	 SHORT $LN39@SkillAreaM
  002ee	56		 push	 esi
  002ef	6a 00		 push	 0
  002f1	6a 00		 push	 0
  002f3	56		 push	 esi
  002f4	56		 push	 esi

; 5723 : 											}
; 5724 : 											else

  002f5	eb 09		 jmp	 SHORT $LN70@SkillAreaM
$LN39@SkillAreaM:

; 5725 : 											{
; 5726 : 												gObjAttack(lpObj,&gObj[tObjNum],lpMagic,FALSE,TRUE,0,0,i,0);

  002f7	56		 push	 esi
  002f8	6a 00		 push	 0
  002fa	6a 00		 push	 0
  002fc	6a 01		 push	 1
  002fe	6a 00		 push	 0
$LN70@SkillAreaM:
  00300	51		 push	 ecx
  00301	50		 push	 eax
  00302	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  00305	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0030a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  0030d	46		 inc	 esi
  0030e	83 c4 24	 add	 esp, 36			; 00000024H
  00311	83 fe 04	 cmp	 esi, 4
  00314	7e ca		 jle	 SHORT $LL6@SkillAreaM

; 5733 : 									}
; 5734 : 								}
; 5735 : 								else

  00316	8b 75 08	 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  00319	e9 8c 00 00 00	 jmp	 $LN30@SkillAreaM
$LN29@SkillAreaM:

; 5736 : 								{
; 5737 : 									if( lpMagic->m_Skill == AT_SKILL_GIGANTICSTORM &&

  0031e	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00321	81 78 08 ed 00
	00 00		 cmp	 DWORD PTR [eax+8], 237	; 000000edH
  00328	75 69		 jne	 SHORT $LN42@SkillAreaM
  0032a	b8 31 02 00 00	 mov	 eax, 561		; 00000231H
  0032f	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  00336	75 5b		 jne	 SHORT $LN42@SkillAreaM

; 5738 : 										lpObj->Class == 561 )
; 5739 : 									{
; 5740 : 										if( gObjCheckUsedBuffEffect(&gObj[tObjNum],BUFF_ICE) == FALSE )

  00338	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033d	03 c7		 add	 eax, edi
  0033f	6a 38		 push	 56			; 00000038H
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00347	83 c4 08	 add	 esp, 8
  0034a	84 c0		 test	 al, al
  0034c	75 45		 jne	 SHORT $LN42@SkillAreaM

; 5741 : 										{
; 5742 : 											gObj[tObjNum].DelayActionTime = 800;

  0034e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 5743 : 											gObj[tObjNum].DelayLevel = 1;
; 5744 : 											gObj[tObjNum].lpAttackObj = lpObj;
; 5745 : 											gObjAddBuffEffect(&gObj[tObjNum],BUFF_ICE,0,0,0,0,3);

  00353	6a 03		 push	 3
  00355	6a 00		 push	 0
  00357	6a 00		 push	 0
  00359	c7 84 07 a4 05
	00 00 20 03 00
	00		 mov	 DWORD PTR [edi+eax+1444], 800 ; 00000320H
  00364	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00369	6a 00		 push	 0
  0036b	6a 00		 push	 0
  0036d	6a 38		 push	 56			; 00000038H
  0036f	c6 84 07 a8 05
	00 00 01	 mov	 BYTE PTR [edi+eax+1448], 1
  00377	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0037c	89 b4 07 b4 05
	00 00		 mov	 DWORD PTR [edi+eax+1460], esi
  00383	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00388	03 c7		 add	 eax, edi
  0038a	50		 push	 eax
  0038b	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  00390	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN42@SkillAreaM:

; 5746 : 										}
; 5747 : 									}
; 5748 : 
; 5749 : 									gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,nDelay,lpMagic->m_Skill,0);

  00393	8b 7d 0c	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00396	6a 00		 push	 0
  00398	ff 77 08	 push	 DWORD PTR [edi+8]
  0039b	ff 75 24	 push	 DWORD PTR _nDelay$[ebp]
  0039e	53		 push	 ebx
  0039f	6a 32		 push	 50			; 00000032H
  003a1	56		 push	 esi
  003a2	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  003a7	83 c4 18	 add	 esp, 24			; 00000018H
$LN30@SkillAreaM:

; 5750 : 								}
; 5751 : 							}
; 5752 : 
; 5753 : 							bRet = TRUE;

  003aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b0	b8 01 00 00 00	 mov	 eax, 1
  003b5	8b 55 14	 mov	 edx, DWORD PTR tv650[ebp]
  003b8	89 45 fc	 mov	 DWORD PTR _bRet$1$[ebp], eax
  003bb	e9 80 fd ff ff	 jmp	 $LN23@SkillAreaM
$LN55@SkillAreaM:
  003c0	5f		 pop	 edi
  003c1	5e		 pop	 esi

; 5762 : 			{
; 5763 : 				break;
; 5764 : 			}
; 5765 : 		}
; 5766 : 	}
; 5767 : 	return bRet;

  003c2	33 c0		 xor	 eax, eax
  003c4	5b		 pop	 ebx

; 5768 : }

  003c5	8b e5		 mov	 esp, ebp
  003c7	5d		 pop	 ebp
  003c8	c2 20 00	 ret	 32			; 00000020H
?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z ENDP ; CObjUseSkill::SkillAreaMonsterAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillInnovation@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -12					; size = 4
_HitCount$1$ = -8					; size = 4
_count$1$ = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
tv479 = 24						; size = 4
_aTargetIndex$ = 24					; size = 4
?SkillInnovation@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z PROC ; CObjUseSkill::SkillInnovation, COMDAT
; _this$ = ecx

; 5058 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5059 : 	LPOBJ lpObj = &gObj[aIndex];

  00009	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048

; 5060 : 	int bSuccess = FALSE;
; 5061 : 	int tObjNum;
; 5062 : 	int count = 0;
; 5063 : 	int HitCount = 0;
; 5064 : 	int DuelIndex = lpObj->m_iDuelUser;
; 5065 : 	int EnableAttack;
; 5066 : 
; 5067 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00010	6a 01		 push	 1
  00012	ff 75 18	 push	 DWORD PTR _aTargetIndex$[ebp]
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$1$[ebp], 0
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _HitCount$1$[ebp], 0
  00023	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	89 7d 08	 mov	 DWORD PTR _lpObj$1$[ebp], edi
  0002c	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]
  00032	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00035	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00038	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  0003c	50		 push	 eax
  0003d	57		 push	 edi
  0003e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	8d 87 4c 0c 00
	00		 lea	 eax, DWORD PTR [edi+3148]
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	89 45 18	 mov	 DWORD PTR tv479[ebp], eax
  00055	33 d2		 xor	 edx, edx
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@SkillInnov:

; 5068 : 
; 5069 : 	while( TRUE )
; 5070 : 	{
; 5071 : 		if(lpObj->VpPlayer2[count].state != 0)

  00060	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  00064	0f 84 6a 01 00
	00		 je	 $LN20@SkillInnov

; 5072 : 		{
; 5073 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0006a	0f bf 70 fe	 movsx	 esi, WORD PTR [eax-2]

; 5074 : 
; 5075 : 			if( tObjNum >= 0 )

  0006e	85 f6		 test	 esi, esi
  00070	0f 88 5e 01 00
	00		 js	 $LN20@SkillInnov

; 5076 : 			{
; 5077 : 				EnableAttack = 0;
; 5078 : 
; 5079 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00076	8a 18		 mov	 bl, BYTE PTR [eax]
  00078	80 fb 02	 cmp	 bl, 2
  0007b	75 14		 jne	 SHORT $LN6@SkillInnov
  0007d	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00083	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0008b	0f 8c f6 00 00
	00		 jl	 $LN12@SkillInnov
$LN6@SkillInnov:

; 5080 : 				{
; 5081 : 					EnableAttack = 1;
; 5082 : 				}
; 5083 : 				else if(DuelIndex == tObjNum)

  00091	39 75 f4	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  00094	0f 84 ed 00 00
	00		 je	 $LN12@SkillInnov

; 5084 : 				{
; 5085 : 					EnableAttack = 1;
; 5086 : 				}
; 5087 : 				else if( CC_MAP_RANGE(lpObj->MapNumber) ||
; 5088 : 						 IT_MAP_RANGE(lpObj->MapNumber) ||

  0009a	8a 97 23 01 00
	00		 mov	 dl, BYTE PTR [edi+291]
  000a0	80 fa 35	 cmp	 dl, 53			; 00000035H
  000a3	0f 84 de 00 00
	00		 je	 $LN12@SkillInnov
  000a9	80 fa 12	 cmp	 dl, 18			; 00000012H
  000ac	72 0f		 jb	 SHORT $LN36@SkillInnov
  000ae	b0 17		 mov	 al, 23			; 00000017H
  000b0	3a c2		 cmp	 al, dl
  000b2	1b c0		 sbb	 eax, eax
  000b4	83 c0 01	 add	 eax, 1
  000b7	0f 85 ca 00 00
	00		 jne	 $LN12@SkillInnov
$LN36@SkillInnov:
  000bd	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  000c0	72 0f		 jb	 SHORT $LN37@SkillInnov
  000c2	b0 32		 mov	 al, 50			; 00000032H
  000c4	3a c2		 cmp	 al, dl
  000c6	1b c0		 sbb	 eax, eax
  000c8	83 c0 01	 add	 eax, 1
  000cb	0f 85 b6 00 00
	00		 jne	 $LN12@SkillInnov
$LN37@SkillInnov:
  000d1	80 fa 3f	 cmp	 dl, 63			; 0000003fH
  000d4	0f 84 ad 00 00
	00		 je	 $LN12@SkillInnov

; 5089 : 						 lpObj->MapNumber == MAP_INDEX_VULCANUS)
; 5090 : 				{
; 5091 : 					EnableAttack = 1;
; 5092 : 				}
; 5093 : #if (GS_CASTLE == 1)
; 5094 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000da	80 fb 03	 cmp	 bl, 3
  000dd	74 67		 je	 SHORT $LN13@SkillInnov
  000df	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000e5	80 bc 0f 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+ecx+291], 30 ; 0000001eH
  000ed	75 54		 jne	 SHORT $LN45@SkillInnov
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000f4	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 5095 : 				{
; 5096 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	83 f8 07	 cmp	 eax, 7
  00102	75 3f		 jne	 SHORT $LN45@SkillInnov
  00104	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  00107	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  0010d	3a 84 0f 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+ecx+8282]
  00114	0f 84 b1 00 00
	00		 je	 $LN44@SkillInnov

; 5097 : 					{
; 5098 : 						if( gObj[tObjNum].Class != 283 &&

  0011a	0f b7 84 0f 90
	00 00 00	 movzx	 eax, WORD PTR [edi+ecx+144]
  00122	ba 1b 01 00 00	 mov	 edx, 283		; 0000011bH

; 5099 : 							gObj[tObjNum].Class != 277 )
; 5100 : 							EnableAttack = 1;
; 5101 : 					}
; 5102 : 				}
; 5103 : #endif
; 5104 : 				else

  00127	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  0012a	66 3b c2	 cmp	 ax, dx
  0012d	0f 84 9b 00 00
	00		 je	 $LN46@SkillInnov

; 5097 : 					{
; 5098 : 						if( gObj[tObjNum].Class != 283 &&

  00133	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  00138	66 3b c2	 cmp	 ax, dx
  0013b	0f 84 8d 00 00
	00		 je	 $LN46@SkillInnov

; 5099 : 							gObj[tObjNum].Class != 277 )
; 5100 : 							EnableAttack = 1;
; 5101 : 					}
; 5102 : 				}
; 5103 : #endif
; 5104 : 				else

  00141	eb 44		 jmp	 SHORT $LN12@SkillInnov
$LN45@SkillInnov:
  00143	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN13@SkillInnov:

; 5105 : 				{
; 5106 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  00146	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 5107 : 
; 5108 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0014c	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00151	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00154	75 14		 jne	 SHORT $LN17@SkillInnov
  00156	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  0015d	85 c0		 test	 eax, eax
  0015f	78 09		 js	 SHORT $LN17@SkillInnov

; 5109 : 					{
; 5110 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00161	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00167	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN17@SkillInnov:

; 5111 : 					}
; 5112 : 
; 5113 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  0016a	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00170	03 c1		 add	 eax, ecx
  00172	50		 push	 eax
  00173	57		 push	 edi
  00174	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00179	83 c4 08	 add	 esp, 8
  0017c	83 f8 01	 cmp	 eax, 1
  0017f	75 42		 jne	 SHORT $LN40@SkillInnov
  00181	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN12@SkillInnov:

; 5114 : 					{
; 5115 : 						EnableAttack = 1;
; 5116 : 					}
; 5117 : 				}
; 5118 : 
; 5119 : 				if( EnableAttack != 0 &&

  00187	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  0018d	03 c1		 add	 eax, ecx
  0018f	50		 push	 eax
  00190	57		 push	 edi
  00191	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00196	83 c4 08	 add	 esp, 8
  00199	83 f8 05	 cmp	 eax, 5
  0019c	7d 25		 jge	 SHORT $LN40@SkillInnov

; 5120 : 					gObjCalDistance(lpObj,&gObj[tObjNum]) < 5 )
; 5121 : 				{
; 5122 : 					gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,700,lpMagic->m_Skill,0);

  0019e	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001a1	6a 00		 push	 0
  001a3	ff 70 08	 push	 DWORD PTR [eax+8]
  001a6	68 bc 02 00 00	 push	 700			; 000002bcH
  001ab	56		 push	 esi
  001ac	6a 32		 push	 50			; 00000032H
  001ae	57		 push	 edi
  001af	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 5123 : 					HitCount++;

  001b4	8b 5d f8	 mov	 ebx, DWORD PTR _HitCount$1$[ebp]
  001b7	83 c4 18	 add	 esp, 24			; 00000018H
  001ba	43		 inc	 ebx
  001bb	89 5d f8	 mov	 DWORD PTR _HitCount$1$[ebp], ebx

; 5124 : 
; 5125 : 					if(HitCount >= 5)

  001be	83 fb 05	 cmp	 ebx, 5
  001c1	7d 24		 jge	 SHORT $LN41@SkillInnov
$LN40@SkillInnov:
  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c9	eb 03		 jmp	 SHORT $LN46@SkillInnov
$LN44@SkillInnov:
  001cb	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN46@SkillInnov:
  001ce	8b 55 fc	 mov	 edx, DWORD PTR _count$1$[ebp]
  001d1	8b 45 18	 mov	 eax, DWORD PTR tv479[ebp]
$LN20@SkillInnov:

; 5126 : 					{
; 5127 : 						break;
; 5128 : 					}
; 5129 : 				}
; 5130 : 			}
; 5131 : 		}
; 5132 : 
; 5133 : 		count++;

  001d4	42		 inc	 edx
  001d5	83 c0 0c	 add	 eax, 12			; 0000000cH
  001d8	89 55 fc	 mov	 DWORD PTR _count$1$[ebp], edx
  001db	89 45 18	 mov	 DWORD PTR tv479[ebp], eax

; 5134 : 
; 5135 : 		if( count > MAX_VIEWPORT -1)

  001de	83 fa 4a	 cmp	 edx, 74			; 0000004aH
  001e1	0f 8e 79 fe ff
	ff		 jle	 $LL2@SkillInnov
$LN41@SkillInnov:
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi

; 5136 : 		{
; 5137 : 			break;
; 5138 : 		}
; 5139 : 	}
; 5140 : 
; 5141 : return bSuccess;

  001e9	33 c0		 xor	 eax, eax
  001eb	5b		 pop	 ebx

; 5142 : }

  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c2 14 00	 ret	 20			; 00000014H
?SkillInnovation@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ENDP ; CObjUseSkill::SkillInnovation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillWeakness@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -12					; size = 4
_HitCount$1$ = -8					; size = 4
_count$1$ = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
tv479 = 24						; size = 4
_aTargetIndex$ = 24					; size = 4
?SkillWeakness@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z PROC ; CObjUseSkill::SkillWeakness, COMDAT
; _this$ = ecx

; 4971 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4972 : 	LPOBJ lpObj = &gObj[aIndex];

  00009	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048

; 4973 : 	int bSuccess = FALSE;
; 4974 : 	int tObjNum;
; 4975 : 	int count = 0;
; 4976 : 	int HitCount = 0;
; 4977 : 	int DuelIndex = lpObj->m_iDuelUser;
; 4978 : 	int EnableAttack;
; 4979 : 
; 4980 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00010	6a 01		 push	 1
  00012	ff 75 18	 push	 DWORD PTR _aTargetIndex$[ebp]
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$1$[ebp], 0
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _HitCount$1$[ebp], 0
  00023	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	89 7d 08	 mov	 DWORD PTR _lpObj$1$[ebp], edi
  0002c	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]
  00032	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00035	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00038	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  0003c	50		 push	 eax
  0003d	57		 push	 edi
  0003e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	8d 87 4c 0c 00
	00		 lea	 eax, DWORD PTR [edi+3148]
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	89 45 18	 mov	 DWORD PTR tv479[ebp], eax
  00055	33 d2		 xor	 edx, edx
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@SkillWeakn:

; 4981 : 
; 4982 : 	while( TRUE )
; 4983 : 	{
; 4984 : 		if(lpObj->VpPlayer2[count].state != 0)

  00060	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  00064	0f 84 6a 01 00
	00		 je	 $LN20@SkillWeakn

; 4985 : 		{
; 4986 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0006a	0f bf 70 fe	 movsx	 esi, WORD PTR [eax-2]

; 4987 : 
; 4988 : 			if( tObjNum >= 0 )

  0006e	85 f6		 test	 esi, esi
  00070	0f 88 5e 01 00
	00		 js	 $LN20@SkillWeakn

; 4989 : 			{
; 4990 : 				EnableAttack = 0;
; 4991 : 
; 4992 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00076	8a 18		 mov	 bl, BYTE PTR [eax]
  00078	80 fb 02	 cmp	 bl, 2
  0007b	75 14		 jne	 SHORT $LN6@SkillWeakn
  0007d	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00083	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0008b	0f 8c f6 00 00
	00		 jl	 $LN12@SkillWeakn
$LN6@SkillWeakn:

; 4993 : 				{
; 4994 : 					EnableAttack = 1;
; 4995 : 				}
; 4996 : 				else if(DuelIndex == tObjNum)

  00091	39 75 f4	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  00094	0f 84 ed 00 00
	00		 je	 $LN12@SkillWeakn

; 4997 : 				{
; 4998 : 					EnableAttack = 1;
; 4999 : 				}
; 5000 : 				else if( CC_MAP_RANGE(lpObj->MapNumber) ||
; 5001 : 						 IT_MAP_RANGE(lpObj->MapNumber) ||

  0009a	8a 97 23 01 00
	00		 mov	 dl, BYTE PTR [edi+291]
  000a0	80 fa 35	 cmp	 dl, 53			; 00000035H
  000a3	0f 84 de 00 00
	00		 je	 $LN12@SkillWeakn
  000a9	80 fa 12	 cmp	 dl, 18			; 00000012H
  000ac	72 0f		 jb	 SHORT $LN36@SkillWeakn
  000ae	b0 17		 mov	 al, 23			; 00000017H
  000b0	3a c2		 cmp	 al, dl
  000b2	1b c0		 sbb	 eax, eax
  000b4	83 c0 01	 add	 eax, 1
  000b7	0f 85 ca 00 00
	00		 jne	 $LN12@SkillWeakn
$LN36@SkillWeakn:
  000bd	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  000c0	72 0f		 jb	 SHORT $LN37@SkillWeakn
  000c2	b0 32		 mov	 al, 50			; 00000032H
  000c4	3a c2		 cmp	 al, dl
  000c6	1b c0		 sbb	 eax, eax
  000c8	83 c0 01	 add	 eax, 1
  000cb	0f 85 b6 00 00
	00		 jne	 $LN12@SkillWeakn
$LN37@SkillWeakn:
  000d1	80 fa 3f	 cmp	 dl, 63			; 0000003fH
  000d4	0f 84 ad 00 00
	00		 je	 $LN12@SkillWeakn

; 5002 : 						 lpObj->MapNumber == MAP_INDEX_VULCANUS)
; 5003 : 				{
; 5004 : 					EnableAttack = 1;
; 5005 : 				}
; 5006 : #if (GS_CASTLE == 1)
; 5007 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000da	80 fb 03	 cmp	 bl, 3
  000dd	74 67		 je	 SHORT $LN13@SkillWeakn
  000df	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000e5	80 bc 0f 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+ecx+291], 30 ; 0000001eH
  000ed	75 54		 jne	 SHORT $LN45@SkillWeakn
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000f4	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 5008 : 				{
; 5009 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	83 f8 07	 cmp	 eax, 7
  00102	75 3f		 jne	 SHORT $LN45@SkillWeakn
  00104	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  00107	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  0010d	3a 84 0f 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+ecx+8282]
  00114	0f 84 b1 00 00
	00		 je	 $LN44@SkillWeakn

; 5010 : 					{
; 5011 : 						if( gObj[tObjNum].Class != 283 &&

  0011a	0f b7 84 0f 90
	00 00 00	 movzx	 eax, WORD PTR [edi+ecx+144]
  00122	ba 1b 01 00 00	 mov	 edx, 283		; 0000011bH

; 5012 : 							gObj[tObjNum].Class != 277 )
; 5013 : 							EnableAttack = 1;
; 5014 : 					}
; 5015 : 				}
; 5016 : #endif
; 5017 : 				else

  00127	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  0012a	66 3b c2	 cmp	 ax, dx
  0012d	0f 84 9b 00 00
	00		 je	 $LN46@SkillWeakn

; 5010 : 					{
; 5011 : 						if( gObj[tObjNum].Class != 283 &&

  00133	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  00138	66 3b c2	 cmp	 ax, dx
  0013b	0f 84 8d 00 00
	00		 je	 $LN46@SkillWeakn

; 5012 : 							gObj[tObjNum].Class != 277 )
; 5013 : 							EnableAttack = 1;
; 5014 : 					}
; 5015 : 				}
; 5016 : #endif
; 5017 : 				else

  00141	eb 44		 jmp	 SHORT $LN12@SkillWeakn
$LN45@SkillWeakn:
  00143	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN13@SkillWeakn:

; 5018 : 				{
; 5019 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  00146	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 5020 : 
; 5021 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  0014c	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00151	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00154	75 14		 jne	 SHORT $LN17@SkillWeakn
  00156	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  0015d	85 c0		 test	 eax, eax
  0015f	78 09		 js	 SHORT $LN17@SkillWeakn

; 5022 : 					{
; 5023 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00161	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00167	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN17@SkillWeakn:

; 5024 : 					}
; 5025 : 
; 5026 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  0016a	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00170	03 c1		 add	 eax, ecx
  00172	50		 push	 eax
  00173	57		 push	 edi
  00174	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00179	83 c4 08	 add	 esp, 8
  0017c	83 f8 01	 cmp	 eax, 1
  0017f	75 42		 jne	 SHORT $LN40@SkillWeakn
  00181	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN12@SkillWeakn:

; 5027 : 					{
; 5028 : 						EnableAttack = 1;
; 5029 : 					}
; 5030 : 				}
; 5031 : 
; 5032 : 				if( EnableAttack != 0 &&

  00187	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  0018d	03 c1		 add	 eax, ecx
  0018f	50		 push	 eax
  00190	57		 push	 edi
  00191	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00196	83 c4 08	 add	 esp, 8
  00199	83 f8 05	 cmp	 eax, 5
  0019c	7d 25		 jge	 SHORT $LN40@SkillWeakn

; 5033 : 					gObjCalDistance(lpObj,&gObj[tObjNum]) < 5 )
; 5034 : 				{
; 5035 : 					gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,700,lpMagic->m_Skill,0);

  0019e	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001a1	6a 00		 push	 0
  001a3	ff 70 08	 push	 DWORD PTR [eax+8]
  001a6	68 bc 02 00 00	 push	 700			; 000002bcH
  001ab	56		 push	 esi
  001ac	6a 32		 push	 50			; 00000032H
  001ae	57		 push	 edi
  001af	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 5036 : 					HitCount++;

  001b4	8b 5d f8	 mov	 ebx, DWORD PTR _HitCount$1$[ebp]
  001b7	83 c4 18	 add	 esp, 24			; 00000018H
  001ba	43		 inc	 ebx
  001bb	89 5d f8	 mov	 DWORD PTR _HitCount$1$[ebp], ebx

; 5037 : 
; 5038 : 					if(HitCount >= 5)

  001be	83 fb 05	 cmp	 ebx, 5
  001c1	7d 24		 jge	 SHORT $LN41@SkillWeakn
$LN40@SkillWeakn:
  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c9	eb 03		 jmp	 SHORT $LN46@SkillWeakn
$LN44@SkillWeakn:
  001cb	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN46@SkillWeakn:
  001ce	8b 55 fc	 mov	 edx, DWORD PTR _count$1$[ebp]
  001d1	8b 45 18	 mov	 eax, DWORD PTR tv479[ebp]
$LN20@SkillWeakn:

; 5039 : 					{
; 5040 : 						break;
; 5041 : 					}
; 5042 : 				}
; 5043 : 			}
; 5044 : 		}
; 5045 : 
; 5046 : 		count++;

  001d4	42		 inc	 edx
  001d5	83 c0 0c	 add	 eax, 12			; 0000000cH
  001d8	89 55 fc	 mov	 DWORD PTR _count$1$[ebp], edx
  001db	89 45 18	 mov	 DWORD PTR tv479[ebp], eax

; 5047 : 
; 5048 : 		if( count > MAX_VIEWPORT -1)

  001de	83 fa 4a	 cmp	 edx, 74			; 0000004aH
  001e1	0f 8e 79 fe ff
	ff		 jle	 $LL2@SkillWeakn
$LN41@SkillWeakn:
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi

; 5049 : 		{
; 5050 : 			break;
; 5051 : 		}
; 5052 : 	}
; 5053 : 
; 5054 : return bSuccess;

  001e9	33 c0		 xor	 eax, eax
  001eb	5b		 pop	 ebx

; 5055 : }

  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c2 14 00	 ret	 20			; 00000014H
?SkillWeakness@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ENDP ; CObjUseSkill::SkillWeakness
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillSleep@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -16					; size = 4
_count$1$ = -12						; size = 4
_lpObj$1$ = -8						; size = 4
tv485 = -4						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillSleep@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillSleep, COMDAT
; _this$ = ecx

; 4889 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4890 : 	LPOBJ lpObj = &gObj[aIndex];
; 4891 : 	int bSuccess = FALSE;
; 4892 : 	int tObjNum;
; 4893 : 
; 4894 : 	int Angle = GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);
; 4895 : 	int count = 0;
; 4896 : 
; 4897 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00006	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00013	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00017	6a 01		 push	 1
  00019	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0001c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$1$[ebp], 0
  00023	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	89 7d f8	 mov	 DWORD PTR _lpObj$1$[ebp], edi
  0002e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 4898 : 
; 4899 : 	int DuelIndex = lpObj->m_iDuelUser;

  00033	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]
  00039	8d 97 4c 0c 00
	00		 lea	 edx, DWORD PTR [edi+3148]
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	89 45 f0	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  0004b	33 c0		 xor	 eax, eax
  0004d	89 55 fc	 mov	 DWORD PTR tv485[ebp], edx
$LL2@SkillSleep:

; 4900 : 	int EnableAttack;
; 4901 : 
; 4902 : 	while( TRUE )
; 4903 : 	{
; 4904 : 		if(lpObj->VpPlayer2[count].state != 0)

  00050	80 7a fc 00	 cmp	 BYTE PTR [edx-4], 0
  00054	0f 84 32 01 00
	00		 je	 $LN19@SkillSleep

; 4905 : 		{
; 4906 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0005a	0f bf 72 fe	 movsx	 esi, WORD PTR [edx-2]

; 4907 : 
; 4908 : 			if( tObjNum >= 0 )

  0005e	85 f6		 test	 esi, esi
  00060	0f 88 26 01 00
	00		 js	 $LN19@SkillSleep

; 4909 : 			{
; 4910 : 				EnableAttack = 0;
; 4911 : 
; 4912 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00066	8a 1a		 mov	 bl, BYTE PTR [edx]
  00068	80 fb 02	 cmp	 bl, 2
  0006b	75 14		 jne	 SHORT $LN6@SkillSleep
  0006d	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00073	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0007b	0f 8c dd 00 00
	00		 jl	 $LN13@SkillSleep
$LN6@SkillSleep:

; 4913 : 				{
; 4914 : 					EnableAttack = 1;
; 4915 : 				}
; 4916 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00081	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00084	0f 84 dd 00 00
	00		 je	 $LN47@SkillSleep
  0008a	39 75 f0	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  0008d	0f 84 cb 00 00
	00		 je	 $LN13@SkillSleep

; 4917 : 				{
; 4918 : 					EnableAttack = 1;
; 4919 : 				}
; 4920 : 				else if( CC_MAP_RANGE(lpObj->MapNumber) ||
; 4921 : 						 IT_MAP_RANGE(lpObj->MapNumber) ||

  00093	8a 97 23 01 00
	00		 mov	 dl, BYTE PTR [edi+291]
  00099	80 fa 35	 cmp	 dl, 53			; 00000035H
  0009c	0f 84 b9 00 00
	00		 je	 $LN45@SkillSleep
  000a2	80 fa 12	 cmp	 dl, 18			; 00000012H
  000a5	72 0f		 jb	 SHORT $LN35@SkillSleep
  000a7	b0 17		 mov	 al, 23			; 00000017H
  000a9	3a c2		 cmp	 al, dl
  000ab	1b c0		 sbb	 eax, eax
  000ad	83 c0 01	 add	 eax, 1
  000b0	0f 85 a5 00 00
	00		 jne	 $LN45@SkillSleep
$LN35@SkillSleep:
  000b6	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  000b9	72 0f		 jb	 SHORT $LN36@SkillSleep
  000bb	b0 32		 mov	 al, 50			; 00000032H
  000bd	3a c2		 cmp	 al, dl
  000bf	1b c0		 sbb	 eax, eax
  000c1	83 c0 01	 add	 eax, 1
  000c4	0f 85 91 00 00
	00		 jne	 $LN45@SkillSleep
$LN36@SkillSleep:
  000ca	80 fa 3f	 cmp	 dl, 63			; 0000003fH
  000cd	0f 84 88 00 00
	00		 je	 $LN45@SkillSleep

; 4922 : 						 lpObj->MapNumber == MAP_INDEX_VULCANUS )
; 4923 : 				{
; 4924 : 					EnableAttack = 1;
; 4925 : 				}
; 4926 : #if (GS_CASTLE == 1)
; 4927 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000d3	80 fb 03	 cmp	 bl, 3
  000d6	74 42		 je	 SHORT $LN14@SkillSleep
  000d8	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000de	80 bc 0f 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+ecx+291], 30 ; 0000001eH
  000e6	75 2f		 jne	 SHORT $LN46@SkillSleep
  000e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000ed	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 4928 : 				{
; 4929 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f8	83 f8 07	 cmp	 eax, 7
  000fb	75 1a		 jne	 SHORT $LN46@SkillSleep
  000fd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$1$[ebp]

; 4930 : 						EnableAttack = 1;
; 4931 : 				}
; 4932 : #endif
; 4933 : 				else

  00100	8b 55 fc	 mov	 edx, DWORD PTR tv485[ebp]
  00103	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  00109	3a 84 0f 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+ecx+8282]
  00110	74 77		 je	 SHORT $LN48@SkillSleep
  00112	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  00115	eb 47		 jmp	 SHORT $LN13@SkillSleep
$LN46@SkillSleep:
  00117	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN14@SkillSleep:

; 4934 : 				{
; 4935 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0011a	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 4936 : 
; 4937 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00120	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00125	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00128	75 14		 jne	 SHORT $LN17@SkillSleep
  0012a	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  00131	85 c0		 test	 eax, eax
  00133	78 09		 js	 SHORT $LN17@SkillSleep

; 4938 : 					{
; 4939 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00135	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0013b	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN17@SkillSleep:

; 4940 : 					}
; 4941 : 
; 4942 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  0013e	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00144	03 c1		 add	 eax, ecx
  00146	50		 push	 eax
  00147	57		 push	 edi
  00148	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0014d	83 c4 08	 add	 esp, 8
  00150	83 f8 01	 cmp	 eax, 1
  00153	75 2b		 jne	 SHORT $LN40@SkillSleep
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN45@SkillSleep:
  0015b	8b 55 fc	 mov	 edx, DWORD PTR tv485[ebp]
$LN13@SkillSleep:

; 4943 : 					{
; 4944 : 						EnableAttack = 1;
; 4945 : 					}
; 4946 : 				}
; 4947 : 
; 4948 : 				if( EnableAttack != 0 &&
; 4949 : 					tObjNum == aTargetIndex && 

  0015e	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00161	3b f3		 cmp	 esi, ebx
  00163	75 24		 jne	 SHORT $LN48@SkillSleep
  00165	eb 03		 jmp	 SHORT $LN37@SkillSleep
$LN47@SkillSleep:
  00167	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
$LN37@SkillSleep:
  0016a	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0016d	ff 76 08	 push	 DWORD PTR [esi+8]
  00170	53		 push	 ebx
  00171	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00174	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017c	85 c0		 test	 eax, eax
  0017e	75 23		 jne	 SHORT $LN30@SkillSleep
$LN40@SkillSleep:
  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00186	8b 55 fc	 mov	 edx, DWORD PTR tv485[ebp]
$LN48@SkillSleep:
  00189	8b 45 f4	 mov	 eax, DWORD PTR _count$1$[ebp]
$LN19@SkillSleep:

; 4953 : 					bSuccess = TRUE;
; 4954 : 					break;
; 4955 : 				}
; 4956 : 			}
; 4957 : 		}
; 4958 : 
; 4959 : 		count++;

  0018c	40		 inc	 eax
  0018d	83 c2 0c	 add	 edx, 12			; 0000000cH
  00190	89 45 f4	 mov	 DWORD PTR _count$1$[ebp], eax
  00193	89 55 fc	 mov	 DWORD PTR tv485[ebp], edx

; 4960 : 
; 4961 : 		if( count > MAX_VIEWPORT -1)

  00196	83 f8 4a	 cmp	 eax, 74			; 0000004aH
  00199	7f 39		 jg	 SHORT $LN38@SkillSleep

; 4962 : 		{
; 4963 : 			break;
; 4964 : 		}
; 4965 : 	}

  0019b	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  0019e	e9 ad fe ff ff	 jmp	 $LL2@SkillSleep
$LN30@SkillSleep:

; 4950 : 					gCheckSkillDistance(aIndex,aTargetIndex,lpMagic->m_Skill) != FALSE )
; 4951 : 				{
; 4952 : 					gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,1,0,0,0,0,0);

  001a3	6a 00		 push	 0
  001a5	6a 00		 push	 0
  001a7	6a 00		 push	 0
  001a9	6a 00		 push	 0
  001ab	6a 00		 push	 0
  001ad	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048
  001b3	6a 01		 push	 1
  001b5	56		 push	 esi
  001b6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bc	50		 push	 eax
  001bd	57		 push	 edi
  001be	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  001c3	83 c4 24	 add	 esp, 36			; 00000024H

; 4966 : 
; 4967 : return bSuccess;

  001c6	b8 01 00 00 00	 mov	 eax, 1
  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	5b		 pop	 ebx

; 4968 : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c2 0c 00	 ret	 12			; 0000000cH
$LN38@SkillSleep:
  001d4	5f		 pop	 edi
  001d5	5e		 pop	 esi

; 4966 : 
; 4967 : return bSuccess;

  001d6	33 c0		 xor	 eax, eax
  001d8	5b		 pop	 ebx

; 4968 : }

  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c2 0c 00	 ret	 12			; 0000000cH
?SkillSleep@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillSleep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDamageReflect@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpTargetObj$1$ = -16					; size = 4
_DuelIndex$1$ = -12					; size = 4
_count$1$ = -8						; size = 4
_Time$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Reflect$1$ = 12					; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillDamageReflect@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillDamageReflect, COMDAT
; _this$ = ecx

; 4782 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 4783 : 	LPOBJ lpObj = &gObj[aIndex];
; 4784 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  0000a	56		 push	 esi
  0000b	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00011	57		 push	 edi
  00012	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00019	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001f	89 75 f0	 mov	 DWORD PTR _lpTargetObj$1$[ebp], esi
  00022	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 4785 : 
; 4786 : 	if( lpTargetObj->Type != OBJ_USER || lpObj->Class != CLASS_SUMMONER )

  00028	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0002c	0f 85 da 00 00
	00		 jne	 $LN5@SkillDamag
  00032	66 83 bf 90 00
	00 00 05	 cmp	 WORD PTR [edi+144], 5
  0003a	0f 85 cc 00 00
	00		 jne	 $LN5@SkillDamag

; 4789 : 	}
; 4790 : 
; 4791 : 	int bSuccess = FALSE;
; 4792 : 	int tObjNum;
; 4793 : 
; 4794 : 	int Angle = GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);
; 4795 : 	int count = 0;
; 4796 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00040	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00043	6a 01		 push	 1
  00045	53		 push	 ebx
  00046	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$1$[ebp], 0
  0004d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00051	50		 push	 eax
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 4797 : 	int DuelIndex = lpObj->m_iDuelUser;

  00058	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax

; 4798 : 	int EnableAttack;
; 4799 : 
; 4800 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00064	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  00069	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0006c	ff 70 08	 push	 DWORD PTR [eax+8]
  0006f	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  00074	8b c8		 mov	 ecx, eax

; 4801 : 
; 4802 : 	if( !lpInfo )

  00076	85 c9		 test	 ecx, ecx
  00078	0f 84 8e 00 00
	00		 je	 $LN5@SkillDamag

; 4803 : 	{
; 4804 : 		return 0;
; 4805 : 	}
; 4806 : 
; 4807 : 	int Reflect = lpInfo->m_Arg1 + lpObj->Energy / lpInfo->m_Arg2;

  0007e	0f b7 87 d6 00
	00 00		 movzx	 eax, WORD PTR [edi+214]

; 4808 : 
; 4809 : 	if( Reflect > lpInfo->m_Arg3 )

  00085	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [ecx+12]
  0008a	66 0f 6e c8	 movd	 xmm1, eax
  0008e	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00091	0f 28 c1	 movaps	 xmm0, xmm1
  00094	f3 0f 5e 41 08	 divss	 xmm0, DWORD PTR [ecx+8]
  00099	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0009e	f3 0f 2c c0	 cvttss2si eax, xmm0
  000a2	89 45 0c	 mov	 DWORD PTR _Reflect$1$[ebp], eax
  000a5	66 0f 6e c0	 movd	 xmm0, eax
  000a9	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ac	0f 2f c2	 comiss	 xmm0, xmm2
  000af	76 07		 jbe	 SHORT $LN7@SkillDamag

; 4810 : 		Reflect = lpInfo->m_Arg3;

  000b1	f3 0f 2c c2	 cvttss2si eax, xmm2
  000b5	89 45 0c	 mov	 DWORD PTR _Reflect$1$[ebp], eax
$LN7@SkillDamag:

; 4811 : 
; 4812 : 	int Time = lpInfo->m_Arg4 + lpObj->Energy / lpInfo->m_Arg5;

  000b8	f3 0f 5e 49 14	 divss	 xmm1, DWORD PTR [ecx+20]
  000bd	f3 0f 58 49 10	 addss	 xmm1, DWORD PTR [ecx+16]
  000c2	f3 0f 2c d1	 cvttss2si edx, xmm1

; 4813 : 
; 4814 : 	if( Time > lpInfo->m_Arg6 )

  000c6	f3 0f 10 49 18	 movss	 xmm1, DWORD PTR [ecx+24]
  000cb	89 55 fc	 mov	 DWORD PTR _Time$1$[ebp], edx
  000ce	66 0f 6e c2	 movd	 xmm0, edx
  000d2	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000d5	0f 2f c1	 comiss	 xmm0, xmm1
  000d8	76 07		 jbe	 SHORT $LN8@SkillDamag

; 4815 : 		Time = lpInfo->m_Arg6;

  000da	f3 0f 2c c9	 cvttss2si ecx, xmm1
  000de	89 4d fc	 mov	 DWORD PTR _Time$1$[ebp], ecx
$LN8@SkillDamag:

; 4816 : 
; 4817 : 	if( aIndex == aTargetIndex )

  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000e4	3b cb		 cmp	 ecx, ebx
  000e6	75 55		 jne	 SHORT $LN39@SkillDamag

; 4818 : 	{
; 4819 : 		if( gObjCheckPowerfulEffect(lpObj,BUFF_DAMAGEREFLECT,Reflect,0) == TRUE )

  000e8	6a 00		 push	 0
  000ea	50		 push	 eax
  000eb	6a 47		 push	 71			; 00000047H
  000ed	57		 push	 edi
  000ee	e8 00 00 00 00	 call	 ?gObjCheckPowerfulEffect@@YA_NPAUOBJECTSTRUCT@@HHH@Z ; gObjCheckPowerfulEffect
  000f3	83 c4 10	 add	 esp, 16			; 00000010H
  000f6	3c 01		 cmp	 al, 1
  000f8	75 1d		 jne	 SHORT $LN11@SkillDamag

; 4820 : 		{
; 4821 : 			GCMagicAttackNumberSend(lpObj,0xD9,lpTargetObj->m_Index,0);

  000fa	6a 00		 push	 0
  000fc	ff 36		 push	 DWORD PTR [esi]
  000fe	68 d9 00 00 00	 push	 217			; 000000d9H
  00103	57		 push	 edi

; 4863 : 								{
; 4864 : 									GCMagicAttackNumberSend(lpTargetObj,0xD9,lpTargetObj->m_Index,0);

  00104	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00109	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@SkillDamag:

; 4787 : 	{
; 4788 : 		return FALSE;

  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	33 c0		 xor	 eax, eax
  00110	5b		 pop	 ebx

; 4880 : 			{
; 4881 : 				break;
; 4882 : 			}
; 4883 : 		}
; 4884 : 	}
; 4885 : return bSuccess;
; 4886 : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 0c 00	 ret	 12			; 0000000cH
$LN11@SkillDamag:

; 4822 : 			return FALSE;
; 4823 : 		}
; 4824 : 
; 4825 : 		gObjAddBuffEffect(lpObj,BUFF_DAMAGEREFLECT,ADD_OPTION_REFLECTDAMAGE,Reflect,0,0,Time);

  00117	ff 75 fc	 push	 DWORD PTR _Time$1$[ebp]
  0011a	8b 5d 0c	 mov	 ebx, DWORD PTR _Reflect$1$[ebp]
  0011d	6a 00		 push	 0
  0011f	6a 00		 push	 0
  00121	53		 push	 ebx
  00122	6a 18		 push	 24			; 00000018H
  00124	6a 47		 push	 71			; 00000047H
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  0012c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4826 : 		bSuccess = TRUE;

  0012f	b8 01 00 00 00	 mov	 eax, 1
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5b		 pop	 ebx

; 4880 : 			{
; 4881 : 				break;
; 4882 : 			}
; 4883 : 		}
; 4884 : 	}
; 4885 : return bSuccess;
; 4886 : }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 0c 00	 ret	 12			; 0000000cH
$LN39@SkillDamag:
  0013d	8d b7 4a 0c 00
	00		 lea	 esi, DWORD PTR [edi+3146]
$LL2@SkillDamag:

; 4827 : 	}
; 4828 : 	else
; 4829 : 	{
; 4830 : 		while( TRUE )
; 4831 : 		{
; 4832 : 			if( CC_MAP_RANGE(lpObj->MapNumber) )

  00143	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  00149	3c 35		 cmp	 al, 53			; 00000035H
  0014b	74 bf		 je	 SHORT $LN5@SkillDamag
  0014d	3c 12		 cmp	 al, 18			; 00000012H
  0014f	72 0b		 jb	 SHORT $LN37@SkillDamag
  00151	b2 17		 mov	 dl, 23			; 00000017H
  00153	3a d0		 cmp	 dl, al
  00155	1b c0		 sbb	 eax, eax
  00157	83 c0 01	 add	 eax, 1
  0015a	75 b0		 jne	 SHORT $LN5@SkillDamag
$LN37@SkillDamag:

; 4833 : 			{
; 4834 : 				break;
; 4835 : 			}
; 4836 : 
; 4837 : 			if(lpObj->VpPlayer2[count].state != 0)

  0015c	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00160	74 31		 je	 SHORT $LN21@SkillDamag

; 4838 : 			{
; 4839 : 				tObjNum = lpObj->VpPlayer2[count].number;

  00162	0f bf 06	 movsx	 eax, WORD PTR [esi]

; 4840 : 
; 4841 : 				if( tObjNum >= 0 )

  00165	85 c0		 test	 eax, eax
  00167	78 2a		 js	 SHORT $LN21@SkillDamag

; 4842 : 				{
; 4843 : 					EnableAttack = FALSE;
; 4844 : 
; 4845 : 					if( lpObj->VpPlayer2[count].type == OBJ_USER )

  00169	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  0016d	74 09		 je	 SHORT $LN18@SkillDamag

; 4846 : 					{
; 4847 : 						EnableAttack = TRUE;
; 4848 : 					}
; 4849 : 					else if( tObjNum == aTargetIndex || DuelIndex != tObjNum)

  0016f	3b c3		 cmp	 eax, ebx
  00171	74 09		 je	 SHORT $LN41@SkillDamag
  00173	39 45 f4	 cmp	 DWORD PTR _DuelIndex$1$[ebp], eax
  00176	74 1b		 je	 SHORT $LN21@SkillDamag
$LN18@SkillDamag:

; 4850 : 					{
; 4851 : 						EnableAttack = TRUE;
; 4852 : 					}
; 4853 : 
; 4854 : 					if( EnableAttack != 0 )
; 4855 : 					{
; 4856 : 						if( tObjNum == aTargetIndex )

  00178	3b c3		 cmp	 eax, ebx
  0017a	75 17		 jne	 SHORT $LN21@SkillDamag
$LN41@SkillDamag:

; 4857 : 						{
; 4858 : 							if( gCheckSkillDistance(aIndex,aTargetIndex,lpMagic->m_Skill) )

  0017c	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0017f	ff 70 08	 push	 DWORD PTR [eax+8]
  00182	53		 push	 ebx
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  00189	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018c	85 c0		 test	 eax, eax
  0018e	75 1d		 jne	 SHORT $LN31@SkillDamag
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
$LN21@SkillDamag:

; 4870 : 								break;
; 4871 : 							}
; 4872 : 						}
; 4873 : 					}
; 4874 : 				}
; 4875 : 			}
; 4876 : 
; 4877 : 			count++;

  00193	8b 45 f8	 mov	 eax, DWORD PTR _count$1$[ebp]
  00196	83 c6 0c	 add	 esi, 12			; 0000000cH
  00199	40		 inc	 eax
  0019a	89 45 f8	 mov	 DWORD PTR _count$1$[ebp], eax

; 4878 : 
; 4879 : 			if( count > MAX_VIEWPORT -1)

  0019d	83 f8 4a	 cmp	 eax, 74			; 0000004aH
  001a0	7e a1		 jle	 SHORT $LL2@SkillDamag

; 4787 : 	{
; 4788 : 		return FALSE;

  001a2	5f		 pop	 edi
  001a3	5e		 pop	 esi
  001a4	33 c0		 xor	 eax, eax
  001a6	5b		 pop	 ebx

; 4880 : 			{
; 4881 : 				break;
; 4882 : 			}
; 4883 : 		}
; 4884 : 	}
; 4885 : return bSuccess;
; 4886 : }

  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c2 0c 00	 ret	 12			; 0000000cH
$LN31@SkillDamag:

; 4859 : 							{
; 4860 : 								lpTargetObj->lpAttackObj = lpObj;

  001ad	8b 75 f0	 mov	 esi, DWORD PTR _lpTargetObj$1$[ebp]

; 4861 : 
; 4862 : 								if( gObjCheckPowerfulEffect(lpTargetObj,BUFF_DAMAGEREFLECT,Reflect,0) == TRUE )

  001b0	8b 5d 0c	 mov	 ebx, DWORD PTR _Reflect$1$[ebp]
  001b3	6a 00		 push	 0
  001b5	53		 push	 ebx
  001b6	6a 47		 push	 71			; 00000047H
  001b8	56		 push	 esi
  001b9	89 be b4 05 00
	00		 mov	 DWORD PTR [esi+1460], edi
  001bf	e8 00 00 00 00	 call	 ?gObjCheckPowerfulEffect@@YA_NPAUOBJECTSTRUCT@@HHH@Z ; gObjCheckPowerfulEffect
  001c4	83 c4 10	 add	 esp, 16			; 00000010H
  001c7	3c 01		 cmp	 al, 1
  001c9	75 1d		 jne	 SHORT $LN22@SkillDamag

; 4863 : 								{
; 4864 : 									GCMagicAttackNumberSend(lpTargetObj,0xD9,lpTargetObj->m_Index,0);

  001cb	6a 00		 push	 0
  001cd	ff 36		 push	 DWORD PTR [esi]
  001cf	68 d9 00 00 00	 push	 217			; 000000d9H
  001d4	56		 push	 esi
  001d5	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  001da	83 c4 10	 add	 esp, 16			; 00000010H
  001dd	33 c0		 xor	 eax, eax
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5b		 pop	 ebx

; 4880 : 			{
; 4881 : 				break;
; 4882 : 			}
; 4883 : 		}
; 4884 : 	}
; 4885 : return bSuccess;
; 4886 : }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c2 0c 00	 ret	 12			; 0000000cH
$LN22@SkillDamag:

; 4865 : 									return FALSE;
; 4866 : 								}
; 4867 : 
; 4868 : 								gObjAddBuffEffect(lpTargetObj,BUFF_DAMAGEREFLECT,ADD_OPTION_REFLECTDAMAGE,Reflect,0,0,Time);

  001e8	ff 75 fc	 push	 DWORD PTR _Time$1$[ebp]
  001eb	6a 00		 push	 0
  001ed	6a 00		 push	 0
  001ef	53		 push	 ebx
  001f0	6a 18		 push	 24			; 00000018H
  001f2	6a 47		 push	 71			; 00000047H
  001f4	56		 push	 esi
  001f5	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  001fa	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4869 : 								bSuccess = TRUE;

  001fd	b8 01 00 00 00	 mov	 eax, 1
  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx

; 4880 : 			{
; 4881 : 				break;
; 4882 : 			}
; 4883 : 		}
; 4884 : 	}
; 4885 : return bSuccess;
; 4886 : }

  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c2 0c 00	 ret	 12			; 0000000cH
?SkillDamageReflect@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillDamageReflect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillCurse@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -12					; size = 4
tv473 = -8						; size = 4
_lpObj$1$ = -4						; size = 4
_bSuccess$1$ = 8					; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
tv472 = 16						; size = 4
_X$ = 16						; size = 1
tv475 = 20						; size = 4
_Y$ = 20						; size = 1
_aTargetIndex$ = 24					; size = 4
?SkillCurse@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z PROC	; CObjUseSkill::SkillCurse, COMDAT
; _this$ = ecx

; 4707 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 4708 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  0000e	56		 push	 esi

; 4709 : 	int bSuccess = FALSE;
; 4710 : 	int count = 0;
; 4711 : 	int tObjNum;
; 4712 : 	int DuelIndex = lpObj->m_iDuelUser;
; 4713 : 
; 4714 : 	int Angle = GetAngle(lpObj->X,lpObj->Y,X,Y);
; 4715 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  0000f	8b 75 0c	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  00012	57		 push	 edi
  00013	6a 01		 push	 1
  00015	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001b	8b f9		 mov	 edi, ecx
  0001d	ff 75 18	 push	 DWORD PTR _aTargetIndex$[ebp]
  00020	89 5d fc	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00023	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _bSuccess$1$[ebp], 0
  0002a	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00030	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00033	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00037	50		 push	 eax
  00038	53		 push	 ebx
  00039	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 4716 : 	int Distance = MagicDamageC.GetSkillDistance(lpMagic->m_Skill);

  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00046	ff 76 08	 push	 DWORD PTR [esi+8]
  00049	e8 00 00 00 00	 call	 ?GetSkillDistance@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillDistance

; 4717 : 	int EnableAttack;
; 4718 : 
; 4719 : 	if( CalDistance(lpObj->X,lpObj->Y,X,Y) <= Distance )

  0004e	0f b6 4d 10	 movzx	 ecx, BYTE PTR _X$[ebp]
  00052	8b f0		 mov	 esi, eax
  00054	0f b6 45 14	 movzx	 eax, BYTE PTR _Y$[ebp]
  00058	50		 push	 eax
  00059	89 45 f8	 mov	 DWORD PTR tv473[ebp], eax
  0005c	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00063	51		 push	 ecx
  00064	50		 push	 eax
  00065	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  0006c	89 4d 10	 mov	 DWORD PTR tv472[ebp], ecx
  0006f	8b cf		 mov	 ecx, edi
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  00077	3b c6		 cmp	 eax, esi
  00079	0f 8f 2e 01 00
	00		 jg	 $LN23@SkillCurse

; 4708 : 	LPOBJ lpObj = &gObj[aIndex];

  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	8d bb 4a 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3146]
  0008b	c7 45 14 4b 00
	00 00		 mov	 DWORD PTR tv475[ebp], 75 ; 0000004bH
  00092	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@SkillCurse:

; 4720 : 	{
; 4721 : 		while( TRUE )
; 4722 : 		{
; 4723 : 			if(lpObj->VpPlayer2[count].state != 0)

  000a0	80 7f fe 00	 cmp	 BYTE PTR [edi-2], 0
  000a4	0f 84 e6 00 00
	00		 je	 $LN30@SkillCurse

; 4724 : 			{
; 4725 : 				tObjNum = lpObj->VpPlayer2[count].number;

  000aa	0f bf 37	 movsx	 esi, WORD PTR [edi]

; 4726 : 
; 4727 : 				if( tObjNum >= 0 )

  000ad	85 f6		 test	 esi, esi
  000af	0f 88 db 00 00
	00		 js	 $LN30@SkillCurse

; 4728 : 				{
; 4729 : 					EnableAttack = 0;
; 4730 : 
; 4731 : 					if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  000b5	80 7f 02 02	 cmp	 BYTE PTR [edi+2], 2
  000b9	75 10		 jne	 SHORT $LN7@SkillCurse
  000bb	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  000c1	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  000c9	7c 4b		 jl	 SHORT $LN11@SkillCurse
$LN7@SkillCurse:

; 4732 : 					{
; 4733 : 						EnableAttack = 1;
; 4734 : 					}
; 4735 : 					else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000cb	3b 75 18	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  000ce	74 46		 je	 SHORT $LN11@SkillCurse
  000d0	39 75 f4	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000d3	74 41		 je	 SHORT $LN11@SkillCurse

; 4736 : 					{
; 4737 : 						EnableAttack = 1;
; 4738 : 					}
; 4739 : 					else
; 4740 : 					{
; 4741 : 						int CallMonIndex = gObj[tObjNum].m_Index;

  000d5	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 4742 : 	
; 4743 : 						if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000db	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  000e0	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  000e3	75 14		 jne	 SHORT $LN12@SkillCurse
  000e5	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  000ec	85 c0		 test	 eax, eax
  000ee	78 09		 js	 SHORT $LN12@SkillCurse

; 4744 : 						{
; 4745 : 							CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000f0	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000f6	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN12@SkillCurse:

; 4746 : 						}
; 4747 : 	
; 4748 : 						if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000f9	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  000ff	03 c1		 add	 eax, ecx
  00101	50		 push	 eax
  00102	53		 push	 ebx
  00103	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010e	83 c4 08	 add	 esp, 8
  00111	83 f8 01	 cmp	 eax, 1
  00114	75 77		 jne	 SHORT $LN25@SkillCurse
$LN11@SkillCurse:

; 4749 : 						{
; 4750 : 							EnableAttack = 1;
; 4751 : 						}
; 4752 : 					}
; 4753 : 					
; 4754 : 					if( EnableAttack != 0 )
; 4755 : 					{
; 4756 : 						if( gObj[tObjNum].X >= (X -2) &&
; 4757 : 						gObj[tObjNum].X <= (X +2) &&
; 4758 : 						gObj[tObjNum].Y >= (Y -2) &&

  00116	8b 45 10	 mov	 eax, DWORD PTR tv472[ebp]
  00119	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  0011f	83 c0 fe	 add	 eax, -2			; fffffffeH
  00122	0f b6 9c 0a 20
	01 00 00	 movzx	 ebx, BYTE PTR [edx+ecx+288]
  0012a	3b d8		 cmp	 ebx, eax
  0012c	7c 5c		 jl	 SHORT $LN28@SkillCurse
  0012e	8b 45 10	 mov	 eax, DWORD PTR tv472[ebp]
  00131	83 c0 02	 add	 eax, 2
  00134	3b d8		 cmp	 ebx, eax
  00136	7f 52		 jg	 SHORT $LN28@SkillCurse
  00138	8b 45 f8	 mov	 eax, DWORD PTR tv473[ebp]
  0013b	0f b6 9c 0a 21
	01 00 00	 movzx	 ebx, BYTE PTR [edx+ecx+289]
  00143	83 c0 fe	 add	 eax, -2			; fffffffeH
  00146	3b d8		 cmp	 ebx, eax
  00148	7c 40		 jl	 SHORT $LN28@SkillCurse
  0014a	8b 45 f8	 mov	 eax, DWORD PTR tv473[ebp]
  0014d	83 c0 02	 add	 eax, 2
  00150	3b d8		 cmp	 ebx, eax

; 4759 : 						gObj[tObjNum].Y <= (Y +2) )
; 4760 : 						{
; 4761 : 							gObj[tObjNum].lpAttackObj = lpObj;

  00152	8b 5d fc	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  00155	7f 36		 jg	 SHORT $LN25@SkillCurse

; 4762 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,1000,lpMagic->m_Skill,0);

  00157	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0015a	6a 00		 push	 0
  0015c	89 9c 0a b4 05
	00 00		 mov	 DWORD PTR [edx+ecx+1460], ebx
  00163	ff 70 08	 push	 DWORD PTR [eax+8]
  00166	68 e8 03 00 00	 push	 1000			; 000003e8H
  0016b	56		 push	 esi
  0016c	6a 32		 push	 50			; 00000032H
  0016e	53		 push	 ebx
  0016f	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 4763 : 							bSuccess = TRUE;

  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017a	ba 01 00 00 00	 mov	 edx, 1
  0017f	8b 45 14	 mov	 eax, DWORD PTR tv475[ebp]
  00182	83 c4 18	 add	 esp, 24			; 00000018H
  00185	89 55 08	 mov	 DWORD PTR _bSuccess$1$[ebp], edx
  00188	eb 09		 jmp	 SHORT $LN15@SkillCurse
$LN28@SkillCurse:
  0018a	8b 5d fc	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
$LN25@SkillCurse:
  0018d	8b 45 14	 mov	 eax, DWORD PTR tv475[ebp]
$LN30@SkillCurse:
  00190	8b 55 08	 mov	 edx, DWORD PTR _bSuccess$1$[ebp]
$LN15@SkillCurse:

; 4764 : 						}
; 4765 : 					}
; 4766 : 				}
; 4767 : 			}
; 4768 : 
; 4769 : 			count++;

  00193	83 c7 0c	 add	 edi, 12			; 0000000cH

; 4770 : 
; 4771 : 			if( count > MAX_VIEWPORT -1)

  00196	83 e8 01	 sub	 eax, 1
  00199	89 45 14	 mov	 DWORD PTR tv475[ebp], eax
  0019c	0f 85 fe fe ff
	ff		 jne	 $LL2@SkillCurse

; 4772 : 			{
; 4773 : 				break;
; 4774 : 			}
; 4775 : 		}
; 4776 : 	}
; 4777 : return bSuccess;

  001a2	5f		 pop	 edi
  001a3	5e		 pop	 esi
  001a4	8b c2		 mov	 eax, edx
  001a6	5b		 pop	 ebx

; 4778 : }

  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c2 14 00	 ret	 20			; 00000014H
$LN23@SkillCurse:
  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi

; 4772 : 			{
; 4773 : 				break;
; 4774 : 			}
; 4775 : 		}
; 4776 : 	}
; 4777 : return bSuccess;

  001af	33 c0		 xor	 eax, eax
  001b1	5b		 pop	 ebx

; 4778 : }

  001b2	8b e5		 mov	 esp, ebp
  001b4	5d		 pop	 ebp
  001b5	c2 14 00	 ret	 20			; 00000014H
?SkillCurse@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ENDP	; CObjUseSkill::SkillCurse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillLightExplode@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0HHHH@Z
_TEXT	SEGMENT
tv402 = 8						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_SkillNumber$ = 16					; size = 4
tv406 = 20						; size = 4
_AttackDamage$ = 20					; size = 4
_Distance$ = 24						; size = 4
_Damage$1$ = 28						; size = 4
_DmgPerc$ = 28						; size = 4
?SkillLightExplode@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0HHHH@Z PROC ; CObjUseSkill::SkillLightExplode, COMDAT
; _this$ = ecx

; 4410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 4411 : 	if( gObjIsConnected(lpObj->m_Index) == FALSE &&

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00007	ff 37		 push	 DWORD PTR [edi]
  00009	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 18		 jne	 SHORT $LN4@SkillLight
  00015	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00018	ff 30		 push	 DWORD PTR [eax]
  0001a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	75 07		 jne	 SHORT $LN4@SkillLight
$LN36@SkillLight:

; 4412 : 		gObjIsConnected(lpTargetObj->m_Index) == FALSE )
; 4413 : 	{
; 4414 : 		return false;

  00026	33 c0		 xor	 eax, eax
  00028	5f		 pop	 edi

; 4478 : }

  00029	5d		 pop	 ebp
  0002a	c2 18 00	 ret	 24			; 00000018H
$LN4@SkillLight:

; 4415 : 	}
; 4416 : 
; 4417 : 	if( AttackDamage <= 0 )

  0002d	8b 4d 14	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  00030	85 c9		 test	 ecx, ecx
  00032	7e f2		 jle	 SHORT $LN36@SkillLight

; 4418 : 	{
; 4419 : 		return false;
; 4420 : 	}
; 4421 : 
; 4422 : 	int Damage = AttackDamage * DmgPerc / 100;

  00034	0f af 4d 1c	 imul	 ecx, DWORD PTR _DmgPerc$[ebp]
  00038	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0003d	53		 push	 ebx
  0003e	56		 push	 esi
  0003f	8d b7 4a 0c 00
	00		 lea	 esi, DWORD PTR [edi+3146]
  00045	f7 e9		 imul	 ecx
  00047	c1 fa 05	 sar	 edx, 5
  0004a	8b c2		 mov	 eax, edx
  0004c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004f	03 c2		 add	 eax, edx
  00051	89 45 1c	 mov	 DWORD PTR _Damage$1$[ebp], eax
  00054	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00059	89 45 08	 mov	 DWORD PTR tv402[ebp], eax
  0005c	0f 1f 40 00	 npad	 4
$LL2@SkillLight:

; 4423 : 	int tObjNum;
; 4424 : 	int count = 0;
; 4425 : 	int EnableAttack;
; 4426 : 
; 4427 : 	while( TRUE )
; 4428 : 	{
; 4429 : 		if(lpObj->VpPlayer2[count].state != 0)

  00060	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00064	0f 84 c1 00 00
	00		 je	 $LN28@SkillLight

; 4430 : 		{
; 4431 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0006a	0f bf 1e	 movsx	 ebx, WORD PTR [esi]

; 4432 : 
; 4433 : 			if( tObjNum >= 0 )

  0006d	85 db		 test	 ebx, ebx
  0006f	0f 88 b6 00 00
	00		 js	 $LN28@SkillLight

; 4434 : 			{
; 4435 : 				EnableAttack = 0;
; 4436 : 
; 4437 : 				if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007a	69 d3 40 27 00
	00		 imul	 edx, ebx, 10048
  00080	03 c2		 add	 eax, edx
  00082	89 55 14	 mov	 DWORD PTR tv406[ebp], edx
  00085	80 78 50 02	 cmp	 BYTE PTR [eax+80], 2
  00089	75 09		 jne	 SHORT $LN8@SkillLight
  0008b	83 b8 30 06 00
	00 00		 cmp	 DWORD PTR [eax+1584], 0
  00092	7c 69		 jl	 SHORT $LN26@SkillLight
$LN8@SkillLight:

; 4438 : 				{
; 4439 : 					EnableAttack = 1;
; 4440 : 				}
; 4441 : 				else if(lpTargetObj->m_cChaosCastleIndex != -1 && lpTargetObj->m_cChaosCastleIndex == gObj[tObjNum].m_cChaosCastleIndex)

  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00097	8a 89 3d 12 00
	00		 mov	 cl, BYTE PTR [ecx+4669]
  0009d	80 f9 ff	 cmp	 cl, -1
  000a0	74 08		 je	 SHORT $LN10@SkillLight
  000a2	3a 88 3d 12 00
	00		 cmp	 cl, BYTE PTR [eax+4669]
  000a8	74 53		 je	 SHORT $LN26@SkillLight
$LN10@SkillLight:

; 4442 : 				{
; 4443 : 					EnableAttack = 1;
; 4444 : 				}
; 4445 : #if (GS_CASTLE == 1)
; 4446 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000aa	80 7e 02 03	 cmp	 BYTE PTR [esi+2], 3
  000ae	74 31		 je	 SHORT $LN27@SkillLight
  000b0	80 b8 23 01 00
	00 1e		 cmp	 BYTE PTR [eax+291], 30	; 0000001eH
  000b7	75 28		 jne	 SHORT $LN27@SkillLight
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000be	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  000c3	83 f8 07	 cmp	 eax, 7
  000c6	75 16		 jne	 SHORT $LN29@SkillLight

; 4447 : 				{
; 4448 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cd	03 45 14	 add	 eax, DWORD PTR tv406[ebp]
  000d0	8a 8f 5a 20 00
	00		 mov	 cl, BYTE PTR [edi+8282]
  000d6	3a 88 5a 20 00
	00		 cmp	 cl, BYTE PTR [eax+8282]

; 4449 : 						EnableAttack = 1;
; 4450 : 				}

  000dc	eb 1d		 jmp	 SHORT $LN37@SkillLight
$LN29@SkillLight:
  000de	8b 55 14	 mov	 edx, DWORD PTR tv406[ebp]
$LN27@SkillLight:

; 4451 : #endif
; 4452 : 				else if(lpTargetObj->Type == OBJ_USER && lpObj->Type == OBJ_USER && gObj[tObjNum].Type != OBJ_NPC)

  000e1	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000e4	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  000e8	75 3e		 jne	 SHORT $LN35@SkillLight
  000ea	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  000ee	75 38		 jne	 SHORT $LN35@SkillLight
  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	03 c2		 add	 eax, edx
  000f7	80 78 50 03	 cmp	 BYTE PTR [eax+80], 3
$LN37@SkillLight:
  000fb	74 2b		 je	 SHORT $LN35@SkillLight
$LN26@SkillLight:

; 4453 : 				{
; 4454 : 					EnableAttack = 1;
; 4455 : 				}
; 4456 : 
; 4457 : 				if( EnableAttack != 0 &&

  000fd	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000ff	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00101	74 25		 je	 SHORT $LN35@SkillLight

; 4458 : 					lpObj->m_Index != gObj[tObjNum].m_Index )
; 4459 : 				{
; 4460 : 					int Dis = gObjCalDistance(lpTargetObj,&gObj[tObjNum]);

  00103	50		 push	 eax
  00104	ff 75 0c	 push	 DWORD PTR _lpTargetObj$[ebp]
  00107	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0010c	83 c4 08	 add	 esp, 8

; 4461 : 
; 4462 : 					if( Dis <= Distance )

  0010f	3b 45 18	 cmp	 eax, DWORD PTR _Distance$[ebp]
  00112	7f 14		 jg	 SHORT $LN35@SkillLight

; 4463 : 					{
; 4464 : 						gObjAddMsgSendDelay(lpObj,0x3A,tObjNum,300,Damage);

  00114	ff 75 1c	 push	 DWORD PTR _Damage$1$[ebp]
  00117	68 2c 01 00 00	 push	 300			; 0000012cH
  0011c	53		 push	 ebx
  0011d	6a 3a		 push	 58			; 0000003aH
  0011f	57		 push	 edi
  00120	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00125	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@SkillLight:
  00128	8b 45 08	 mov	 eax, DWORD PTR tv402[ebp]
$LN28@SkillLight:

; 4465 : 					}
; 4466 : 				}
; 4467 : 			}
; 4468 : 		}
; 4469 : 
; 4470 : 		count++;

  0012b	83 c6 0c	 add	 esi, 12			; 0000000cH

; 4471 : 
; 4472 : 		if( count > MAX_VIEWPORT -1)

  0012e	83 e8 01	 sub	 eax, 1
  00131	89 45 08	 mov	 DWORD PTR tv402[ebp], eax
  00134	0f 85 26 ff ff
	ff		 jne	 $LL2@SkillLight

; 4473 : 		{
; 4474 : 			break;
; 4475 : 		}
; 4476 : 	}
; 4477 : return TRUE;

  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	b8 01 00 00 00	 mov	 eax, 1
  00141	5f		 pop	 edi

; 4478 : }

  00142	5d		 pop	 ebp
  00143	c2 18 00	 ret	 24			; 00000018H
?SkillLightExplode@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0HHHH@Z ENDP ; CObjUseSkill::SkillLightExplode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillLightExplode@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -12					; size = 4
_lpObj$1$ = -8						; size = 4
_count$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillLightExplode@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillLightExplode, COMDAT
; _this$ = ecx

; 4334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 4335 : 	LPOBJ lpObj = &gObj[aIndex];
; 4336 : 	int bSuccess = FALSE;
; 4337 : 	int tObjNum;
; 4338 : 
; 4339 : 	int Angle = GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);
; 4340 : 	int count = 0;
; 4341 : 
; 4342 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00006	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00009	53		 push	 ebx
  0000a	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  00011	56		 push	 esi
  00012	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00016	57		 push	 edi
  00017	6a 01		 push	 1
  00019	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0001c	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	33 ff		 xor	 edi, edi
  00024	50		 push	 eax
  00025	53		 push	 ebx
  00026	89 5d f8	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00029	89 7d fc	 mov	 DWORD PTR _count$1$[ebp], edi
  0002c	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 4343 : 
; 4344 : 	int DuelIndex = lpObj->m_iDuelUser;

  00031	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	81 c3 4c 0c 00
	00		 add	 ebx, 3148		; 00000c4cH
  00046	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@SkillLight:

; 4345 : 	int EnableAttack;
; 4346 : 
; 4347 : 	while( TRUE )
; 4348 : 	{
; 4349 : 		if(lpObj->VpPlayer2[count].state != 0)

  00050	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00054	74 76		 je	 SHORT $LN16@SkillLight

; 4350 : 		{
; 4351 : 			tObjNum = lpObj->VpPlayer2[count].number;

  00056	0f bf 73 fe	 movsx	 esi, WORD PTR [ebx-2]

; 4352 : 
; 4353 : 			if( tObjNum >= 0 )

  0005a	85 f6		 test	 esi, esi
  0005c	78 6e		 js	 SHORT $LN16@SkillLight

; 4354 : 			{
; 4355 : 				EnableAttack = 0;
; 4356 : 
; 4357 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0005e	8a 13		 mov	 dl, BYTE PTR [ebx]
  00060	80 fa 02	 cmp	 dl, 2
  00063	75 17		 jne	 SHORT $LN6@SkillLight
  00065	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  0006b	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  00073	0f 8c b1 00 00
	00		 jl	 $LN10@SkillLight
  00079	8b 45 f4	 mov	 eax, DWORD PTR _DuelIndex$1$[ebp]
$LN6@SkillLight:

; 4358 : 				{
; 4359 : 					EnableAttack = 1;
; 4360 : 				}
; 4361 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  0007c	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  0007f	0f 84 ad 00 00
	00		 je	 $LN26@SkillLight
  00085	3b c6		 cmp	 eax, esi
  00087	0f 84 9d 00 00
	00		 je	 $LN10@SkillLight

; 4362 : 				{
; 4363 : 					EnableAttack = 1;
; 4364 : 				}
; 4365 : #if (GS_CASTLE == 1)
; 4366 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  0008d	80 fa 03	 cmp	 dl, 3
  00090	74 55		 je	 SHORT $LN11@SkillLight
  00092	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00098	80 bc 0f 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+ecx+291], 30 ; 0000001eH
  000a0	75 42		 jne	 SHORT $LN32@SkillLight
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a7	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 4367 : 				{
; 4368 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b2	83 f8 07	 cmp	 eax, 7
  000b5	75 2d		 jne	 SHORT $LN32@SkillLight
  000b7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000ba	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  000c0	3a 84 0f 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+ecx+8282]
  000c7	75 61		 jne	 SHORT $LN10@SkillLight
  000c9	8b 7d fc	 mov	 edi, DWORD PTR _count$1$[ebp]
$LN16@SkillLight:

; 4392 : 					bSuccess = TRUE;
; 4393 : 					break;
; 4394 : 				}
; 4395 : 			}
; 4396 : 		}
; 4397 : 
; 4398 : 		count++;

  000cc	47		 inc	 edi
  000cd	83 c3 0c	 add	 ebx, 12			; 0000000cH
  000d0	89 7d fc	 mov	 DWORD PTR _count$1$[ebp], edi

; 4399 : 
; 4400 : 		if( count > MAX_VIEWPORT -1)

  000d3	83 ff 4a	 cmp	 edi, 74			; 0000004aH
  000d6	0f 8f a2 00 00
	00		 jg	 $LN27@SkillLight

; 4401 : 		{
; 4402 : 			break;
; 4403 : 		}
; 4404 : 	}

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _DuelIndex$1$[ebp]
  000df	e9 6c ff ff ff	 jmp	 $LL2@SkillLight
$LN32@SkillLight:
  000e4	8b 7d fc	 mov	 edi, DWORD PTR _count$1$[ebp]
$LN11@SkillLight:

; 4369 : 						EnableAttack = 1;
; 4370 : 				}
; 4371 : #endif
; 4372 : 				else
; 4373 : 				{
; 4374 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000e7	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 4375 : 
; 4376 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000ed	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  000f2	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  000f5	75 14		 jne	 SHORT $LN14@SkillLight
  000f7	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  000fe	85 c0		 test	 eax, eax
  00100	78 09		 js	 SHORT $LN14@SkillLight

; 4377 : 					{
; 4378 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00102	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00108	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN14@SkillLight:

; 4379 : 					}
; 4380 : 
; 4381 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  0010b	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00111	03 c1		 add	 eax, ecx
  00113	50		 push	 eax
  00114	ff 75 f8	 push	 DWORD PTR _lpObj$1$[ebp]
  00117	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0011c	83 c4 08	 add	 esp, 8
  0011f	83 f8 01	 cmp	 eax, 1
  00122	75 26		 jne	 SHORT $LN29@SkillLight
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillLight:
  0012a	8b 7d fc	 mov	 edi, DWORD PTR _count$1$[ebp]

; 4382 : 					{
; 4383 : 						EnableAttack = 1;
; 4384 : 					}
; 4385 : 				}
; 4386 : 
; 4387 : 				if( EnableAttack != 0 &&
; 4388 : 					tObjNum == aTargetIndex && 

  0012d	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00130	75 9a		 jne	 SHORT $LN16@SkillLight
$LN26@SkillLight:
  00132	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00135	ff 70 08	 push	 DWORD PTR [eax+8]
  00138	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0013b	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0013e	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH
  00146	85 c0		 test	 eax, eax
  00148	75 0b		 jne	 SHORT $LN21@SkillLight
$LN29@SkillLight:
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00150	e9 77 ff ff ff	 jmp	 $LN16@SkillLight
$LN21@SkillLight:

; 4389 : 					gCheckSkillDistance(aIndex,aTargetIndex,lpMagic->m_Skill) != FALSE )
; 4390 : 				{
; 4391 : 					gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,700,lpMagic->m_Skill,0);

  00155	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00158	6a 00		 push	 0
  0015a	ff 70 08	 push	 DWORD PTR [eax+8]
  0015d	68 bc 02 00 00	 push	 700			; 000002bcH
  00162	56		 push	 esi
  00163	6a 32		 push	 50			; 00000032H
  00165	ff 75 f8	 push	 DWORD PTR _lpObj$1$[ebp]
  00168	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0016d	83 c4 18	 add	 esp, 24			; 00000018H

; 4405 : 
; 4406 : return bSuccess;

  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx

; 4407 : }

  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c2 0c 00	 ret	 12			; 0000000cH
$LN27@SkillLight:
  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi

; 4405 : 
; 4406 : return bSuccess;

  00180	33 c0		 xor	 eax, eax
  00182	5b		 pop	 ebx

; 4407 : }

  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 0c 00	 ret	 12			; 0000000cH
?SkillLightExplode@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillLightExplode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillChainLightning@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv810 = -328						; size = 4
_DuelIndex$1$ = -324					; size = 4
_lpObj$1$ = -320					; size = 4
_aIndex$GSCopy$1$ = -316				; size = 4
tv812 = -312						; size = 4
_lpTargetObj$1$ = -308					; size = 4
_lpMagic$GSCopy$1$ = -304				; size = 4
_Target$2$ = -300					; size = 4
tv807 = -296						; size = 4
_count$1$ = -292					; size = 4
_aTargetIndex$GSCopy$1$ = -288				; size = 4
_pMsg$ = -284						; size = 10
_Target$ = -272						; size = 12
_cBUFF$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillChainLightning@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillChainLightning, COMDAT
; _this$ = ecx

; 4564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  00019	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi

; 4565 : 	LPOBJ lpObj = &gObj[aIndex];

  0001f	69 fa 40 27 00
	00		 imul	 edi, edx, 10048

; 4566 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 4567 : 
; 4568 : 	int bSuccess = TRUE;
; 4569 : 	int tObjNum;
; 4570 : 	int count = 0;
; 4571 : 
; 4572 : 	int Target[3];
; 4573 : 
; 4574 : 	Target[0] = -1;
; 4575 : 	Target[1] = -1;

  00025	83 ce ff	 or	 esi, -1
  00028	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], edx

; 4576 : 	Target[2] = -1;

  0002e	0b de		 or	 ebx, esi
  00030	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048

; 4577 : 
; 4578 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00036	6a 01		 push	 1
  00038	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _lpMagic$GSCopy$1$[ebp], eax
  0003e	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00042	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004e	51		 push	 ecx
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _aTargetIndex$GSCopy$1$[ebp], ecx
  00057	89 bd c0 fe ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], edi
  0005d	89 95 cc fe ff
	ff		 mov	 DWORD PTR _lpTargetObj$1$[ebp], edx
  00063	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$1$[ebp], 0
  0006d	c7 85 f0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _Target$[ebp], -1
  00077	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp+4], esi
  0007d	89 9d d4 fe ff
	ff		 mov	 DWORD PTR _Target$2$[ebp], ebx
  00083	89 9d f8 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp+8], ebx
  00089	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 4579 : 
; 4580 : 	int DuelIndex = lpObj->m_iDuelUser;

  0008e	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]

; 4581 : 	int EnableAttack;
; 4582 : 
; 4583 : 	if( gCheckSkillDistance(aIndex,aTargetIndex,lpMagic->m_Skill) == FALSE )

  00094	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$1$[ebp]
  0009a	89 85 bc fe ff
	ff		 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  000a0	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMagic$GSCopy$1$[ebp]
  000a6	ff 70 08	 push	 DWORD PTR [eax+8]
  000a9	51		 push	 ecx
  000aa	ff b5 c4 fe ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  000b0	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  000b5	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b8	85 c0		 test	 eax, eax
  000ba	75 13		 jne	 SHORT $LN10@SkillChain
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx

; 4702 : 	}
; 4703 : return bSuccess;
; 4704 : }

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	33 cd		 xor	 ecx, ebp
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SkillChain:

; 4584 : 	{
; 4585 : 		return FALSE;
; 4586 : 	}
; 4587 : 
; 4588 : 	Target[0] = aTargetIndex;

  000cf	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$1$[ebp]
  000d5	8d 97 4a 0c 00
	00		 lea	 edx, DWORD PTR [edi+3146]
  000db	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv807[ebp], edx
  000e1	33 c0		 xor	 eax, eax
  000e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e9	8b bd d8 fe ff
	ff		 mov	 edi, DWORD PTR tv807[ebp]
  000ef	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp], ecx
$LL2@SkillChain:

; 4589 : 
; 4590 : 	while( TRUE )
; 4591 : 	{
; 4592 : 		if(lpObj->VpPlayer2[count].state != 0)

  000f5	80 7f fe 00	 cmp	 BYTE PTR [edi-2], 0
  000f9	0f 84 92 01 00
	00		 je	 $LN25@SkillChain

; 4593 : 		{
; 4594 : 			tObjNum = lpObj->VpPlayer2[count].number;

  000ff	0f bf 37	 movsx	 esi, WORD PTR [edi]

; 4595 : 
; 4596 : 			if( tObjNum >= 0 )

  00102	85 f6		 test	 esi, esi
  00104	0f 88 81 01 00
	00		 js	 $LN57@SkillChain

; 4597 : 			{
; 4598 : 				EnableAttack = 0;
; 4599 : 
; 4600 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0010a	80 7f 02 02	 cmp	 BYTE PTR [edi+2], 2
  0010e	75 10		 jne	 SHORT $LN13@SkillChain
  00110	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00116	83 bc 10 30 06
	00 00 00	 cmp	 DWORD PTR [eax+edx+1584], 0
  0011e	7c 56		 jl	 SHORT $LN17@SkillChain
$LN13@SkillChain:

; 4601 : 				{
; 4602 : 					EnableAttack = 1;
; 4603 : 				}
; 4604 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00120	3b f1		 cmp	 esi, ecx
  00122	74 52		 je	 SHORT $LN17@SkillChain
  00124	39 b5 bc fe ff
	ff		 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  0012a	74 4a		 je	 SHORT $LN17@SkillChain

; 4605 : 				{
; 4606 : 					EnableAttack = 1;
; 4607 : 				}
; 4608 : 				else
; 4609 : 				{
; 4610 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0012c	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 4611 : 
; 4612 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00132	80 7c 10 50 02	 cmp	 BYTE PTR [eax+edx+80], 2
  00137	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0013a	75 14		 jne	 SHORT $LN18@SkillChain
  0013c	8b 84 10 30 06
	00 00		 mov	 eax, DWORD PTR [eax+edx+1584]
  00143	85 c0		 test	 eax, eax
  00145	78 09		 js	 SHORT $LN18@SkillChain

; 4613 : 					{
; 4614 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00147	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0014d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
$LN18@SkillChain:

; 4615 : 					}
; 4616 : 
; 4617 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00150	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  00156	03 c2		 add	 eax, edx
  00158	50		 push	 eax
  00159	ff b5 c0 fe ff
	ff		 push	 DWORD PTR _lpObj$1$[ebp]
  0015f	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00164	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016a	83 c4 08	 add	 esp, 8
  0016d	83 f8 01	 cmp	 eax, 1
  00170	0f 85 09 01 00
	00		 jne	 $LN59@SkillChain
$LN17@SkillChain:

; 4618 : 					{
; 4619 : 						EnableAttack = 1;
; 4620 : 					}
; 4621 : 				}
; 4622 : 
; 4623 : 				if( EnableAttack != 0 )
; 4624 : 				{
; 4625 : 					if( gObj[tObjNum].X >= (lpTargetObj->X -1) &&
; 4626 : 						gObj[tObjNum].X <= (lpTargetObj->X +1) &&
; 4627 : 						gObj[tObjNum].Y >= (lpTargetObj->Y -1) &&
; 4628 : 						gObj[tObjNum].Y <= (lpTargetObj->Y +1) &&

  00176	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _lpTargetObj$1$[ebp]
  0017c	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00182	03 ca		 add	 ecx, edx
  00184	0f b6 98 20 01
	00 00		 movzx	 ebx, BYTE PTR [eax+288]
  0018b	0f b6 b9 20 01
	00 00		 movzx	 edi, BYTE PTR [ecx+288]
  00192	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00195	3b f8		 cmp	 edi, eax
  00197	7c 77		 jl	 SHORT $LN21@SkillChain
  00199	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0019c	3b f8		 cmp	 edi, eax
  0019e	7f 70		 jg	 SHORT $LN21@SkillChain
  001a0	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _lpTargetObj$1$[ebp]
  001a6	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  001ad	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv812[ebp], eax
  001b3	0f b6 82 21 01
	00 00		 movzx	 eax, BYTE PTR [edx+289]
  001ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c0	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv810[ebp], eax
  001c6	48		 dec	 eax
  001c7	39 85 c8 fe ff
	ff		 cmp	 DWORD PTR tv812[ebp], eax
  001cd	7c 41		 jl	 SHORT $LN21@SkillChain
  001cf	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv810[ebp]
  001d5	40		 inc	 eax
  001d6	39 85 c8 fe ff
	ff		 cmp	 DWORD PTR tv812[ebp], eax
  001dc	7f 32		 jg	 SHORT $LN21@SkillChain
  001de	80 79 50 02	 cmp	 BYTE PTR [ecx+80], 2
  001e2	75 2c		 jne	 SHORT $LN21@SkillChain

; 4629 : 						gObj[tObjNum].Type == OBJ_MONSTER )
; 4630 : 					{
; 4631 : 						Target[1] = tObjNum;
; 4632 : 
; 4633 : 						if(Target[2] != -1)

  001e4	8b 9d d4 fe ff
	ff		 mov	 ebx, DWORD PTR _Target$2$[ebp]
  001ea	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp+4], esi
  001f0	83 fb ff	 cmp	 ebx, -1
  001f3	0f 85 bd 00 00
	00		 jne	 $LN27@SkillChain

; 4634 : 							break;
; 4635 : 					}
; 4636 : 					else if( gObj[tObjNum].X >= (lpTargetObj->X -2) &&

  001f9	8b bd d8 fe ff
	ff		 mov	 edi, DWORD PTR tv807[ebp]
  001ff	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _count$1$[ebp]
  00205	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$1$[ebp]
  0020b	e9 81 00 00 00	 jmp	 $LN25@SkillChain
$LN21@SkillChain:

; 4637 : 						gObj[tObjNum].X <= (lpTargetObj->X +2) &&
; 4638 : 						gObj[tObjNum].Y >= (lpTargetObj->Y -2) &&
; 4639 : 						gObj[tObjNum].Y <= (lpTargetObj->Y +2) &&

  00210	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  00213	3b f8		 cmp	 edi, eax
  00215	7c 5c		 jl	 SHORT $LN51@SkillChain
  00217	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0021a	3b f8		 cmp	 edi, eax
  0021c	7f 55		 jg	 SHORT $LN51@SkillChain
  0021e	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _lpTargetObj$1$[ebp]
  00224	0f b6 b9 21 01
	00 00		 movzx	 edi, BYTE PTR [ecx+289]
  0022b	0f b6 98 21 01
	00 00		 movzx	 ebx, BYTE PTR [eax+289]
  00232	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  00235	3b f8		 cmp	 edi, eax
  00237	7c 3a		 jl	 SHORT $LN51@SkillChain
  00239	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0023c	3b f8		 cmp	 edi, eax
  0023e	7f 33		 jg	 SHORT $LN51@SkillChain
  00240	80 79 50 02	 cmp	 BYTE PTR [ecx+80], 2
  00244	75 2d		 jne	 SHORT $LN51@SkillChain

; 4640 : 						gObj[tObjNum].Type == OBJ_MONSTER )
; 4641 : 					{
; 4642 : 						Target[2] = tObjNum;

  00246	8b de		 mov	 ebx, esi

; 4643 : 	
; 4644 : 						if(Target[1] != -1)

  00248	8b b5 f4 fe ff
	ff		 mov	 esi, DWORD PTR _Target$[ebp+4]
  0024e	89 9d d4 fe ff
	ff		 mov	 DWORD PTR _Target$2$[ebp], ebx
  00254	89 9d f8 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp+8], ebx
  0025a	83 fe ff	 cmp	 esi, -1
  0025d	75 4b		 jne	 SHORT $LN35@SkillChain

; 4634 : 							break;
; 4635 : 					}
; 4636 : 					else if( gObj[tObjNum].X >= (lpTargetObj->X -2) &&

  0025f	8b bd d8 fe ff
	ff		 mov	 edi, DWORD PTR tv807[ebp]
  00265	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _count$1$[ebp]
  0026b	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$1$[ebp]
  00271	eb 1e		 jmp	 SHORT $LN25@SkillChain
$LN51@SkillChain:
  00273	8b 9d d4 fe ff
	ff		 mov	 ebx, DWORD PTR _Target$2$[ebp]
  00279	8b bd d8 fe ff
	ff		 mov	 edi, DWORD PTR tv807[ebp]
$LN59@SkillChain:
  0027f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _count$1$[ebp]
  00285	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$1$[ebp]
$LN57@SkillChain:
  0028b	8b b5 f4 fe ff
	ff		 mov	 esi, DWORD PTR _Target$[ebp+4]
$LN25@SkillChain:

; 4645 : 							break;
; 4646 : 					}
; 4647 : 				}
; 4648 : 			}
; 4649 : 		}
; 4650 : 
; 4651 : 		count++;

  00291	40		 inc	 eax
  00292	83 c7 0c	 add	 edi, 12			; 0000000cH
  00295	89 85 dc fe ff
	ff		 mov	 DWORD PTR _count$1$[ebp], eax
  0029b	89 bd d8 fe ff
	ff		 mov	 DWORD PTR tv807[ebp], edi

; 4652 : 
; 4653 : 		if( count > MAX_VIEWPORT -1)

  002a1	83 f8 4a	 cmp	 eax, 74			; 0000004aH
  002a4	0f 8e 4b fe ff
	ff		 jle	 $LL2@SkillChain
$LN35@SkillChain:

; 4654 : 		{
; 4655 : 			break;
; 4656 : 		}
; 4657 : 	}
; 4658 : 
; 4659 : 	if( Target[2] == -1 )

  002aa	83 fb ff	 cmp	 ebx, -1
  002ad	0f 44 de	 cmove	 ebx, esi
  002b0	89 9d f8 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp+8], ebx
$LN27@SkillChain:

; 4660 : 	{
; 4661 : 		Target[2] = Target[1];
; 4662 : 	}
; 4663 : 
; 4664 : 	if( Target[1] == -1 )

  002b6	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$1$[ebp]
  002bc	83 fe ff	 cmp	 esi, -1
  002bf	75 10		 jne	 SHORT $LN28@SkillChain

; 4665 : 	{
; 4666 : 		Target[1] = Target[0];
; 4667 : 		Target[2] = Target[1];

  002c1	8b f1		 mov	 esi, ecx
  002c3	8b d9		 mov	 ebx, ecx
  002c5	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp+4], esi
  002cb	89 9d f8 fe ff
	ff		 mov	 DWORD PTR _Target$[ebp+8], ebx
$LN28@SkillChain:

; 4668 : 	}
; 4669 : 
; 4670 : 	int lOfs = 0;
; 4671 : 	BYTE cBUFF[256];
; 4672 : 	PMSG_SKILL_TARGET_COUNT pMsg;
; 4673 : 
; 4674 : 	pMsg.MagicNumberH = SET_NUMBERH(lpMagic->m_Skill);

  002d1	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMagic$GSCopy$1$[ebp]

; 4675 : 	pMsg.MagicNumberL = SET_NUMBERL(lpMagic->m_Skill);
; 4676 : 	pMsg.Index = aIndex;
; 4677 : 	pMsg.Count = 3;
; 4678 : 
; 4679 : 	lOfs += sizeof(pMsg);
; 4680 : 
; 4681 : 	int i;
; 4682 : 	for(i = 0; i < 3; i++)
; 4683 : 	{
; 4684 : 		WORD wIndex = Target[i];
; 4685 : 		memcpy(&cBUFF[lOfs],&wIndex,2);
; 4686 : 		lOfs+= 2;
; 4687 : 	}
; 4688 : 
; 4689 : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,10,lOfs);

  002d7	6a 10		 push	 16			; 00000010H
  002d9	6a 0a		 push	 10			; 0000000aH
  002db	68 bf 00 00 00	 push	 191			; 000000bfH
  002e0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002e3	c1 e8 08	 shr	 eax, 8
  002e6	88 85 e8 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al
  002ec	8a 42 08	 mov	 al, BYTE PTR [edx+8]
  002ef	88 85 e9 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+5], al
  002f5	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$1$[ebp]
  002fb	66 89 85 ea fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+6], ax
  00302	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00308	50		 push	 eax
  00309	c6 85 ec fe ff
	ff 03		 mov	 BYTE PTR _pMsg$[ebp+8], 3
  00310	66 89 8d 06 ff
	ff ff		 mov	 WORD PTR _cBUFF$[ebp+10], cx
  00317	66 89 b5 08 ff
	ff ff		 mov	 WORD PTR _cBUFF$[ebp+12], si
  0031e	66 89 9d 0a ff
	ff ff		 mov	 WORD PTR _cBUFF$[ebp+14], bx
  00325	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 4690 : 	memcpy(&cBUFF[0],&pMsg,sizeof(pMsg));
; 4691 : 
; 4692 : 	if( lpObj->Type == OBJ_USER )

  0032a	8b 9d c0 fe ff
	ff		 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  00330	83 c4 10	 add	 esp, 16			; 00000010H
  00333	f3 0f 7e 85 e4
	fe ff ff	 movq	 xmm0, QWORD PTR _pMsg$[ebp]
  0033b	66 8b 85 ec fe
	ff ff		 mov	 ax, WORD PTR _pMsg$[ebp+8]
  00342	66 0f d6 85 fc
	fe ff ff	 movq	 QWORD PTR _cBUFF$[ebp], xmm0
  0034a	66 89 85 04 ff
	ff ff		 mov	 WORD PTR _cBUFF$[ebp+8], ax
  00351	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  00355	75 19		 jne	 SHORT $LN29@SkillChain

; 4693 : 	{
; 4694 : 		DataSend(lpObj->m_Index,(LPBYTE)&cBUFF[0],pMsg.h.size);

  00357	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0035e	50		 push	 eax
  0035f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cBUFF$[ebp]
  00365	50		 push	 eax
  00366	ff 33		 push	 DWORD PTR [ebx]
  00368	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0036d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@SkillChain:

; 4695 : 	}
; 4696 : 
; 4697 : 	MsgSendV2(lpObj,(LPBYTE)&cBUFF[0],pMsg.h.size);

  00370	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00377	50		 push	 eax
  00378	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cBUFF$[ebp]
  0037e	50		 push	 eax
  0037f	53		 push	 ebx
  00380	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00385	83 c4 0c	 add	 esp, 12			; 0000000cH
  00388	bf c8 00 00 00	 mov	 edi, 200		; 000000c8H

; 4698 : 
; 4699 : 	for(i = 0; i < 3; i++)

  0038d	33 c0		 xor	 eax, eax
  0038f	90		 npad	 1
$LL9@SkillChain:

; 4700 : 	{
; 4701 : 		gObjAddAttackProcMsgSendDelay(lpObj,50,Target[i],200 + 200*i,lpMagic->m_Skill,i+1);

  00390	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMagic$GSCopy$1$[ebp]
  00396	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00399	56		 push	 esi
  0039a	ff 71 08	 push	 DWORD PTR [ecx+8]
  0039d	57		 push	 edi
  0039e	ff b4 85 f0 fe
	ff ff		 push	 DWORD PTR _Target$[ebp+eax*4]
  003a5	6a 32		 push	 50			; 00000032H
  003a7	53		 push	 ebx
  003a8	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  003ad	81 c7 c8 00 00
	00		 add	 edi, 200		; 000000c8H
  003b3	83 c4 18	 add	 esp, 24			; 00000018H
  003b6	8b c6		 mov	 eax, esi
  003b8	81 ff 20 03 00
	00		 cmp	 edi, 800		; 00000320H
  003be	7c d0		 jl	 SHORT $LL9@SkillChain

; 4702 : 	}
; 4703 : return bSuccess;
; 4704 : }

  003c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c3	b8 01 00 00 00	 mov	 eax, 1
  003c8	5f		 pop	 edi
  003c9	5e		 pop	 esi
  003ca	33 cd		 xor	 ecx, ebp
  003cc	5b		 pop	 ebx
  003cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d2	8b e5		 mov	 esp, ebp
  003d4	5d		 pop	 ebp
  003d5	c2 0c 00	 ret	 12			; 0000000cH
?SkillChainLightning@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillChainLightning
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDrainLife@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -8					; size = 4
_lpObj$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillDrainLife@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillDrainLife, COMDAT
; _this$ = ecx

; 4481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4482 : 	LPOBJ lpObj = &gObj[aIndex];
; 4483 : 	int bSuccess = FALSE;
; 4484 : 	int tObjNum;
; 4485 : 
; 4486 : 	int Angle = GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);
; 4487 : 	int count = 0;
; 4488 : 
; 4489 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00006	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  00012	33 db		 xor	 ebx, ebx
  00014	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00018	57		 push	 edi
  00019	6a 01		 push	 1
  0001b	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0001e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00024	50		 push	 eax
  00025	56		 push	 esi
  00026	89 75 fc	 mov	 DWORD PTR _lpObj$1$[ebp], esi
  00029	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 4490 : 
; 4491 : 	int DuelIndex = lpObj->m_iDuelUser;

  0002e	8b 96 50 12 00
	00		 mov	 edx, DWORD PTR [esi+4688]
  00034	8d be 4a 0c 00
	00		 lea	 edi, DWORD PTR [esi+3146]
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	89 55 f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], edx
$LL2@SkillDrain:

; 4492 : 	int EnableAttack;
; 4493 : 
; 4494 : 	while( TRUE )
; 4495 : 	{
; 4496 : 		if(lpObj->VpPlayer2[count].state != 0)

  00046	80 7f fe 00	 cmp	 BYTE PTR [edi-2], 0
  0004a	0f 84 92 00 00
	00		 je	 $LN13@SkillDrain

; 4497 : 		{
; 4498 : 			tObjNum = lpObj->VpPlayer2[count].number;

  00050	0f bf 37	 movsx	 esi, WORD PTR [edi]

; 4499 : 
; 4500 : 			if( tObjNum >= 0 )

  00053	85 f6		 test	 esi, esi
  00055	0f 88 87 00 00
	00		 js	 $LN13@SkillDrain

; 4501 : 			{
; 4502 : 				EnableAttack = 0;
; 4503 : 
; 4504 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0005b	80 7f 02 02	 cmp	 BYTE PTR [edi+2], 2
  0005f	75 10		 jne	 SHORT $LN6@SkillDrain
  00061	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00067	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0006f	7c 4e		 jl	 SHORT $LN26@SkillDrain
$LN6@SkillDrain:

; 4505 : 				{
; 4506 : 					EnableAttack = 1;
; 4507 : 				}
; 4508 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00071	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00074	3b f0		 cmp	 esi, eax
  00076	74 4e		 je	 SHORT $LN23@SkillDrain
  00078	3b d6		 cmp	 edx, esi
  0007a	74 46		 je	 SHORT $LN10@SkillDrain

; 4509 : 				{
; 4510 : 					EnableAttack = 1;
; 4511 : 				}
; 4512 : 				else
; 4513 : 				{
; 4514 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0007c	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 4515 : 
; 4516 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00082	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00087	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  0008a	75 14		 jne	 SHORT $LN11@SkillDrain
  0008c	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  00093	85 c0		 test	 eax, eax
  00095	78 09		 js	 SHORT $LN11@SkillDrain

; 4517 : 					{
; 4518 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00097	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0009d	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN11@SkillDrain:

; 4519 : 					}
; 4520 : 
; 4521 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000a0	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  000a6	03 c1		 add	 eax, ecx
  000a8	50		 push	 eax
  000a9	ff 75 fc	 push	 DWORD PTR _lpObj$1$[ebp]
  000ac	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000b1	83 c4 08	 add	 esp, 8
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	75 23		 jne	 SHORT $LN25@SkillDrain
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN26@SkillDrain:
  000bf	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
$LN10@SkillDrain:

; 4522 : 					{
; 4523 : 						EnableAttack = 1;
; 4524 : 					}
; 4525 : 				}
; 4526 : 
; 4527 : 				if( EnableAttack != 0 &&
; 4528 : 					tObjNum == aTargetIndex && 

  000c2	3b f0		 cmp	 esi, eax
  000c4	75 1c		 jne	 SHORT $LN13@SkillDrain
$LN23@SkillDrain:
  000c6	8b 4d 10	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  000c9	ff 71 08	 push	 DWORD PTR [ecx+8]
  000cc	50		 push	 eax
  000cd	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  000d0	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d8	85 c0		 test	 eax, eax
  000da	75 17		 jne	 SHORT $LN18@SkillDrain
$LN25@SkillDrain:
  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN13@SkillDrain:

; 4532 : 					bSuccess = TRUE;
; 4533 : 					break;
; 4534 : 				}
; 4535 : 			}
; 4536 : 		}
; 4537 : 
; 4538 : 		count++;

  000e2	43		 inc	 ebx
  000e3	83 c7 0c	 add	 edi, 12			; 0000000cH

; 4539 : 
; 4540 : 		if( count > MAX_VIEWPORT -1)

  000e6	83 fb 4a	 cmp	 ebx, 74			; 0000004aH
  000e9	7f 31		 jg	 SHORT $LN24@SkillDrain

; 4541 : 		{
; 4542 : 			break;
; 4543 : 		}
; 4544 : 	}

  000eb	8b 55 f8	 mov	 edx, DWORD PTR _DuelIndex$1$[ebp]
  000ee	e9 53 ff ff ff	 jmp	 $LL2@SkillDrain
$LN18@SkillDrain:

; 4529 : 					gCheckSkillDistance(aIndex,aTargetIndex,lpMagic->m_Skill) != FALSE )
; 4530 : 				{
; 4531 : 					gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,700,lpMagic->m_Skill,0);

  000f3	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000f6	6a 00		 push	 0
  000f8	ff 70 08	 push	 DWORD PTR [eax+8]
  000fb	68 bc 02 00 00	 push	 700			; 000002bcH
  00100	56		 push	 esi
  00101	6a 32		 push	 50			; 00000032H
  00103	ff 75 fc	 push	 DWORD PTR _lpObj$1$[ebp]
  00106	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0010b	83 c4 18	 add	 esp, 24			; 00000018H

; 4545 : 
; 4546 : return bSuccess;

  0010e	b8 01 00 00 00	 mov	 eax, 1
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx

; 4547 : }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 0c 00	 ret	 12			; 0000000cH
$LN24@SkillDrain:
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi

; 4545 : 
; 4546 : return bSuccess;

  0011e	33 c0		 xor	 eax, eax
  00120	5b		 pop	 ebx

; 4547 : }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 0c 00	 ret	 12			; 0000000cH
?SkillDrainLife@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillDrainLife
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_fSkillValue$1 = 16					; size = 4
_lpMagic$ = 16						; size = 4
_iAttackDamage$ = 20					; size = 4
?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z PROC ; CObjUseSkill::SpecificSkillAdditionTreat, COMDAT
; _this$ = ecx

; 4277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4278 : 	int bySkillNum = lpMagic->m_Skill;

  00003	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 4279 : 
; 4280 : 	if( bySkillNum == AT_SKILL_FIRESCREAM ||

  00009	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  0000c	0f 84 1e 01 00
	00		 je	 $LN4@SpecificSk
  00012	81 f9 06 02 00
	00		 cmp	 ecx, 518		; 00000206H
  00018	0f 84 12 01 00
	00		 je	 $LN4@SpecificSk

; 4284 : 	}
; 4285 : 	else if( bySkillNum == AT_MSKILL_DL_FIRESCREAM2 )

  0001e	81 f9 08 02 00
	00		 cmp	 ecx, 520		; 00000208H
  00024	75 44		 jne	 SHORT $LN5@SpecificSk

; 4286 : 	{
; 4287 : 		float fSkillValue = g_MasterSkillSystem.GetMasterSkillValue(MagicDamageC.SkillGet(lpMagic->m_Skill),lpMagic->m_Level);

  00026	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00031	e8 00 00 00 00	 call	 ?SkillGet@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGet
  00036	50		 push	 eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0003c	e8 00 00 00 00	 call	 ?GetMasterSkillValue@CMasterLevelSkillTreeSystem@@QAEMHH@Z ; CMasterLevelSkillTreeSystem::GetMasterSkillValue
  00041	66 0f 6e 45 14	 movd	 xmm0, DWORD PTR _iAttackDamage$[ebp]

; 4288 : 		gObjUseSkill.FireScreamExplosionAttack(lpObj,lpTargetObj,iAttackDamage+fSkillValue);

  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0004b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0004e	d9 5d 10	 fstp	 DWORD PTR _fSkillValue$1[ebp]
  00051	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _fSkillValue$1[ebp]
  00056	f3 0f 2c c0	 cvttss2si eax, xmm0
  0005a	50		 push	 eax
  0005b	ff 75 0c	 push	 DWORD PTR _lpTargetObj$[ebp]
  0005e	ff 75 08	 push	 DWORD PTR _lpObj$[ebp]
  00061	e8 00 00 00 00	 call	 ?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjUseSkill::FireScreamExplosionAttack

; 4312 : 	}
; 4313 : }

  00066	5d		 pop	 ebp
  00067	c2 10 00	 ret	 16			; 00000010H
$LN5@SpecificSk:
  0006a	56		 push	 esi

; 4289 : 	}
; 4290 : 	else if( bySkillNum == AT_SKILL_LIGHTSHOCK ||

  0006b	81 f9 e6 00 00
	00		 cmp	 ecx, 230		; 000000e6H
  00071	0f 84 9a 00 00
	00		 je	 $LN9@SpecificSk
  00077	81 f9 c8 01 00
	00		 cmp	 ecx, 456		; 000001c8H
  0007d	0f 84 8e 00 00
	00		 je	 $LN9@SpecificSk

; 4295 : 	}
; 4296 : 	else if( bySkillNum == AT_SKILL_FLAMESTRIKE ||
; 4297 : 			 bySkillNum == AT_MSKILL_MG_FLAMESTRIKE1 ||

  00083	81 f9 ec 00 00
	00		 cmp	 ecx, 236		; 000000ecH
  00089	74 67		 je	 SHORT $LN12@SpecificSk
  0008b	81 f9 ec 01 00
	00		 cmp	 ecx, 492		; 000001ecH
  00091	74 5f		 je	 SHORT $LN12@SpecificSk
  00093	81 f9 ee 01 00
	00		 cmp	 ecx, 494		; 000001eeH
  00099	74 57		 je	 SHORT $LN12@SpecificSk

; 4302 : 	}
; 4303 : 	else if( bySkillNum == AT_SKILL_GIGANTICSTORM ||

  0009b	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  000a1	74 30		 je	 SHORT $LN15@SpecificSk
  000a3	81 f9 f0 01 00
	00		 cmp	 ecx, 496		; 000001f0H
  000a9	74 28		 je	 SHORT $LN15@SpecificSk

; 4308 : 	}
; 4309 : 	else if( bySkillNum == AT_MSKILL_DK_BLOODSTORM || bySkillNum == AT_MSKILL_DK_BLOODSTORM1 )

  000ab	81 f9 58 01 00
	00		 cmp	 ecx, 344		; 00000158H
  000b1	74 08		 je	 SHORT $LN17@SpecificSk
  000b3	81 f9 5a 01 00
	00		 cmp	 ecx, 346		; 0000015aH
  000b9	75 32		 jne	 SHORT $LN19@SpecificSk
$LN17@SpecificSk:

; 4310 : 	{
; 4311 : 		gObjUseSkill.BloodStormExplosionAttack(lpObj,lpTargetObj,iAttackDamage);

  000bb	ff 75 14	 push	 DWORD PTR _iAttackDamage$[ebp]
  000be	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000c3	ff 75 0c	 push	 DWORD PTR _lpTargetObj$[ebp]
  000c6	ff 75 08	 push	 DWORD PTR _lpObj$[ebp]
  000c9	e8 00 00 00 00	 call	 ?BloodStormExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjUseSkill::BloodStormExplosionAttack
  000ce	5e		 pop	 esi

; 4312 : 	}
; 4313 : }

  000cf	5d		 pop	 ebp
  000d0	c2 10 00	 ret	 16			; 00000010H
$LN15@SpecificSk:

; 4304 : 		bySkillNum == AT_MSKILL_MG_GIGANTICSTORM1 )
; 4305 : 	{
; 4306 : 		GCStateInfoSend(lpTargetObj,1,0x54);

  000d3	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  000d6	6a 54		 push	 84			; 00000054H
  000d8	6a 01		 push	 1
  000da	56		 push	 esi
  000db	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend

; 4307 : 		GCStateInfoSend(lpTargetObj,0,0x54);

  000e0	6a 54		 push	 84			; 00000054H
  000e2	6a 00		 push	 0
  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend
  000ea	83 c4 18	 add	 esp, 24			; 00000018H
$LN19@SpecificSk:
  000ed	5e		 pop	 esi

; 4312 : 	}
; 4313 : }

  000ee	5d		 pop	 ebp
  000ef	c2 10 00	 ret	 16			; 00000010H
$LN12@SpecificSk:

; 4298 : 			 bySkillNum == AT_MSKILL_MG_FLAMESTRIKE2 )
; 4299 : 	{
; 4300 : 		GCStateInfoSend(lpTargetObj,1,0x53);

  000f2	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  000f5	6a 53		 push	 83			; 00000053H
  000f7	6a 01		 push	 1
  000f9	56		 push	 esi
  000fa	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend

; 4301 : 		GCStateInfoSend(lpTargetObj,0,0x53);

  000ff	6a 53		 push	 83			; 00000053H
  00101	6a 00		 push	 0
  00103	56		 push	 esi
  00104	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend
  00109	83 c4 18	 add	 esp, 24			; 00000018H
  0010c	5e		 pop	 esi

; 4312 : 	}
; 4313 : }

  0010d	5d		 pop	 ebp
  0010e	c2 10 00	 ret	 16			; 00000010H
$LN9@SpecificSk:

; 4291 : 		     bySkillNum == AT_MSKILL_SUM_LIGHTNSHOCK1 )
; 4292 : 	{
; 4293 : 		GCStateInfoSend(lpTargetObj,1,0x55);

  00111	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  00114	6a 55		 push	 85			; 00000055H
  00116	6a 01		 push	 1
  00118	56		 push	 esi
  00119	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend

; 4294 : 		GCStateInfoSend(lpTargetObj,0,0x55);

  0011e	6a 55		 push	 85			; 00000055H

; 4301 : 		GCStateInfoSend(lpTargetObj,0,0x53);

  00120	6a 00		 push	 0
  00122	56		 push	 esi
  00123	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend
  00128	83 c4 18	 add	 esp, 24			; 00000018H
  0012b	5e		 pop	 esi

; 4312 : 	}
; 4313 : }

  0012c	5d		 pop	 ebp
  0012d	c2 10 00	 ret	 16			; 00000010H
$LN4@SpecificSk:

; 4281 : 		bySkillNum == AT_MSKILL_DL_FIRESCREAM1 )
; 4282 : 	{
; 4283 : 		gObjUseSkill.FireScreamExplosionAttack(lpObj,lpTargetObj,iAttackDamage);

  00130	ff 75 14	 push	 DWORD PTR _iAttackDamage$[ebp]

; 4288 : 		gObjUseSkill.FireScreamExplosionAttack(lpObj,lpTargetObj,iAttackDamage+fSkillValue);

  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00138	ff 75 0c	 push	 DWORD PTR _lpTargetObj$[ebp]
  0013b	ff 75 08	 push	 DWORD PTR _lpObj$[ebp]
  0013e	e8 00 00 00 00	 call	 ?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjUseSkill::FireScreamExplosionAttack

; 4312 : 	}
; 4313 : }

  00143	5d		 pop	 ebp
  00144	c2 10 00	 ret	 16			; 00000010H
?SpecificSkillAdditionTreat@CObjUseSkill@@QAEXPAUOBJECTSTRUCT@@0PAVCMagicInf@@H@Z ENDP ; CObjUseSkill::SpecificSkillAdditionTreat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_iExplosionDamage$1$ = -4				; size = 4
tv397 = 8						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
tv402 = 16						; size = 4
_iAttackDamage$ = 16					; size = 4
?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z PROC ; CObjUseSkill::FireScreamExplosionAttack, COMDAT
; _this$ = ecx

; 4198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 4199 : 
; 4200 : 	if(gObjIsConnected(lpObj->m_Index) == false && gObjIsConnected(lpTargetObj->m_Index) == false)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	ff 37		 push	 DWORD PTR [edi]
  0000a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	75 18		 jne	 SHORT $LN4@FireScream
  00016	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	75 07		 jne	 SHORT $LN4@FireScream
  00027	5f		 pop	 edi

; 4273 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
$LN4@FireScream:
  0002e	56		 push	 esi
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h

; 39   : 	int GetFireScreamExplosionRate(){return this->m_iFireScreamExplosionRate;}

  0002f	8b 35 24 00 00
	00		 mov	 esi, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+36
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 4205 : 	if(rand()%10000 > g_SkillAdditionInfo.GetFireScreamExplosionRate())

  00035	e8 00 00 00 00	 call	 _rand
  0003a	99		 cdq
  0003b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00040	f7 f9		 idiv	 ecx
  00042	3b d6		 cmp	 edx, esi
  00044	7e 0a		 jle	 SHORT $LN5@FireScream

; 4206 : 	{
; 4207 : 		return false;

  00046	5e		 pop	 esi
  00047	33 c0		 xor	 eax, eax
  00049	5f		 pop	 edi

; 4273 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@FireScream:

; 4208 : 	}
; 4209 : 
; 4210 : 	int iExplosionDamage = iAttackDamage / 10;

  00050	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00055	f7 6d 10	 imul	 DWORD PTR _iAttackDamage$[ebp]
  00058	c1 fa 02	 sar	 edx, 2
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00060	03 c2		 add	 eax, edx
  00062	89 45 fc	 mov	 DWORD PTR _iExplosionDamage$1$[ebp], eax

; 4211 : 	int iTarObjNum;
; 4212 : 
; 4213 : 	if(iExplosionDamage < 1)

  00065	83 f8 01	 cmp	 eax, 1
  00068	0f 8c e0 00 00
	00		 jl	 $LN42@FireScream

; 4214 : 	{
; 4215 : 		return true;
; 4216 : 	}
; 4217 : 
; 4218 : 	int iCount = 0;

  0006e	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00073	8d b7 4a 0c 00
	00		 lea	 esi, DWORD PTR [edi+3146]
  00079	89 45 08	 mov	 DWORD PTR tv397[ebp], eax
  0007c	53		 push	 ebx
  0007d	0f 1f 00	 npad	 3
$LL2@FireScream:

; 4219 : 	int bEnableAttack;
; 4220 : 
; 4221 : 	while( true )
; 4222 : 	{
; 4223 : 		if(lpObj->VpPlayer2[iCount].state != 0)

  00080	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00084	0f 84 b4 00 00
	00		 je	 $LN33@FireScream

; 4224 : 		{
; 4225 : 			iTarObjNum = lpObj->VpPlayer2[iCount].number;

  0008a	0f bf 1e	 movsx	 ebx, WORD PTR [esi]

; 4226 : 
; 4227 : 			if(iTarObjNum >= 0)

  0008d	85 db		 test	 ebx, ebx
  0008f	0f 88 a9 00 00
	00		 js	 $LN33@FireScream

; 4228 : 			{
; 4229 : 				bEnableAttack = 0;
; 4230 : 
; 4231 : 				if(gObj[iTarObjNum].Type == OBJ_MONSTER && gObj[iTarObjNum].m_RecallMon < 0)

  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  000a0	89 4d 10	 mov	 DWORD PTR tv402[ebp], ecx
  000a3	03 c8		 add	 ecx, eax
  000a5	8a 41 50	 mov	 al, BYTE PTR [ecx+80]
  000a8	3c 02		 cmp	 al, 2
  000aa	75 09		 jne	 SHORT $LN9@FireScream
  000ac	83 b9 30 06 00
	00 00		 cmp	 DWORD PTR [ecx+1584], 0
  000b3	7c 5a		 jl	 SHORT $LN34@FireScream
$LN9@FireScream:

; 4232 : 				{
; 4233 : 					bEnableAttack = 1;
; 4234 : 				}
; 4235 : 				else if(lpTargetObj->Type == OBJ_USER && lpObj->Type == OBJ_USER && gObj[iTarObjNum].Type != OBJ_NPC)

  000b5	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000b8	80 7a 50 01	 cmp	 BYTE PTR [edx+80], 1
  000bc	75 0a		 jne	 SHORT $LN11@FireScream
  000be	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  000c2	75 04		 jne	 SHORT $LN11@FireScream
  000c4	3c 03		 cmp	 al, 3
  000c6	75 4a		 jne	 SHORT $LN32@FireScream
$LN11@FireScream:

; 4236 : 				{
; 4237 : 					bEnableAttack = 1;
; 4238 : 				}
; 4239 : 				else if(lpTargetObj->m_cChaosCastleIndex == gObj[iTarObjNum].m_cChaosCastleIndex && lpTargetObj->m_cChaosCastleIndex != -1)

  000c8	8a 82 3d 12 00
	00		 mov	 al, BYTE PTR [edx+4669]
  000ce	3a 81 3d 12 00
	00		 cmp	 al, BYTE PTR [ecx+4669]
  000d4	75 04		 jne	 SHORT $LN13@FireScream
  000d6	3c ff		 cmp	 al, -1
  000d8	75 38		 jne	 SHORT $LN32@FireScream
$LN13@FireScream:

; 4240 : 				{
; 4241 : 					bEnableAttack = 1;
; 4242 : 				}
; 4243 : #if (GS_CASTLE == 1)
; 4244 : 				else if(lpObj->VpPlayer2[iCount].type != OBJ_NPC && gObj[iTarObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000da	80 7e 02 03	 cmp	 BYTE PTR [esi+2], 3
  000de	74 5b		 je	 SHORT $LN40@FireScream
  000e0	80 b9 23 01 00
	00 1e		 cmp	 BYTE PTR [ecx+291], 30	; 0000001eH
  000e7	75 52		 jne	 SHORT $LN40@FireScream
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000ee	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  000f3	83 f8 07	 cmp	 eax, 7
  000f6	75 43		 jne	 SHORT $LN40@FireScream

; 4245 : 				{
; 4246 : 					if( lpObj->m_btCsJoinSide != gObj[iTarObjNum].m_btCsJoinSide )

  000f8	8b 4d 10	 mov	 ecx, DWORD PTR tv402[ebp]
  000fb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00101	8a 87 5a 20 00
	00		 mov	 al, BYTE PTR [edi+8282]
  00107	3a 81 5a 20 00
	00		 cmp	 al, BYTE PTR [ecx+8282]
  0010d	74 2c		 je	 SHORT $LN40@FireScream
$LN34@FireScream:
  0010f	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
$LN32@FireScream:

; 4247 : 						bEnableAttack = 1;
; 4248 : 				}
; 4249 : #endif
; 4250 : 				if(bEnableAttack != 0)
; 4251 : 				{
; 4252 : 					if(lpObj->m_Index != gObj[iTarObjNum].m_Index)

  00112	8b 07		 mov	 eax, DWORD PTR [edi]
  00114	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00116	74 23		 je	 SHORT $LN40@FireScream

; 4253 : 					{
; 4254 : 						int iSkillDistance = gObjCalDistance(lpTargetObj,&gObj[iTarObjNum]);

  00118	51		 push	 ecx
  00119	52		 push	 edx
  0011a	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0011f	83 c4 08	 add	 esp, 8

; 4255 : 
; 4256 : 						if(iSkillDistance <= g_SkillAdditionInfo.GetFireScreamExplosionAttackDistance())

  00122	3b 05 20 00 00
	00		 cmp	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+32
  00128	7f 11		 jg	 SHORT $LN40@FireScream

; 4257 : 						{
; 4258 : 							gObjAddMsgSendDelay(lpObj,54,iTarObjNum,100,iExplosionDamage);

  0012a	ff 75 fc	 push	 DWORD PTR _iExplosionDamage$1$[ebp]
  0012d	6a 64		 push	 100			; 00000064H
  0012f	53		 push	 ebx
  00130	6a 36		 push	 54			; 00000036H
  00132	57		 push	 edi
  00133	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00138	83 c4 14	 add	 esp, 20			; 00000014H
$LN40@FireScream:
  0013b	8b 45 08	 mov	 eax, DWORD PTR tv397[ebp]
$LN33@FireScream:

; 4259 : 						}
; 4260 : 					}
; 4261 : 				}
; 4262 : 			}
; 4263 : 		}
; 4264 : 
; 4265 : 		iCount++;

  0013e	83 c6 0c	 add	 esi, 12			; 0000000cH

; 4266 : 
; 4267 : 		if(iCount > MAX_VIEWPORT -1)

  00141	83 e8 01	 sub	 eax, 1
  00144	89 45 08	 mov	 DWORD PTR tv397[ebp], eax
  00147	0f 85 33 ff ff
	ff		 jne	 $LL2@FireScream
  0014d	5b		 pop	 ebx
$LN42@FireScream:
  0014e	5e		 pop	 esi

; 4268 : 		{
; 4269 : 			break;
; 4270 : 		}
; 4271 : 	}
; 4272 : 	return true;

  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	5f		 pop	 edi

; 4273 : }

  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 0c 00	 ret	 12			; 0000000cH
?FireScreamExplosionAttack@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@0H@Z ENDP ; CObjUseSkill::FireScreamExplosionAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillFireScream, COMDAT
; _this$ = ecx

; 4167 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4168 : 	if(g_SkillAdditionInfo.GetFireScreamSkill() == false)

  00003	83 3d 1c 00 00
	00 00		 cmp	 DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+28, 0
  0000a	75 06		 jne	 SHORT $LN2@SkillFireS

; 4169 : 	{
; 4170 : 		return false;

  0000c	33 c0		 xor	 eax, eax

; 4193 : }

  0000e	5d		 pop	 ebp
  0000f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SkillFireS:
  00012	56		 push	 esi

; 4171 : 	}
; 4172 : 
; 4173 : 	LPOBJ lpObj = &gObj[aIndex];

  00013	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0001a	57		 push	 edi

; 4174 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0001b	69 7d 0c 40 27
	00 00		 imul	 edi, DWORD PTR _aTargetIndex$[ebp], 10048
  00022	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 4175 : 
; 4176 : 	if(gObjIsConnected(lpObj->m_Index) == false && gObjIsConnected(lpTargetObj->m_Index) == false)

  0002e	ff 36		 push	 DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00035	83 c4 04	 add	 esp, 4
  00038	85 c0		 test	 eax, eax
  0003a	75 0e		 jne	 SHORT $LN3@SkillFireS
  0003c	ff 37		 push	 DWORD PTR [edi]
  0003e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00043	83 c4 04	 add	 esp, 4
  00046	85 c0		 test	 eax, eax
  00048	74 10		 je	 SHORT $LN11@SkillFireS
$LN3@SkillFireS:

; 4177 : 	{
; 4178 : 		return false;
; 4179 : 	}
; 4180 : 
; 4181 : 	if(lpObj->Type != OBJ_USER)

  0004a	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0004e	75 0a		 jne	 SHORT $LN11@SkillFireS

; 4182 : 	{
; 4183 : 		return false;
; 4184 : 	}
; 4185 : 
; 4186 : 	if(lpObj->Class != CLASS_DARKLORD)

  00050	66 83 be 90 00
	00 00 04	 cmp	 WORD PTR [esi+144], 4
  00058	74 08		 je	 SHORT $LN5@SkillFireS
$LN11@SkillFireS:
  0005a	5f		 pop	 edi

; 4187 : 	{
; 4188 : 		return false;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 4193 : }

  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@SkillFireS:

; 4189 : 	}
; 4190 : 
; 4191 : 	gObjAttack(lpObj,lpTargetObj,lpMagic,0,0,0,0,0,0);

  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	ff 75 10	 push	 DWORD PTR _lpMagic$[ebp]
  00071	57		 push	 edi
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00078	83 c4 24	 add	 esp, 36			; 00000024H

; 4192 : 	return true;

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi

; 4193 : }

  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillFireScream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillInfinityArrow, COMDAT
; _this$ = ecx

; 4134 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4135 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0000b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 4136 : 
; 4137 : 	if(lpObj->Type != OBJ_USER)

  00011	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00015	0f 85 87 00 00
	00		 jne	 $LN4@SkillInfin

; 4138 : 	{
; 4139 : 		return false;
; 4140 : 	}
; 4141 : 
; 4142 : 	if(lpObj->Class != CLASS_ELF || lpObj->ChangeUP == 0)

  0001b	66 83 be 90 00
	00 00 02	 cmp	 WORD PTR [esi+144], 2
  00023	75 7d		 jne	 SHORT $LN4@SkillInfin
  00025	80 be 93 00 00
	00 00		 cmp	 BYTE PTR [esi+147], 0
  0002c	74 74		 je	 SHORT $LN4@SkillInfin

; 4145 : 	}
; 4146 : 
; 4147 : 	if(lpObj->m_Index != aTargetIndex)

  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	3b 45 0c	 cmp	 eax, DWORD PTR _aTargetIndex$[ebp]
  00033	75 6d		 jne	 SHORT $LN4@SkillInfin

; 4148 : 	{
; 4149 : 		return false;
; 4150 : 	}
; 4151 : 
; 4152 : 	if( gObjCheckUsedBuffEffect(lpObj,BUFF_INFINITY_ARROW) == TRUE )

  00035	6a 06		 push	 6
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0003d	83 c4 08	 add	 esp, 8
  00040	3c 01		 cmp	 al, 1
  00042	74 5e		 je	 SHORT $LN4@SkillInfin

; 4153 : 	{
; 4154 : 		return false;
; 4155 : 	}
; 4156 : 	
; 4157 : 
; 4158 : 	gObjAddBuffEffect(lpObj,BUFF_INFINITY_ARROW,0,0,0,0,g_SkillAdditionInfo.GetInfinityArrowSkillTime());

  00044	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+4
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	6a 06		 push	 6
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 4159 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpObj->m_Index,1);

  0005a	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0005d	6a 01		 push	 1
  0005f	ff 36		 push	 DWORD PTR [esi]
  00061	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 4160 : 
; 4161 : 	LogAddTD("[%s][%s] Use Infinity Arrow Skill (Time:%d)(Character Level : %d)(ChangeUp: %d)",

  0006c	0f b6 86 93 00
	00 00		 movzx	 eax, BYTE PTR [esi+147]
  00073	50		 push	 eax
  00074	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  0007b	50		 push	 eax
  0007c	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+4
  00082	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00085	50		 push	 eax
  00086	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NONLFBKD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Infinity?5Arrow?5Skil@
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00095	83 c4 44	 add	 esp, 68			; 00000044H

; 4162 : 		lpObj->AccountID,lpObj->Name,g_SkillAdditionInfo.GetInfinityArrowSkillTime(),lpObj->Level,lpObj->ChangeUP);
; 4163 : 	return true;

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	5e		 pop	 esi

; 4164 : }

  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SkillInfin:

; 4143 : 	{
; 4144 : 		return false;

  000a2	33 c0		 xor	 eax, eax
  000a4	5e		 pop	 esi

; 4164 : }

  000a5	5d		 pop	 ebp
  000a6	c2 0c 00	 ret	 12			; 0000000cH
?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillInfinityArrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -16					; size = 4
tv437 = -12						; size = 4
_HitCount$1$ = -8					; size = 4
tv455 = -4						; size = 4
tv456 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillFenrirAttack, COMDAT
; _this$ = ecx

; 4033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4034 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	57		 push	 edi
  0000d	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00014	03 f9		 add	 edi, ecx

; 4035 : 	int tObjNum;
; 4036 : 	int count = 0;
; 4037 : 	int HitCount = 0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _HitCount$1$[ebp], 0

; 4038 : 	int bAttack;
; 4039 : 	int DuelIndex = lpObj->m_iDuelUser;

  0001d	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]
  00023	89 45 f0	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax

; 4040 : 	int EnableAttack;
; 4041 : 
; 4042 : 	if(lpObj->Level < 300)

  00026	b8 2c 01 00 00	 mov	 eax, 300		; 0000012cH
  0002b	66 39 87 96 00
	00 00		 cmp	 WORD PTR [edi+150], ax
  00032	7d 09		 jge	 SHORT $LN37@SkillFenri

; 4043 : 	{
; 4044 : 		return false;

  00034	33 c0		 xor	 eax, eax
  00036	5f		 pop	 edi

; 4129 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
$LN37@SkillFenri:
  0003d	53		 push	 ebx

; 4045 : 	}
; 4046 : 
; 4047 : 	while( true )
; 4048 : 	{
; 4049 : 		if(lpObj->VpPlayer2[count].state != 0)

  0003e	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00043	c7 45 f4 0b 02
	00 00		 mov	 DWORD PTR tv437[ebp], 523 ; 0000020bH
  0004a	56		 push	 esi
  0004b	8d 9f 4c 0c 00
	00		 lea	 ebx, DWORD PTR [edi+3148]
  00051	89 45 08	 mov	 DWORD PTR tv456[ebp], eax
$LL2@SkillFenri:
  00054	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00058	0f 84 1c 01 00
	00		 je	 $LN24@SkillFenri

; 4050 : 		{
; 4051 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0005e	0f bf 73 fe	 movsx	 esi, WORD PTR [ebx-2]

; 4052 : 
; 4053 : 			if(tObjNum >= 0)

  00062	85 f6		 test	 esi, esi
  00064	0f 88 10 01 00
	00		 js	 $LN24@SkillFenri

; 4054 : 			{
; 4055 : 				EnableAttack = 0;
; 4056 : 
; 4057 : 				if( (gObj[tObjNum].Class < 100 || gObj[tObjNum].Class > 110) && gObj[tObjNum].Class != 523 )

  0006a	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00070	89 55 fc	 mov	 DWORD PTR tv455[ebp], edx
  00073	0f b7 84 0a 90
	00 00 00	 movzx	 eax, WORD PTR [edx+ecx+144]
  0007b	83 f8 64	 cmp	 eax, 100		; 00000064H
  0007e	72 09		 jb	 SHORT $LN8@SkillFenri
  00080	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00083	0f 86 ee 00 00
	00		 jbe	 $LN42@SkillFenri
$LN8@SkillFenri:
  00089	66 3b 45 f4	 cmp	 ax, WORD PTR tv437[ebp]
  0008d	0f 84 e4 00 00
	00		 je	 $LN42@SkillFenri

; 4058 : 				{
; 4059 : 					if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00093	8a 03		 mov	 al, BYTE PTR [ebx]
  00095	3c 02		 cmp	 al, 2
  00097	75 0e		 jne	 SHORT $LN9@SkillFenri
  00099	83 bc 0a 30 06
	00 00 00	 cmp	 DWORD PTR [edx+ecx+1584], 0
  000a1	0f 8c 8a 00 00
	00		 jl	 $LN13@SkillFenri
$LN9@SkillFenri:

; 4060 : 					{
; 4061 : 						EnableAttack = 1;
; 4062 : 					}
; 4063 : 					else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000a7	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  000aa	0f 84 81 00 00
	00		 je	 $LN13@SkillFenri
  000b0	39 75 f0	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000b3	74 7c		 je	 SHORT $LN13@SkillFenri

; 4064 : 					{
; 4065 : 						EnableAttack = 1;
; 4066 : 					}
; 4067 : #if (GS_CASTLE == 1)
; 4068 : 					else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000b5	3c 03		 cmp	 al, 3
  000b7	74 37		 je	 SHORT $LN14@SkillFenri
  000b9	80 bc 0a 23 01
	00 00 1e	 cmp	 BYTE PTR [edx+ecx+291], 30 ; 0000001eH
  000c1	75 2d		 jne	 SHORT $LN14@SkillFenri
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000c8	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 4069 : 					{
; 4070 : 						if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	8b 55 fc	 mov	 edx, DWORD PTR tv455[ebp]
  000d6	83 f8 07	 cmp	 eax, 7
  000d9	75 15		 jne	 SHORT $LN14@SkillFenri
  000db	8a 87 5a 20 00
	00		 mov	 al, BYTE PTR [edi+8282]
  000e1	3a 84 0a 5a 20
	00 00		 cmp	 al, BYTE PTR [edx+ecx+8282]
  000e8	0f 84 89 00 00
	00		 je	 $LN42@SkillFenri

; 4071 : 							EnableAttack = 1;
; 4072 : 					}
; 4073 : #endif
; 4074 : 					else

  000ee	eb 41		 jmp	 SHORT $LN13@SkillFenri
$LN14@SkillFenri:

; 4075 : 					{
; 4076 : 						int CallMonIndex = gObj[tObjNum].m_Index;
; 4077 : 
; 4078 : 
; 4079 : 						if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000f0	8b 45 fc	 mov	 eax, DWORD PTR tv455[ebp]
  000f3	8b 14 0a	 mov	 edx, DWORD PTR [edx+ecx]
  000f6	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  000fb	75 14		 jne	 SHORT $LN17@SkillFenri
  000fd	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  00104	85 c0		 test	 eax, eax
  00106	78 09		 js	 SHORT $LN17@SkillFenri

; 4080 : 						{
; 4081 : 							CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00108	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0010e	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN17@SkillFenri:

; 4082 : 						}
; 4083 : 
; 4084 : 						if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex]) == 1)

  00111	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00117	03 c1		 add	 eax, ecx
  00119	50		 push	 eax
  0011a	57		 push	 edi
  0011b	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00120	83 c4 08	 add	 esp, 8
  00123	83 f8 01	 cmp	 eax, 1
  00126	75 49		 jne	 SHORT $LN39@SkillFenri
  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012e	8b 55 fc	 mov	 edx, DWORD PTR tv455[ebp]
$LN13@SkillFenri:

; 4085 : 						{
; 4086 : 							EnableAttack = 1;
; 4087 : 						}
; 4088 : 					}
; 4089 : 				}
; 4090 : 
; 4091 : 				if(EnableAttack != 0)
; 4092 : 				{
; 4093 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 6)

  00131	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00134	50		 push	 eax
  00135	57		 push	 edi
  00136	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0013b	83 c4 08	 add	 esp, 8
  0013e	83 f8 06	 cmp	 eax, 6
  00141	7d 2e		 jge	 SHORT $LN39@SkillFenri

; 4094 : 					{
; 4095 : 						bAttack = 0;
; 4096 : 
; 4097 : 						if(HitCount >= 5)

  00143	33 c0		 xor	 eax, eax
  00145	83 7d f8 05	 cmp	 DWORD PTR _HitCount$1$[ebp], 5
  00149	0f 9c c0	 setl	 al

; 4098 : 						{
; 4099 : 							bAttack = 0;
; 4100 : 						}
; 4101 : 						else
; 4102 : 						{
; 4103 : 							bAttack = 1;
; 4104 : 						}
; 4105 : 
; 4106 : 						if(tObjNum == aTargetIndex)

  0014c	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  0014f	74 04		 je	 SHORT $LN36@SkillFenri

; 4107 : 						{
; 4108 : 							bAttack = 1;
; 4109 : 						}
; 4110 : 
; 4111 : 						if(bAttack != 0)

  00151	85 c0		 test	 eax, eax
  00153	74 1c		 je	 SHORT $LN39@SkillFenri
$LN36@SkillFenri:

; 4112 : 						{
; 4113 : 							gObjAddAttackProcMsgSendDelay(lpObj,53,tObjNum,300,lpMagic->m_Skill,0);

  00155	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00158	6a 00		 push	 0
  0015a	ff 70 08	 push	 DWORD PTR [eax+8]
  0015d	68 2c 01 00 00	 push	 300			; 0000012cH
  00162	56		 push	 esi
  00163	6a 35		 push	 53			; 00000035H
  00165	57		 push	 edi
  00166	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0016b	83 c4 18	 add	 esp, 24			; 00000018H

; 4114 : 							HitCount++;

  0016e	ff 45 f8	 inc	 DWORD PTR _HitCount$1$[ebp]
$LN39@SkillFenri:
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN42@SkillFenri:
  00177	8b 45 08	 mov	 eax, DWORD PTR tv456[ebp]
$LN24@SkillFenri:

; 4115 : 						}
; 4116 : 					}
; 4117 : 				}
; 4118 : 			}
; 4119 : 		}
; 4120 : 
; 4121 : 		count++;

  0017a	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 4122 : 
; 4123 : 		if(count > MAX_VIEWPORT - 1)

  0017d	83 e8 01	 sub	 eax, 1
  00180	89 45 08	 mov	 DWORD PTR tv456[ebp], eax
  00183	0f 85 cb fe ff
	ff		 jne	 $LL2@SkillFenri

; 4124 : 		{
; 4125 : 			break;
; 4126 : 		}
; 4127 : 	}
; 4128 : 	return true;

  00189	5e		 pop	 esi
  0018a	5b		 pop	 ebx
  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	5f		 pop	 edi

; 4129 : }

  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	c2 0c 00	 ret	 12			; 0000000cH
?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillFenrirAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iSkillNumber$ = 12					; size = 4
?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z PROC ; CObjUseSkill::RemoveSpecificSkillState, COMDAT
; _this$ = ecx

; 4316 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4317 : 	if(lpObj->Type != OBJ_USER)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  0000a	74 06		 je	 SHORT $LN2@RemoveSpec

; 4318 : 	{
; 4319 : 		return false;

  0000c	33 c0		 xor	 eax, eax

; 4331 : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN2@RemoveSpec:

; 4320 : 	}
; 4321 : 
; 4322 : 	if(iSkillNumber == AT_SKILL_ATTACK)

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _iSkillNumber$[ebp]
  00015	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  00018	75 14		 jne	 SHORT $LN3@RemoveSpec

; 4323 : 	{
; 4324 : 		gObjRemoveBuffEffect(lpObj,BUFF_ADD_ATTACK);

  0001a	6a 01		 push	 1

; 4327 : 	{
; 4328 : 		gObjRemoveBuffEffect(lpObj,BUFF_ADD_DEFENSE);

  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00022	83 c4 08	 add	 esp, 8

; 4329 : 	}
; 4330 : 	return true;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 4331 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
$LN3@RemoveSpec:

; 4325 : 	}
; 4326 : 	else if(iSkillNumber == AT_SKILL_DEFENSE)

  0002e	83 f9 1b	 cmp	 ecx, 27			; 0000001bH
  00031	75 0b		 jne	 SHORT $LN5@RemoveSpec

; 4327 : 	{
; 4328 : 		gObjRemoveBuffEffect(lpObj,BUFF_ADD_DEFENSE);

  00033	6a 02		 push	 2
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  0003b	83 c4 08	 add	 esp, 8
$LN5@RemoveSpec:

; 4329 : 	}
; 4330 : 	return true;

  0003e	b8 01 00 00 00	 mov	 eax, 1

; 4331 : }

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
?RemoveSpecificSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP ; CObjUseSkill::RemoveSpecificSkillState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState, COMDAT
; _this$ = ecx

; 3452 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3453 : 	if(lpObj->Type != OBJ_USER)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  0000a	74 06		 je	 SHORT $LN2@RemoveAllC

; 3454 : 	{
; 3455 : 		return false;

  0000c	33 c0		 xor	 eax, eax

; 3461 : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
$LN2@RemoveAllC:

; 3456 : 	}
; 3457 : 
; 3458 : 	lpObj->m_SkillAttackTime2 = 0;

  00012	c6 80 08 06 00
	00 00		 mov	 BYTE PTR [eax+1544], 0

; 3459 : 	lpObj->m_SkillAttack2 = 0;

  00019	c7 80 04 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1540], 0

; 3460 : 	return true;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 3461 : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z
_TEXT	SEGMENT
_iangle$1$ = -4						; size = 4
_this$1$ = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_btX$ = 20						; size = 1
_btY$ = 24						; size = 1
_btDir$ = 28						; size = 1
tv428 = 32						; size = 4
_btTargetPos$ = 32					; size = 1
?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z PROC ; CObjUseSkill::SkillStun, COMDAT
; _this$ = ecx

; 3675 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 3676 : 	if(OBJMAX_RANGE(aIndex) == false)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000b	85 ff		 test	 edi, edi
  0000d	0f 88 6c 01 00
	00		 js	 $LN23@SkillStun
  00013	33 c0		 xor	 eax, eax
  00015	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 59 01 00
	00		 je	 $LN23@SkillStun

; 3679 : 	}
; 3680 : 
; 3681 : 	LPOBJ lpObj = &gObj[aIndex];
; 3682 : 
; 3683 : 	int TargePosx = lpObj->X - (8 - (btTargetPos & 15));
; 3684 : 	int TargePosy = lpObj->Y - (8 - ((btTargetPos & 240) >> 4));
; 3685 : 
; 3686 : 	int iangle = GetAngle(lpObj->X,lpObj->Y,TargePosx,TargePosy);

  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	0f b6 75 20	 movzx	 esi, BYTE PTR _btTargetPos$[ebp]
  0002c	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  00032	8b c6		 mov	 eax, esi
  00034	c1 e8 04	 shr	 eax, 4
  00037	83 e6 0f	 and	 esi, 15			; 0000000fH
  0003a	83 c0 f8	 add	 eax, -8			; fffffff8H
  0003d	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	89 5d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00046	0f b6 93 21 01
	00 00		 movzx	 edx, BYTE PTR [ebx+289]
  0004d	0f b6 8b 20 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+288]
  00054	03 c2		 add	 eax, edx
  00056	50		 push	 eax
  00057	8d 46 f8	 lea	 eax, DWORD PTR [esi-8]
  0005a	03 c1		 add	 eax, ecx
  0005c	50		 push	 eax
  0005d	52		 push	 edx
  0005e	51		 push	 ecx
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00062	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle

; 3687 : 
; 3688 : #if (__CUSTOM__ == 1)
; 3689 : #else
; 3690 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3691 : 	{
; 3692 : 		return false;
; 3693 : 	}
; 3694 : #endif
; 3695 : 
; 3696 : 	int tObjNum;
; 3697 : 	int count = 0;
; 3698 : 
; 3699 : 	gObjSetKillCount(aIndex,0);

  00067	6a 00		 push	 0
  00069	57		 push	 edi
  0006a	89 45 fc	 mov	 DWORD PTR _iangle$1$[ebp], eax
  0006d	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount
  00072	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00077	8d b3 4c 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3148]
  0007d	83 c4 08	 add	 esp, 8
  00080	89 4d 20	 mov	 DWORD PTR tv428[ebp], ecx
$LL2@SkillStun:

; 3700 : 
; 3701 : 	while( true )
; 3702 : 	{
; 3703 : 		if(lpObj->VpPlayer2[count].state != 0)

  00083	80 7e fc 00	 cmp	 BYTE PTR [esi-4], 0
  00087	0f 84 d5 00 00
	00		 je	 $LN10@SkillStun

; 3704 : 		{
; 3705 : 			if(lpObj->VpPlayer2[count].type == OBJ_USER || lpObj->VpPlayer2[count].type == OBJ_MONSTER)

  0008d	8a 06		 mov	 al, BYTE PTR [esi]
  0008f	3c 01		 cmp	 al, 1
  00091	74 08		 je	 SHORT $LN7@SkillStun
  00093	3c 02		 cmp	 al, 2
  00095	0f 85 c7 00 00
	00		 jne	 $LN10@SkillStun
$LN7@SkillStun:

; 3706 : 			{
; 3707 : 				tObjNum = lpObj->VpPlayer2[count].number;

  0009b	0f bf 7e fe	 movsx	 edi, WORD PTR [esi-2]

; 3708 : 
; 3709 : 				if(OBJMAX_RANGE(tObjNum))

  0009f	85 ff		 test	 edi, edi
  000a1	0f 88 bb 00 00
	00		 js	 $LN10@SkillStun
  000a7	33 c0		 xor	 eax, eax
  000a9	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  000af	0f 9e c0	 setle	 al
  000b2	85 c0		 test	 eax, eax
  000b4	0f 84 a8 00 00
	00		 je	 $LN10@SkillStun

; 3710 : 				{
; 3711 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) <= 4)

  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bf	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  000c5	03 c3		 add	 eax, ebx
  000c7	50		 push	 eax
  000c8	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  000cb	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000d0	83 c4 08	 add	 esp, 8
  000d3	83 f8 04	 cmp	 eax, 4
  000d6	0f 8f 83 00 00
	00		 jg	 $LN25@SkillStun

; 3712 : 					{
; 3713 : 						if(SkillElectricSparkHitBox.HitCheck(iangle,lpObj->X,lpObj->Y,gObj[tObjNum].X,gObj[tObjNum].Y))

  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	0f b6 84 19 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+289]
  000ea	50		 push	 eax
  000eb	0f b6 84 19 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+288]
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  000f6	50		 push	 eax
  000f7	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000fe	50		 push	 eax
  000ff	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00106	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillElectricSparkHitBox@@3VCSkillHitBox@@A ; SkillElectricSparkHitBox
  0010b	50		 push	 eax
  0010c	ff 75 fc	 push	 DWORD PTR _iangle$1$[ebp]
  0010f	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  00114	85 c0		 test	 eax, eax
  00116	74 47		 je	 SHORT $LN25@SkillStun

; 3714 : 						{
; 3715 : 							gObjAddBuffEffect(&gObj[tObjNum],BUFF_STUN,0,0,0,0,10);

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011d	6a 0a		 push	 10			; 0000000aH
  0011f	6a 00		 push	 0
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	03 c3		 add	 eax, ebx
  00129	6a 3d		 push	 61			; 0000003dH
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 3716 : 							GCMagicAttackNumberSend(lpObj,AT_SKILL_STUN,tObjNum,1);

  00131	6a 01		 push	 1
  00133	57		 push	 edi
  00134	6a 43		 push	 67			; 00000043H
  00136	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  00139	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3717 : 							gObjSetPosition(tObjNum,gObj[tObjNum].X,gObj[tObjNum].Y);

  0013e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00144	0f b6 84 19 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+289]
  0014c	50		 push	 eax
  0014d	0f b6 84 19 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+288]
  00155	50		 push	 eax
  00156	57		 push	 edi
  00157	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  0015c	83 c4 38	 add	 esp, 56			; 00000038H
$LN25@SkillStun:
  0015f	8b 4d 20	 mov	 ecx, DWORD PTR tv428[ebp]
$LN10@SkillStun:

; 3718 : 						}
; 3719 : 					}
; 3720 : 				}
; 3721 : 			}
; 3722 : 		}
; 3723 : 
; 3724 : 		count++;

  00162	83 c6 0c	 add	 esi, 12			; 0000000cH

; 3725 : 
; 3726 : 		if(count > MAX_VIEWPORT - 1)

  00165	83 e9 01	 sub	 ecx, 1
  00168	89 4d 20	 mov	 DWORD PTR tv428[ebp], ecx
  0016b	0f 85 12 ff ff
	ff		 jne	 $LL2@SkillStun

; 3727 : 		{
; 3728 : 			break;
; 3729 : 		}
; 3730 : 	}
; 3731 : 	return true;

  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx
  00173	b8 01 00 00 00	 mov	 eax, 1
  00178	5f		 pop	 edi

; 3732 : }

  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c2 1c 00	 ret	 28			; 0000001cH
$LN23@SkillStun:

; 3677 : 	{
; 3678 : 		return false;

  0017f	33 c0		 xor	 eax, eax
  00181	5f		 pop	 edi

; 3732 : }

  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 1c 00	 ret	 28			; 0000001cH
?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z ENDP ; CObjUseSkill::SkillStun
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z PROC	; CObjUseSkill::RemoveCloakingEffect, COMDAT
; _this$ = ecx

; 3914 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3915 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 2f		 js	 SHORT $LN6@RemoveCloa
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 20		 je	 SHORT $LN6@RemoveCloa

; 3918 : 	}
; 3919 : 
; 3920 : 	gObjRemoveBuffEffect(&gObj[aIndex],BUFF_INVISIBILITY);

  00019	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  0001f	6a 12		 push	 18			; 00000012H
  00021	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  0002d	83 c4 08	 add	 esp, 8

; 3921 : 	return true;

  00030	b8 01 00 00 00	 mov	 eax, 1

; 3922 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN6@RemoveCloa:

; 3916 : 	{
; 3917 : 		return false;

  00039	33 c0		 xor	 eax, eax

; 3922 : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z ENDP	; CObjUseSkill::RemoveCloakingEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
tv336 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillRemoveMagic, COMDAT
; _this$ = ecx

; 3984 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3985 : 	if(OBJMAX_RANGE(aIndex) == false)

  00006	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00009	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000c	85 d2		 test	 edx, edx
  0000e	0f 88 c4 00 00
	00		 js	 $LN20@SkillRemov
  00014	33 c0		 xor	 eax, eax
  00016	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0001c	0f 9e c0	 setle	 al
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 b1 00 00
	00		 je	 $LN20@SkillRemov

; 3988 : 	}
; 3989 : 
; 3990 : 	LPOBJ lpObj = &gObj[aIndex];

  00027	53		 push	 ebx
  00028	56		 push	 esi
  00029	69 da 40 27 00
	00		 imul	 ebx, edx, 10048
  0002f	57		 push	 edi

; 3991 : 
; 3992 : #if (__CUSTOM__ == 1)
; 3993 : #else
; 3994 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3995 : 	{
; 3996 : 		return false;
; 3997 : 	}
; 3998 : #endif
; 3999 : 
; 4000 : 	int tObjNum;
; 4001 : 	int count = 0;
; 4002 : 
; 4003 : 	gObjSetKillCount(aIndex,0);

  00030	6a 00		 push	 0
  00032	52		 push	 edx
  00033	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	89 5d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  0003c	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 4004 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_MAGIC,lpObj->m_Index,1);

  00041	6a 01		 push	 1
  00043	ff 33		 push	 DWORD PTR [ebx]
  00045	6a 48		 push	 72			; 00000048H
  00047	53		 push	 ebx
  00048	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0004d	8d b3 4a 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3146]
  00053	83 c4 18	 add	 esp, 24			; 00000018H
  00056	bb 4b 00 00 00	 mov	 ebx, 75			; 0000004bH
  0005b	0f 1f 44 00 00	 npad	 5
$LL2@SkillRemov:

; 4005 : 
; 4006 : 	while ( true )
; 4007 : 	{
; 4008 : 		if(lpObj->VpPlayer2[count].state != 0)

  00060	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00064	74 5e		 je	 SHORT $LN7@SkillRemov

; 4009 : 		{
; 4010 : 			tObjNum = lpObj->VpPlayer2[count].number;

  00066	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 4011 : 
; 4012 : 			if(OBJMAX_RANGE(tObjNum) && lpObj->VpPlayer2[count].type == OBJ_USER)

  00069	85 ff		 test	 edi, edi
  0006b	78 57		 js	 SHORT $LN7@SkillRemov
  0006d	33 c0		 xor	 eax, eax
  0006f	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00075	0f 9e c0	 setle	 al
  00078	85 c0		 test	 eax, eax
  0007a	74 48		 je	 SHORT $LN7@SkillRemov
  0007c	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  00080	75 42		 jne	 SHORT $LN7@SkillRemov

; 4013 : 			{
; 4014 : 				if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  0008d	03 c1		 add	 eax, ecx
  0008f	89 4d fc	 mov	 DWORD PTR tv336[ebp], ecx
  00092	50		 push	 eax
  00093	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  00096	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0009b	83 c4 08	 add	 esp, 8
  0009e	83 f8 05	 cmp	 eax, 5
  000a1	7d 21		 jge	 SHORT $LN7@SkillRemov

; 4015 : 				{
; 4016 : 					RemoveAllCharacterInvalidMagicAndSkillState(&gObj[tObjNum]);

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a8	03 45 fc	 add	 eax, DWORD PTR tv336[ebp]
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ?RemoveAllCharacterInvalidMagicAndSkillState@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@@Z ; CObjUseSkill::RemoveAllCharacterInvalidMagicAndSkillState

; 4017 : 					GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_MAGIC,tObjNum,1);

  000b4	6a 01		 push	 1
  000b6	57		 push	 edi
  000b7	6a 48		 push	 72			; 00000048H
  000b9	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  000bc	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000c1	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@SkillRemov:

; 4018 : 				}
; 4019 : 			}
; 4020 : 		}
; 4021 : 
; 4022 : 		count++;

  000c4	83 c6 0c	 add	 esi, 12			; 0000000cH

; 4023 : 
; 4024 : 		if(count > MAX_VIEWPORT - 1)

  000c7	83 eb 01	 sub	 ebx, 1
  000ca	75 94		 jne	 SHORT $LL2@SkillRemov

; 4025 : 		{
; 4026 : 			break;
; 4027 : 		}
; 4028 : 	}
; 4029 : 	return true;

  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000d1	5b		 pop	 ebx

; 4030 : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH
$LN20@SkillRemov:

; 3986 : 	{
; 3987 : 		return false;

  000d8	33 c0		 xor	 eax, eax

; 4030 : }

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 0c 00	 ret	 12			; 0000000cH
?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillRemoveMagic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
tv357 = 12						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillRemoveCloaking, COMDAT
; _this$ = ecx

; 3925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3926 : 	if(OBJMAX_RANGE(aIndex) == false)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 88 e8 00 00
	00		 js	 $LN21@SkillRemov
  0000f	33 c0		 xor	 eax, eax
  00011	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 d5 00 00
	00		 je	 $LN21@SkillRemov

; 3929 : 	}
; 3930 : 
; 3931 : 	LPOBJ lpObj = &gObj[aIndex];
; 3932 : 
; 3933 : #if (__CUSTOM__ == 1)
; 3934 : #else
; 3935 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3936 : 	{
; 3937 : 		return false;
; 3938 : 	}
; 3939 : #endif
; 3940 : 
; 3941 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00022	69 4d 0c 40 27
	00 00		 imul	 ecx, DWORD PTR _aTargetIndex$[ebp], 10048
  00029	53		 push	 ebx
  0002a	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00030	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	89 5d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ebx

; 3942 : 
; 3943 : 	if( (lpTargetObj->Authority&32)== 32 && gObjCheckUsedBuffEffect(lpTargetObj,BUFF_INVISIBILITY) )

  0003f	f6 81 bc 01 00
	00 20		 test	 BYTE PTR [ecx+444], 32	; 00000020H
  00046	74 17		 je	 SHORT $LN5@SkillRemov
  00048	6a 12		 push	 18			; 00000012H
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00050	83 c4 08	 add	 esp, 8
  00053	84 c0		 test	 al, al
  00055	74 08		 je	 SHORT $LN5@SkillRemov

; 3944 : 	{
; 3945 : 		return false;

  00057	5b		 pop	 ebx
  00058	33 c0		 xor	 eax, eax
  0005a	5e		 pop	 esi

; 3978 : }

  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
$LN5@SkillRemov:

; 3946 : 	}
; 3947 :  
; 3948 : 	int tObjNum;
; 3949 : 	int count = 0;
; 3950 : 
; 3951 : 	gObjSetKillCount(aIndex,0);

  0005f	6a 00		 push	 0
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3952 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_INVISIBLE,lpObj->m_Index,1);

  00067	6a 01		 push	 1
  00069	ff 33		 push	 DWORD PTR [ebx]
  0006b	6a 47		 push	 71			; 00000047H
  0006d	53		 push	 ebx
  0006e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00073	83 c4 18	 add	 esp, 24			; 00000018H
  00076	8d b3 4a 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3146]
  0007c	bb 4b 00 00 00	 mov	 ebx, 75			; 0000004bH
  00081	57		 push	 edi
$LL2@SkillRemov:

; 3953 : 
; 3954 : 	while ( true )
; 3955 : 	{
; 3956 : 		if(lpObj->VpPlayer2[count].state != 0)

  00082	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00086	74 5d		 je	 SHORT $LN8@SkillRemov

; 3957 : 		{
; 3958 : 			tObjNum = lpObj->VpPlayer2[count].number;

  00088	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 3959 : 
; 3960 : 			if(OBJMAX_RANGE(tObjNum) && lpObj->VpPlayer2[count].type == OBJ_USER)

  0008b	85 ff		 test	 edi, edi
  0008d	78 56		 js	 SHORT $LN8@SkillRemov
  0008f	33 c0		 xor	 eax, eax
  00091	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00097	0f 9e c0	 setle	 al
  0009a	85 c0		 test	 eax, eax
  0009c	74 47		 je	 SHORT $LN8@SkillRemov
  0009e	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  000a2	75 41		 jne	 SHORT $LN8@SkillRemov

; 3961 : 			{
; 3962 : 				if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a9	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  000af	03 c1		 add	 eax, ecx
  000b1	89 4d 0c	 mov	 DWORD PTR tv357[ebp], ecx
  000b4	50		 push	 eax
  000b5	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  000b8	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000bd	83 c4 08	 add	 esp, 8
  000c0	83 f8 05	 cmp	 eax, 5
  000c3	7d 20		 jge	 SHORT $LN8@SkillRemov

; 3963 : 				{
; 3964 : 					gObjRemoveBuffEffect(&gObj[tObjNum],BUFF_INVISIBILITY);

  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ca	03 45 0c	 add	 eax, DWORD PTR tv357[ebp]
  000cd	6a 12		 push	 18			; 00000012H
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 3965 : 					GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_INVISIBLE,tObjNum,1);

  000d5	6a 01		 push	 1
  000d7	57		 push	 edi
  000d8	6a 47		 push	 71			; 00000047H
  000da	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  000dd	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000e2	83 c4 18	 add	 esp, 24			; 00000018H
$LN8@SkillRemov:

; 3966 : 				}
; 3967 : 			}
; 3968 : 		}
; 3969 : 
; 3970 : 		count++;

  000e5	83 c6 0c	 add	 esi, 12			; 0000000cH

; 3971 : 
; 3972 : 		if(count > MAX_VIEWPORT - 1)

  000e8	83 eb 01	 sub	 ebx, 1
  000eb	75 95		 jne	 SHORT $LL2@SkillRemov

; 3973 : 		{
; 3974 : 			break;
; 3975 : 		}
; 3976 : 	}
; 3977 : 	return true;

  000ed	5f		 pop	 edi
  000ee	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000f1	5b		 pop	 ebx
  000f2	5e		 pop	 esi

; 3978 : }

  000f3	5d		 pop	 ebp
  000f4	c2 0c 00	 ret	 12			; 0000000cH
$LN21@SkillRemov:

; 3927 : 	{
; 3928 : 		return false;

  000f7	33 c0		 xor	 eax, eax
  000f9	5e		 pop	 esi

; 3978 : }

  000fa	5d		 pop	 ebp
  000fb	c2 0c 00	 ret	 12			; 0000000cH
?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillRemoveCloaking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillCloaking, COMDAT
; _this$ = ecx

; 3876 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3877 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 88 c6 00 00
	00		 js	 $LN10@SkillCloak
  0000e	33 c0		 xor	 eax, eax
  00010	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 b3 00 00
	00		 je	 $LN10@SkillCloak

; 3880 : 	}
; 3881 : 
; 3882 : 	if(OBJMAX_RANGE(aTargetIndex) == false)

  00021	56		 push	 esi
  00022	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	0f 88 a0 00 00
	00		 js	 $LN11@SkillCloak
  0002d	33 c0		 xor	 eax, eax
  0002f	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00035	0f 9e c0	 setle	 al
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 8d 00 00
	00		 je	 $LN11@SkillCloak

; 3885 : 	}
; 3886 : 
; 3887 : 	LPOBJ lpObj = &gObj[aIndex];
; 3888 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  00040	53		 push	 ebx
  00041	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00047	57		 push	 edi
  00048	69 f9 40 27 00
	00		 imul	 edi, ecx, 10048
  0004e	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00054	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3889 : 
; 3890 : #if (__CUSTOM__ == 1)
; 3891 : #else
; 3892 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3893 : 	{
; 3894 : 		return false;
; 3895 : 	}
; 3896 : #endif
; 3897 : 
; 3898 : 	if(lpTargetObj->Type != OBJ_USER)

  0005a	8a 53 50	 mov	 dl, BYTE PTR [ebx+80]
  0005d	80 fa 01	 cmp	 dl, 1
  00060	74 2b		 je	 SHORT $LN4@SkillCloak

; 3899 : 	{
; 3900 : 		LogAddTD("[ANTI-HACK][Cloaking Skill] [%s][%s] Invalid Targeting  TargetType [%d] TargetClass [%d]",

  00062	0f b7 83 90 00
	00 00		 movzx	 eax, WORD PTR [ebx+144]
  00069	50		 push	 eax
  0006a	0f b6 c2	 movzx	 eax, dl
  0006d	50		 push	 eax
  0006e	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00071	50		 push	 eax
  00072	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00075	50		 push	 eax
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@KFEKMJMJ@?$FLANTI?9HACK?$FN?$FLCloaking?5Skill?$FN?5?$FL?$CFs?$FN@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00081	83 c4 14	 add	 esp, 20			; 00000014H

; 3901 : 			lpObj->AccountID,lpObj->Name,lpTargetObj->Type,lpTargetObj->Class);
; 3902 : 		return false;

  00084	33 c0		 xor	 eax, eax
  00086	5f		 pop	 edi
  00087	5b		 pop	 ebx
  00088	5e		 pop	 esi

; 3911 : }

  00089	5d		 pop	 ebp
  0008a	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SkillCloak:

; 3903 : 	}
; 3904 : 
; 3905 : 	gObjSetKillCount(aIndex,0);

  0008d	6a 00		 push	 0
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3906 : 
; 3907 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_INVISIBLE,lpObj->m_Index,1);

  00095	6a 01		 push	 1
  00097	ff 37		 push	 DWORD PTR [edi]
  00099	6a 46		 push	 70			; 00000046H
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3908 : 	gObjAddBuffEffect(lpTargetObj,BUFF_INVISIBILITY,0,0,0,0,60);

  000a1	6a 3c		 push	 60			; 0000003cH
  000a3	6a 00		 push	 0
  000a5	6a 00		 push	 0
  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	6a 12		 push	 18			; 00000012H
  000ad	53		 push	 ebx
  000ae	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 3909 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_INVISIBLE,aTargetIndex,1);

  000b3	6a 01		 push	 1
  000b5	56		 push	 esi
  000b6	6a 46		 push	 70			; 00000046H
  000b8	57		 push	 edi
  000b9	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000be	83 c4 44	 add	 esp, 68			; 00000044H

; 3910 : 	return true;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	5f		 pop	 edi
  000c7	5b		 pop	 ebx
  000c8	5e		 pop	 esi

; 3911 : }

  000c9	5d		 pop	 ebp
  000ca	c2 0c 00	 ret	 12			; 0000000cH
$LN11@SkillCloak:

; 3883 : 	{
; 3884 : 		return false;

  000cd	33 c0		 xor	 eax, eax
  000cf	5e		 pop	 esi

; 3911 : }

  000d0	5d		 pop	 ebp
  000d1	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SkillCloak:

; 3878 : 	{
; 3879 : 		return false;

  000d4	33 c0		 xor	 eax, eax

; 3911 : }

  000d6	5d		 pop	 ebp
  000d7	c2 0c 00	 ret	 12			; 0000000cH
?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillCloaking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv506 = -12						; size = 4
_count$1$ = -8						; size = 4
tv508 = -4						; size = 4
tv507 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillAddMana, COMDAT
; _this$ = ecx

; 3794 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3795 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 88 f2 02 00
	00		 js	 $LN24@SkillAddMa
  00011	33 c0		 xor	 eax, eax
  00013	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 df 02 00
	00		 je	 $LN24@SkillAddMa

; 3798 : 	}
; 3799 : 
; 3800 : 	LPOBJ lpObj = &gObj[aIndex];

  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  0002c	57		 push	 edi

; 3801 : 
; 3802 : #if (__CUSTOM__ == 1)
; 3803 : #else
; 3804 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3805 : 	{
; 3806 : 		return false;
; 3807 : 	}
; 3808 : #endif
; 3809 : 
; 3810 : 	int tObjNum;
; 3811 : 	int count = 0;
; 3812 : 	gObjSetKillCount(aIndex,0);

  0002d	6a 00		 push	 0
  0002f	51		 push	 ecx
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$1$[ebp], 0
  00037	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount
  00042	66 0f 6e 83 28
	01 00 00	 movd	 xmm0, DWORD PTR [ebx+296]

; 3813 : 
; 3814 : 	int iSwelledMana = 0;
; 3815 : 	iSwelledMana = (int)((lpObj->MaxMana + lpObj->AddMana) * 50.0f / 100.0f);

  0004a	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 3816 : 
; 3817 : 	gObjAddBuffEffect(lpObj,BUFF_SWELL_MANA,ADD_OPTION_MANA,iSwelledMana,0,0,60);

  0004d	6a 3c		 push	 60			; 0000003cH
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	f3 0f 58 83 f0
	00 00 00	 addss	 xmm0, DWORD PTR [ebx+240]
  0005b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42480000
  00063	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0006b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0006f	50		 push	 eax
  00070	6a 05		 push	 5
  00072	6a 09		 push	 9
  00074	53		 push	 ebx
  00075	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  0007a	66 0f 6e 83 28
	01 00 00	 movd	 xmm0, DWORD PTR [ebx+296]

; 3818 : 	GCManaSend(lpObj->m_Index,(WORD)(lpObj->MaxMana+lpObj->AddMana),0xFE,0,lpObj->MaxBP+lpObj->AddBP);

  00082	66 8b 83 0c 01
	00 00		 mov	 ax, WORD PTR [ebx+268]
  00089	66 03 83 08 01
	00 00		 add	 ax, WORD PTR [ebx+264]
  00090	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00093	0f b7 c0	 movzx	 eax, ax
  00096	50		 push	 eax
  00097	6a 00		 push	 0
  00099	68 fe 00 00 00	 push	 254			; 000000feH
  0009e	f3 0f 58 83 f0
	00 00 00	 addss	 xmm0, DWORD PTR [ebx+240]
  000a6	f3 0f 2c c0	 cvttss2si eax, xmm0
  000aa	0f b7 c0	 movzx	 eax, ax
  000ad	50		 push	 eax
  000ae	ff 33		 push	 DWORD PTR [ebx]
  000b0	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  000b5	66 0f 6e 8b 28
	01 00 00	 movd	 xmm1, DWORD PTR [ebx+296]
  000bd	83 c4 38	 add	 esp, 56			; 00000038H

; 3819 : 
; 3820 : 	if( (lpObj->MaxMana + lpObj->AddMana) < lpObj->Mana)

  000c0	f3 0f 10 83 ec
	00 00 00	 movss	 xmm0, DWORD PTR [ebx+236]
  000c8	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000cb	f3 0f 58 8b f0
	00 00 00	 addss	 xmm1, DWORD PTR [ebx+240]
  000d3	0f 2f c1	 comiss	 xmm0, xmm1
  000d6	76 29		 jbe	 SHORT $LN5@SkillAddMa

; 3821 : 	{
; 3822 : 		lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;
; 3823 : 		GCManaSend(lpObj->m_Index,(WORD)lpObj->Mana,0xFF,0,lpObj->BP);

  000d8	0f b7 83 04 01
	00 00		 movzx	 eax, WORD PTR [ebx+260]
  000df	50		 push	 eax
  000e0	f3 0f 2c c1	 cvttss2si eax, xmm1
  000e4	6a 00		 push	 0
  000e6	68 ff 00 00 00	 push	 255			; 000000ffH
  000eb	f3 0f 11 8b ec
	00 00 00	 movss	 DWORD PTR [ebx+236], xmm1
  000f3	0f b7 c0	 movzx	 eax, ax
  000f6	50		 push	 eax
  000f7	ff 33		 push	 DWORD PTR [ebx]
  000f9	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  000fe	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@SkillAddMa:

; 3824 : 	}
; 3825 : 
; 3826 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_ADD_MANA,lpObj->m_Index,1);

  00101	6a 01		 push	 1
  00103	ff 33		 push	 DWORD PTR [ebx]
  00105	6a 45		 push	 69			; 00000045H
  00107	53		 push	 ebx
  00108	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0010d	8d 8b 4c 0c 00
	00		 lea	 ecx, DWORD PTR [ebx+3148]
  00113	83 c4 10	 add	 esp, 16			; 00000010H
  00116	89 4d fc	 mov	 DWORD PTR tv508[ebp], ecx
  00119	8d bb 4c 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3148]
  0011f	8d 8b 4a 0c 00
	00		 lea	 ecx, DWORD PTR [ebx+3146]
  00125	33 d2		 xor	 edx, edx
  00127	89 4d 08	 mov	 DWORD PTR tv507[ebp], ecx
  0012a	8d 83 4a 0c 00
	00		 lea	 eax, DWORD PTR [ebx+3146]
  00130	8d 8b 48 0c 00
	00		 lea	 ecx, DWORD PTR [ebx+3144]
$LN32@SkillAddMa:
  00136	89 4d f4	 mov	 DWORD PTR tv506[ebp], ecx
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@SkillAddMa:

; 3827 : 
; 3828 : 	while( true )
; 3829 : 	{
; 3830 : 		if(lpObj->VpPlayer2[count].state != 0)

  00140	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00143	0f 84 8d 01 00
	00		 je	 $LN25@SkillAddMa

; 3831 : 		{
; 3832 : 			tObjNum = lpObj->VpPlayer2[count].number;

  00149	8b 7d 08	 mov	 edi, DWORD PTR tv507[ebp]
  0014c	0f bf 3f	 movsx	 edi, WORD PTR [edi]

; 3833 : 
; 3834 : 			if(OBJMAX_RANGE(tObjNum) && lpObj->VpPlayer2[count].type == OBJ_USER)

  0014f	85 ff		 test	 edi, edi
  00151	0f 88 79 01 00
	00		 js	 $LN31@SkillAddMa
  00157	33 c0		 xor	 eax, eax
  00159	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0015f	0f 9e c0	 setle	 al
  00162	85 c0		 test	 eax, eax
  00164	0f 84 66 01 00
	00		 je	 $LN31@SkillAddMa
  0016a	8b 45 fc	 mov	 eax, DWORD PTR tv508[ebp]
  0016d	80 38 01	 cmp	 BYTE PTR [eax], 1
  00170	0f 85 5a 01 00
	00		 jne	 $LN31@SkillAddMa

; 3835 : 			{
; 3836 : 				if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  00176	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017b	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00181	03 c6		 add	 eax, esi
  00183	50		 push	 eax
  00184	53		 push	 ebx
  00185	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0018a	83 c4 08	 add	 esp, 8
  0018d	83 f8 05	 cmp	 eax, 5
  00190	0f 8d 34 01 00
	00		 jge	 $LN28@SkillAddMa

; 3837 : 				{
; 3838 : 					if(lpObj->GuildNumber > 0 && gObj[tObjNum].GuildNumber > 0)

  00196	8b 8b 14 06 00
	00		 mov	 ecx, DWORD PTR [ebx+1556]
  0019c	85 c9		 test	 ecx, ecx
  0019e	0f 8e 26 01 00
	00		 jle	 $LN28@SkillAddMa
  001a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001aa	03 d6		 add	 edx, esi
  001ac	8b 82 14 06 00
	00		 mov	 eax, DWORD PTR [edx+1556]
  001b2	85 c0		 test	 eax, eax
  001b4	0f 8e 10 01 00
	00		 jle	 $LN28@SkillAddMa

; 3839 : 					{
; 3840 : 						if(lpObj->GuildNumber != gObj[tObjNum].GuildNumber)

  001ba	3b c8		 cmp	 ecx, eax
  001bc	74 22		 je	 SHORT $LN10@SkillAddMa

; 3841 : 						{
; 3842 : 							count++;

  001be	8b 55 f8	 mov	 edx, DWORD PTR _count$1$[ebp]
  001c1	8b 4d f4	 mov	 ecx, DWORD PTR tv506[ebp]
  001c4	42		 inc	 edx
  001c5	8b 7d fc	 mov	 edi, DWORD PTR tv508[ebp]
  001c8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001cb	83 45 08 0c	 add	 DWORD PTR tv507[ebp], 12 ; 0000000cH
  001cf	83 c7 0c	 add	 edi, 12			; 0000000cH

; 3843 : 							continue;

  001d2	8b 45 08	 mov	 eax, DWORD PTR tv507[ebp]
  001d5	89 55 f8	 mov	 DWORD PTR _count$1$[ebp], edx
  001d8	89 7d fc	 mov	 DWORD PTR tv508[ebp], edi
  001db	e9 56 ff ff ff	 jmp	 $LN32@SkillAddMa
$LN10@SkillAddMa:
  001e0	66 0f 6e 82 28
	01 00 00	 movd	 xmm0, DWORD PTR [edx+296]

; 3844 : 						}
; 3845 : 
; 3846 : 
; 3847 : 						iSwelledMana = (int)((gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana) * 50.0f / 100.0f);

  001e8	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 3848 : 						gObjAddBuffEffect(&gObj[tObjNum],BUFF_SWELL_MANA,ADD_OPTION_MANA,iSwelledMana,0,0,60);

  001eb	6a 3c		 push	 60			; 0000003cH
  001ed	6a 00		 push	 0
  001ef	6a 00		 push	 0
  001f1	f3 0f 58 82 f0
	00 00 00	 addss	 xmm0, DWORD PTR [edx+240]
  001f9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42480000
  00201	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00209	f3 0f 2c c0	 cvttss2si eax, xmm0
  0020d	50		 push	 eax
  0020e	6a 05		 push	 5
  00210	6a 09		 push	 9
  00212	52		 push	 edx
  00213	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 3849 : 						GCManaSend(tObjNum,(WORD)(gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana),0xFE,0,gObj[tObjNum].MaxBP + gObj[tObjNum].AddBP);

  00218	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021e	66 0f 6e 84 0e
	28 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+296]
  00227	66 8b 84 0e 0c
	01 00 00	 mov	 ax, WORD PTR [esi+ecx+268]
  0022f	66 03 84 0e 08
	01 00 00	 add	 ax, WORD PTR [esi+ecx+264]
  00237	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0023a	0f b7 c0	 movzx	 eax, ax
  0023d	50		 push	 eax
  0023e	6a 00		 push	 0
  00240	68 fe 00 00 00	 push	 254			; 000000feH
  00245	f3 0f 58 84 0e
	f0 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+240]
  0024e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00252	0f b7 c0	 movzx	 eax, ax
  00255	50		 push	 eax
  00256	57		 push	 edi
  00257	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend

; 3850 : 
; 3851 : 						if(gObj[tObjNum].Mana > gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana)

  0025c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00261	83 c4 30	 add	 esp, 48			; 00000030H
  00264	66 0f 6e 8c 06
	28 01 00 00	 movd	 xmm1, DWORD PTR [esi+eax+296]
  0026d	f3 0f 10 84 06
	ec 00 00 00	 movss	 xmm0, DWORD PTR [esi+eax+236]
  00276	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00279	f3 0f 58 8c 06
	f0 00 00 00	 addss	 xmm1, DWORD PTR [esi+eax+240]
  00282	0f 2f c1	 comiss	 xmm0, xmm1
  00285	76 35		 jbe	 SHORT $LN11@SkillAddMa

; 3852 : 						{
; 3853 : 							gObj[tObjNum].Mana = gObj[tObjNum].MaxMana + gObj[tObjNum].AddMana;

  00287	f3 0f 11 8c 06
	ec 00 00 00	 movss	 DWORD PTR [esi+eax+236], xmm1

; 3854 : 							GCManaSend(tObjNum,(WORD)gObj[tObjNum].Mana,0xFF,0,gObj[tObjNum].BP);

  00290	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00296	0f b7 84 0e 04
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+260]
  0029e	50		 push	 eax
  0029f	f3 0f 2c 84 0e
	ec 00 00 00	 cvttss2si eax, DWORD PTR [esi+ecx+236]
  002a8	6a 00		 push	 0
  002aa	68 ff 00 00 00	 push	 255			; 000000ffH
  002af	0f b7 c0	 movzx	 eax, ax
  002b2	50		 push	 eax
  002b3	57		 push	 edi
  002b4	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  002b9	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@SkillAddMa:

; 3855 : 						}
; 3856 : 						GCMagicAttackNumberSend(lpObj,AT_SKILL_ADD_MANA,tObjNum,1);

  002bc	6a 01		 push	 1
  002be	57		 push	 edi
  002bf	6a 45		 push	 69			; 00000045H
  002c1	53		 push	 ebx
  002c2	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  002c7	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@SkillAddMa:
  002ca	8b 55 f8	 mov	 edx, DWORD PTR _count$1$[ebp]
  002cd	8b 4d f4	 mov	 ecx, DWORD PTR tv506[ebp]
$LN31@SkillAddMa:
  002d0	8b 7d fc	 mov	 edi, DWORD PTR tv508[ebp]
  002d3	8b 45 08	 mov	 eax, DWORD PTR tv507[ebp]
$LN25@SkillAddMa:

; 3857 : 					}
; 3858 : 				}
; 3859 : 			}
; 3860 : 		}
; 3861 : 
; 3862 : 		count++;

  002d6	42		 inc	 edx
  002d7	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002da	83 c0 0c	 add	 eax, 12			; 0000000cH
  002dd	89 55 f8	 mov	 DWORD PTR _count$1$[ebp], edx
  002e0	83 c7 0c	 add	 edi, 12			; 0000000cH
  002e3	89 4d f4	 mov	 DWORD PTR tv506[ebp], ecx
  002e6	89 45 08	 mov	 DWORD PTR tv507[ebp], eax
  002e9	89 7d fc	 mov	 DWORD PTR tv508[ebp], edi

; 3863 : 
; 3864 : 		if(count > MAX_VIEWPORT - 1)

  002ec	83 fa 4a	 cmp	 edx, 74			; 0000004aH
  002ef	0f 8e 4b fe ff
	ff		 jle	 $LL2@SkillAddMa

; 3865 : 		{
; 3866 : 			break;
; 3867 : 		}
; 3868 : 	}
; 3869 : 	return true;

  002f5	5f		 pop	 edi
  002f6	5e		 pop	 esi
  002f7	b8 01 00 00 00	 mov	 eax, 1
  002fc	5b		 pop	 ebx

; 3870 : }

  002fd	8b e5		 mov	 esp, ebp
  002ff	5d		 pop	 ebp
  00300	c2 0c 00	 ret	 12			; 0000000cH
$LN24@SkillAddMa:

; 3796 : 	{
; 3797 : 		return false;

  00303	33 c0		 xor	 eax, eax

; 3870 : }

  00305	8b e5		 mov	 esp, ebp
  00307	5d		 pop	 ebp
  00308	c2 0c 00	 ret	 12			; 0000000cH
?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillAddMana
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv337 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillRemoveStun, COMDAT
; _this$ = ecx

; 3738 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3739 : 
; 3740 : 	if(OBJMAX_RANGE(aIndex) == false)

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00007	85 c9		 test	 ecx, ecx
  00009	0f 88 be 00 00
	00		 js	 $LN21@SkillRemov
  0000f	33 c0		 xor	 eax, eax
  00011	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 ab 00 00
	00		 je	 $LN21@SkillRemov

; 3743 : 	}
; 3744 : 
; 3745 : 	LPOBJ lpObj = &gObj[aIndex];

  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  0002a	57		 push	 edi

; 3746 : 
; 3747 : #if (__CUSTOM__ == 1)
; 3748 : #else
; 3749 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3750 : 	{
; 3751 : 		return false;
; 3752 : 	}
; 3753 : #endif
; 3754 : 
; 3755 : 	int tObjNum;
; 3756 : 	int count = 0;
; 3757 : 
; 3758 : 	gObjSetKillCount(aIndex,0);

  0002b	6a 00		 push	 0
  0002d	51		 push	 ecx
  0002e	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	89 5d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00037	e8 00 00 00 00	 call	 ?gObjSetKillCount@@YAXHH@Z ; gObjSetKillCount

; 3759 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_STUN,lpObj->m_Index,1);

  0003c	6a 01		 push	 1
  0003e	ff 33		 push	 DWORD PTR [ebx]
  00040	6a 44		 push	 68			; 00000044H
  00042	53		 push	 ebx
  00043	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00048	8d b3 4a 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3146]
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
  00051	bb 4b 00 00 00	 mov	 ebx, 75			; 0000004bH
$LL2@SkillRemov:

; 3760 : 
; 3761 : 	while( true )
; 3762 : 	{
; 3763 : 		if(lpObj->VpPlayer2[count].state != 0)

  00056	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  0005a	74 5d		 je	 SHORT $LN8@SkillRemov

; 3764 : 		{
; 3765 : 
; 3766 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0005c	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 3767 : 			if(OBJMAX_RANGE(tObjNum))

  0005f	85 ff		 test	 edi, edi
  00061	78 56		 js	 SHORT $LN8@SkillRemov
  00063	33 c0		 xor	 eax, eax
  00065	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0006b	0f 9e c0	 setle	 al
  0006e	85 c0		 test	 eax, eax
  00070	74 47		 je	 SHORT $LN8@SkillRemov

; 3768 : 			{
; 3769 : 				if(lpObj->VpPlayer2[count].type == OBJ_USER)

  00072	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  00076	75 41		 jne	 SHORT $LN8@SkillRemov

; 3770 : 				{
; 3771 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 6)

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007d	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00083	03 c1		 add	 eax, ecx
  00085	89 4d fc	 mov	 DWORD PTR tv337[ebp], ecx
  00088	50		 push	 eax
  00089	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  0008c	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00091	83 c4 08	 add	 esp, 8
  00094	83 f8 06	 cmp	 eax, 6
  00097	7d 20		 jge	 SHORT $LN8@SkillRemov

; 3772 : 					{
; 3773 : 						gObjRemoveBuffEffect(&gObj[tObjNum],BUFF_STUN);

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009e	03 45 fc	 add	 eax, DWORD PTR tv337[ebp]
  000a1	6a 3d		 push	 61			; 0000003dH
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 3774 : 						GCMagicAttackNumberSend(lpObj,AT_SKILL_REMOVAL_STUN,tObjNum,1);

  000a9	6a 01		 push	 1
  000ab	57		 push	 edi
  000ac	6a 44		 push	 68			; 00000044H
  000ae	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  000b1	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000b6	83 c4 18	 add	 esp, 24			; 00000018H
$LN8@SkillRemov:

; 3775 : 					}
; 3776 : 				}
; 3777 : 			}
; 3778 : 		}
; 3779 : 
; 3780 : 		count++;

  000b9	83 c6 0c	 add	 esi, 12			; 0000000cH

; 3781 : 
; 3782 : 		if(count > MAX_VIEWPORT - 1)

  000bc	83 eb 01	 sub	 ebx, 1
  000bf	75 95		 jne	 SHORT $LL2@SkillRemov

; 3783 : 		{
; 3784 : 			break;
; 3785 : 		}
; 3786 : 	}
; 3787 : return true;

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000c6	5b		 pop	 ebx

; 3788 : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 0c 00	 ret	 12			; 0000000cH
$LN21@SkillRemov:

; 3741 : 	{
; 3742 : 		return false;

  000cd	33 c0		 xor	 eax, eax

; 3788 : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 0c 00	 ret	 12			; 0000000cH
?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillRemoveStun
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv347 = -4						; size = 4
tv345 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillBrandOfSkill, COMDAT
; _this$ = ecx

; 3621 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3622 : 	if(OBJMAX_RANGE(aIndex) == false)

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00007	85 c9		 test	 ecx, ecx
  00009	0f 88 d6 00 00
	00		 js	 $LN21@SkillBrand
  0000f	33 c0		 xor	 eax, eax
  00011	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 c3 00 00
	00		 je	 $LN21@SkillBrand

; 3625 : 	}
; 3626 : 
; 3627 : 	LPOBJ lpObj = &gObj[aIndex];
; 3628 : 	int tObjNum;
; 3629 : 
; 3630 : #if (__CUSTOM__ == 1)
; 3631 : #else
; 3632 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3633 : 	{
; 3634 : 		return false;
; 3635 : 	}
; 3636 : #endif
; 3637 : 
; 3638 : 	int count = 0;
; 3639 : 	gObjAddBuffEffect(lpObj,BUFF_BATTLEROD,0,0,0,0,10);

  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	6a 0a		 push	 10			; 0000000aH
  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 13		 push	 19			; 00000013H
  00037	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 3640 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_BRAND_OF_SKILL,lpObj->m_Index,1);

  00043	6a 01		 push	 1
  00045	ff 33		 push	 DWORD PTR [ebx]
  00047	6a 4b		 push	 75			; 0000004bH
  00049	53		 push	 ebx
  0004a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0004f	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00054	8d b3 4a 0c 00
	00		 lea	 esi, DWORD PTR [ebx+3146]
  0005a	83 c4 2c	 add	 esp, 44			; 0000002cH
  0005d	89 4d 08	 mov	 DWORD PTR tv345[ebp], ecx
$LL2@SkillBrand:

; 3641 : 
; 3642 : 	while( true )
; 3643 : 	{
; 3644 : 		if(lpObj->VpPlayer2[count].state != 0)

  00060	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  00064	74 66		 je	 SHORT $LN8@SkillBrand

; 3645 : 		{
; 3646 : 			tObjNum = lpObj->VpPlayer2[count].number;

  00066	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 3647 : 
; 3648 : 			if(OBJMAX_RANGE(tObjNum))

  00069	85 ff		 test	 edi, edi
  0006b	78 5f		 js	 SHORT $LN8@SkillBrand
  0006d	33 c0		 xor	 eax, eax
  0006f	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00075	0f 9e c0	 setle	 al
  00078	85 c0		 test	 eax, eax
  0007a	74 50		 je	 SHORT $LN8@SkillBrand

; 3649 : 			{
; 3650 : 				if(lpObj->VpPlayer2[count].type == OBJ_USER)

  0007c	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  00080	75 4a		 jne	 SHORT $LN8@SkillBrand

; 3651 : 				{
; 3652 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  0008d	03 c1		 add	 eax, ecx
  0008f	89 4d fc	 mov	 DWORD PTR tv347[ebp], ecx
  00092	50		 push	 eax
  00093	53		 push	 ebx
  00094	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00099	83 c4 08	 add	 esp, 8
  0009c	83 f8 05	 cmp	 eax, 5
  0009f	7d 28		 jge	 SHORT $LN22@SkillBrand

; 3653 : 					{
; 3654 : 						gObjAddBuffEffect(&gObj[tObjNum],BUFF_BATTLEROD,0,0,0,0,10);

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a6	03 45 fc	 add	 eax, DWORD PTR tv347[ebp]
  000a9	6a 0a		 push	 10			; 0000000aH
  000ab	6a 00		 push	 0
  000ad	6a 00		 push	 0
  000af	6a 00		 push	 0
  000b1	6a 00		 push	 0
  000b3	6a 13		 push	 19			; 00000013H
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 3655 : 						GCMagicAttackNumberSend(lpObj,AT_SKILL_BRAND_OF_SKILL,tObjNum,1);

  000bb	6a 01		 push	 1
  000bd	57		 push	 edi
  000be	6a 4b		 push	 75			; 0000004bH
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  000c6	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN22@SkillBrand:
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR tv345[ebp]
$LN8@SkillBrand:

; 3656 : 					}
; 3657 : 				}
; 3658 : 			}
; 3659 : 		}
; 3660 : 
; 3661 : 		count++;

  000cc	83 c6 0c	 add	 esi, 12			; 0000000cH

; 3662 : 
; 3663 : 		if(count > MAX_VIEWPORT - 1)

  000cf	83 e9 01	 sub	 ecx, 1
  000d2	89 4d 08	 mov	 DWORD PTR tv345[ebp], ecx
  000d5	75 89		 jne	 SHORT $LL2@SkillBrand

; 3664 : 		{
; 3665 : 			break;
; 3666 : 		}
; 3667 : 	}
; 3668 : 	return true;

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	5b		 pop	 ebx

; 3669 : }

  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c2 0c 00	 ret	 12			; 0000000cH
$LN21@SkillBrand:

; 3623 : 	{
; 3624 : 		return false;

  000e5	33 c0		 xor	 eax, eax

; 3669 : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 0c 00	 ret	 12			; 0000000cH
?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillBrandOfSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillDarklordSpaceSplit, COMDAT
; _this$ = ecx

; 3596 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3597 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 53		 js	 SHORT $LN6@SkillDarkl
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 44		 je	 SHORT $LN6@SkillDarkl

; 3600 : 	}
; 3601 : 
; 3602 : 	LPOBJ lpObj = &gObj[aIndex];
; 3603 : 
; 3604 : #if (__CUSTOM__ == 1)
; 3605 : #else
; 3606 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3607 : 	{
; 3608 : 		return false;
; 3609 : 	}
; 3610 : #endif
; 3611 : 
; 3612 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0001e	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00024	6a 01		 push	 1
  00026	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00029	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0002d	50		 push	 eax
  0002e	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	53		 push	 ebx
  00035	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3613 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,500,lpMagic->m_Skill,0);

  0003a	6a 00		 push	 0
  0003c	ff 76 08	 push	 DWORD PTR [esi+8]
  0003f	68 f4 01 00 00	 push	 500			; 000001f4H
  00044	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00047	6a 32		 push	 50			; 00000032H
  00049	53		 push	 ebx
  0004a	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0004f	83 c4 28	 add	 esp, 40			; 00000028H

; 3614 : 	return true;

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx

; 3615 : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillDarkl:

; 3598 : 	{
; 3599 : 		return false;

  0005d	33 c0		 xor	 eax, eax

; 3615 : }

  0005f	5d		 pop	 ebp
  00060	c2 0c 00	 ret	 12			; 0000000cH
?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillDarklordSpaceSplit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillMagumDeathCannon, COMDAT
; _this$ = ecx

; 3571 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3572 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 61		 js	 SHORT $LN6@SkillMagum
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 52		 je	 SHORT $LN6@SkillMagum

; 3575 : 	}
; 3576 : 
; 3577 : 	LPOBJ lpObj = &gObj[aIndex];
; 3578 : 
; 3579 : #if (__CUSTOM__ == 1)
; 3580 : #else
; 3581 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3582 : 	{
; 3583 : 		return false;
; 3584 : 	}
; 3585 : #endif
; 3586 : 
; 3587 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00022	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00028	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0002c	6a 01		 push	 1
  0002e	57		 push	 edi
  0002f	50		 push	 eax
  00030	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3588 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0,0,0);

  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  0004c	6a 00		 push	 0
  0004e	56		 push	 esi
  0004f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	50		 push	 eax
  00056	53		 push	 ebx
  00057	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0005c	83 c4 34	 add	 esp, 52			; 00000034H

; 3589 : 	return true;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx

; 3590 : }

  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillMagum:

; 3573 : 	{
; 3574 : 		return false;

  0006b	33 c0		 xor	 eax, eax

; 3590 : }

  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillMagumDeathCannon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillMagumOneFlash, COMDAT
; _this$ = ecx

; 3545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3546 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 71		 js	 SHORT $LN6@SkillMagum
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 62		 je	 SHORT $LN6@SkillMagum

; 3549 : 	}
; 3550 : 
; 3551 : 	LPOBJ lpObj = &gObj[aIndex];
; 3552 : 
; 3553 : #if (__CUSTOM__ == 1)
; 3554 : #else
; 3555 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3556 : 	{
; 3557 : 		return false;
; 3558 : 	}
; 3559 : #endif
; 3560 : 
; 3561 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00022	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00028	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0002c	6a 01		 push	 1
  0002e	57		 push	 edi
  0002f	50		 push	 eax
  00030	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3562 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0,0,0);

  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  0004c	6a 00		 push	 0
  0004e	56		 push	 esi
  0004f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	50		 push	 eax
  00056	53		 push	 ebx
  00057	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack

; 3563 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,100,lpMagic->m_Skill,0);

  0005c	6a 00		 push	 0
  0005e	ff 76 08	 push	 DWORD PTR [esi+8]
  00061	6a 64		 push	 100			; 00000064H
  00063	57		 push	 edi
  00064	6a 32		 push	 50			; 00000032H
  00066	53		 push	 ebx
  00067	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0006c	83 c4 4c	 add	 esp, 76			; 0000004cH

; 3564 : 	return true;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 3565 : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillMagum:

; 3547 : 	{
; 3548 : 		return false;

  0007b	33 c0		 xor	 eax, eax

; 3565 : }

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillMagumOneFlash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillElfRush, COMDAT
; _this$ = ecx

; 3520 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3521 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 53		 js	 SHORT $LN6@SkillElfRu
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 44		 je	 SHORT $LN6@SkillElfRu

; 3524 : 	}
; 3525 : 
; 3526 : 	LPOBJ lpObj = &gObj[aIndex];
; 3527 : 
; 3528 : #if (__CUSTOM__ == 1)
; 3529 : #else
; 3530 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3531 : 	{
; 3532 : 		return false;
; 3533 : 	}
; 3534 : #endif
; 3535 : 
; 3536 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0001e	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00024	6a 01		 push	 1
  00026	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00029	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0002d	50		 push	 eax
  0002e	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	53		 push	 ebx
  00035	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3537 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,800,lpMagic->m_Skill,0);

  0003a	6a 00		 push	 0
  0003c	ff 76 08	 push	 DWORD PTR [esi+8]
  0003f	68 20 03 00 00	 push	 800			; 00000320H
  00044	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00047	6a 32		 push	 50			; 00000032H
  00049	53		 push	 ebx
  0004a	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0004f	83 c4 28	 add	 esp, 40			; 00000028H

; 3538 : 	return true;

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx

; 3539 : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillElfRu:

; 3522 : 	{
; 3523 : 		return false;

  0005d	33 c0		 xor	 eax, eax

; 3539 : }

  0005f	5d		 pop	 ebp
  00060	c2 0c 00	 ret	 12			; 0000000cH
?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillElfRush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillWizardJavalin, COMDAT
; _this$ = ecx

; 3492 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3493 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 67		 js	 SHORT $LN6@SkillWizar
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 58		 je	 SHORT $LN6@SkillWizar

; 3496 : 	}
; 3497 : 
; 3498 : 	LPOBJ lpObj = &gObj[aIndex];
; 3499 : #if (__CUSTOM__ == 1)
; 3500 : #else
; 3501 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3502 : 	{
; 3503 : 		return false;
; 3504 : 	}
; 3505 : #endif
; 3506 : 
; 3507 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00022	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00028	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0002c	6a 01		 push	 1
  0002e	57		 push	 edi
  0002f	50		 push	 eax
  00030	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3508 : 
; 3509 : 	int iDelay = 500;
; 3510 : 
; 3511 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,iDelay,lpMagic->m_Skill,0);

  0003c	6a 00		 push	 0
  0003e	ff 76 08	 push	 DWORD PTR [esi+8]
  00041	68 f4 01 00 00	 push	 500			; 000001f4H
  00046	57		 push	 edi
  00047	6a 32		 push	 50			; 00000032H
  00049	53		 push	 ebx
  0004a	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay

; 3512 : 	gObjAddAttackProcMsgSendDelay(lpObj,50,aTargetIndex,iDelay+200,lpMagic->m_Skill,0);

  0004f	6a 00		 push	 0
  00051	ff 76 08	 push	 DWORD PTR [esi+8]
  00054	68 bc 02 00 00	 push	 700			; 000002bcH
  00059	57		 push	 edi
  0005a	6a 32		 push	 50			; 00000032H
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00062	83 c4 40	 add	 esp, 64			; 00000040H

; 3513 : 	return true;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx

; 3514 : }

  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillWizar:

; 3494 : 	{
; 3495 : 		return false;

  00071	33 c0		 xor	 eax, eax

; 3514 : }

  00073	5d		 pop	 ebp
  00074	c2 0c 00	 ret	 12			; 0000000cH
?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillWizardJavalin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillKnightRush, COMDAT
; _this$ = ecx

; 3467 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3468 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 61		 js	 SHORT $LN6@SkillKnigh
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 52		 je	 SHORT $LN6@SkillKnigh

; 3471 : 	}
; 3472 : 
; 3473 : 	LPOBJ lpObj = &gObj[aIndex];
; 3474 : #if (__CUSTOM__ == 1)
; 3475 : 
; 3476 : #else
; 3477 : 	if(lpObj->MapNumber != MAP_INDEX_CASTLESIEGE && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 3478 : 	{
; 3479 : 		return false;
; 3480 : 	}
; 3481 : #endif
; 3482 : 
; 3483 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00022	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00028	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0002c	6a 01		 push	 1
  0002e	57		 push	 edi
  0002f	50		 push	 eax
  00030	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3484 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0,0,0);

  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  0004c	6a 00		 push	 0
  0004e	56		 push	 esi
  0004f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	50		 push	 eax
  00056	53		 push	 ebx
  00057	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0005c	83 c4 34	 add	 esp, 52			; 00000034H

; 3485 : 	return true;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx

; 3486 : }

  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SkillKnigh:

; 3469 : 	{
; 3470 : 		return false;

  0006b	33 c0		 xor	 eax, eax

; 3486 : }

  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillKnightRush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillImmuneToHarm, COMDAT
; _this$ = ecx

; 3430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3431 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 60		 js	 SHORT $LN7@SkillImmun
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 51		 je	 SHORT $LN7@SkillImmun

; 3434 : 	}
; 3435 : 
; 3436 : 	LPOBJ lpObj = &gObj[aIndex];

  00019	56		 push	 esi
  0001a	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048

; 3437 : 
; 3438 : 
; 3439 : 	if( gObjCheckUsedBuffEffect(lpObj,BUFF_MONSTERMAGIC_RESIST)== FALSE &&

  00020	6a 3f		 push	 63			; 0000003fH
  00022	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0002e	83 c4 08	 add	 esp, 8
  00031	84 c0		 test	 al, al
  00033	75 2e		 jne	 SHORT $LN3@SkillImmun
  00035	6a 40		 push	 64			; 00000040H
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0003d	83 c4 08	 add	 esp, 8
  00040	84 c0		 test	 al, al
  00042	75 1f		 jne	 SHORT $LN3@SkillImmun

; 3440 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_MONCHEMISTRY_RESIST)== FALSE )
; 3441 : 	{
; 3442 : 		gObjAddBuffEffect(lpObj,BUFF_MONCHEMISTRY_RESIST,0,0,0,0,10);

  00044	6a 0a		 push	 10			; 0000000aH
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 40		 push	 64			; 00000040H
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  00056	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3443 : 		return TRUE;

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	5e		 pop	 esi

; 3446 : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
$LN3@SkillImmun:

; 3444 : 	}
; 3445 : 	return false;

  00063	33 c0		 xor	 eax, eax
  00065	5e		 pop	 esi

; 3446 : }

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN7@SkillImmun:

; 3432 : 	{
; 3433 : 		return false;

  0006a	33 c0		 xor	 eax, eax

; 3446 : }

  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillImmuneToHarm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillImmuneToMagic, COMDAT
; _this$ = ecx

; 3408 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3409 : 	if(OBJMAX_RANGE(aIndex) == false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 60		 js	 SHORT $LN7@SkillImmun
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 51		 je	 SHORT $LN7@SkillImmun

; 3412 : 	}
; 3413 : 
; 3414 : 	LPOBJ lpObj = &gObj[aIndex];

  00019	56		 push	 esi
  0001a	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048

; 3415 : 
; 3416 : 
; 3417 : 	if( gObjCheckUsedBuffEffect(lpObj,BUFF_MONSTERMAGIC_RESIST)== FALSE &&

  00020	6a 3f		 push	 63			; 0000003fH
  00022	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0002e	83 c4 08	 add	 esp, 8
  00031	84 c0		 test	 al, al
  00033	75 2e		 jne	 SHORT $LN3@SkillImmun
  00035	6a 40		 push	 64			; 00000040H
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0003d	83 c4 08	 add	 esp, 8
  00040	84 c0		 test	 al, al
  00042	75 1f		 jne	 SHORT $LN3@SkillImmun

; 3418 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_MONCHEMISTRY_RESIST)== FALSE )
; 3419 : 	{
; 3420 : 		gObjAddBuffEffect(lpObj,BUFF_MONSTERMAGIC_RESIST,0,0,0,0,10);

  00044	6a 0a		 push	 10			; 0000000aH
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 3f		 push	 63			; 0000003fH
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  00056	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3421 : 		return TRUE;

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	5e		 pop	 esi

; 3424 : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
$LN3@SkillImmun:

; 3422 : 	}
; 3423 : 	return false;

  00063	33 c0		 xor	 eax, eax
  00065	5e		 pop	 esi

; 3424 : }

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN7@SkillImmun:

; 3410 : 	{
; 3411 : 		return false;

  0006a	33 c0		 xor	 eax, eax

; 3424 : }

  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillImmuneToMagic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_bSummonSuccess$ = -7					; size = 1
_cSummonX$1$ = -2					; size = 1
_cSY$1 = -1						; size = 1
_aIndex$ = 8						; size = 4
_cSX$2 = 11						; size = 1
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillSummon, COMDAT
; _this$ = ecx

; 3319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3320 : 	if(OBJMAX_RANGE(aIndex)==false)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 88 d5 02 00
	00		 js	 $LN24@SkillSummo
  00011	33 c0		 xor	 eax, eax
  00013	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 c2 02 00
	00		 je	 $LN24@SkillSummo

; 3323 : 	}
; 3324 : 
; 3325 : 	int iSummonCount = 1;
; 3326 : 	int iSummonMonterType = 0;
; 3327 : 	BYTE bDoSummon = 1;
; 3328 : 	BYTE bSummonSuccess = 0;
; 3329 : 	BYTE cSummonX = 0;
; 3330 : 	BYTE cSummonY = 0;
; 3331 : 
; 3332 : 	LPOBJ lpObj = &gObj[aIndex];

  00024	53		 push	 ebx
  00025	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  0002b	57		 push	 edi
  0002c	33 ff		 xor	 edi, edi
  0002e	c6 45 f9 00	 mov	 BYTE PTR _bSummonSuccess$[ebp], 0
  00032	c6 45 fe 00	 mov	 BYTE PTR _cSummonX$1$[ebp], 0
  00036	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3333 : 
; 3334 : 	switch(lpObj->Class)

  0003c	0f b7 83 90 00
	00 00		 movzx	 eax, WORD PTR [ebx+144]
  00043	05 5f ff ff ff	 add	 eax, -161		; ffffff5fH
  00048	83 f8 72	 cmp	 eax, 114		; 00000072H
  0004b	0f 87 d7 00 00
	00		 ja	 $LN14@SkillSummo
  00051	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN25@SkillSummo[eax]
  00058	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN39@SkillSummo[eax*4]
$LN8@SkillSummo:

; 3335 : 	{
; 3336 : 	case 161:
; 3337 : 		iSummonMonterType = rand()%2+ 147;

  0005f	e8 00 00 00 00	 call	 _rand
  00064	8b f8		 mov	 edi, eax
  00066	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  0006c	79 05		 jns	 SHORT $LN30@SkillSummo
  0006e	4f		 dec	 edi
  0006f	83 cf fe	 or	 edi, -2			; fffffffeH
  00072	47		 inc	 edi
$LN30@SkillSummo:
  00073	81 c7 93 00 00
	00		 add	 edi, 147		; 00000093H

; 3338 : 		bDoSummon = (rand()%15) ? false : true;
; 3339 : 		break;

  00079	e9 8a 00 00 00	 jmp	 $LN37@SkillSummo
$LN9@SkillSummo:

; 3340 : 	case 181:
; 3341 : 		iSummonMonterType = rand()%2+ 177;

  0007e	e8 00 00 00 00	 call	 _rand
  00083	8b f8		 mov	 edi, eax
  00085	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  0008b	79 05		 jns	 SHORT $LN31@SkillSummo
  0008d	4f		 dec	 edi
  0008e	83 cf fe	 or	 edi, -2			; fffffffeH
  00091	47		 inc	 edi
$LN31@SkillSummo:
  00092	81 c7 b1 00 00
	00		 add	 edi, 177		; 000000b1H

; 3342 : 		bDoSummon = (rand()%15) ? false : true;
; 3343 : 		break;

  00098	eb 6e		 jmp	 SHORT $LN37@SkillSummo
$LN10@SkillSummo:

; 3344 : 	case 189:
; 3345 : 		iSummonMonterType = rand()%2+ 185;

  0009a	e8 00 00 00 00	 call	 _rand
  0009f	8b f8		 mov	 edi, eax
  000a1	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000a7	79 05		 jns	 SHORT $LN32@SkillSummo
  000a9	4f		 dec	 edi
  000aa	83 cf fe	 or	 edi, -2			; fffffffeH
  000ad	47		 inc	 edi
$LN32@SkillSummo:
  000ae	81 c7 b9 00 00
	00		 add	 edi, 185		; 000000b9H

; 3346 : 		bDoSummon = (rand()%15) ? false : true;
; 3347 : 		break;

  000b4	eb 52		 jmp	 SHORT $LN37@SkillSummo
$LN11@SkillSummo:

; 3348 : 	case 197:
; 3349 : 		iSummonMonterType = rand()%2+ 193;

  000b6	e8 00 00 00 00	 call	 _rand
  000bb	8b f8		 mov	 edi, eax
  000bd	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000c3	79 05		 jns	 SHORT $LN33@SkillSummo
  000c5	4f		 dec	 edi
  000c6	83 cf fe	 or	 edi, -2			; fffffffeH
  000c9	47		 inc	 edi
$LN33@SkillSummo:
  000ca	81 c7 c1 00 00
	00		 add	 edi, 193		; 000000c1H

; 3350 : 		bDoSummon = (rand()%15) ? false : true;
; 3351 : 		break;

  000d0	eb 36		 jmp	 SHORT $LN37@SkillSummo
$LN12@SkillSummo:

; 3352 : 	case 267:
; 3353 : 		iSummonMonterType = rand()%2+ 263;

  000d2	e8 00 00 00 00	 call	 _rand
  000d7	8b f8		 mov	 edi, eax
  000d9	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000df	79 05		 jns	 SHORT $LN34@SkillSummo
  000e1	4f		 dec	 edi
  000e2	83 cf fe	 or	 edi, -2			; fffffffeH
  000e5	47		 inc	 edi
$LN34@SkillSummo:
  000e6	81 c7 07 01 00
	00		 add	 edi, 263		; 00000107H

; 3354 : 		bDoSummon = (rand()%15) ? false : true;
; 3355 : 		break;

  000ec	eb 1a		 jmp	 SHORT $LN37@SkillSummo
$LN13@SkillSummo:

; 3356 : 	case 275:
; 3357 : 		iSummonMonterType = rand()%2+ 271;

  000ee	e8 00 00 00 00	 call	 _rand
  000f3	8b f8		 mov	 edi, eax
  000f5	81 e7 01 00 00
	80		 and	 edi, -2147483647	; 80000001H
  000fb	79 05		 jns	 SHORT $LN35@SkillSummo
  000fd	4f		 dec	 edi
  000fe	83 cf fe	 or	 edi, -2			; fffffffeH
  00101	47		 inc	 edi
$LN35@SkillSummo:
  00102	81 c7 0f 01 00
	00		 add	 edi, 271		; 0000010fH
$LN37@SkillSummo:

; 3358 : 		bDoSummon = (rand()%15) ? false : true;

  00108	e8 00 00 00 00	 call	 _rand
  0010d	99		 cdq
  0010e	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00113	f7 f9		 idiv	 ecx
  00115	85 d2		 test	 edx, edx
  00117	0f 94 c0	 sete	 al

; 3359 : 		break;
; 3360 : 	}
; 3361 : 
; 3362 : 	if(bDoSummon == false)

  0011a	84 c0		 test	 al, al
  0011c	75 0a		 jne	 SHORT $LN14@SkillSummo

; 3363 : 	{
; 3364 : 		return false;

  0011e	5f		 pop	 edi
  0011f	33 c0		 xor	 eax, eax
  00121	5b		 pop	 ebx

; 3402 : }

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 0c 00	 ret	 12			; 0000000cH
$LN14@SkillSummo:

; 3365 : 	}
; 3366 : 
; 3367 : 	for(int iSC = 0; iSC < iSummonCount; iSC++)
; 3368 : 	{
; 3369 : 		BYTE cSX = lpObj->X;

  00128	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  0012f	88 45 0b	 mov	 BYTE PTR _cSX$2[ebp], al

; 3370 : 		BYTE cSY = lpObj->Y;

  00132	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]

; 3371 : 
; 3372 : 		if(gObjGetRandomFreeLocation(lpObj->MapNumber,(BYTE &)cSX,(BYTE &)cSY,2,2,30)==1)

  00139	6a 1e		 push	 30			; 0000001eH
  0013b	6a 02		 push	 2
  0013d	88 45 ff	 mov	 BYTE PTR _cSY$1[ebp], al
  00140	8d 45 ff	 lea	 eax, DWORD PTR _cSY$1[ebp]
  00143	6a 02		 push	 2
  00145	50		 push	 eax
  00146	8d 45 0b	 lea	 eax, DWORD PTR _cSX$2[ebp]
  00149	50		 push	 eax
  0014a	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z ; gObjGetRandomFreeLocation
  00157	83 c4 18	 add	 esp, 24			; 00000018H
  0015a	83 f8 01	 cmp	 eax, 1
  0015d	0f 85 55 01 00
	00		 jne	 $LN27@SkillSummo

; 3373 : 		{
; 3374 : 			int result = gObjAddMonster(lpObj->MapNumber);

  00163	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00170	0f bf d0	 movsx	 edx, ax
  00173	83 c4 04	 add	 esp, 4

; 3375 : 
; 3376 : 			if(result >= 0)

  00176	85 d2		 test	 edx, edx
  00178	0f 88 3a 01 00
	00		 js	 $LN27@SkillSummo

; 3377 : 			{
; 3378 : 				gObj[result].m_PosNum = (WORD)-1;

  0017e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00183	83 c9 ff	 or	 ecx, -1
  00186	56		 push	 esi
  00187	69 f2 40 27 00
	00		 imul	 esi, edx, 10048

; 3379 : 				gObj[result].X = cSX;
; 3380 : 				gObj[result].Y = cSY;
; 3381 : 				gObj[result].MapNumber = lpObj->MapNumber;
; 3382 : 				gObj[result].TX = gObj[result].X;
; 3383 : 				gObj[result].TY = gObj[result].Y;
; 3384 : 				gObj[result].m_OldX = gObj[result].X;
; 3385 : 				gObj[result].m_OldY = gObj[result].Y;
; 3386 : 				gObj[result].Dir = 1;
; 3387 : 				gObj[result].StartX = gObj[result].X;
; 3388 : 				gObj[result].StartY = gObj[result].Y;
; 3389 : 				gObjSetMonster(result,iSummonMonterType);

  0018d	57		 push	 edi
  0018e	52		 push	 edx
  0018f	66 89 8c 06 98
	05 00 00	 mov	 WORD PTR [esi+eax+1432], cx
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019d	0f b6 45 0b	 movzx	 eax, BYTE PTR _cSX$2[ebp]
  001a1	88 84 0e 20 01
	00 00		 mov	 BYTE PTR [esi+ecx+288], al
  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ae	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSY$1[ebp]
  001b2	88 84 0e 21 01
	00 00		 mov	 BYTE PTR [esi+ecx+289], al
  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001be	8a 8b 23 01 00
	00		 mov	 cl, BYTE PTR [ebx+291]
  001c4	88 8c 06 23 01
	00 00		 mov	 BYTE PTR [esi+eax+291], cl
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d1	0f b6 84 31 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+288]
  001d9	88 84 31 52 01
	00 00		 mov	 BYTE PTR [ecx+esi+338], al
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e6	0f b6 84 31 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+289]
  001ee	88 84 31 53 01
	00 00		 mov	 BYTE PTR [ecx+esi+339], al
  001f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fb	0f b6 84 31 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+288]
  00203	88 84 31 50 01
	00 00		 mov	 BYTE PTR [ecx+esi+336], al
  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00210	0f b6 84 31 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+289]
  00218	88 84 31 51 01
	00 00		 mov	 BYTE PTR [ecx+esi+337], al
  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00224	c6 84 06 22 01
	00 00 01	 mov	 BYTE PTR [esi+eax+290], 1
  0022c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00232	0f b6 84 31 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+288]
  0023a	88 84 31 4e 01
	00 00		 mov	 BYTE PTR [ecx+esi+334], al
  00241	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00247	0f b6 84 31 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+289]
  0024f	88 84 31 4f 01
	00 00		 mov	 BYTE PTR [ecx+esi+335], al
  00256	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 3390 : 				gObj[result].m_Attribute = 60;

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00260	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00265	83 c4 08	 add	 esp, 8
  00268	66 89 8c 06 96
	06 00 00	 mov	 WORD PTR [esi+eax+1686], cx

; 3391 : 				gObj[result].MaxRegenTime = 0;

  00270	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00275	c7 84 06 94 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+1428], 0

; 3392 : 				gObj[result].Dir = rand()%8;

  00280	e8 00 00 00 00	 call	 _rand
  00285	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0028a	79 05		 jns	 SHORT $LN36@SkillSummo
  0028c	48		 dec	 eax
  0028d	83 c8 f8	 or	 eax, -8			; fffffff8H
  00290	40		 inc	 eax
$LN36@SkillSummo:
  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3393 : 				bSummonSuccess = 1;

  00297	c6 45 f9 01	 mov	 BYTE PTR _bSummonSuccess$[ebp], 1
  0029b	88 84 0e 22 01
	00 00		 mov	 BYTE PTR [esi+ecx+290], al

; 3394 : 				cSummonX = gObj[result].StartX;

  002a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a7	8a 94 06 4e 01
	00 00		 mov	 dl, BYTE PTR [esi+eax+334]

; 3395 : 				cSummonY = gObj[result].StartY;

  002ae	8a 84 06 4f 01
	00 00		 mov	 al, BYTE PTR [esi+eax+335]
  002b5	5e		 pop	 esi
  002b6	eb 05		 jmp	 SHORT $LN4@SkillSummo
$LN27@SkillSummo:
  002b8	8a 55 fe	 mov	 dl, BYTE PTR _cSummonX$1$[ebp]
  002bb	8a c2		 mov	 al, dl
$LN4@SkillSummo:

; 3396 : 			}
; 3397 : 		}
; 3398 : 	}
; 3399 : 
; 3400 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_SUMMON,(((cSummonX & 0xFF)&0xFF) | ((cSummonY & 0xFF)&0xFF) << 8) & 0xFFFF,bSummonSuccess);

  002bd	ff 75 f9	 push	 DWORD PTR _bSummonSuccess$[ebp]
  002c0	0f b6 c8	 movzx	 ecx, al
  002c3	c1 e1 08	 shl	 ecx, 8
  002c6	0f b6 c2	 movzx	 eax, dl
  002c9	0b c8		 or	 ecx, eax
  002cb	51		 push	 ecx
  002cc	68 c8 00 00 00	 push	 200			; 000000c8H
  002d1	53		 push	 ebx
  002d2	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 3401 : 	return bSummonSuccess;

  002d7	0f b6 45 f9	 movzx	 eax, BYTE PTR _bSummonSuccess$[ebp]
  002db	83 c4 10	 add	 esp, 16			; 00000010H
  002de	5f		 pop	 edi
  002df	5b		 pop	 ebx

; 3402 : }

  002e0	8b e5		 mov	 esp, ebp
  002e2	5d		 pop	 ebp
  002e3	c2 0c 00	 ret	 12			; 0000000cH
$LN24@SkillSummo:

; 3321 : 	{
; 3322 : 		return false;

  002e6	33 c0		 xor	 eax, eax

; 3402 : }

  002e8	8b e5		 mov	 esp, ebp
  002ea	5d		 pop	 ebp
  002eb	c2 0c 00	 ret	 12			; 0000000cH
  002ee	66 90		 npad	 2
$LN39@SkillSummo:
  002f0	00 00 00 00	 DD	 $LN8@SkillSummo
  002f4	00 00 00 00	 DD	 $LN9@SkillSummo
  002f8	00 00 00 00	 DD	 $LN10@SkillSummo
  002fc	00 00 00 00	 DD	 $LN11@SkillSummo
  00300	00 00 00 00	 DD	 $LN12@SkillSummo
  00304	00 00 00 00	 DD	 $LN13@SkillSummo
  00308	00 00 00 00	 DD	 $LN14@SkillSummo
$LN25@SkillSummo:
  0030c	00		 DB	 0
  0030d	06		 DB	 6
  0030e	06		 DB	 6
  0030f	06		 DB	 6
  00310	06		 DB	 6
  00311	06		 DB	 6
  00312	06		 DB	 6
  00313	06		 DB	 6
  00314	06		 DB	 6
  00315	06		 DB	 6
  00316	06		 DB	 6
  00317	06		 DB	 6
  00318	06		 DB	 6
  00319	06		 DB	 6
  0031a	06		 DB	 6
  0031b	06		 DB	 6
  0031c	06		 DB	 6
  0031d	06		 DB	 6
  0031e	06		 DB	 6
  0031f	06		 DB	 6
  00320	01		 DB	 1
  00321	06		 DB	 6
  00322	06		 DB	 6
  00323	06		 DB	 6
  00324	06		 DB	 6
  00325	06		 DB	 6
  00326	06		 DB	 6
  00327	06		 DB	 6
  00328	02		 DB	 2
  00329	06		 DB	 6
  0032a	06		 DB	 6
  0032b	06		 DB	 6
  0032c	06		 DB	 6
  0032d	06		 DB	 6
  0032e	06		 DB	 6
  0032f	06		 DB	 6
  00330	03		 DB	 3
  00331	06		 DB	 6
  00332	06		 DB	 6
  00333	06		 DB	 6
  00334	06		 DB	 6
  00335	06		 DB	 6
  00336	06		 DB	 6
  00337	06		 DB	 6
  00338	06		 DB	 6
  00339	06		 DB	 6
  0033a	06		 DB	 6
  0033b	06		 DB	 6
  0033c	06		 DB	 6
  0033d	06		 DB	 6
  0033e	06		 DB	 6
  0033f	06		 DB	 6
  00340	06		 DB	 6
  00341	06		 DB	 6
  00342	06		 DB	 6
  00343	06		 DB	 6
  00344	06		 DB	 6
  00345	06		 DB	 6
  00346	06		 DB	 6
  00347	06		 DB	 6
  00348	06		 DB	 6
  00349	06		 DB	 6
  0034a	06		 DB	 6
  0034b	06		 DB	 6
  0034c	06		 DB	 6
  0034d	06		 DB	 6
  0034e	06		 DB	 6
  0034f	06		 DB	 6
  00350	06		 DB	 6
  00351	06		 DB	 6
  00352	06		 DB	 6
  00353	06		 DB	 6
  00354	06		 DB	 6
  00355	06		 DB	 6
  00356	06		 DB	 6
  00357	06		 DB	 6
  00358	06		 DB	 6
  00359	06		 DB	 6
  0035a	06		 DB	 6
  0035b	06		 DB	 6
  0035c	06		 DB	 6
  0035d	06		 DB	 6
  0035e	06		 DB	 6
  0035f	06		 DB	 6
  00360	06		 DB	 6
  00361	06		 DB	 6
  00362	06		 DB	 6
  00363	06		 DB	 6
  00364	06		 DB	 6
  00365	06		 DB	 6
  00366	06		 DB	 6
  00367	06		 DB	 6
  00368	06		 DB	 6
  00369	06		 DB	 6
  0036a	06		 DB	 6
  0036b	06		 DB	 6
  0036c	06		 DB	 6
  0036d	06		 DB	 6
  0036e	06		 DB	 6
  0036f	06		 DB	 6
  00370	06		 DB	 6
  00371	06		 DB	 6
  00372	06		 DB	 6
  00373	06		 DB	 6
  00374	06		 DB	 6
  00375	06		 DB	 6
  00376	04		 DB	 4
  00377	06		 DB	 6
  00378	06		 DB	 6
  00379	06		 DB	 6
  0037a	06		 DB	 6
  0037b	06		 DB	 6
  0037c	06		 DB	 6
  0037d	06		 DB	 6
  0037e	05		 DB	 5
?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillSummon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_iangle$1$ = -20					; size = 4
tv553 = -16						; size = 4
tv549 = -12						; size = 4
_DuelIndex$1$ = -8					; size = 4
_Hit$1$ = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
tv555 = 28						; size = 4
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillElectricSpark, COMDAT
; _this$ = ecx

; 3185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 3186 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	69 45 08 40 27
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 10048

; 3187 : 
; 3188 : 	int TargePosx = lpObj->X - (8 - (TargetPos & 15));
; 3189 : 	int TargePosy = lpObj->Y - (8 - ((TargetPos & 240) >> 4));
; 3190 : 
; 3191 : 	int tObjNum;
; 3192 : 	int count = 0;
; 3193 : 	int DuelIndex = lpObj->m_iDuelUser;
; 3194 : 	int iangle = GetAngle(lpObj->X,lpObj->Y,TargePosx,TargePosy);

  0000d	0f b6 55 1c	 movzx	 edx, BYTE PTR _TargetPos$[ebp]
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	8b d9		 mov	 ebx, ecx
  0001b	89 45 f0	 mov	 DWORD PTR tv553[ebp], eax
  0001e	03 c6		 add	 eax, esi
  00020	57		 push	 edi
  00021	89 45 08	 mov	 DWORD PTR _lpObj$1$[ebp], eax
  00024	8b 88 50 12 00
	00		 mov	 ecx, DWORD PTR [eax+4688]
  0002a	0f b6 b8 21 01
	00 00		 movzx	 edi, BYTE PTR [eax+289]
  00031	89 4d f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], ecx
  00034	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  0003b	8b c2		 mov	 eax, edx
  0003d	c1 e8 04	 shr	 eax, 4
  00040	83 e2 0f	 and	 edx, 15			; 0000000fH
  00043	83 c0 f8	 add	 eax, -8			; fffffff8H
  00046	03 c7		 add	 eax, edi
  00048	50		 push	 eax
  00049	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0004c	03 c1		 add	 eax, ecx
  0004e	50		 push	 eax
  0004f	57		 push	 edi
  00050	51		 push	 ecx
  00051	8b cb		 mov	 ecx, ebx
  00053	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  00058	8b 55 08	 mov	 edx, DWORD PTR _lpObj$1$[ebp]

; 3195 : 	int delaytime;
; 3196 : 	int Hit = 0;

  0005b	33 c9		 xor	 ecx, ecx
  0005d	89 45 ec	 mov	 DWORD PTR _iangle$1$[ebp], eax
  00060	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00065	89 4d fc	 mov	 DWORD PTR _Hit$1$[ebp], ecx
  00068	89 45 1c	 mov	 DWORD PTR tv555[ebp], eax
  0006b	8d 9a 4c 0c 00
	00		 lea	 ebx, DWORD PTR [edx+3148]
$LL2@SkillElect:

; 3197 : 	int EnableAttack;
; 3198 : 
; 3199 : 	while ( true )
; 3200 : 	{
; 3201 : 		if(lpObj->VpPlayer2[count].state != 0)

  00071	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00075	0f 84 2f 01 00
	00		 je	 $LN17@SkillElect

; 3202 : 		{
; 3203 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007b	0f bf 7b fe	 movsx	 edi, WORD PTR [ebx-2]

; 3204 : 
; 3205 : 			if(tObjNum >= 0)

  0007f	85 ff		 test	 edi, edi
  00081	0f 88 23 01 00
	00		 js	 $LN17@SkillElect

; 3206 : 			{
; 3207 : 				EnableAttack = 0;
; 3208 : 
; 3209 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00087	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00089	80 f9 02	 cmp	 cl, 2
  0008c	75 14		 jne	 SHORT $LN6@SkillElect
  0008e	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  00094	83 bc 30 30 06
	00 00 00	 cmp	 DWORD PTR [eax+esi+1584], 0
  0009c	0f 8c 9b 00 00
	00		 jl	 $LN10@SkillElect
$LN6@SkillElect:

; 3210 : 				{
; 3211 : 					EnableAttack = 1;
; 3212 : 				}
; 3213 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000a2	3b 7d 20	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  000a5	0f 84 92 00 00
	00		 je	 $LN10@SkillElect
  000ab	39 7d f8	 cmp	 DWORD PTR _DuelIndex$1$[ebp], edi
  000ae	0f 84 89 00 00
	00		 je	 $LN10@SkillElect

; 3214 : 				{
; 3215 : 					EnableAttack = 1;
; 3216 : 				}
; 3217 : #if (GS_CASTLE == 1)
; 3218 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000b4	80 f9 03	 cmp	 cl, 3
  000b7	74 43		 je	 SHORT $LN11@SkillElect
  000b9	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  000bf	89 45 f4	 mov	 DWORD PTR tv549[ebp], eax
  000c2	80 bc 30 23 01
	00 00 1e	 cmp	 BYTE PTR [eax+esi+291], 30 ; 0000001eH
  000ca	75 30		 jne	 SHORT $LN11@SkillElect
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000d1	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 3219 : 				{
; 3220 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000d6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  000d9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000df	83 f8 07	 cmp	 eax, 7
  000e2	75 18		 jne	 SHORT $LN11@SkillElect
  000e4	8b 4d f4	 mov	 ecx, DWORD PTR tv549[ebp]
  000e7	8a 82 5a 20 00
	00		 mov	 al, BYTE PTR [edx+8282]
  000ed	3a 84 31 5a 20
	00 00		 cmp	 al, BYTE PTR [ecx+esi+8282]
  000f4	0f 84 ad 00 00
	00		 je	 $LN30@SkillElect

; 3221 : 						EnableAttack = 1;
; 3222 : 				}
; 3223 : #endif
; 3224 : 				else

  000fa	eb 41		 jmp	 SHORT $LN10@SkillElect
$LN11@SkillElect:

; 3225 : 				{
; 3226 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000fc	69 c7 40 27 00
	00		 imul	 eax, edi, 10048

; 3227 : 
; 3228 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00102	80 7c 30 50 02	 cmp	 BYTE PTR [eax+esi+80], 2
  00107	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]
  0010a	75 14		 jne	 SHORT $LN14@SkillElect
  0010c	8b 84 30 30 06
	00 00		 mov	 eax, DWORD PTR [eax+esi+1584]
  00113	85 c0		 test	 eax, eax
  00115	78 09		 js	 SHORT $LN14@SkillElect

; 3229 : 					{
; 3230 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00117	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0011d	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]
$LN14@SkillElect:

; 3231 : 					}
; 3232 : 
; 3233 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00120	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  00126	03 c6		 add	 eax, esi
  00128	50		 push	 eax
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0012f	83 c4 08	 add	 esp, 8
  00132	83 f8 01	 cmp	 eax, 1
  00135	75 67		 jne	 SHORT $LN29@SkillElect
  00137	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillElect:

; 3234 : 					{
; 3235 : 						EnableAttack = 1;
; 3236 : 					}
; 3237 : 				}
; 3238 : 
; 3239 : 				if(EnableAttack != 0)
; 3240 : 				{
; 3241 : 					if(SkillElectricSparkHitBox.HitCheck(iangle,gObj[aIndex].X,gObj[aIndex].Y,gObj[tObjNum].X,gObj[tObjNum].Y))

  0013d	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00143	0f b6 84 31 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+289]
  0014b	50		 push	 eax
  0014c	0f b6 84 31 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+288]
  00154	8b 4d f0	 mov	 ecx, DWORD PTR tv553[ebp]
  00157	50		 push	 eax
  00158	0f b6 84 31 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+289]
  00160	50		 push	 eax
  00161	0f b6 84 31 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+288]
  00169	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillElectricSparkHitBox@@3VCSkillHitBox@@A ; SkillElectricSparkHitBox
  0016e	50		 push	 eax
  0016f	ff 75 ec	 push	 DWORD PTR _iangle$1$[ebp]
  00172	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  00177	85 c0		 test	 eax, eax
  00179	74 23		 je	 SHORT $LN29@SkillElect

; 3242 : 					{
; 3243 : 						delaytime = 500;
; 3244 : 						Hit = 1;
; 3245 : 
; 3246 : 						gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,delaytime,lpMagic->m_Skill,0);

  0017b	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0017e	6a 00		 push	 0
  00180	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Hit$1$[ebp], 1
  00187	ff 70 08	 push	 DWORD PTR [eax+8]
  0018a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  0018d	68 f4 01 00 00	 push	 500			; 000001f4H
  00192	57		 push	 edi
  00193	6a 32		 push	 50			; 00000032H
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0019b	83 c4 18	 add	 esp, 24			; 00000018H
$LN29@SkillElect:
  0019e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  001a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN30@SkillElect:
  001a7	8b 45 1c	 mov	 eax, DWORD PTR tv555[ebp]
$LN17@SkillElect:

; 3247 : 					}
; 3248 : 				}
; 3249 : 			}
; 3250 : 		}
; 3251 : 
; 3252 : 		count++;

  001aa	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 3253 : 		if(count > MAX_VIEWPORT -1)

  001ad	83 e8 01	 sub	 eax, 1
  001b0	89 45 1c	 mov	 DWORD PTR tv555[ebp], eax
  001b3	0f 85 b8 fe ff
	ff		 jne	 $LL2@SkillElect

; 3254 : 		{
; 3255 : 			break;
; 3256 : 		}
; 3257 : 	}
; 3258 : 
; 3259 : 	if(Hit != 0)

  001b9	8b 4d fc	 mov	 ecx, DWORD PTR _Hit$1$[ebp]
  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 09		 je	 SHORT $LN19@SkillElect

; 3260 : 	{
; 3261 : 		DecPartyMemberHPandMP(lpObj);

  001c3	52		 push	 edx
  001c4	e8 00 00 00 00	 call	 ?DecPartyMemberHPandMP@@YAHPAUOBJECTSTRUCT@@@Z ; DecPartyMemberHPandMP
  001c9	83 c4 04	 add	 esp, 4
$LN19@SkillElect:

; 3262 : 	}
; 3263 : }

  001cc	8b e5		 mov	 esp, ebp
  001ce	5d		 pop	 ebp
  001cf	c2 1c 00	 ret	 28			; 0000001cH
?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillElectricSpark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillAddCriticalDamage@CObjUseSkill@@QAEXHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_partynum$1$ = -48					; size = 4
_addcriticaldamagevalue$1$ = -44			; size = 4
_lpMagic$GSCopy$1$ = -40				; size = 4
_aIndex$GSCopy$1$ = -36					; size = 4
_Buffnumber$2$ = -32					; size = 4
_SkillTime$1$ = -28					; size = 4
tv456 = -28						; size = 4
_ApplyPartyIndex$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillAddCriticalDamage@CObjUseSkill@@QAEXHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillAddCriticalDamage, COMDAT
; _this$ = ecx

; 3077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00017	57		 push	 edi

; 3078 : 	int skillSuccess = true;
; 3079 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  0001e	89 45 dc	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], eax
  00021	89 5d d8	 mov	 DWORD PTR _lpMagic$GSCopy$1$[ebp], ebx
  00024	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3080 : 	int number;
; 3081 : 
; 3082 : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon == -1)

  0002a	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0002e	74 0d		 je	 SHORT $LN8@SkillAddCr
  00030	83 bf 30 06 00
	00 ff		 cmp	 DWORD PTR [edi+1584], -1
  00037	0f 84 1a 02 00
	00		 je	 $LN6@SkillAddCr
$LN8@SkillAddCr:

; 3083 : 	{
; 3084 : 		return;
; 3085 : 	}
; 3086 : 
; 3087 : 	if(lpObj->Class != CLASS_DARKLORD)

  0003d	66 83 bf 90 00
	00 00 04	 cmp	 WORD PTR [edi+144], 4
  00045	0f 85 0c 02 00
	00		 jne	 $LN6@SkillAddCr

; 3088 : 	{
; 3089 : 		return;
; 3090 : 	}
; 3091 : 
; 3092 : 
; 3093 : 	int partynum = 0;
; 3094 : 	int totallevel = 0;
; 3095 : 	int partycount;
; 3096 : 	int dis;
; 3097 : 
; 3098 : 	int ApplyPartyIndex[MAX_USER_IN_PARTY];
; 3099 : 	LPOBJ lpPartyObj;
; 3100 : 	memset(ApplyPartyIndex,-1,sizeof(ApplyPartyIndex));

  0004b	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff

; 3101 : 
; 3102 : 	partynum = lpObj->PartyNumber;
; 3103 : 
; 3104 : 	int Buffnumber = BUFF_ADD_CRITDMG;

  00052	b8 05 00 00 00	 mov	 eax, 5

; 3105 : 
; 3106 : 	if( lpMagic->m_Skill == AT_MSKILL_DL_CRITICALDAMAGE3 )

  00057	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0005a	8b 97 0c 06 00
	00		 mov	 edx, DWORD PTR [edi+1548]
  00060	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _ApplyPartyIndex$[ebp+16], -1
  00067	89 55 d0	 mov	 DWORD PTR _partynum$1$[ebp], edx
  0006a	56		 push	 esi
  0006b	0f 11 45 e8	 movups	 XMMWORD PTR _ApplyPartyIndex$[ebp], xmm0
  0006f	81 f9 05 02 00
	00		 cmp	 ecx, 517		; 00000205H
  00075	75 09		 jne	 SHORT $LN10@SkillAddCr

; 3107 : 	{
; 3108 : 		Buffnumber = BUFF_ADD_CRITDMG2;

  00077	c7 45 e0 94 00
	00 00		 mov	 DWORD PTR _Buffnumber$2$[ebp], 148 ; 00000094H
  0007e	eb 11		 jmp	 SHORT $LN12@SkillAddCr
$LN10@SkillAddCr:

; 3109 : 	}
; 3110 : 	else if( lpMagic->m_Skill == AT_MSKILL_DL_CRITICALDAMAGE4 )

  00080	81 f9 0a 02 00
	00		 cmp	 ecx, 522		; 0000020aH
  00086	be 95 00 00 00	 mov	 esi, 149		; 00000095H
  0008b	0f 44 c6	 cmove	 eax, esi
  0008e	89 45 e0	 mov	 DWORD PTR _Buffnumber$2$[ebp], eax
$LN12@SkillAddCr:

; 3111 : 	{
; 3112 : 		Buffnumber = BUFF_ADD_CRITDMG3;
; 3113 : 	}
; 3114 : 
; 3115 : 	if(partynum != -1)

  00091	83 fa ff	 cmp	 edx, -1
  00094	74 61		 je	 SHORT $LN3@SkillAddCr

; 3116 : 	{
; 3117 : 		partycount = gParty.m_PartyS[partynum].Count;
; 3118 : 
; 3119 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00096	8b c2		 mov	 eax, edx
  00098	33 f6		 xor	 esi, esi
  0009a	c1 e0 04	 shl	 eax, 4
  0009d	2b c2		 sub	 eax, edx
  0009f	8d 14 85 0c 00
	00 00		 lea	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  000a6	89 55 e4	 mov	 DWORD PTR tv456[ebp], edx
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@SkillAddCr:

; 3120 : 		{
; 3121 : 			number = gParty.m_PartyS[partynum].Number[n];

  000b0	8b 02		 mov	 eax, DWORD PTR [edx]

; 3122 : 
; 3123 : 			if(number >= 0)

  000b2	85 c0		 test	 eax, eax
  000b4	78 32		 js	 SHORT $LN2@SkillAddCr

; 3124 : 			{
; 3125 : 				lpPartyObj = &gObj[number];

  000b6	69 d8 40 27 00
	00		 imul	 ebx, eax, 10048

; 3126 : 
; 3127 : 				if(lpObj->MapNumber == lpPartyObj->MapNumber)

  000bc	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  000c2	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c8	3a 83 23 01 00
	00		 cmp	 al, BYTE PTR [ebx+291]
  000ce	75 18		 jne	 SHORT $LN2@SkillAddCr

; 3128 : 				{
; 3129 : 					dis = gObjCalDistance(lpObj,&gObj[number]);

  000d0	53		 push	 ebx
  000d1	57		 push	 edi
  000d2	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000d7	8b 55 e4	 mov	 edx, DWORD PTR tv456[ebp]
  000da	83 c4 08	 add	 esp, 8

; 3130 : 					if(dis < 10)

  000dd	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000e0	7d 06		 jge	 SHORT $LN2@SkillAddCr

; 3131 : 					{
; 3132 : 						ApplyPartyIndex[n] = lpPartyObj->m_Index;

  000e2	8b 03		 mov	 eax, DWORD PTR [ebx]
  000e4	89 44 b5 e8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+esi*4], eax
$LN2@SkillAddCr:

; 3116 : 	{
; 3117 : 		partycount = gParty.m_PartyS[partynum].Count;
; 3118 : 
; 3119 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  000e8	46		 inc	 esi
  000e9	83 c2 04	 add	 edx, 4
  000ec	89 55 e4	 mov	 DWORD PTR tv456[ebp], edx
  000ef	83 fe 05	 cmp	 esi, 5
  000f2	7c bc		 jl	 SHORT $LL4@SkillAddCr
  000f4	8b 5d d8	 mov	 ebx, DWORD PTR _lpMagic$GSCopy$1$[ebp]
$LN3@SkillAddCr:

; 3133 : 					}
; 3134 : 				}
; 3135 : 			}
; 3136 : 		}
; 3137 : 	}
; 3138 : 
; 3139 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  000f7	ff 73 08	 push	 DWORD PTR [ebx+8]
  000fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  000ff	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  00104	8b f0		 mov	 esi, eax

; 3140 : 
; 3141 : 	if( !lpInfo )

  00106	85 f6		 test	 esi, esi
  00108	0f 84 48 01 00
	00		 je	 $LN34@SkillAddCr

; 3142 : 	{
; 3143 : 		return;
; 3144 : 	}
; 3145 : 
; 3146 : 	int addcriticaldamagevalue = (lpObj->Leadership + lpObj->AddLeadership)/lpInfo->m_Arg1 + (lpObj->Energy + lpObj->AddEnergy)/lpInfo->m_Arg2;

  0010e	0f b7 8f d6 00
	00 00		 movzx	 ecx, WORD PTR [edi+214]
  00115	0f b7 97 02 01
	00 00		 movzx	 edx, WORD PTR [edi+258]
  0011c	0f b7 87 f4 00
	00 00		 movzx	 eax, WORD PTR [edi+244]
  00123	03 d1		 add	 edx, ecx
  00125	0f b7 8f f6 00
	00 00		 movzx	 ecx, WORD PTR [edi+246]
  0012c	03 c8		 add	 ecx, eax
  0012e	66 0f 6e d2	 movd	 xmm2, edx
  00132	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00135	66 0f 6e c9	 movd	 xmm1, ecx
  00139	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0013c	0f 28 c2	 movaps	 xmm0, xmm2
  0013f	f3 0f 5e 46 08	 divss	 xmm0, DWORD PTR [esi+8]
  00144	f3 0f 5e 4e 04	 divss	 xmm1, DWORD PTR [esi+4]
  00149	f3 0f 58 c8	 addss	 xmm1, xmm0
  0014d	f3 0f 2c d1	 cvttss2si edx, xmm1

; 3147 : 
; 3148 : 	if( addcriticaldamagevalue > lpInfo->m_Arg3 )

  00151	f3 0f 10 4e 0c	 movss	 xmm1, DWORD PTR [esi+12]
  00156	89 55 d4	 mov	 DWORD PTR _addcriticaldamagevalue$1$[ebp], edx
  00159	66 0f 6e c2	 movd	 xmm0, edx
  0015d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00160	0f 2f c1	 comiss	 xmm0, xmm1
  00163	76 07		 jbe	 SHORT $LN18@SkillAddCr

; 3149 : 	{
; 3150 : 		addcriticaldamagevalue = lpInfo->m_Arg3;

  00165	f3 0f 2c d1	 cvttss2si edx, xmm1
  00169	89 55 d4	 mov	 DWORD PTR _addcriticaldamagevalue$1$[ebp], edx
$LN18@SkillAddCr:

; 3151 : 	}
; 3152 : 
; 3153 : 	int SkillTime = lpInfo->m_Arg4 + (lpObj->Energy + lpObj->AddEnergy) / lpInfo->m_Arg5;

  0016c	f3 0f 5e 56 14	 divss	 xmm2, DWORD PTR [esi+20]

; 3154 : 
; 3155 : 	if( SkillTime > lpInfo->m_Arg6 )

  00171	f3 0f 10 4e 18	 movss	 xmm1, DWORD PTR [esi+24]
  00176	f3 0f 58 56 10	 addss	 xmm2, DWORD PTR [esi+16]
  0017b	f3 0f 2c ca	 cvttss2si ecx, xmm2
  0017f	89 4d e4	 mov	 DWORD PTR _SkillTime$1$[ebp], ecx
  00182	66 0f 6e c1	 movd	 xmm0, ecx
  00186	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00189	0f 2f c1	 comiss	 xmm0, xmm1
  0018c	76 07		 jbe	 SHORT $LN19@SkillAddCr

; 3156 : 	{
; 3157 : 		SkillTime = lpInfo->m_Arg6;

  0018e	f3 0f 2c c9	 cvttss2si ecx, xmm1
  00192	89 4d e4	 mov	 DWORD PTR _SkillTime$1$[ebp], ecx
$LN19@SkillAddCr:

; 3158 : 	}
; 3159 : 
; 3160 : 	if(partynum == -1)

  00195	83 7d d0 ff	 cmp	 DWORD PTR _partynum$1$[ebp], -1
  00199	75 54		 jne	 SHORT $LN20@SkillAddCr

; 3161 : 	{
; 3162 : 		gObjAddBuffEffect(lpObj,Buffnumber,ADD_OPTION_CRITICALDMG,addcriticaldamagevalue,0,0,SkillTime);

  0019b	51		 push	 ecx
  0019c	6a 00		 push	 0
  0019e	6a 00		 push	 0
  001a0	52		 push	 edx
  001a1	6a 11		 push	 17			; 00000011H
  001a3	ff 75 e0	 push	 DWORD PTR _Buffnumber$2$[ebp]
  001a6	57		 push	 edi
  001a7	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  001ac	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3163 : 		MsgOutput(aIndex,lMsg.Get(1240),SkillTime);

  001af	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001b4	ff 75 e4	 push	 DWORD PTR _SkillTime$1$[ebp]
  001b7	68 d8 04 00 00	 push	 1240			; 000004d8H
  001bc	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001c1	50		 push	 eax
  001c2	ff 75 dc	 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  001c5	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 3164 : 		GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpObj->m_Index,skillSuccess);

  001ca	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  001ce	6a 01		 push	 1
  001d0	ff 37		 push	 DWORD PTR [edi]
  001d2	50		 push	 eax
  001d3	57		 push	 edi
  001d4	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  001d9	83 c4 1c	 add	 esp, 28			; 0000001cH
  001dc	5e		 pop	 esi
  001dd	5f		 pop	 edi
  001de	5b		 pop	 ebx

; 3176 : 			}
; 3177 : 		}
; 3178 : 	}
; 3179 : }

  001df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e2	33 cd		 xor	 ecx, ebp
  001e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c2 08 00	 ret	 8
$LN20@SkillAddCr:

; 3165 : 	}
; 3166 : 	else
; 3167 : 	{
; 3168 : 		for(int n = 0;n < MAX_USER_IN_PARTY;n++)

  001ef	33 db		 xor	 ebx, ebx
$LL7@SkillAddCr:

; 3169 : 		{
; 3170 : 			if(ApplyPartyIndex[n] != -1)

  001f1	8b 44 9d e8	 mov	 eax, DWORD PTR _ApplyPartyIndex$[ebp+ebx*4]
  001f5	83 f8 ff	 cmp	 eax, -1
  001f8	74 50		 je	 SHORT $LN5@SkillAddCr

; 3171 : 			{
; 3172 : 				lpPartyObj = &gObj[ApplyPartyIndex[n]];
; 3173 : 				gObjAddBuffEffect(lpPartyObj,Buffnumber,ADD_OPTION_CRITICALDMG,addcriticaldamagevalue,0,0,SkillTime);

  001fa	51		 push	 ecx
  001fb	6a 00		 push	 0
  001fd	6a 00		 push	 0
  001ff	52		 push	 edx
  00200	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  00206	6a 11		 push	 17			; 00000011H
  00208	ff 75 e0	 push	 DWORD PTR _Buffnumber$2$[ebp]
  0020b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00211	56		 push	 esi
  00212	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  00217	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3174 : 				MsgOutput(aIndex,lMsg.Get(1240),SkillTime);

  0021a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0021f	ff 75 e4	 push	 DWORD PTR _SkillTime$1$[ebp]
  00222	68 d8 04 00 00	 push	 1240			; 000004d8H
  00227	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0022c	50		 push	 eax
  0022d	ff 75 dc	 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00230	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 3175 : 				GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpPartyObj->m_Index,skillSuccess);

  00235	8b 45 d8	 mov	 eax, DWORD PTR _lpMagic$GSCopy$1$[ebp]
  00238	6a 01		 push	 1
  0023a	ff 36		 push	 DWORD PTR [esi]
  0023c	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00240	50		 push	 eax
  00241	57		 push	 edi
  00242	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00247	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@SkillAddCr:

; 3165 : 	}
; 3166 : 	else
; 3167 : 	{
; 3168 : 		for(int n = 0;n < MAX_USER_IN_PARTY;n++)

  0024a	8b 4d e4	 mov	 ecx, DWORD PTR _SkillTime$1$[ebp]
  0024d	43		 inc	 ebx
  0024e	8b 55 d4	 mov	 edx, DWORD PTR _addcriticaldamagevalue$1$[ebp]
  00251	83 fb 05	 cmp	 ebx, 5
  00254	7c 9b		 jl	 SHORT $LL7@SkillAddCr
$LN34@SkillAddCr:
  00256	5e		 pop	 esi
$LN6@SkillAddCr:

; 3176 : 			}
; 3177 : 		}
; 3178 : 	}
; 3179 : }

  00257	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025a	5f		 pop	 edi
  0025b	33 cd		 xor	 ecx, ebp
  0025d	5b		 pop	 ebx
  0025e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c2 08 00	 ret	 8
?SkillAddCriticalDamage@CObjUseSkill@@QAEXHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillAddCriticalDamage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillRecallParty@CObjUseSkill@@QAEXHH@Z
_TEXT	SEGMENT
tv479 = -280						; size = 4
_addy$1$ = -276						; size = 4
_bCheckEquipmentToMove$1$ = -276			; size = 4
tv485 = -272						; size = 4
_addx$1$ = -268						; size = 4
_bCheckMainToMove$1$ = -268				; size = 4
_recallcount$1$ = -264					; size = 4
_msg$1 = -260						; size = 255
_msg$2 = -260						; size = 255
_msg$3 = -260						; size = 255
_msg$4 = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_skill_level$ = 12					; size = 4
?SkillRecallParty@CObjUseSkill@@QAEXHH@Z PROC		; CObjUseSkill::SkillRecallParty, COMDAT
; _this$ = ecx

; 2915 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 2916 : 	int skillSuccess = true;
; 2917 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0001e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2918 : 
; 2919 : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon == -1)

  00024	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00028	74 0d		 je	 SHORT $LN7@SkillRecal
  0002a	83 be 30 06 00
	00 ff		 cmp	 DWORD PTR [esi+1584], -1
  00031	0f 84 cc 03 00
	00		 je	 $LN23@SkillRecal
$LN7@SkillRecal:

; 2920 : 	{
; 2921 : 		return;
; 2922 : 	}
; 2923 : 
; 2924 : 	if(RecallPartyCheck(aIndex,skill_level) == 0)

  00037	ff 75 0c	 push	 DWORD PTR _skill_level$[ebp]
  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 ?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z ; CObjUseSkill::RecallPartyCheck
  00040	85 c0		 test	 eax, eax
  00042	75 2b		 jne	 SHORT $LN8@SkillRecal

; 2925 : 	{
; 2926 : 		MsgOutput(aIndex,lMsg.Get(1238));

  00044	68 d6 04 00 00	 push	 1238			; 000004d6H
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0004e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00053	50		 push	 eax
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0005a	83 c4 08	 add	 esp, 8
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 3070 : 	}
; 3071 : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
$LN8@SkillRecal:

; 2927 : 		return;
; 2928 : 	}
; 2929 : 
; 2930 : 	if(gMoveCommand.CheckMainToMove(lpObj) == 0)

  0006f	56		 push	 esi
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00075	e8 00 00 00 00	 call	 ?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove
  0007a	85 c0		 test	 eax, eax
  0007c	75 42		 jne	 SHORT $LN9@SkillRecal

; 2931 : 	{
; 2932 : 		char msg[255];
; 2933 : 		wsprintf(msg,lMsg.Get(1249));

  0007e	68 e1 04 00 00	 push	 1249			; 000004e1H
$LN47@SkillRecal:
  00083	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00088	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0008d	50		 push	 eax
  0008e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$4[ebp]
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 2934 : 		GCServerMsgStringSend(msg,lpObj->m_Index,1);

  0009b	6a 01		 push	 1
  0009d	ff 36		 push	 DWORD PTR [esi]
  0009f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$4[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi

; 3070 : 	}
; 3071 : }

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b3	33 cd		 xor	 ecx, ebp
  000b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
$LN9@SkillRecal:

; 2935 : 		return;
; 2936 : 	}
; 2937 : 
; 2938 : 	if(gMoveCommand.CheckInterfaceToMove(lpObj) == 0)

  000c0	56		 push	 esi
  000c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  000c6	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  000cb	85 c0		 test	 eax, eax
  000cd	75 07		 jne	 SHORT $LN10@SkillRecal

; 2939 : 	{
; 2940 : 		char msg[255];
; 2941 : 		wsprintf(msg,lMsg.Get(1239));

  000cf	68 d7 04 00 00	 push	 1239			; 000004d7H

; 2942 : 		GCServerMsgStringSend(msg,lpObj->m_Index,1);
; 2943 : 		return;

  000d4	eb ad		 jmp	 SHORT $LN47@SkillRecal
$LN10@SkillRecal:
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  000d6	8b 8e 50 12 00
	00		 mov	 ecx, DWORD PTR [esi+4688]
  000dc	85 c9		 test	 ecx, ecx
  000de	78 13		 js	 SHORT $LN38@SkillRecal
  000e0	33 c0		 xor	 eax, eax
  000e2	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  000e8	0f 9e c0	 setle	 al
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 2947 : 	if (g_NewPVP.IsDuel(*lpObj)) {

  000eb	85 c0		 test	 eax, eax
  000ed	0f 85 10 03 00
	00		 jne	 $LN23@SkillRecal
$LN38@SkillRecal:

; 2948 : 		//char msg[255];
; 2949 : 		//wsprintf(msg, lMsg.Get(3433), lpObj->Name);
; 2950 : 		//GCServerMsgStringSend(msg, lpObj->m_Index, 1);
; 2951 : 		return;
; 2952 : 	}
; 2953 : #endif
; 2954 : 
; 2955 : 	//season 4 add-on
; 2956 : 	if( lpObj->MapNumber == MAP_INDEX_RAKLIONBOSS &&
; 2957 : 		lpObj->Connected == PLAYER_PLAYING &&

  000f3	80 be 23 01 00
	00 3a		 cmp	 BYTE PTR [esi+291], 58	; 0000003aH
  000fa	75 4c		 jne	 SHORT $LN12@SkillRecal
  000fc	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  00100	75 46		 jne	 SHORT $LN12@SkillRecal
  00102	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Raklion@@3VCRaklion@@A ; g_Raklion
  00107	e8 00 00 00 00	 call	 ?GetRaklionState@CRaklion@@QAEHXZ ; CRaklion::GetRaklionState
  0010c	83 f8 07	 cmp	 eax, 7
  0010f	74 2d		 je	 SHORT $LN13@SkillRecal
  00111	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Raklion@@3VCRaklion@@A ; g_Raklion
  00116	e8 00 00 00 00	 call	 ?GetRaklionState@CRaklion@@QAEHXZ ; CRaklion::GetRaklionState
  0011b	83 f8 08	 cmp	 eax, 8
  0011e	74 1e		 je	 SHORT $LN13@SkillRecal
  00120	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Raklion@@3VCRaklion@@A ; g_Raklion
  00125	e8 00 00 00 00	 call	 ?GetRaklionState@CRaklion@@QAEHXZ ; CRaklion::GetRaklionState
  0012a	83 f8 09	 cmp	 eax, 9
  0012d	74 0f		 je	 SHORT $LN13@SkillRecal
  0012f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Raklion@@3VCRaklion@@A ; g_Raklion
  00134	e8 00 00 00 00	 call	 ?GetRaklionState@CRaklion@@QAEHXZ ; CRaklion::GetRaklionState
  00139	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0013c	75 0a		 jne	 SHORT $LN12@SkillRecal
$LN13@SkillRecal:

; 2958 : 		(g_Raklion.GetRaklionState() == RAKLION_STATE_CLOSE_DOOR ||
; 2959 : 		g_Raklion.GetRaklionState() == RAKLION_STATE_ALL_USER_DIE ||
; 2960 : 		g_Raklion.GetRaklionState() == RAKLION_STATE_NOTIFY_4 ||
; 2961 : 		g_Raklion.GetRaklionState() == RAKLION_STATE_END) ) 
; 2962 : 	{
; 2963 : 		char msg[255];
; 2964 : 		wsprintf(msg,lMsg.Get(3417));

  0013e	68 59 0d 00 00	 push	 3417			; 00000d59H

; 2965 : 		GCServerMsgStringSend(msg,lpObj->m_Index,1);
; 2966 : 		return;

  00143	e9 3b ff ff ff	 jmp	 $LN47@SkillRecal
$LN12@SkillRecal:

; 2967 : 	}
; 2968 : 
; 2969 : 	int number;
; 2970 : 	int partynum;
; 2971 : 	int partycount;
; 2972 : 	LPOBJ lpPartyObj;
; 2973 : 	int recallcount;
; 2974 : 
; 2975 : 	partynum = 0;
; 2976 : 	partynum = lpObj->PartyNumber;

  00148	8b be 0c 06 00
	00		 mov	 edi, DWORD PTR [esi+1548]

; 2977 : 
; 2978 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_RECALL_PARTY,lpObj->m_Index,skillSuccess);

  0014e	6a 01		 push	 1
  00150	ff 36		 push	 DWORD PTR [esi]
  00152	6a 3f		 push	 63			; 0000003fH
  00154	56		 push	 esi
  00155	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0015a	83 c4 10	 add	 esp, 16			; 00000010H

; 2979 : 
; 2980 : 	recallcount = 0;

  0015d	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _recallcount$1$[ebp], 0

; 2981 : 
; 2982 : 	if(partynum != -1)

  00167	83 ff ff	 cmp	 edi, -1
  0016a	0f 84 93 02 00
	00		 je	 $LN23@SkillRecal

; 2983 : 	{
; 2984 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2985 : 
; 2986 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n ++)

  00170	8b c7		 mov	 eax, edi
  00172	c7 85 f0 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR tv485[ebp], 5
  0017c	c1 e0 04	 shl	 eax, 4
  0017f	ba 05 00 00 00	 mov	 edx, 5
  00184	2b c7		 sub	 eax, edi
  00186	53		 push	 ebx
  00187	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__wsprintfA
  0018d	8d 04 85 0c 00
	00 00		 lea	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  00194	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv479[ebp], eax
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL4@SkillRecal:

; 2987 : 		{
; 2988 : 			number = gParty.m_PartyS[partynum].Number[n];

  001a0	8b 00		 mov	 eax, DWORD PTR [eax]

; 2989 : 
; 2990 : 			if(number >= 0)

  001a2	85 c0		 test	 eax, eax
  001a4	0f 88 6b 02 00
	00		 js	 $LN42@SkillRecal

; 2991 : 			{
; 2992 : 				lpPartyObj = &gObj[number];

  001aa	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  001b0	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2993 : 
; 2994 : 				if(lpPartyObj->m_Index != lpObj->m_Index)

  001b6	8b 07		 mov	 eax, DWORD PTR [edi]
  001b8	3b 06		 cmp	 eax, DWORD PTR [esi]
  001ba	0f 84 55 02 00
	00		 je	 $LN42@SkillRecal

; 2995 : 				{
; 2996 : #if (GS_CASTLE == 1)
; 2997 : 					if( g_CastleSiege.GetCastleState() == 7 && lpObj->m_btCsJoinSide != lpPartyObj->m_btCsJoinSide )

  001c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  001c5	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  001ca	83 f8 07	 cmp	 eax, 7
  001cd	75 12		 jne	 SHORT $LN17@SkillRecal
  001cf	8a 86 5a 20 00
	00		 mov	 al, BYTE PTR [esi+8282]
  001d5	3a 87 5a 20 00
	00		 cmp	 al, BYTE PTR [edi+8282]
  001db	0f 85 c6 01 00
	00		 jne	 $LN44@SkillRecal
$LN17@SkillRecal:

; 2998 : 					{
; 2999 : 						continue;
; 3000 : 					}
; 3001 : #endif
; 3002 : 
; 3003 : 					int movelevel = gMoveCommand.GetMoveLevel(lpObj->MapNumber,lpObj->X,lpObj->Y,lpPartyObj->Class);

  001e1	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  001ed	50		 push	 eax
  001ee	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  001f5	50		 push	 eax
  001f6	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  001fd	50		 push	 eax
  001fe	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 ?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z ; CMoveCommand::GetMoveLevel

; 3004 : 					int bCheckMainToMove = gMoveCommand.CheckMainToMove(lpPartyObj);

  0020b	57		 push	 edi
  0020c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00211	8b d8		 mov	 ebx, eax
  00213	e8 00 00 00 00	 call	 ?CheckMainToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove

; 3005 : 					int bCheckEquipmentToMove = gMoveCommand.CheckEquipmentToMove(lpPartyObj,lpObj->MapNumber);

  00218	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  0021f	51		 push	 ecx
  00220	57		 push	 edi
  00221	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00226	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _bCheckMainToMove$1$[ebp], eax
  0022c	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 3006 : 					int bCheckInterfaceToMove = gMoveCommand.CheckInterfaceToMove(lpPartyObj);

  00231	57		 push	 edi
  00232	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00237	89 85 ec fe ff
	ff		 mov	 DWORD PTR _bCheckEquipmentToMove$1$[ebp], eax
  0023d	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove

; 3007 : 
; 3008 : 					if(lpPartyObj->Level >= movelevel
; 3009 : 						&& movelevel != -1
; 3010 : 						&& bCheckMainToMove != false
; 3011 : 						&& bCheckEquipmentToMove != false
; 3012 : 						&& bCheckInterfaceToMove != false)

  00242	0f bf 8f 96 00
	00 00		 movsx	 ecx, WORD PTR [edi+150]
  00249	3b cb		 cmp	 ecx, ebx
  0024b	0f 8c 24 01 00
	00		 jl	 $LN18@SkillRecal
  00251	83 fb ff	 cmp	 ebx, -1
  00254	0f 84 1b 01 00
	00		 je	 $LN18@SkillRecal
  0025a	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _bCheckMainToMove$1$[ebp], 0
  00261	0f 84 0e 01 00
	00		 je	 $LN18@SkillRecal
  00267	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _bCheckEquipmentToMove$1$[ebp], 0
  0026e	0f 84 01 01 00
	00		 je	 $LN18@SkillRecal
  00274	85 c0		 test	 eax, eax
  00276	0f 84 f9 00 00
	00		 je	 $LN18@SkillRecal

; 3013 : 					{
; 3014 : 						int addx;
; 3015 : 						int addy;
; 3016 : 						int count = 50;

  0027c	bb 32 00 00 00	 mov	 ebx, 50			; 00000032H
$LL5@SkillRecal:

; 3017 : 						int Find = 0;
; 3018 : 
; 3019 : 						while(count--)

  00281	4b		 dec	 ebx

; 3020 : 						{
; 3021 : 							addx = lpObj->X + rand()%9 - 4;

  00282	e8 00 00 00 00	 call	 _rand
  00287	99		 cdq
  00288	b9 09 00 00 00	 mov	 ecx, 9
  0028d	f7 f9		 idiv	 ecx
  0028f	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00296	83 c0 fc	 add	 eax, -4			; fffffffcH
  00299	03 c2		 add	 eax, edx
  0029b	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _addx$1$[ebp], eax

; 3022 : 							addy = lpObj->Y + rand()%9 - 4;

  002a1	e8 00 00 00 00	 call	 _rand
  002a6	99		 cdq
  002a7	b9 09 00 00 00	 mov	 ecx, 9
  002ac	f7 f9		 idiv	 ecx
  002ae	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  002b5	83 c0 fc	 add	 eax, -4			; fffffffcH
  002b8	03 c2		 add	 eax, edx

; 3023 : 
; 3024 : 							if(gObjCheckTeleportArea(lpObj->m_Index,addx,addy))

  002ba	50		 push	 eax
  002bb	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _addx$1$[ebp]
  002c1	89 85 ec fe ff
	ff		 mov	 DWORD PTR _addy$1$[ebp], eax
  002c7	ff 36		 push	 DWORD PTR [esi]
  002c9	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  002ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d1	85 c0		 test	 eax, eax
  002d3	75 1a		 jne	 SHORT $LN41@SkillRecal

; 3017 : 						int Find = 0;
; 3018 : 
; 3019 : 						while(count--)

  002d5	85 db		 test	 ebx, ebx
  002d7	75 a8		 jne	 SHORT $LL5@SkillRecal

; 3025 : 							{
; 3026 : 								Find = 1;
; 3027 : 								break;
; 3028 : 							}
; 3029 : 						}
; 3030 : 
; 3031 : 						if(Find == 0)
; 3032 : 						{
; 3033 : 							addx = lpObj->X;

  002d9	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]

; 3034 : 							addy = lpObj->Y;

  002e0	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  002e7	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _addx$1$[ebp], eax
  002ed	eb 06		 jmp	 SHORT $LN21@SkillRecal
$LN41@SkillRecal:
  002ef	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _addy$1$[ebp]
$LN21@SkillRecal:

; 3035 : 						}
; 3036 : 
; 3037 : 						lpPartyObj->SkillRecallParty_Time = 7;

  002f5	b8 07 00 00 00	 mov	 eax, 7
  002fa	66 89 87 04 16
	00 00		 mov	 WORD PTR [edi+5636], ax

; 3038 : 						lpPartyObj->SkillRecallParty_MapNumber = lpObj->MapNumber;

  00301	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  00307	88 87 06 16 00
	00		 mov	 BYTE PTR [edi+5638], al

; 3039 : 						lpPartyObj->SkillRecallParty_X = addx;

  0030d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _addx$1$[ebp]
  00313	88 87 07 16 00
	00		 mov	 BYTE PTR [edi+5639], al

; 3040 : 						lpPartyObj->SkillRecallParty_Y = addy;

  00319	88 8f 08 16 00
	00		 mov	 BYTE PTR [edi+5640], cl

; 3041 : 
; 3042 : 						//Season4 add-on
; 3043 : 						if(lpObj->MapNumber == MAP_INDEX_RAKLIONBOSS)

  0031f	80 be 23 01 00
	00 3a		 cmp	 BYTE PTR [esi+291], 58	; 0000003aH
  00326	75 0c		 jne	 SHORT $LN22@SkillRecal

; 3044 : 						{
; 3045 : 							g_RaklionBattleUserMng.AddUserData(lpPartyObj->m_Index);

  00328	ff 37		 push	 DWORD PTR [edi]
  0032a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RaklionBattleUserMng@@3VCRaklionBattleUserMng@@A ; g_RaklionBattleUserMng
  0032f	e8 00 00 00 00	 call	 ?AddUserData@CRaklionBattleUserMng@@QAEHH@Z ; CRaklionBattleUserMng::AddUserData
$LN22@SkillRecal:

; 3046 : 						}
; 3047 : 
; 3048 : 						char msg[255];
; 3049 : 
; 3050 : 						wsprintf(msg,lMsg.Get(1251));

  00334	68 e3 04 00 00	 push	 1251			; 000004e3H
  00339	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0033e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00343	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__wsprintfA
  00349	50		 push	 eax
  0034a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$3[ebp]
  00350	50		 push	 eax
  00351	ff d3		 call	 ebx

; 3051 : 						GCServerMsgStringSend(msg,lpPartyObj->m_Index,1);

  00353	6a 01		 push	 1
  00355	ff 37		 push	 DWORD PTR [edi]
  00357	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$3[ebp]
  0035d	50		 push	 eax
  0035e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 3052 : 						recallcount++;

  00363	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _recallcount$1$[ebp]
  00369	83 c4 14	 add	 esp, 20			; 00000014H
  0036c	41		 inc	 ecx
  0036d	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _recallcount$1$[ebp], ecx

; 3053 : 					}
; 3054 : 					else

  00373	eb 38		 jmp	 SHORT $LN46@SkillRecal
$LN18@SkillRecal:

; 3055 : 					{
; 3056 : 						char msg[255];
; 3057 : 						wsprintf(msg,lMsg.Get(1252));

  00375	68 e4 04 00 00	 push	 1252			; 000004e4H
  0037a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0037f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00384	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__wsprintfA
  0038a	50		 push	 eax
  0038b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  00391	50		 push	 eax
  00392	ff d3		 call	 ebx

; 3058 : 						GCServerMsgStringSend(msg,lpPartyObj->m_Index,1);

  00394	6a 01		 push	 1
  00396	ff 37		 push	 DWORD PTR [edi]
  00398	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  0039e	50		 push	 eax
  0039f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003a4	83 c4 14	 add	 esp, 20			; 00000014H
$LN44@SkillRecal:
  003a7	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _recallcount$1$[ebp]
$LN46@SkillRecal:
  003ad	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv485[ebp]
$LN2@SkillRecal:

; 2983 : 	{
; 2984 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2985 : 
; 2986 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n ++)

  003b3	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv479[ebp]
  003b9	83 c0 04	 add	 eax, 4
  003bc	83 ea 01	 sub	 edx, 1
  003bf	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv479[ebp], eax
  003c5	89 95 f0 fe ff
	ff		 mov	 DWORD PTR tv485[ebp], edx
  003cb	0f 85 cf fd ff
	ff		 jne	 $LL4@SkillRecal

; 3059 : 					}
; 3060 : 				}
; 3061 : 			}
; 3062 : 		}
; 3063 : 	}
; 3064 : 
; 3065 : 	if(recallcount != 0)

  003d1	85 c9		 test	 ecx, ecx
  003d3	74 2d		 je	 SHORT $LN45@SkillRecal

; 3066 : 	{
; 3067 : 		char msg[255];
; 3068 : 		wsprintf(msg,lMsg.Get(1244),recallcount);

  003d5	51		 push	 ecx
  003d6	68 dc 04 00 00	 push	 1244			; 000004dcH
  003db	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003e0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003e5	50		 push	 eax
  003e6	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$1[ebp]
  003ec	50		 push	 eax
  003ed	ff d3		 call	 ebx

; 3069 : 		GCServerMsgStringSend(msg,lpObj->m_Index,1);

  003ef	6a 01		 push	 1
  003f1	ff 36		 push	 DWORD PTR [esi]
  003f3	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$1[ebp]
  003f9	50		 push	 eax
  003fa	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003ff	83 c4 18	 add	 esp, 24			; 00000018H
$LN45@SkillRecal:
  00402	5b		 pop	 ebx
$LN23@SkillRecal:

; 3070 : 	}
; 3071 : }

  00403	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00406	5f		 pop	 edi
  00407	33 cd		 xor	 ecx, ebp
  00409	5e		 pop	 esi
  0040a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040f	8b e5		 mov	 esp, ebp
  00411	5d		 pop	 ebp
  00412	c2 08 00	 ret	 8
$LN42@SkillRecal:
  00415	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _recallcount$1$[ebp]
  0041b	eb 96		 jmp	 SHORT $LN2@SkillRecal
?SkillRecallParty@CObjUseSkill@@QAEXHH@Z ENDP		; CObjUseSkill::SkillRecallParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_skill_level$ = 12					; size = 4
?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z PROC		; CObjUseSkill::RecallPartyCheck, COMDAT
; _this$ = ecx

; 2872 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2873 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048

; 2874 : 	int number;
; 2875 : 	int partynum = 0;
; 2876 : 
; 2877 : 	partynum = lpObj->PartyNumber;

  00013	8b 8c 1f 0c 06
	00 00		 mov	 ecx, DWORD PTR [edi+ebx+1548]

; 2878 : 
; 2879 : 	int partycount;
; 2880 : 	LPOBJ lpPartyObj;
; 2881 : 	int recallcount = 0;
; 2882 : 
; 2883 : 	if(partynum != -1)

  0001a	83 f9 ff	 cmp	 ecx, -1
  0001d	74 49		 je	 SHORT $LN16@RecallPart

; 2884 : 	{
; 2885 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2886 : 
; 2887 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n++)

  0001f	8b c1		 mov	 eax, ecx
  00021	33 d2		 xor	 edx, edx
  00023	c1 e0 04	 shl	 eax, 4
  00026	2b c1		 sub	 eax, ecx
  00028	8d 34 85 0c 00
	00 00		 lea	 esi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  0002f	90		 npad	 1
$LL4@RecallPart:

; 2888 : 		{
; 2889 : 			number = gParty.m_PartyS[partynum].Number[n];

  00030	8b 06		 mov	 eax, DWORD PTR [esi]

; 2890 : 
; 2891 : 			if(number >= 0)

  00032	85 c0		 test	 eax, eax
  00034	78 29		 js	 SHORT $LN2@RecallPart

; 2892 : 			{
; 2893 : 				lpPartyObj = &gObj[number];

  00036	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048

; 2894 : 
; 2895 : 				if(lpPartyObj->m_Index != lpObj->m_Index)

  0003c	8b 04 19	 mov	 eax, DWORD PTR [ecx+ebx]
  0003f	3b 04 1f	 cmp	 eax, DWORD PTR [edi+ebx]
  00042	74 1b		 je	 SHORT $LN2@RecallPart

; 2896 : 				{
; 2897 : 					if(lpPartyObj->MapNumber == lpObj->MapNumber)

  00044	8a 84 19 23 01
	00 00		 mov	 al, BYTE PTR [ecx+ebx+291]
  0004b	3a 84 1f 23 01
	00 00		 cmp	 al, BYTE PTR [edi+ebx+291]
  00052	75 0b		 jne	 SHORT $LN2@RecallPart

; 2898 : 					{
; 2899 : 						if(lpPartyObj->SkillRecallParty_Time != 0)

  00054	66 83 bc 19 04
	16 00 00 00	 cmp	 WORD PTR [ecx+ebx+5636], 0
  0005d	75 15		 jne	 SHORT $LN12@RecallPart
$LN2@RecallPart:

; 2884 : 	{
; 2885 : 		partycount = gParty.m_PartyS[partynum].Count;
; 2886 : 
; 2887 : 		for(int n = 0; n < MAX_USER_IN_PARTY;n++)

  0005f	42		 inc	 edx
  00060	83 c6 04	 add	 esi, 4
  00063	83 fa 05	 cmp	 edx, 5
  00066	7c c8		 jl	 SHORT $LL4@RecallPart
$LN16@RecallPart:
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 2902 : 						}
; 2903 : 					}
; 2904 : 				}
; 2905 : 			}
; 2906 : 		}
; 2907 : 	}
; 2908 : 	return true;

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	5b		 pop	 ebx

; 2909 : }

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
$LN12@RecallPart:
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi

; 2900 : 						{
; 2901 : 							return false;

  00076	33 c0		 xor	 eax, eax
  00078	5b		 pop	 ebx

; 2909 : }

  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
?RecallPartyCheck@CObjUseSkill@@QAEHHH@Z ENDP		; CObjUseSkill::RecallPartyCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -8					; size = 4
_lpObj$1$ = -4						; size = 4
tv457 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillDarkHorseAttack, COMDAT
; _this$ = ecx

; 2773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2774 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  0000e	56		 push	 esi
  0000f	57		 push	 edi

; 2775 : 	int tObjNum;
; 2776 : 	int count = 0;
; 2777 : 	int HitCount = 0;
; 2778 : 	int bAttack;
; 2779 : 	int DuelIndex = lpObj->m_iDuelUser;
; 2780 : 	int EnableAttack;
; 2781 : 
; 2782 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_DARKHORSE_ATTACK,lpObj->m_Index,1);

  00010	6a 01		 push	 1
  00012	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	89 5d fc	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  0001b	ff 33		 push	 DWORD PTR [ebx]
  0001d	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00023	6a 3e		 push	 62			; 0000003eH
  00025	53		 push	 ebx
  00026	89 45 f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00029	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	8d bb 4c 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3148]
  0003a	83 c4 10	 add	 esp, 16			; 00000010H
  0003d	c7 45 08 4b 00
	00 00		 mov	 DWORD PTR tv457[ebp], 75 ; 0000004bH
  00044	ba 0b 02 00 00	 mov	 edx, 523		; 0000020bH
  00049	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0004e	66 90		 npad	 2
$LL2@SkillDarkH:

; 2783 : 
; 2784 : 	while ( true )
; 2785 : 	{
; 2786 : 		if(lpObj->VpPlayer2[count].state != 0)

  00050	80 7f fc 00	 cmp	 BYTE PTR [edi-4], 0
  00054	0f 84 fb 00 00
	00		 je	 $LN24@SkillDarkH

; 2787 : 		{
; 2788 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0005a	0f bf 77 fe	 movsx	 esi, WORD PTR [edi-2]

; 2789 : 
; 2790 : 			if(tObjNum >= 0)

  0005e	85 f6		 test	 esi, esi
  00060	0f 88 ef 00 00
	00		 js	 $LN24@SkillDarkH

; 2791 : 			{
; 2792 : 				EnableAttack = 0;
; 2793 : 				if( (gObj[tObjNum].Class < 100 || gObj[tObjNum].Class > 110) && gObj[tObjNum].Class != 523 )

  00066	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  0006c	0f b7 84 0b 90
	00 00 00	 movzx	 eax, WORD PTR [ebx+ecx+144]
  00074	83 f8 64	 cmp	 eax, 100		; 00000064H
  00077	72 09		 jb	 SHORT $LN7@SkillDarkH
  00079	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0007c	0f 86 d0 00 00
	00		 jbe	 $LN39@SkillDarkH
$LN7@SkillDarkH:
  00082	66 3b c2	 cmp	 ax, dx
  00085	0f 84 c7 00 00
	00		 je	 $LN39@SkillDarkH

; 2794 : 				{
; 2795 : 	
; 2796 : 					if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0008b	8a 07		 mov	 al, BYTE PTR [edi]
  0008d	3c 02		 cmp	 al, 2
  0008f	75 0a		 jne	 SHORT $LN8@SkillDarkH
  00091	83 bc 0b 30 06
	00 00 00	 cmp	 DWORD PTR [ebx+ecx+1584], 0
  00099	7c 7e		 jl	 SHORT $LN12@SkillDarkH
$LN8@SkillDarkH:

; 2797 : 					{
; 2798 : 						EnableAttack = 1;
; 2799 : 					}
; 2800 : 					else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  0009b	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  0009e	74 79		 je	 SHORT $LN12@SkillDarkH
  000a0	39 75 f8	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000a3	74 74		 je	 SHORT $LN12@SkillDarkH

; 2801 : 					{
; 2802 : 						EnableAttack = 1;
; 2803 : 					}
; 2804 : #if (GS_CASTLE == 1)
; 2805 : 					else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000a5	3c 03		 cmp	 al, 3
  000a7	74 33		 je	 SHORT $LN13@SkillDarkH
  000a9	80 bc 0b 23 01
	00 00 1e	 cmp	 BYTE PTR [ebx+ecx+291], 30 ; 0000001eH
  000b1	75 29		 jne	 SHORT $LN13@SkillDarkH
  000b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b8	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 2806 : 					{
; 2807 : 						if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	83 f8 07	 cmp	 eax, 7
  000c6	75 14		 jne	 SHORT $LN13@SkillDarkH
  000c8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000cb	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  000d1	3a 84 0b 5a 20
	00 00		 cmp	 al, BYTE PTR [ebx+ecx+8282]
  000d8	74 73		 je	 SHORT $LN37@SkillDarkH

; 2808 : 							EnableAttack = 1;
; 2809 : 					}
; 2810 : #endif
; 2811 : 					else

  000da	eb 3d		 jmp	 SHORT $LN12@SkillDarkH
$LN13@SkillDarkH:

; 2812 : 					{
; 2813 : 						int CallMonIndex = gObj[tObjNum].m_Index;
; 2814 : 	
; 2815 : 						if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000dc	80 7c 0b 50 02	 cmp	 BYTE PTR [ebx+ecx+80], 2
  000e1	8b 14 0b	 mov	 edx, DWORD PTR [ebx+ecx]
  000e4	75 14		 jne	 SHORT $LN16@SkillDarkH
  000e6	8b 84 0b 30 06
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+1584]
  000ed	85 c0		 test	 eax, eax
  000ef	78 09		 js	 SHORT $LN16@SkillDarkH

; 2816 : 						{
; 2817 : 							CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000f1	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000f7	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN16@SkillDarkH:

; 2818 : 						}
; 2819 : 	
; 2820 : 						if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000fa	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00100	03 c1		 add	 eax, ecx
  00102	50		 push	 eax
  00103	ff 75 fc	 push	 DWORD PTR _lpObj$1$[ebp]
  00106	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0010b	83 c4 08	 add	 esp, 8
  0010e	83 f8 01	 cmp	 eax, 1
  00111	75 34		 jne	 SHORT $LN36@SkillDarkH
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN12@SkillDarkH:

; 2821 : 						{
; 2822 : 							EnableAttack = 1;
; 2823 : 						}
; 2824 : 					}
; 2825 : 	
; 2826 : 					if(EnableAttack != 0)
; 2827 : 					{
; 2828 : 						if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 5)

  00119	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  0011c	8b 5d fc	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  0011f	50		 push	 eax
  00120	53		 push	 ebx
  00121	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00126	83 c4 08	 add	 esp, 8
  00129	83 f8 05	 cmp	 eax, 5
  0012c	7d 19		 jge	 SHORT $LN36@SkillDarkH

; 2829 : 						{
; 2830 : 							bAttack = 0;
; 2831 : 	
; 2832 : 							if(HitCount > 15)
; 2833 : 							{
; 2834 : 								bAttack = 0;
; 2835 : 							}
; 2836 : 	
; 2837 : 							if(HitCount >= 10)
; 2838 : 							{
; 2839 : 								if(rand()%2)
; 2840 : 								{
; 2841 : 									bAttack = 1;
; 2842 : 								}
; 2843 : 							}
; 2844 : 							else
; 2845 : 							{
; 2846 : 								bAttack = 1;
; 2847 : 							}
; 2848 : 	
; 2849 : 							if(bAttack != 0)
; 2850 : 							{
; 2851 : 								gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,500,lpMagic->m_Skill,0);

  0012e	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00131	6a 00		 push	 0
  00133	ff 70 08	 push	 DWORD PTR [eax+8]
  00136	68 f4 01 00 00	 push	 500			; 000001f4H
  0013b	56		 push	 esi
  0013c	6a 32		 push	 50			; 00000032H
  0013e	53		 push	 ebx
  0013f	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00144	83 c4 18	 add	 esp, 24			; 00000018H
$LN36@SkillDarkH:
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN37@SkillDarkH:
  0014d	ba 0b 02 00 00	 mov	 edx, 523		; 0000020bH
$LN39@SkillDarkH:
  00152	8b 45 08	 mov	 eax, DWORD PTR tv457[ebp]
$LN24@SkillDarkH:

; 2852 : 							}
; 2853 : 						}
; 2854 : 					}
; 2855 : 				}
; 2856 : 			}
; 2857 : 		}
; 2858 : 	
; 2859 : 		count++;

  00155	83 c7 0c	 add	 edi, 12			; 0000000cH

; 2860 : 		if(count > MAX_VIEWPORT -1)

  00158	83 e8 01	 sub	 eax, 1
  0015b	89 45 08	 mov	 DWORD PTR tv457[ebp], eax
  0015e	0f 85 ec fe ff
	ff		 jne	 $LL2@SkillDarkH

; 2861 : 		{
; 2862 : 			break;
; 2863 : 		}
; 2864 : 	}
; 2865 : return true;

  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	b8 01 00 00 00	 mov	 eax, 1
  0016b	5b		 pop	 ebx

; 2866 : }

  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c2 0c 00	 ret	 12			; 0000000cH
?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillDarkHorseAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
tv444 = -12						; size = 4
_DuelIndex$1$ = -8					; size = 4
tv447 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillFireBurst, COMDAT
; _this$ = ecx

; 2679 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 2680 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  0000e	56		 push	 esi

; 2681 : 	int StartDis = 1;
; 2682 : 	int tObjNum;
; 2683 : 	int count = 0;
; 2684 : 	int loopcount = 0;
; 2685 : 
; 2686 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  0000f	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]
  00012	57		 push	 edi
  00013	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00016	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001c	6a 01		 push	 1
  0001e	56		 push	 esi
  0001f	0f b7 47 08	 movzx	 eax, WORD PTR [edi+8]
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	89 5d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00028	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 2687 : 	gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0,0,0);

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00040	6a 01		 push	 1
  00042	6a 00		 push	 0
  00044	57		 push	 edi
  00045	03 c1		 add	 eax, ecx
  00047	89 4d f4	 mov	 DWORD PTR tv444[ebp], ecx
  0004a	50		 push	 eax
  0004b	53		 push	 ebx
  0004c	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack

; 2688 : 
; 2689 : 	int attackcheck;
; 2690 : 	int DuelIndex = lpObj->m_iDuelUser;

  00051	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00057	8d bb 4c 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3148]
  0005d	89 45 f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  00060	83 c4 34	 add	 esp, 52			; 00000034H
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv447[ebp], 75 ; 0000004bH
  0006f	90		 npad	 1
$LL2@SkillFireB:

; 2691 : 	int EnableAttack;
; 2692 : 	int delaytime;
; 2693 : 
; 2694 : 	while ( true )
; 2695 : 	{
; 2696 : 		if(lpObj->VpPlayer2[count].state != 0)

  00070	80 7f fc 00	 cmp	 BYTE PTR [edi-4], 0
  00074	0f 84 13 01 00
	00		 je	 $LN21@SkillFireB

; 2697 : 		{
; 2698 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007a	0f bf 77 fe	 movsx	 esi, WORD PTR [edi-2]

; 2699 : 
; 2700 : 			if(tObjNum >= 0 && aTargetIndex != tObjNum)

  0007e	85 f6		 test	 esi, esi
  00080	0f 88 07 01 00
	00		 js	 $LN21@SkillFireB
  00086	39 75 0c	 cmp	 DWORD PTR _aTargetIndex$[ebp], esi
  00089	0f 84 fe 00 00
	00		 je	 $LN21@SkillFireB

; 2701 : 			{
; 2702 : 				EnableAttack = 0;
; 2703 : 
; 2704 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0008f	8a 17		 mov	 dl, BYTE PTR [edi]
  00091	80 fa 02	 cmp	 dl, 2
  00094	75 14		 jne	 SHORT $LN6@SkillFireB
  00096	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0009c	83 bc 01 30 06
	00 00 00	 cmp	 DWORD PTR [ecx+eax+1584], 0
  000a4	0f 8c 95 00 00
	00		 jl	 $LN10@SkillFireB
$LN6@SkillFireB:

; 2705 : 				{
; 2706 : 					EnableAttack = 1;
; 2707 : 				}
; 2708 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000aa	39 75 f8	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000ad	0f 84 8c 00 00
	00		 je	 $LN10@SkillFireB

; 2709 : 				{
; 2710 : 					EnableAttack = 1;
; 2711 : 				}
; 2712 : #if (GS_CASTLE == 1)
; 2713 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000b3	80 fa 03	 cmp	 dl, 3
  000b6	74 47		 je	 SHORT $LN11@SkillFireB
  000b8	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  000be	80 bc 03 23 01
	00 00 1e	 cmp	 BYTE PTR [ebx+eax+291], 30 ; 0000001eH
  000c6	75 34		 jne	 SHORT $LN35@SkillFireB
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000cd	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  000d2	83 f8 07	 cmp	 eax, 7
  000d5	75 20		 jne	 SHORT $LN33@SkillFireB

; 2714 : 				{
; 2715 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000da	8a 88 5a 20 00
	00		 mov	 cl, BYTE PTR [eax+8282]
  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e5	3a 8c 03 5a 20
	00 00		 cmp	 cl, BYTE PTR [ebx+eax+8282]
  000ec	0f 84 9b 00 00
	00		 je	 $LN21@SkillFireB

; 2716 : 						EnableAttack = 1;
; 2717 : 				}
; 2718 : #endif
; 2719 : 				else

  000f2	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  000f5	eb 48		 jmp	 SHORT $LN10@SkillFireB
$LN33@SkillFireB:
  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN35@SkillFireB:
  000fc	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
$LN11@SkillFireB:

; 2720 : 				{
; 2721 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000ff	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048

; 2722 : 
; 2723 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00105	80 7c 01 50 02	 cmp	 BYTE PTR [ecx+eax+80], 2
  0010a	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0010d	75 14		 jne	 SHORT $LN14@SkillFireB
  0010f	8b 8c 01 30 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1584]
  00116	85 c9		 test	 ecx, ecx
  00118	78 09		 js	 SHORT $LN14@SkillFireB

; 2724 : 					{
; 2725 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  0011a	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  00120	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
$LN14@SkillFireB:

; 2726 : 					}
; 2727 : 
; 2728 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00123	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00129	03 c8		 add	 ecx, eax
  0012b	51		 push	 ecx
  0012c	53		 push	 ebx
  0012d	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00132	83 c4 08	 add	 esp, 8
  00135	83 f8 01	 cmp	 eax, 1
  00138	75 4e		 jne	 SHORT $LN34@SkillFireB
  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillFireB:

; 2729 : 					{
; 2730 : 						EnableAttack = 1;
; 2731 : 					}
; 2732 : 				}
; 2733 : 
; 2734 : 				if(EnableAttack != 0)
; 2735 : 				{
; 2736 : 					attackcheck = 0;
; 2737 : 
; 2738 : 					if(loopcount == 0)
; 2739 : 					{
; 2740 : 						attackcheck = 1;
; 2741 : 					}
; 2742 : 					else if(rand()%3==0)
; 2743 : 					{
; 2744 : 						attackcheck = 1;
; 2745 : 					}
; 2746 : 
; 2747 : 					if(attackcheck != 0)
; 2748 : 					{
; 2749 : 						if(gObjCalDistance(&gObj[aTargetIndex],&gObj[tObjNum]) < 3)

  0013f	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00145	03 c8		 add	 ecx, eax
  00147	03 45 f4	 add	 eax, DWORD PTR tv444[ebp]
  0014a	51		 push	 ecx
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00151	83 c4 08	 add	 esp, 8
  00154	83 f8 03	 cmp	 eax, 3
  00157	7d 2f		 jge	 SHORT $LN34@SkillFireB

; 2750 : 						{
; 2751 : 							delaytime = (rand()*17)%300 + 500;

  00159	e8 00 00 00 00	 call	 _rand
  0015e	8b c8		 mov	 ecx, eax
  00160	c1 e1 04	 shl	 ecx, 4
  00163	03 c1		 add	 eax, ecx
  00165	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH
  0016a	99		 cdq
  0016b	f7 f9		 idiv	 ecx

; 2752 : 
; 2753 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,delaytime,lpMagic->m_Skill,0);

  0016d	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00170	6a 00		 push	 0
  00172	81 c2 f4 01 00
	00		 add	 edx, 500		; 000001f4H
  00178	ff 70 08	 push	 DWORD PTR [eax+8]
  0017b	52		 push	 edx
  0017c	56		 push	 esi
  0017d	6a 32		 push	 50			; 00000032H
  0017f	53		 push	 ebx
  00180	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00185	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@SkillFireB:
  00188	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN21@SkillFireB:

; 2754 : 						}
; 2755 : 					}
; 2756 : 				}
; 2757 : 			}
; 2758 : 		}
; 2759 : 
; 2760 : 		count++;
; 2761 : 		if(count > MAX_VIEWPORT -1)

  0018d	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  00190	83 c7 0c	 add	 edi, 12			; 0000000cH
  00193	83 6d fc 01	 sub	 DWORD PTR tv447[ebp], 1
  00197	0f 85 d3 fe ff
	ff		 jne	 $LL2@SkillFireB

; 2762 : 		{
; 2763 : 			break;
; 2764 : 		}
; 2765 : 	}
; 2766 : 	return true;

  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	b8 01 00 00 00	 mov	 eax, 1
  001a4	5b		 pop	 ebx

; 2767 : }

  001a5	8b e5		 mov	 esp, ebp
  001a7	5d		 pop	 ebp
  001a8	c2 0c 00	 ret	 12			; 0000000cH
?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillFireBurst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_iangle$1$ = -12					; size = 4
_DuelIndex$1$ = -8					; size = 4
tv534 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillSpear, COMDAT
; _this$ = ecx

; 2581 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2582 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000b	53		 push	 ebx
  0000c	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  00013	56		 push	 esi
  00014	57		 push	 edi

; 2583 : 	int StartDis = 1;
; 2584 : 	int tObjNum;
; 2585 : 
; 2586 : 	int iangle = GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);

  00015	8b 7d 0c	 mov	 edi, DWORD PTR _aTargetIndex$[ebp]
  00018	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0001e	03 d8		 add	 ebx, eax
  00020	89 5d 08	 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00023	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  00026	0f b6 82 21 01
	00 00		 movzx	 eax, BYTE PTR [edx+289]
  0002d	50		 push	 eax
  0002e	0f b6 82 20 01
	00 00		 movzx	 eax, BYTE PTR [edx+288]
  00035	50		 push	 eax
  00036	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  0003d	50		 push	 eax
  0003e	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle

; 2587 : 	int count = 0;
; 2588 : 	int loopcount = 0;
; 2589 : 	int attackcheck;
; 2590 : 
; 2591 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  0004b	6a 01		 push	 1
  0004d	57		 push	 edi
  0004e	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00051	89 45 f4	 mov	 DWORD PTR _iangle$1$[ebp], eax
  00054	0f b7 4f 08	 movzx	 ecx, WORD PTR [edi+8]
  00058	51		 push	 ecx
  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0005f	83 c4 10	 add	 esp, 16			; 00000010H

; 2592 : 
; 2593 : 	if(lpObj->SkillLongSpearChange == 0)

  00062	80 bb 0a 16 00
	00 00		 cmp	 BYTE PTR [ebx+5642], 0
  00069	75 2c		 jne	 SHORT $LN4@SkillSpear

; 2594 : 	{
; 2595 : 		gObjAttack(lpObj,&gObj[aTargetIndex],lpMagic,0,1,0,0,0,0);

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	6a 01		 push	 1
  0007a	6a 00		 push	 0
  0007c	57		 push	 edi
  0007d	03 c6		 add	 eax, esi
  0007f	50		 push	 eax
  00080	53		 push	 ebx
  00081	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00086	83 c4 24	 add	 esp, 36			; 00000024H

; 2668 : 		{
; 2669 : 			break;
; 2670 : 		}
; 2671 : 	}
; 2672 : 	return true;

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 2673 : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SkillSpear:

; 2596 : 		return true;
; 2597 : 	}
; 2598 : 
; 2599 : 	int DuelIndex = lpObj->m_iDuelUser;

  00097	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  0009d	8d bb 4c 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3148]
  000a3	89 45 f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  000a6	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b0	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv534[ebp], 75 ; 0000004bH
  000b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@SkillSpear:

; 2600 : 	int EnableAttack;
; 2601 : 
; 2602 : 	while ( true )
; 2603 : 	{
; 2604 : 		if(lpObj->VpPlayer2[count].state != 0)

  000c0	80 7f fc 00	 cmp	 BYTE PTR [edi-4], 0
  000c4	0f 84 27 01 00
	00		 je	 $LN22@SkillSpear

; 2605 : 		{
; 2606 : 			tObjNum = lpObj->VpPlayer2[count].number;

  000ca	0f bf 77 fe	 movsx	 esi, WORD PTR [edi-2]

; 2607 : 
; 2608 : 			if(tObjNum >= 0)

  000ce	85 f6		 test	 esi, esi
  000d0	0f 88 1b 01 00
	00		 js	 $LN22@SkillSpear

; 2609 : 			{
; 2610 : 				EnableAttack = 0;
; 2611 : 
; 2612 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  000d6	8a 17		 mov	 dl, BYTE PTR [edi]
  000d8	80 fa 02	 cmp	 dl, 2
  000db	75 14		 jne	 SHORT $LN7@SkillSpear
  000dd	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000e3	83 bc 01 30 06
	00 00 00	 cmp	 DWORD PTR [ecx+eax+1584], 0
  000eb	0f 8c 9e 00 00
	00		 jl	 $LN11@SkillSpear
$LN7@SkillSpear:

; 2613 : 				{
; 2614 : 					EnableAttack = 1;
; 2615 : 				}
; 2616 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000f1	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  000f4	0f 84 95 00 00
	00		 je	 $LN11@SkillSpear
  000fa	39 75 f8	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000fd	0f 84 8c 00 00
	00		 je	 $LN11@SkillSpear

; 2617 : 				{
; 2618 : 					EnableAttack = 1;
; 2619 : 				}
; 2620 : #if (GS_CASTLE == 1)
; 2621 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  00103	80 fa 03	 cmp	 dl, 3
  00106	74 47		 je	 SHORT $LN12@SkillSpear
  00108	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  0010e	80 bc 03 23 01
	00 00 1e	 cmp	 BYTE PTR [ebx+eax+291], 30 ; 0000001eH
  00116	75 34		 jne	 SHORT $LN37@SkillSpear
  00118	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0011d	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00122	83 f8 07	 cmp	 eax, 7
  00125	75 20		 jne	 SHORT $LN34@SkillSpear

; 2622 : 				{
; 2623 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  00127	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  0012a	8a 88 5a 20 00
	00		 mov	 cl, BYTE PTR [eax+8282]
  00130	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00135	3a 8c 03 5a 20
	00 00		 cmp	 cl, BYTE PTR [ebx+eax+8282]

; 2624 : 						EnableAttack = 1;
; 2625 : 				}
; 2626 : #endif
; 2627 : 				else

  0013c	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  0013f	0f 84 a9 00 00
	00		 je	 $LN36@SkillSpear
  00145	eb 48		 jmp	 SHORT $LN11@SkillSpear
$LN34@SkillSpear:
  00147	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN37@SkillSpear:
  0014c	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
$LN12@SkillSpear:

; 2628 : 				{
; 2629 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0014f	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048

; 2630 : 
; 2631 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00155	80 7c 01 50 02	 cmp	 BYTE PTR [ecx+eax+80], 2
  0015a	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0015d	75 14		 jne	 SHORT $LN15@SkillSpear
  0015f	8b 8c 01 30 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1584]
  00166	85 c9		 test	 ecx, ecx
  00168	78 09		 js	 SHORT $LN15@SkillSpear

; 2632 : 					{
; 2633 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  0016a	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  00170	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
$LN15@SkillSpear:

; 2634 : 					}
; 2635 : 
; 2636 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00173	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00179	03 c8		 add	 ecx, eax
  0017b	51		 push	 ecx
  0017c	53		 push	 ebx
  0017d	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00182	83 c4 08	 add	 esp, 8
  00185	83 f8 01	 cmp	 eax, 1
  00188	75 5f		 jne	 SHORT $LN35@SkillSpear
  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN11@SkillSpear:

; 2637 : 					{
; 2638 : 						EnableAttack = 1;
; 2639 : 					}
; 2640 : 				}
; 2641 : 
; 2642 : 				if(EnableAttack != 0)
; 2643 : 				{
; 2644 : 					attackcheck = 0;
; 2645 : 
; 2646 : 					if(loopcount == 0)
; 2647 : 					{
; 2648 : 						attackcheck = 1;
; 2649 : 					}
; 2650 : 					else if(rand()%3==0)
; 2651 : 					{
; 2652 : 						attackcheck = 1;
; 2653 : 					}
; 2654 : 
; 2655 : 					if(attackcheck != 0)
; 2656 : 					{
; 2657 : 						if(SkillSpearHitBox.HitCheck(iangle,lpObj->X,lpObj->Y,gObj[tObjNum].X,gObj[tObjNum].Y))

  0018f	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  00195	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00198	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  0019f	50		 push	 eax
  001a0	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  001a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillSpearHitBox@@3VCSkillHitBox@@A ; SkillSpearHitBox
  001ac	50		 push	 eax
  001ad	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  001b4	50		 push	 eax
  001b5	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  001bc	50		 push	 eax
  001bd	ff 75 f4	 push	 DWORD PTR _iangle$1$[ebp]
  001c0	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  001c5	85 c0		 test	 eax, eax
  001c7	74 20		 je	 SHORT $LN35@SkillSpear

; 2658 : 						{
; 2659 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,0,1,0,0,0,0);

  001c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ce	6a 00		 push	 0
  001d0	6a 00		 push	 0
  001d2	6a 00		 push	 0
  001d4	6a 00		 push	 0
  001d6	6a 01		 push	 1
  001d8	6a 00		 push	 0
  001da	ff 75 10	 push	 DWORD PTR _lpMagic$[ebp]
  001dd	03 c6		 add	 eax, esi
  001df	50		 push	 eax
  001e0	53		 push	 ebx
  001e1	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  001e6	83 c4 24	 add	 esp, 36			; 00000024H
$LN35@SkillSpear:
  001e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN36@SkillSpear:
  001ee	8b 4d fc	 mov	 ecx, DWORD PTR tv534[ebp]
$LN22@SkillSpear:

; 2660 : 						}
; 2661 : 					}
; 2662 : 				}
; 2663 : 			}
; 2664 : 		}
; 2665 : 
; 2666 : 		count++;

  001f1	83 c7 0c	 add	 edi, 12			; 0000000cH

; 2667 : 		if(count > MAX_VIEWPORT -1)

  001f4	83 e9 01	 sub	 ecx, 1
  001f7	89 4d fc	 mov	 DWORD PTR tv534[ebp], ecx
  001fa	0f 85 c0 fe ff
	ff		 jne	 $LL2@SkillSpear

; 2668 : 		{
; 2669 : 			break;
; 2670 : 		}
; 2671 : 	}
; 2672 : 	return true;

  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	b8 01 00 00 00	 mov	 eax, 1
  00207	5b		 pop	 ebx

; 2673 : }

  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 0c 00	 ret	 12			; 0000000cH
?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillSpear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z
_TEXT	SEGMENT
_angel$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_tx$ = 20						; size = 4
_ty$ = 24						; size = 4
_dis$ = 28						; size = 4
_arc$ = 32						; size = 4
?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z PROC	; CObjUseSkill::SkillAreaCheck, COMDAT
; _this$ = ecx

; 2519 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2520 : 	int minangel = angel - arc;

  00003	8b 55 08	 mov	 edx, DWORD PTR _angel$[ebp]
  00006	8b 45 20	 mov	 eax, DWORD PTR _arc$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2521 : 	int maxangel = angel + arc;
; 2522 : 
; 2523 : 	if(CalDistance(x,y,tx,ty) > dis)

  0000c	ff 75 18	 push	 DWORD PTR _ty$[ebp]
  0000f	8b fa		 mov	 edi, edx
  00011	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00014	ff 75 14	 push	 DWORD PTR _tx$[ebp]
  00017	8b d9		 mov	 ebx, ecx
  00019	2b f8		 sub	 edi, eax
  0001b	ff 75 10	 push	 DWORD PTR _y$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR _x$[ebp]
  00021	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  00026	3b 45 1c	 cmp	 eax, DWORD PTR _dis$[ebp]
  00029	7f 55		 jg	 SHORT $LN21@SkillAreaC

; 2524 : 	{
; 2525 : 		return false;
; 2526 : 	}
; 2527 : 
; 2528 : 	int targetangle = GetAngle(x,y,tx,ty);

  0002b	ff 75 18	 push	 DWORD PTR _ty$[ebp]
  0002e	8b cb		 mov	 ecx, ebx
  00030	ff 75 14	 push	 DWORD PTR _tx$[ebp]
  00033	ff 75 10	 push	 DWORD PTR _y$[ebp]
  00036	ff 75 0c	 push	 DWORD PTR _x$[ebp]
  00039	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  0003e	8b d0		 mov	 edx, eax

; 2529 : 
; 2530 : 	if(minangel < 0)

  00040	85 ff		 test	 edi, edi
  00042	79 18		 jns	 SHORT $LN3@SkillAreaC

; 2531 : 	{
; 2532 : 		if(targetangle > maxangel)

  00044	3b d6		 cmp	 edx, esi
  00046	7e 4e		 jle	 SHORT $LN19@SkillAreaC

; 2533 : 		{
; 2534 : 			if(targetangle > minangel + 360)

  00048	8d 8f 68 01 00
	00		 lea	 ecx, DWORD PTR [edi+360]
  0004e	33 c0		 xor	 eax, eax
  00050	5f		 pop	 edi
  00051	3b d1		 cmp	 edx, ecx
  00053	5e		 pop	 esi
  00054	0f 9f c0	 setg	 al
  00057	5b		 pop	 ebx

; 2575 : }

  00058	5d		 pop	 ebp
  00059	c2 1c 00	 ret	 28			; 0000001cH
$LN3@SkillAreaC:

; 2535 : 			{
; 2536 : 				return true;
; 2537 : 			}
; 2538 : 			else
; 2539 : 			{
; 2540 : 				return false;
; 2541 : 			}
; 2542 : 		}
; 2543 : 		else if(maxangel < targetangle)
; 2544 : 		{
; 2545 : 			return false;
; 2546 : 		}
; 2547 : 	}
; 2548 : 	else if(maxangel > 360)

  0005c	81 fe 68 01 00
	00		 cmp	 esi, 360		; 00000168H
  00062	7e 25		 jle	 SHORT $LN10@SkillAreaC

; 2549 : 	{
; 2550 : 		if(targetangle < minangel)

  00064	3b d7		 cmp	 edx, edi
  00066	7d 14		 jge	 SHORT $LN12@SkillAreaC

; 2551 : 		{
; 2552 : 			if(targetangle < maxangel - 360)

  00068	8d 8e 98 fe ff
	ff		 lea	 ecx, DWORD PTR [esi-360]
  0006e	33 c0		 xor	 eax, eax
  00070	5f		 pop	 edi
  00071	3b d1		 cmp	 edx, ecx
  00073	5e		 pop	 esi
  00074	0f 9c c0	 setl	 al
  00077	5b		 pop	 ebx

; 2575 : }

  00078	5d		 pop	 ebp
  00079	c2 1c 00	 ret	 28			; 0000001cH
$LN12@SkillAreaC:

; 2553 : 			{
; 2554 : 				return true;
; 2555 : 			}
; 2556 : 			else
; 2557 : 			{
; 2558 : 				return false;
; 2559 : 			}
; 2560 : 		}
; 2561 : 		else if(maxangel < targetangle)

  0007c	3b f2		 cmp	 esi, edx
  0007e	7d 16		 jge	 SHORT $LN19@SkillAreaC
$LN21@SkillAreaC:
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi

; 2562 : 		{
; 2563 : 			return false;

  00082	33 c0		 xor	 eax, eax
  00084	5b		 pop	 ebx

; 2575 : }

  00085	5d		 pop	 ebp
  00086	c2 1c 00	 ret	 28			; 0000001cH
$LN10@SkillAreaC:

; 2564 : 		}
; 2565 : 	}
; 2566 : 	else if(minangel > targetangle)

  00089	3b fa		 cmp	 edi, edx
  0008b	7e ef		 jle	 SHORT $LN12@SkillAreaC

; 2562 : 		{
; 2563 : 			return false;

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	33 c0		 xor	 eax, eax
  00091	5b		 pop	 ebx

; 2575 : }

  00092	5d		 pop	 ebp
  00093	c2 1c 00	 ret	 28			; 0000001cH
$LN19@SkillAreaC:
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi

; 2567 : 	{
; 2568 : 		return false;
; 2569 : 	}
; 2570 : 	else if(maxangel < targetangle)
; 2571 : 	{
; 2572 : 		return false;
; 2573 : 	}
; 2574 : 	return true;

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	5b		 pop	 ebx

; 2575 : }

  0009e	5d		 pop	 ebp
  0009f	c2 1c 00	 ret	 28			; 0000001cH
?SkillAreaCheck@CObjUseSkill@@QAEHHHHHHHH@Z ENDP	; CObjUseSkill::SkillAreaCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z
_TEXT	SEGMENT
_lpObj$1$ = -168					; size = 4
tv396 = -164						; size = 4
_vFrustrum$ = -160					; size = 48
_Matrix$ = -112						; size = 48
_p$ = -64						; size = 48
_Angle$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_fangle$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z PROC		; CObjUseSkill::SkillFrustrum2, COMDAT
; _this$ = ecx

; 2441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 2442 : 	LPOBJ lpObj = &gObj[aIndex];
; 2443 : 
; 2444 : 
; 2445 : 	float p[MAX_ARRAY_FRUSTRUM][3];
; 2446 : 
; 2447 : 	p[0][0] = 0;
; 2448 : 	p[0][1] = ty;

  00016	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _ty$[ebp]

; 2449 : 	p[0][2] = 0;
; 2450 : 	p[1][0] = 0;
; 2451 : 	p[1][1] = ty;
; 2452 : 	p[1][2] = 0;
; 2453 : 	p[2][0] = tx;

  0001b	f3 0f 10 4d 10	 movss	 xmm1, DWORD PTR _tx$[ebp]
  00020	56		 push	 esi
  00021	69 f0 40 27 00
	00		 imul	 esi, eax, 10048

; 2454 : 	p[2][1] = 1.0f;
; 2455 : 	p[2][2] = 0;
; 2456 : 	p[3][0] = -tx;
; 2457 : 	p[3][1] = 1.0f;
; 2458 : 	p[3][2] = 0;
; 2459 : 
; 2460 : 	float Angle[3];
; 2461 : 
; 2462 : 	Angle[0] = 0;
; 2463 : 	Angle[1] = 0;
; 2464 : 	Angle[2] = fangle;
; 2465 : 
; 2466 : 	float Matrix[3][MAX_ARRAY_FRUSTRUM];
; 2467 : 	float vFrustrum[MAX_ARRAY_FRUSTRUM][3];
; 2468 : 
; 2469 : 	AngleMatrix(Angle,Matrix);

  00027	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  0002a	57		 push	 edi
  0002b	50		 push	 eax
  0002c	f3 0f 11 45 c4	 movss	 DWORD PTR _p$[ebp+4], xmm0
  00031	8d 45 f0	 lea	 eax, DWORD PTR _Angle$[ebp]
  00034	f3 0f 11 45 d0	 movss	 DWORD PTR _p$[ebp+16], xmm0
  00039	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fangle$[ebp]
  00044	f3 0f 11 4d d8	 movss	 DWORD PTR _p$[ebp+24], xmm1
  00049	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00050	50		 push	 eax
  00051	89 b5 58 ff ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], esi
  00057	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  0005e	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+8], 0
  00065	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+12], 0
  0006c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+20], 0
  00073	c7 45 dc 00 00
	80 3f		 mov	 DWORD PTR _p$[ebp+28], 1065353216 ; 3f800000H
  0007a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+32], 0
  00081	f3 0f 11 4d e4	 movss	 DWORD PTR _p$[ebp+36], xmm1
  00086	c7 45 e8 00 00
	80 3f		 mov	 DWORD PTR _p$[ebp+40], 1065353216 ; 3f800000H
  0008d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+44], 0
  00094	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Angle$[ebp], 0
  0009b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Angle$[ebp+4], 0
  000a2	f3 0f 11 45 f8	 movss	 DWORD PTR _Angle$[ebp+8], xmm0
  000a7	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  000ac	8d 86 98 14 00
	00		 lea	 eax, DWORD PTR [esi+5272]
  000b2	83 c4 08	 add	 esp, 8
  000b5	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv396[ebp], eax

; 2470 : 
; 2471 : 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; i++)

  000bb	33 ff		 xor	 edi, edi
  000bd	0f 1f 00	 npad	 3
$LL4@SkillFrust:

; 2472 : 	{
; 2473 : 		VectorRotate((const float *)&p[i],(const float *)&Matrix[0],(float *)&vFrustrum[i]);

  000c0	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _vFrustrum$[ebp]
  000c6	03 f7		 add	 esi, edi
  000c8	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000cb	56		 push	 esi
  000cc	50		 push	 eax
  000cd	8d 45 c0	 lea	 eax, DWORD PTR _p$[ebp]
  000d0	03 c7		 add	 eax, edi
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 2474 : 
; 2475 : 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  000d8	f3 0f 2c 0e	 cvttss2si ecx, DWORD PTR [esi]
  000dc	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv396[ebp]
  000eb	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  000f2	03 c8		 add	 ecx, eax
  000f4	89 4a f0	 mov	 DWORD PTR [edx-16], ecx

; 2476 : 		lpObj->fSkillFrustrumY[i] = (int)vFrustrum[i][1] + lpObj->Y;

  000f7	f3 0f 2c 8c 3d
	64 ff ff ff	 cvttss2si ecx, DWORD PTR _vFrustrum$[ebp+edi+4]
  00100	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00107	83 c7 0c	 add	 edi, 12			; 0000000cH
  0010a	03 c8		 add	 ecx, eax
  0010c	89 0a		 mov	 DWORD PTR [edx], ecx
  0010e	83 c2 04	 add	 edx, 4
  00111	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv396[ebp], edx
  00117	83 ff 30	 cmp	 edi, 48			; 00000030H
  0011a	7c a4		 jl	 SHORT $LL4@SkillFrust

; 2477 : 	}
; 2478 : }

  0011c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011f	5f		 pop	 edi
  00120	33 cd		 xor	 ecx, ebp
  00122	5e		 pop	 esi
  00123	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 10 00	 ret	 16			; 00000010H
?SkillFrustrum2@CObjUseSkill@@QAEXHMMM@Z ENDP		; CObjUseSkill::SkillFrustrum2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?CalDistance@CObjUseSkill@@QAEHHHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
?CalDistance@CObjUseSkill@@QAEHHHHH@Z PROC		; CObjUseSkill::CalDistance, COMDAT
; _this$ = ecx

; 2503 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 2504 : 	if(x == x1 && y == y1)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00009	8b 55 14	 mov	 edx, DWORD PTR _y1$[ebp]
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000f	3b 4d 10	 cmp	 ecx, DWORD PTR _x1$[ebp]
  00012	75 0c		 jne	 SHORT $LN2@CalDistanc
  00014	3b c2		 cmp	 eax, edx
  00016	75 08		 jne	 SHORT $LN2@CalDistanc

; 2505 : 	{
; 2506 : 		return 0;

  00018	33 c0		 xor	 eax, eax

; 2513 : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 10 00	 ret	 16			; 00000010H
$LN2@CalDistanc:

; 2507 : 	}
; 2508 : 
; 2509 : 	float tx = (float)(x - x1);

  00020	2b 4d 10	 sub	 ecx, DWORD PTR _x1$[ebp]

; 2510 : 	float ty = (float)(y - y1);

  00023	2b c2		 sub	 eax, edx
  00025	66 0f 6e c9	 movd	 xmm1, ecx
  00029	66 0f 6e c0	 movd	 xmm0, eax
  0002d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00030	0f 5b c9	 cvtdq2ps xmm1, xmm1

; 2512 : 	return (int)sqrt(tx*tx + ty*ty);

  00033	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00037	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0003b	f3 0f 58 c1	 addss	 xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  0003f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00042	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00047	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 2512 : 	return (int)sqrt(tx*tx + ty*ty);

  0004b	f3 0f 2c c0	 cvttss2si eax, xmm0

; 2513 : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 10 00	 ret	 16			; 00000010H
?CalDistance@CObjUseSkill@@QAEHHHHH@Z ENDP		; CObjUseSkill::CalDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?GetAngle@CObjUseSkill@@QAEHHHHH@Z
_TEXT	SEGMENT
tv135 = -8						; size = 8
tv130 = -8						; size = 8
tv84 = -8						; size = 8
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
?GetAngle@CObjUseSkill@@QAEHHHHH@Z PROC			; CObjUseSkill::GetAngle, COMDAT
; _this$ = ecx

; 2484 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2485 : 	double diffX = x - tx;
; 2486 : 	double diffY = y - ty;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00009	2b 45 14	 sub	 eax, DWORD PTR _ty$[ebp]
  0000c	66 0f 6e c0	 movd	 xmm0, eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00013	2b 45 10	 sub	 eax, DWORD PTR _tx$[ebp]
  00016	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 2487 : 
; 2488 : 	double rad = atan2(diffY,diffX);

  0001a	f2 0f 11 45 f8	 movsd	 QWORD PTR tv135[ebp], xmm0
  0001f	dd 45 f8	 fld	 QWORD PTR tv135[ebp]
  00022	66 0f 6e c0	 movd	 xmm0, eax
  00026	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0002a	f2 0f 11 45 f8	 movsd	 QWORD PTR tv130[ebp], xmm0
  0002f	dd 45 f8	 fld	 QWORD PTR tv130[ebp]
  00032	e8 00 00 00 00	 call	 __CIatan2

; 2489 : 
; 2490 : 	int angle = (int)(rad * 180 / 3.141592741012573 + 90);

  00037	dd 5d f8	 fstp	 QWORD PTR tv84[ebp]
  0003a	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR tv84[ebp]
  0003f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4066800000000000
  00047	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@400921fb5fffffff
  0004f	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4056800000000000
  00057	f2 0f 2c c0	 cvttsd2si eax, xmm0

; 2491 : 
; 2492 : 	if(angle < 0)

  0005b	85 c0		 test	 eax, eax
  0005d	79 05		 jns	 SHORT $LN2@GetAngle

; 2493 : 	{
; 2494 : 		angle += 360;

  0005f	05 68 01 00 00	 add	 eax, 360		; 00000168H
$LN2@GetAngle:

; 2495 : 	}
; 2496 : 	return angle;
; 2497 : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 10 00	 ret	 16			; 00000010H
?GetAngle@CObjUseSkill@@QAEHHHHH@Z ENDP			; CObjUseSkill::GetAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z
_TEXT	SEGMENT
_delta_y$1$ = -28					; size = 4
_count$2$ = -24						; size = 4
tv560 = -24						; size = 4
_incx$1$ = -24						; size = 4
tv557 = -20						; size = 4
_incy$1$ = -20						; size = 4
tv554 = -16						; size = 4
tv549 = -16						; size = 4
_delta_x$1$ = -16					; size = 4
_half$1$ = -12						; size = 4
tv547 = -12						; size = 4
tv546 = -12						; size = 4
_half$2$ = -8						; size = 4
_count$1$ = -8						; size = 4
_count$4$ = -4						; size = 4
_count$3$ = -4						; size = 4
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
_PathX$ = 24						; size = 4
_PathY$ = 28						; size = 4
_distance$ = 32						; size = 4
?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z PROC	; CObjUseSkill::GetTargetLinePath, COMDAT
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 41   : 	int x,y;
; 42   : 	int delta_x,delta_y;
; 43   : 	int half;
; 44   : 
; 45   : 	int error = 0;
; 46   : 
; 47   : 	int incx = 1,incy = 1;
; 48   : 	int dis;
; 49   : 	int count;
; 50   : 
; 51   : 	if(sx > tx)

  00009	8b 45 10	 mov	 eax, DWORD PTR _tx$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR _sx$[ebp]
  00012	33 f6		 xor	 esi, esi
  00014	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _incx$1$[esp+40], 1
  0001c	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _incy$1$[esp+40], 1
  00024	3b f8		 cmp	 edi, eax
  00026	7e 0e		 jle	 SHORT $LN14@GetTargetL

; 52   : 	{
; 53   : 		incx = -1;
; 54   : 		delta_x = sx - tx;

  00028	8b d7		 mov	 edx, edi
  0002a	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR _incx$1$[esp+40], -1
  00032	2b d0		 sub	 edx, eax

; 55   : 	}
; 56   : 	else

  00034	eb 04		 jmp	 SHORT $LN54@GetTargetL
$LN14@GetTargetL:

; 57   : 	{
; 58   : 		delta_x = tx - sx;

  00036	8b d0		 mov	 edx, eax
  00038	2b d7		 sub	 edx, edi
$LN54@GetTargetL:

; 59   : 	}
; 60   : 
; 61   : 	if(sy > ty)

  0003a	8b 5d 0c	 mov	 ebx, DWORD PTR _sy$[ebp]
  0003d	8b 4d 14	 mov	 ecx, DWORD PTR _ty$[ebp]
  00040	89 54 24 18	 mov	 DWORD PTR _delta_x$1$[esp+40], edx
  00044	3b d9		 cmp	 ebx, ecx
  00046	7e 0e		 jle	 SHORT $LN16@GetTargetL

; 62   : 	{
; 63   : 		incy = -1;
; 64   : 		delta_y = sy - ty;

  00048	8b c3		 mov	 eax, ebx
  0004a	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR _incy$1$[esp+40], -1
  00052	2b c1		 sub	 eax, ecx

; 65   : 	}
; 66   : 	else

  00054	eb 04		 jmp	 SHORT $LN55@GetTargetL
$LN16@GetTargetL:

; 67   : 	{
; 68   : 		delta_y = ty - sy;

  00056	8b c1		 mov	 eax, ecx
  00058	2b c3		 sub	 eax, ebx
$LN55@GetTargetL:

; 71   : 	dis = (int)(sqrt((float)(delta_x * delta_x + delta_y * delta_y)));

  0005a	8b c8		 mov	 ecx, eax
  0005c	89 44 24 0c	 mov	 DWORD PTR _delta_y$1$[esp+40], eax
  00060	0f af c8	 imul	 ecx, eax
  00063	8b c2		 mov	 eax, edx
  00065	0f af c2	 imul	 eax, edx
  00068	03 c8		 add	 ecx, eax
  0006a	66 0f 6e c1	 movd	 xmm0, ecx
  0006e	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  00071	0f 5a c0	 cvtps2pd xmm0, xmm0
  00074	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 79   : 	if(delta_x > delta_y)

  00079	8b 4c 24 18	 mov	 ecx, DWORD PTR _delta_x$1$[esp+40]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  0007d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 71   : 	dis = (int)(sqrt((float)(delta_x * delta_x + delta_y * delta_y)));

  00081	f3 0f 2c c0	 cvttss2si eax, xmm0

; 72   : 	dis = distance - dis;

  00085	29 45 20	 sub	 DWORD PTR _distance$[ebp], eax

; 73   : 
; 74   : 	count = 0;
; 75   : 	PathX[count] = sx;

  00088	8b 45 18	 mov	 eax, DWORD PTR _PathX$[ebp]
  0008b	89 38		 mov	 DWORD PTR [eax], edi

; 76   : 	PathY[count] = sy;

  0008d	8b 45 1c	 mov	 eax, DWORD PTR _PathY$[ebp]
  00090	89 18		 mov	 DWORD PTR [eax], ebx

; 79   : 	if(delta_x > delta_y)

  00092	8b 44 24 0c	 mov	 eax, DWORD PTR _delta_y$1$[esp+40]
  00096	3b c8		 cmp	 ecx, eax
  00098	0f 8e e7 00 00
	00		 jle	 $LN18@GetTargetL

; 80   : 	{
; 81   : 		y = sy;
; 82   : 		half = delta_x / 2;

  0009e	8b c1		 mov	 eax, ecx
  000a0	99		 cdq
  000a1	2b c2		 sub	 eax, edx
  000a3	d1 f8		 sar	 eax, 1
  000a5	89 44 24 1c	 mov	 DWORD PTR _half$1$[esp+40], eax

; 83   : 
; 84   : 		if(incx > 0)
; 85   : 		{
; 86   : 			for(x = (sx+1); x <= (tx + dis); x++)

  000a9	8b 45 10	 mov	 eax, DWORD PTR _tx$[ebp]
  000ac	39 74 24 10	 cmp	 DWORD PTR _incx$1$[esp+40], esi
  000b0	7e 67		 jle	 SHORT $LN20@GetTargetL
  000b2	03 45 20	 add	 eax, DWORD PTR _distance$[ebp]
  000b5	47		 inc	 edi
  000b6	89 44 24 10	 mov	 DWORD PTR tv560[esp+40], eax
  000ba	3b f8		 cmp	 edi, eax
  000bc	0f 8f a3 01 00
	00		 jg	 $LN50@GetTargetL
  000c2	8b 45 1c	 mov	 eax, DWORD PTR _PathY$[ebp]
  000c5	8b 55 18	 mov	 edx, DWORD PTR _PathX$[ebp]
  000c8	83 c0 04	 add	 eax, 4
  000cb	2b 55 1c	 sub	 edx, DWORD PTR _PathY$[ebp]
  000ce	89 44 24 18	 mov	 DWORD PTR tv554[esp+40], eax
  000d2	8b 44 24 10	 mov	 eax, DWORD PTR tv560[esp+40]
  000d6	2b c7		 sub	 eax, edi
  000d8	83 c0 02	 add	 eax, 2
  000db	89 44 24 20	 mov	 DWORD PTR _count$1$[esp+40], eax
  000df	8b 44 24 0c	 mov	 eax, DWORD PTR _delta_y$1$[esp+40]
$LL4@GetTargetL:

; 87   : 			{
; 88   : 				error += delta_y;

  000e3	03 f0		 add	 esi, eax

; 89   : 
; 90   : 				if(error > half)

  000e5	3b 74 24 1c	 cmp	 esi, DWORD PTR _half$1$[esp+40]
  000e9	7e 06		 jle	 SHORT $LN22@GetTargetL

; 91   : 				{
; 92   : 					y += incy;

  000eb	03 5c 24 14	 add	 ebx, DWORD PTR _incy$1$[esp+40]

; 93   : 					error -= delta_x;

  000ef	2b f1		 sub	 esi, ecx
$LN22@GetTargetL:

; 94   : 				}
; 95   : 
; 96   : 				PathX[count] = x;

  000f1	8b 44 24 18	 mov	 eax, DWORD PTR tv554[esp+40]
  000f5	89 3c 02	 mov	 DWORD PTR [edx+eax], edi

; 97   : 				PathY[count] = y;
; 98   : 
; 99   : 				count++;

  000f8	47		 inc	 edi
  000f9	89 18		 mov	 DWORD PTR [eax], ebx
  000fb	83 c0 04	 add	 eax, 4
  000fe	89 44 24 18	 mov	 DWORD PTR tv554[esp+40], eax
  00102	8b 44 24 0c	 mov	 eax, DWORD PTR _delta_y$1$[esp+40]
  00106	3b 7c 24 10	 cmp	 edi, DWORD PTR tv560[esp+40]
  0010a	7e d7		 jle	 SHORT $LL4@GetTargetL

; 158  : 			}
; 159  : 		}
; 160  : 	}
; 161  : 	return count;

  0010c	8b 44 24 20	 mov	 eax, DWORD PTR _count$1$[esp+40]

; 162  : }

  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 1c 00	 ret	 28			; 0000001cH
$LN20@GetTargetL:

; 100  : 			}
; 101  : 		}
; 102  : 		else
; 103  : 		{
; 104  : 			for(x = (sx-1); x >= (tx - dis);x--)

  00119	2b 45 20	 sub	 eax, DWORD PTR _distance$[ebp]
  0011c	4f		 dec	 edi
  0011d	89 45 10	 mov	 DWORD PTR _tx$[ebp], eax
  00120	3b f8		 cmp	 edi, eax
  00122	0f 8c 3d 01 00
	00		 jl	 $LN50@GetTargetL
  00128	8b 45 1c	 mov	 eax, DWORD PTR _PathY$[ebp]
  0012b	8b 55 18	 mov	 edx, DWORD PTR _PathX$[ebp]
  0012e	83 c0 04	 add	 eax, 4
  00131	2b 55 1c	 sub	 edx, DWORD PTR _PathY$[ebp]
  00134	89 44 24 18	 mov	 DWORD PTR tv549[esp+40], eax
  00138	8b 45 10	 mov	 eax, DWORD PTR _tx$[ebp]
  0013b	89 7c 24 10	 mov	 DWORD PTR _count$2$[esp+40], edi
  0013f	29 44 24 10	 sub	 DWORD PTR _count$2$[esp+40], eax
  00143	83 44 24 10 02	 add	 DWORD PTR _count$2$[esp+40], 2
  00148	8b 44 24 0c	 mov	 eax, DWORD PTR _delta_y$1$[esp+40]
  0014c	0f 1f 40 00	 npad	 4
$LL7@GetTargetL:

; 105  : 			{
; 106  : 				error += delta_y;

  00150	03 f0		 add	 esi, eax

; 107  : 
; 108  : 				if(error > half)

  00152	3b 74 24 1c	 cmp	 esi, DWORD PTR _half$1$[esp+40]
  00156	7e 06		 jle	 SHORT $LN23@GetTargetL

; 109  : 				{
; 110  : 					y += incy;

  00158	03 5c 24 14	 add	 ebx, DWORD PTR _incy$1$[esp+40]

; 111  : 					error -= delta_x;

  0015c	2b f1		 sub	 esi, ecx
$LN23@GetTargetL:

; 112  : 				}
; 113  : 
; 114  : 				PathX[count] = x;

  0015e	8b 44 24 18	 mov	 eax, DWORD PTR tv549[esp+40]
  00162	89 3c 10	 mov	 DWORD PTR [eax+edx], edi
  00165	4f		 dec	 edi

; 115  : 				PathY[count] = y;

  00166	89 18		 mov	 DWORD PTR [eax], ebx

; 116  : 
; 117  : 				count++;

  00168	83 c0 04	 add	 eax, 4
  0016b	89 44 24 18	 mov	 DWORD PTR tv549[esp+40], eax
  0016f	8b 44 24 0c	 mov	 eax, DWORD PTR _delta_y$1$[esp+40]
  00173	3b 7d 10	 cmp	 edi, DWORD PTR _tx$[ebp]
  00176	7d d8		 jge	 SHORT $LL7@GetTargetL

; 158  : 			}
; 159  : 		}
; 160  : 	}
; 161  : 	return count;

  00178	8b 44 24 10	 mov	 eax, DWORD PTR _count$2$[esp+40]

; 162  : }

  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 1c 00	 ret	 28			; 0000001cH
$LN18@GetTargetL:

; 118  : 			}
; 119  : 		}
; 120  : 	}
; 121  : 	else
; 122  : 	{
; 123  : 		x = sx;
; 124  : 		half = delta_y / 2;

  00185	99		 cdq
  00186	2b c2		 sub	 eax, edx
  00188	d1 f8		 sar	 eax, 1
  0018a	89 44 24 20	 mov	 DWORD PTR _half$2$[esp+40], eax

; 125  : 
; 126  : 		if(incy > 0)
; 127  : 		{
; 128  : 			for(y = (sy+1); y <= (ty + dis);y++)

  0018e	8b 45 14	 mov	 eax, DWORD PTR _ty$[ebp]
  00191	39 74 24 14	 cmp	 DWORD PTR _incy$1$[esp+40], esi
  00195	7e 67		 jle	 SHORT $LN24@GetTargetL
  00197	03 45 20	 add	 eax, DWORD PTR _distance$[ebp]
  0019a	43		 inc	 ebx
  0019b	89 44 24 14	 mov	 DWORD PTR tv557[esp+40], eax
  0019f	3b d8		 cmp	 ebx, eax
  001a1	0f 8f be 00 00
	00		 jg	 $LN50@GetTargetL
  001a7	8b 45 1c	 mov	 eax, DWORD PTR _PathY$[ebp]
  001aa	8b 55 18	 mov	 edx, DWORD PTR _PathX$[ebp]
  001ad	83 c0 04	 add	 eax, 4
  001b0	2b 55 1c	 sub	 edx, DWORD PTR _PathY$[ebp]
  001b3	89 44 24 1c	 mov	 DWORD PTR tv547[esp+40], eax
  001b7	8b 44 24 14	 mov	 eax, DWORD PTR tv557[esp+40]
  001bb	2b c3		 sub	 eax, ebx
  001bd	83 c0 02	 add	 eax, 2
  001c0	89 44 24 24	 mov	 DWORD PTR _count$3$[esp+40], eax
  001c4	8b 44 24 0c	 mov	 eax, DWORD PTR _delta_y$1$[esp+40]
$LL10@GetTargetL:

; 129  : 			{
; 130  : 				error += delta_x;

  001c8	03 f1		 add	 esi, ecx

; 131  : 
; 132  : 				if(error > half)

  001ca	3b 74 24 20	 cmp	 esi, DWORD PTR _half$2$[esp+40]
  001ce	7e 06		 jle	 SHORT $LN26@GetTargetL

; 133  : 				{
; 134  : 					x += incx;

  001d0	03 7c 24 10	 add	 edi, DWORD PTR _incx$1$[esp+40]

; 135  : 					error -= delta_y;

  001d4	2b f0		 sub	 esi, eax
$LN26@GetTargetL:

; 136  : 				}
; 137  : 
; 138  : 				PathX[count] = x;

  001d6	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv547[esp+40]
  001da	89 3c 11	 mov	 DWORD PTR [ecx+edx], edi

; 139  : 				PathY[count] = y;

  001dd	89 19		 mov	 DWORD PTR [ecx], ebx

; 140  : 				count++;

  001df	83 c1 04	 add	 ecx, 4
  001e2	43		 inc	 ebx
  001e3	89 4c 24 1c	 mov	 DWORD PTR tv547[esp+40], ecx
  001e7	8b 4c 24 18	 mov	 ecx, DWORD PTR _delta_x$1$[esp+40]
  001eb	3b 5c 24 14	 cmp	 ebx, DWORD PTR tv557[esp+40]
  001ef	7e d7		 jle	 SHORT $LL10@GetTargetL

; 158  : 			}
; 159  : 		}
; 160  : 	}
; 161  : 	return count;

  001f1	8b 44 24 24	 mov	 eax, DWORD PTR _count$4$[esp+40]

; 162  : }

  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	8b e5		 mov	 esp, ebp
  001fa	5d		 pop	 ebp
  001fb	c2 1c 00	 ret	 28			; 0000001cH
$LN24@GetTargetL:

; 141  : 			}
; 142  : 		}
; 143  : 		else
; 144  : 		{
; 145  : 			for(y = (sy-1);y >= (ty - dis);y--)

  001fe	2b 45 20	 sub	 eax, DWORD PTR _distance$[ebp]
  00201	4b		 dec	 ebx
  00202	89 45 14	 mov	 DWORD PTR _ty$[ebp], eax
  00205	3b d8		 cmp	 ebx, eax
  00207	7c 5c		 jl	 SHORT $LN50@GetTargetL
  00209	8b 45 1c	 mov	 eax, DWORD PTR _PathY$[ebp]
  0020c	8b 55 18	 mov	 edx, DWORD PTR _PathX$[ebp]
  0020f	83 c0 04	 add	 eax, 4
  00212	2b 55 1c	 sub	 edx, DWORD PTR _PathY$[ebp]
  00215	89 44 24 1c	 mov	 DWORD PTR tv546[esp+40], eax
  00219	8b c3		 mov	 eax, ebx
  0021b	2b 45 14	 sub	 eax, DWORD PTR _ty$[ebp]
  0021e	83 c0 02	 add	 eax, 2
  00221	89 44 24 24	 mov	 DWORD PTR _count$4$[esp+40], eax
  00225	8b 44 24 0c	 mov	 eax, DWORD PTR _delta_y$1$[esp+40]
  00229	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@GetTargetL:

; 146  : 			{
; 147  : 				error += delta_x;

  00230	03 f1		 add	 esi, ecx

; 148  : 
; 149  : 				if(error > half)

  00232	3b 74 24 20	 cmp	 esi, DWORD PTR _half$2$[esp+40]
  00236	7e 06		 jle	 SHORT $LN27@GetTargetL

; 150  : 				{
; 151  : 					x += incx;

  00238	03 7c 24 10	 add	 edi, DWORD PTR _incx$1$[esp+40]

; 152  : 					error -= delta_y;

  0023c	2b f0		 sub	 esi, eax
$LN27@GetTargetL:

; 153  : 				}
; 154  : 
; 155  : 				PathX[count] = x;

  0023e	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv546[esp+40]
  00242	89 3c 11	 mov	 DWORD PTR [ecx+edx], edi

; 156  : 				PathY[count] = y;

  00245	89 19		 mov	 DWORD PTR [ecx], ebx

; 157  : 				count++;

  00247	83 c1 04	 add	 ecx, 4
  0024a	4b		 dec	 ebx
  0024b	89 4c 24 1c	 mov	 DWORD PTR tv546[esp+40], ecx
  0024f	8b 4c 24 18	 mov	 ecx, DWORD PTR _delta_x$1$[esp+40]
  00253	3b 5d 14	 cmp	 ebx, DWORD PTR _ty$[ebp]
  00256	7d d8		 jge	 SHORT $LL13@GetTargetL

; 158  : 			}
; 159  : 		}
; 160  : 	}
; 161  : 	return count;

  00258	8b 44 24 24	 mov	 eax, DWORD PTR _count$4$[esp+40]

; 162  : }

  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
  0025f	8b e5		 mov	 esp, ebp
  00261	5d		 pop	 ebp
  00262	c2 1c 00	 ret	 28			; 0000001cH
$LN50@GetTargetL:
  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	b8 01 00 00 00	 mov	 eax, 1
  0026c	5b		 pop	 ebx
  0026d	8b e5		 mov	 esp, ebp
  0026f	5d		 pop	 ebp
  00270	c2 1c 00	 ret	 28			; 0000001cH
?GetTargetLinePath@CObjUseSkill@@QAEHHHHHPAH0H@Z ENDP	; CObjUseSkill::GetTargetLinePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z
_TEXT	SEGMENT
_lpObj$1$ = -168					; size = 4
tv393 = -164						; size = 4
_vFrustrum$ = -160					; size = 48
_Matrix$ = -112						; size = 48
_p$ = -64						; size = 48
_Angle$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_fangle$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z PROC		; CObjUseSkill::SkillFrustrum, COMDAT
; _this$ = ecx

; 2399 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2400 : 	LPOBJ lpObj = &gObj[aIndex];
; 2401 : 
; 2402 : 	float p[MAX_ARRAY_FRUSTRUM][3];
; 2403 : 
; 2404 : 	p[0][0] = -tx;

  00013	f3 0f 10 55 10	 movss	 xmm2, DWORD PTR _tx$[ebp]
  00018	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0001b	0f 28 c2	 movaps	 xmm0, xmm2
  0001e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 2405 : 	p[0][1] = ty;

  00025	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _ty$[ebp]
  0002a	56		 push	 esi
  0002b	69 f0 40 27 00
	00		 imul	 esi, eax, 10048

; 2406 : 	p[0][2] = 0;
; 2407 : 	p[1][0] = tx;
; 2408 : 	p[1][1] = ty;
; 2409 : 	p[1][2] = 0;
; 2410 : 	p[2][0] = 1.0f;
; 2411 : 	p[2][1] = 0;
; 2412 : 	p[2][2] = 0;
; 2413 : 	p[3][0] = -1.0f;
; 2414 : 	p[3][1] = 0;
; 2415 : 	p[3][2] = 0;
; 2416 : 
; 2417 : 	float Angle[3];
; 2418 : 
; 2419 : 	Angle[0] = 0;
; 2420 : 	Angle[1] = 0;
; 2421 : 	Angle[2] = fangle;
; 2422 : 
; 2423 : 	float Matrix[3][MAX_ARRAY_FRUSTRUM];
; 2424 : 	float vFrustrum[MAX_ARRAY_FRUSTRUM][3];
; 2425 : 
; 2426 : 	AngleMatrix(Angle,Matrix);

  00031	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  00034	f3 0f 11 45 c0	 movss	 DWORD PTR _p$[ebp], xmm0
  00039	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000000000000003f80000000000000
  00040	57		 push	 edi
  00041	50		 push	 eax
  00042	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	8d 45 f0	 lea	 eax, DWORD PTR _Angle$[ebp]
  0004b	0f 11 45 d4	 movups	 XMMWORD PTR _p$[ebp+20], xmm0
  0004f	50		 push	 eax
  00050	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fangle$[ebp]
  00055	89 b5 58 ff ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], esi
  0005b	f3 0f 11 4d c4	 movss	 DWORD PTR _p$[ebp+4], xmm1
  00060	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+8], 0
  00067	f3 0f 11 55 cc	 movss	 DWORD PTR _p$[ebp+12], xmm2
  0006c	f3 0f 11 4d d0	 movss	 DWORD PTR _p$[ebp+16], xmm1
  00071	c7 45 e4 00 00
	80 bf		 mov	 DWORD PTR _p$[ebp+36], -1082130432 ; bf800000H
  00078	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+40], 0
  0007f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+44], 0
  00086	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Angle$[ebp], 0
  0008d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Angle$[ebp+4], 0
  00094	f3 0f 11 45 f8	 movss	 DWORD PTR _Angle$[ebp+8], xmm0
  00099	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  0009e	8d 86 98 14 00
	00		 lea	 eax, DWORD PTR [esi+5272]
  000a4	83 c4 08	 add	 esp, 8
  000a7	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv393[ebp], eax

; 2427 : 
; 2428 : 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; i++)

  000ad	33 ff		 xor	 edi, edi
  000af	90		 npad	 1
$LL4@SkillFrust:

; 2429 : 	{
; 2430 : 		VectorRotate((const float *)&p[i],(const float *)&Matrix[0],(float *)&vFrustrum[i]);

  000b0	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _vFrustrum$[ebp]
  000b6	03 f7		 add	 esi, edi
  000b8	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000bb	56		 push	 esi
  000bc	50		 push	 eax
  000bd	8d 45 c0	 lea	 eax, DWORD PTR _p$[ebp]
  000c0	03 c7		 add	 eax, edi
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 2431 : 
; 2432 : 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  000c8	f3 0f 2c 0e	 cvttss2si ecx, DWORD PTR [esi]
  000cc	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d5	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv393[ebp]
  000db	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  000e2	03 c8		 add	 ecx, eax
  000e4	89 4a f0	 mov	 DWORD PTR [edx-16], ecx

; 2433 : 		lpObj->fSkillFrustrumY[i] = (int)vFrustrum[i][1] + lpObj->Y;

  000e7	f3 0f 2c 8c 3d
	64 ff ff ff	 cvttss2si ecx, DWORD PTR _vFrustrum$[ebp+edi+4]
  000f0	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000f7	83 c7 0c	 add	 edi, 12			; 0000000cH
  000fa	03 c8		 add	 ecx, eax
  000fc	89 0a		 mov	 DWORD PTR [edx], ecx
  000fe	83 c2 04	 add	 edx, 4
  00101	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv393[ebp], edx
  00107	83 ff 30	 cmp	 edi, 48			; 00000030H
  0010a	7c a4		 jl	 SHORT $LL4@SkillFrust

; 2434 : 	}
; 2435 : }

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010f	5f		 pop	 edi
  00110	33 cd		 xor	 ecx, ebp
  00112	5e		 pop	 esi
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 10 00	 ret	 16			; 00000010H
?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z ENDP		; CObjUseSkill::SkillFrustrum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
tv457 = -12						; size = 4
_HitCount$1$ = -8					; size = 4
_lpObj$1$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_DuelIndex$1$ = 28					; size = 4
_targetangle$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillPowerSlash, COMDAT
; _this$ = ecx

; 1901 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1902 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	69 f8 40 27 00
	00		 imul	 edi, eax, 10048

; 1903 : 	int StartDis = 1;
; 1904 : 	int tObjNum;
; 1905 : 	::SkillFrustrum(targetangle,aIndex);

  00012	50		 push	 eax
  00013	ff 75 1c	 push	 DWORD PTR _targetangle$[ebp]
  00016	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001c	89 7d fc	 mov	 DWORD PTR _lpObj$1$[ebp], edi
  0001f	e8 00 00 00 00	 call	 ?SkillFrustrum@@YAXEH@Z	; SkillFrustrum

; 1906 : 	int count = 0;
; 1907 : 	int HitCount = 0;
; 1908 : 	int bAttack;
; 1909 : 	int DuelIndex = lpObj->m_iDuelUser;

  00024	8b 8f 50 12 00
	00		 mov	 ecx, DWORD PTR [edi+4688]
  0002a	8d 9f 4c 0c 00
	00		 lea	 ebx, DWORD PTR [edi+3148]
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	83 c4 08	 add	 esp, 8
  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _HitCount$1$[ebp], 0
  0003f	89 4d 1c	 mov	 DWORD PTR _DuelIndex$1$[ebp], ecx
  00042	c7 45 f4 4b 00
	00 00		 mov	 DWORD PTR tv457[ebp], 75 ; 0000004bH
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@SkillPower:

; 1910 : 	int EnableAttack;
; 1911 : 
; 1912 : 	while ( true )
; 1913 : 	{
; 1914 : 		if(lpObj->VpPlayer2[count].state != 0)

  00050	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00054	0f 84 33 01 00
	00		 je	 $LN17@SkillPower

; 1915 : 		{
; 1916 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0005a	0f bf 73 fe	 movsx	 esi, WORD PTR [ebx-2]

; 1917 : 
; 1918 : 			if(tObjNum >= 0)

  0005e	85 f6		 test	 esi, esi
  00060	0f 88 27 01 00
	00		 js	 $LN17@SkillPower

; 1919 : 			{
; 1920 : 				EnableAttack = 0;
; 1921 : 
; 1922 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00066	8a 13		 mov	 dl, BYTE PTR [ebx]
  00068	80 fa 02	 cmp	 dl, 2
  0006b	75 17		 jne	 SHORT $LN6@SkillPower
  0006d	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00073	83 bc 01 30 06
	00 00 00	 cmp	 DWORD PTR [ecx+eax+1584], 0
  0007b	0f 8c a0 00 00
	00		 jl	 $LN10@SkillPower
  00081	8b 4d 1c	 mov	 ecx, DWORD PTR _DuelIndex$1$[ebp]
$LN6@SkillPower:

; 1923 : 				{
; 1924 : 					EnableAttack = 1;
; 1925 : 				}
; 1926 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00084	3b 75 20	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00087	0f 84 94 00 00
	00		 je	 $LN10@SkillPower
  0008d	3b ce		 cmp	 ecx, esi
  0008f	0f 84 8c 00 00
	00		 je	 $LN10@SkillPower

; 1927 : 				{
; 1928 : 					EnableAttack = 1;
; 1929 : 				}
; 1930 : #if (GS_CASTLE == 1)
; 1931 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  00095	80 fa 03	 cmp	 dl, 3
  00098	74 47		 je	 SHORT $LN11@SkillPower
  0009a	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000a0	80 bc 07 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+eax+291], 30 ; 0000001eH
  000a8	75 34		 jne	 SHORT $LN35@SkillPower
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000af	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  000b4	83 f8 07	 cmp	 eax, 7
  000b7	75 20		 jne	 SHORT $LN33@SkillPower

; 1932 : 				{
; 1933 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000bc	8a 88 5a 20 00
	00		 mov	 cl, BYTE PTR [eax+8282]
  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c7	3a 8c 07 5a 20
	00 00		 cmp	 cl, BYTE PTR [edi+eax+8282]
  000ce	0f 84 b6 00 00
	00		 je	 $LN36@SkillPower

; 1934 : 						EnableAttack = 1;
; 1935 : 				}
; 1936 : #endif
; 1937 : 				else

  000d4	8b 7d fc	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  000d7	eb 48		 jmp	 SHORT $LN10@SkillPower
$LN33@SkillPower:
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN35@SkillPower:
  000de	8b 7d fc	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN11@SkillPower:

; 1938 : 				{
; 1939 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000e1	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048

; 1940 : 
; 1941 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000e7	80 7c 01 50 02	 cmp	 BYTE PTR [ecx+eax+80], 2
  000ec	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000ef	75 14		 jne	 SHORT $LN14@SkillPower
  000f1	8b 8c 01 30 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1584]
  000f8	85 c9		 test	 ecx, ecx
  000fa	78 09		 js	 SHORT $LN14@SkillPower

; 1942 : 					{
; 1943 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000fc	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  00102	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
$LN14@SkillPower:

; 1944 : 					}
; 1945 : 
; 1946 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00105	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  0010b	03 c8		 add	 ecx, eax
  0010d	51		 push	 ecx
  0010e	57		 push	 edi
  0010f	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00114	83 c4 08	 add	 esp, 8
  00117	83 f8 01	 cmp	 eax, 1
  0011a	75 69		 jne	 SHORT $LN34@SkillPower
  0011c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillPower:

; 1947 : 					{
; 1948 : 						EnableAttack = 1;
; 1949 : 					}
; 1950 : 				}
; 1951 : 
; 1952 : 				if(EnableAttack != 0)
; 1953 : 				{
; 1954 : 					if(SkillTestFrustrum(gObj[tObjNum].X,gObj[tObjNum].Y,aIndex))

  00121	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00124	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  0012a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0012d	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  00134	50		 push	 eax
  00135	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?SkillTestFrustrum@@YAHHHH@Z ; SkillTestFrustrum
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
  00145	85 c0		 test	 eax, eax
  00147	74 3c		 je	 SHORT $LN34@SkillPower

; 1955 : 					{
; 1956 : 						bAttack = 0;
; 1957 : 
; 1958 : 						if(HitCount > 10)
; 1959 : 						{
; 1960 : 							bAttack = 0;
; 1961 : 						}
; 1962 : 						
; 1963 : 						if(HitCount >= 5)

  00149	83 7d f8 05	 cmp	 DWORD PTR _HitCount$1$[ebp], 5
  0014d	7c 13		 jl	 SHORT $LN19@SkillPower

; 1964 : 						{
; 1965 : 							if(rand()%2)

  0014f	e8 00 00 00 00	 call	 _rand
  00154	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00159	79 05		 jns	 SHORT $LN37@SkillPower
  0015b	48		 dec	 eax
  0015c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0015f	40		 inc	 eax
$LN37@SkillPower:
  00160	74 20		 je	 SHORT $LN22@SkillPower
$LN19@SkillPower:

; 1966 : 							{
; 1967 : 								bAttack = 1;
; 1968 : 							}
; 1969 : 						}
; 1970 : 						else
; 1971 : 						{
; 1972 : 							bAttack = 1;
; 1973 : 						}
; 1974 : 
; 1975 : 						if(bAttack != 0)
; 1976 : 						{
; 1977 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,1,1,0,0,0,0);

  00162	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00167	6a 00		 push	 0
  00169	6a 00		 push	 0
  0016b	6a 00		 push	 0
  0016d	6a 00		 push	 0
  0016f	6a 01		 push	 1
  00171	6a 01		 push	 1
  00173	ff 75 0c	 push	 DWORD PTR _lpMagic$[ebp]
  00176	03 c6		 add	 eax, esi
  00178	50		 push	 eax
  00179	57		 push	 edi
  0017a	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0017f	83 c4 24	 add	 esp, 36			; 00000024H
$LN22@SkillPower:

; 1978 : 						}
; 1979 : 
; 1980 : 						HitCount++;

  00182	ff 45 f8	 inc	 DWORD PTR _HitCount$1$[ebp]
$LN34@SkillPower:
  00185	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN36@SkillPower:
  0018a	8b 4d 1c	 mov	 ecx, DWORD PTR _DuelIndex$1$[ebp]
$LN17@SkillPower:

; 1981 : 					}
; 1982 : 				}
; 1983 : 			}
; 1984 : 		}
; 1985 : 
; 1986 : 		count++;
; 1987 : 		if(count > MAX_VIEWPORT -1)

  0018d	8b 7d fc	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  00190	83 c3 0c	 add	 ebx, 12			; 0000000cH
  00193	83 6d f4 01	 sub	 DWORD PTR tv457[ebp], 1
  00197	0f 85 b3 fe ff
	ff		 jne	 $LL2@SkillPower
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx

; 1988 : 		{
; 1989 : 			break;
; 1990 : 		}
; 1991 : 	}
; 1992 : }

  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 1c 00	 ret	 28			; 0000001cH
?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillPowerSlash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z
_TEXT	SEGMENT
tv365 = -12						; size = 4
_DuelIndex$1$ = -8					; size = 4
_loopcount$1$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_isCombo$ = 20						; size = 4
?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z PROC ; CObjUseSkill::SkillKnightBlow, COMDAT
; _this$ = ecx

; 2296 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2297 : 	LPOBJ lpObj = &gObj[aIndex];
; 2298 : 	int StartDis = 1;
; 2299 : 	int tObjNum;
; 2300 : 
; 2301 : 	float fangle = (float)GetAngle(lpObj->X,lpObj->Y,gObj[aTargetIndex].X,gObj[aTargetIndex].Y);

  00006	69 55 0c 40 27
	00 00		 imul	 edx, DWORD PTR _aTargetIndex$[ebp], 10048
  0000d	53		 push	 ebx
  0000e	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  00015	56		 push	 esi
  00016	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001c	57		 push	 edi

; 2302 : 
; 2303 : 	SkillFrustrum(aIndex,fangle,1.5f,3.0f);

  0001d	83 ec 08	 sub	 esp, 8
  00020	03 de		 add	 ebx, esi
  00022	8b f9		 mov	 edi, ecx
  00024	0f b6 84 32 21
	01 00 00	 movzx	 eax, BYTE PTR [edx+esi+289]
  0002c	c7 44 24 04 00
	00 40 40	 mov	 DWORD PTR [esp+4], 1077936128 ; 40400000H
  00034	c7 04 24 00 00
	c0 3f		 mov	 DWORD PTR [esp], 1069547520 ; 3fc00000H
  0003b	50		 push	 eax
  0003c	0f b6 84 32 20
	01 00 00	 movzx	 eax, BYTE PTR [edx+esi+288]
  00044	50		 push	 eax
  00045	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  0004c	50		 push	 eax
  0004d	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  0005a	51		 push	 ecx
  0005b	8b cf		 mov	 ecx, edi
  0005d	66 0f 6e c0	 movd	 xmm0, eax
  00061	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00064	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00069	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0006c	e8 00 00 00 00	 call	 ?SkillFrustrum@CObjUseSkill@@QAEXHMMM@Z ; CObjUseSkill::SkillFrustrum

; 2304 : 
; 2305 : 	int count = 0;
; 2306 : 	int loopcount = 0;
; 2307 : 	int attackcheck;
; 2308 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,aTargetIndex,1);

  00071	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00074	33 f6		 xor	 esi, esi
  00076	6a 01		 push	 1
  00078	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0007b	33 ff		 xor	 edi, edi
  0007d	89 75 fc	 mov	 DWORD PTR _loopcount$1$[ebp], esi
  00080	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00084	50		 push	 eax
  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 2309 : 
; 2310 : 	int DuelIndex = lpObj->m_iDuelUser;

  0008b	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00091	83 c4 10	 add	 esp, 16			; 00000010H
  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	89 45 f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  0009d	0f 1f 00	 npad	 3
$LL2@SkillKnigh:

; 2311 : 	int EnableAttack;
; 2312 : 
; 2313 : 	while ( true )
; 2314 : 	{
; 2315 : 		if(lpObj->VpPlayer2[count].state != 0)

  000a0	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  000a3	80 bc 83 48 0c
	00 00 00	 cmp	 BYTE PTR [ebx+eax*4+3144], 0
  000ab	0f 84 58 01 00
	00		 je	 $LN22@SkillKnigh

; 2316 : 		{
; 2317 : 			tObjNum = lpObj->VpPlayer2[count].number;

  000b1	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  000b4	0f bf b4 83 4a
	0c 00 00	 movsx	 esi, WORD PTR [ebx+eax*4+3146]

; 2318 : 
; 2319 : 			if(tObjNum >= 0)

  000bc	85 f6		 test	 esi, esi
  000be	0f 88 42 01 00
	00		 js	 $LN36@SkillKnigh

; 2320 : 			{
; 2321 : 				EnableAttack = 0;
; 2322 : 
; 2323 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  000c4	8a 94 83 4c 0c
	00 00		 mov	 dl, BYTE PTR [ebx+eax*4+3148]
  000cb	80 fa 02	 cmp	 dl, 2
  000ce	75 14		 jne	 SHORT $LN6@SkillKnigh
  000d0	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  000d6	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  000de	0f 8c 9c 00 00
	00		 jl	 $LN10@SkillKnigh
$LN6@SkillKnigh:

; 2324 : 				{
; 2325 : 					EnableAttack = 1;
; 2326 : 				}
; 2327 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  000e4	3b 75 0c	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  000e7	0f 84 93 00 00
	00		 je	 $LN10@SkillKnigh
  000ed	39 75 f8	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  000f0	0f 84 8a 00 00
	00		 je	 $LN10@SkillKnigh

; 2328 : 				{
; 2329 : 					EnableAttack = 1;
; 2330 : 				}
; 2331 : #if (GS_CASTLE == 1)
; 2332 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000f6	80 fa 03	 cmp	 dl, 3
  000f9	74 40		 je	 SHORT $LN11@SkillKnigh
  000fb	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00101	89 45 f4	 mov	 DWORD PTR tv365[ebp], eax
  00104	80 bc 08 23 01
	00 00 1e	 cmp	 BYTE PTR [eax+ecx+291], 30 ; 0000001eH
  0010c	75 2d		 jne	 SHORT $LN11@SkillKnigh
  0010e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00113	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 2333 : 				{
; 2334 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011e	83 f8 07	 cmp	 eax, 7
  00121	75 18		 jne	 SHORT $LN11@SkillKnigh
  00123	8b 55 f4	 mov	 edx, DWORD PTR tv365[ebp]
  00126	8a 83 5a 20 00
	00		 mov	 al, BYTE PTR [ebx+8282]
  0012c	3a 84 0a 5a 20
	00 00		 cmp	 al, BYTE PTR [edx+ecx+8282]
  00133	0f 84 cd 00 00
	00		 je	 $LN36@SkillKnigh

; 2335 : 						EnableAttack = 1;
; 2336 : 				}
; 2337 : #endif
; 2338 : 				else

  00139	eb 45		 jmp	 SHORT $LN10@SkillKnigh
$LN11@SkillKnigh:

; 2339 : 				{
; 2340 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  0013b	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 2341 : 
; 2342 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  00141	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  00146	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00149	75 14		 jne	 SHORT $LN14@SkillKnigh
  0014b	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  00152	85 c0		 test	 eax, eax
  00154	78 09		 js	 SHORT $LN14@SkillKnigh

; 2343 : 					{
; 2344 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  00156	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0015c	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN14@SkillKnigh:

; 2345 : 					}
; 2346 : 
; 2347 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  0015f	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00165	03 c1		 add	 eax, ecx
  00167	50		 push	 eax
  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0016e	83 c4 08	 add	 esp, 8
  00171	83 f8 01	 cmp	 eax, 1
  00174	0f 85 86 00 00
	00		 jne	 $LN34@SkillKnigh
  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillKnigh:

; 2348 : 					{
; 2349 : 						EnableAttack = 1;
; 2350 : 					}
; 2351 : 				}
; 2352 : 
; 2353 : 				if(EnableAttack != 0)
; 2354 : 				{
; 2355 : 					attackcheck = 0;
; 2356 : 
; 2357 : 					if(loopcount == 0)

  00180	83 7d fc 00	 cmp	 DWORD PTR _loopcount$1$[ebp], 0
  00184	74 17		 je	 SHORT $LN32@SkillKnigh

; 2358 : 					{
; 2359 : 						attackcheck = 1;
; 2360 : 					}
; 2361 : 					else if(rand()%3==0)

  00186	e8 00 00 00 00	 call	 _rand
  0018b	99		 cdq
  0018c	b9 03 00 00 00	 mov	 ecx, 3
  00191	f7 f9		 idiv	 ecx
  00193	85 d2		 test	 edx, edx
  00195	75 69		 jne	 SHORT $LN34@SkillKnigh
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN32@SkillKnigh:

; 2362 : 					{
; 2363 : 						attackcheck = 1;
; 2364 : 					}
; 2365 : 
; 2366 : 					if(attackcheck != 0)
; 2367 : 					{
; 2368 : 						if(::SkillTestFrustrum(gObj[tObjNum].X,gObj[tObjNum].Y,aIndex))

  0019d	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  001a0	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  001a6	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  001ae	50		 push	 eax
  001af	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ?SkillTestFrustrum@@YAHHHH@Z ; SkillTestFrustrum
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c0	85 c0		 test	 eax, eax
  001c2	74 3c		 je	 SHORT $LN34@SkillKnigh

; 2369 : 						{
; 2370 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,0,1,0,isCombo,0,0);

  001c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c9	6a 00		 push	 0
  001cb	6a 00		 push	 0
  001cd	ff 75 14	 push	 DWORD PTR _isCombo$[ebp]
  001d0	03 c6		 add	 eax, esi
  001d2	6a 00		 push	 0
  001d4	6a 01		 push	 1
  001d6	6a 00		 push	 0
  001d8	ff 75 10	 push	 DWORD PTR _lpMagic$[ebp]
  001db	50		 push	 eax
  001dc	53		 push	 ebx
  001dd	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  001e2	83 c4 24	 add	 esp, 36			; 00000024H

; 2371 : 							if(isCombo != 0)

  001e5	83 7d 14 00	 cmp	 DWORD PTR _isCombo$[ebp], 0
  001e9	74 15		 je	 SHORT $LN34@SkillKnigh

; 2372 : 							{
; 2373 : 								GCMagicAttackNumberSend(lpObj,AT_SKILL_COMBO,gObj[tObjNum].m_Index,1);

  001eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f0	6a 01		 push	 1
  001f2	ff 34 06	 push	 DWORD PTR [esi+eax]
  001f5	6a 3b		 push	 59			; 0000003bH
  001f7	53		 push	 ebx
  001f8	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  001fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN34@SkillKnigh:
  00200	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN36@SkillKnigh:
  00206	8b 75 fc	 mov	 esi, DWORD PTR _loopcount$1$[ebp]
$LN22@SkillKnigh:

; 2374 : 							}
; 2375 : 						}
; 2376 : 					}
; 2377 : 				}
; 2378 : 			}
; 2379 : 		}
; 2380 : 
; 2381 : 		count++;

  00209	47		 inc	 edi

; 2382 : 		if(count > MAX_VIEWPORT -1)

  0020a	83 ff 4a	 cmp	 edi, 74			; 0000004aH
  0020d	0f 8e 8d fe ff
	ff		 jle	 $LL2@SkillKnigh

; 2383 : 		{
; 2384 : 			loopcount++;

  00213	46		 inc	 esi

; 2385 : 			count = 0;

  00214	33 ff		 xor	 edi, edi
  00216	89 75 fc	 mov	 DWORD PTR _loopcount$1$[ebp], esi

; 2386 : 			if(loopcount >= 3)

  00219	83 fe 03	 cmp	 esi, 3
  0021c	0f 8c 7e fe ff
	ff		 jl	 $LL2@SkillKnigh

; 2387 : 			{
; 2388 : 				break;
; 2389 : 			}
; 2390 : 		}
; 2391 : 	}
; 2392 : 	return true;

  00222	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00225	5f		 pop	 edi
  00226	5e		 pop	 esi
  00227	5b		 pop	 ebx

; 2393 : }

  00228	8b e5		 mov	 esp, ebp
  0022a	5d		 pop	 ebp
  0022b	c2 10 00	 ret	 16			; 00000010H
?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ENDP ; CObjUseSkill::SkillKnightBlow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -8					; size = 4
tv448 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_aTargetIndex$ = 16					; size = 4
_isCombo$ = 20						; size = 4
?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z PROC	; CObjUseSkill::SkillWheel, COMDAT
; _this$ = ecx

; 1802 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1803 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00016	03 f9		 add	 edi, ecx
  00018	89 7d 08	 mov	 DWORD PTR _lpObj$1$[ebp], edi

; 1804 : 	int tObjNum;
; 1805 : 	int count = 0;
; 1806 : 	int HitCount = 0;
; 1807 : 	int bAttack;
; 1808 : 	int DuelIndex = lpObj->m_iDuelUser;

  0001b	8b 87 50 12 00
	00		 mov	 eax, DWORD PTR [edi+4688]
  00021	8d 9f 4c 0c 00
	00		 lea	 ebx, DWORD PTR [edi+3148]
  00027	89 45 f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  0002a	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0002f	89 45 fc	 mov	 DWORD PTR tv448[ebp], eax
$LL2@SkillWheel:

; 1809 : 	int EnableAttack;
; 1810 : 
; 1811 : 	while ( true )
; 1812 : 	{
; 1813 : 		if(lpObj->VpPlayer2[count].state != 0)

  00032	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00036	0f 84 1f 01 00
	00		 je	 $LN23@SkillWheel

; 1814 : 		{
; 1815 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003c	0f bf 73 fe	 movsx	 esi, WORD PTR [ebx-2]

; 1816 : 
; 1817 : 			if(tObjNum >= 0)

  00040	85 f6		 test	 esi, esi
  00042	0f 88 13 01 00
	00		 js	 $LN23@SkillWheel

; 1818 : 			{
; 1819 : 				EnableAttack = 0;
; 1820 : 
; 1821 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00048	8a 13		 mov	 dl, BYTE PTR [ebx]
  0004a	80 fa 02	 cmp	 dl, 2
  0004d	75 14		 jne	 SHORT $LN6@SkillWheel
  0004f	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00055	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0005d	0f 8c 9b 00 00
	00		 jl	 $LN10@SkillWheel
$LN6@SkillWheel:

; 1822 : 				{
; 1823 : 					EnableAttack = 1;
; 1824 : 				}
; 1825 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00063	3b 75 10	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00066	0f 84 92 00 00
	00		 je	 $LN10@SkillWheel
  0006c	39 75 f8	 cmp	 DWORD PTR _DuelIndex$1$[ebp], esi
  0006f	0f 84 89 00 00
	00		 je	 $LN10@SkillWheel

; 1826 : 				{
; 1827 : 					EnableAttack = 1;
; 1828 : 				}
; 1829 : #if (GS_CASTLE == 1)
; 1830 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  00075	80 fa 03	 cmp	 dl, 3
  00078	74 43		 je	 SHORT $LN11@SkillWheel
  0007a	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00080	80 bc 0f 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+ecx+291], 30 ; 0000001eH
  00088	75 30		 jne	 SHORT $LN37@SkillWheel
  0008a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0008f	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 1831 : 				{
; 1832 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	83 f8 07	 cmp	 eax, 7
  0009d	75 1b		 jne	 SHORT $LN37@SkillWheel
  0009f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  000a2	8a 80 5a 20 00
	00		 mov	 al, BYTE PTR [eax+8282]
  000a8	3a 84 0f 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+ecx+8282]

; 1833 : 						EnableAttack = 1;
; 1834 : 				}
; 1835 : #endif
; 1836 : 				else

  000af	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  000b2	0f 84 a0 00 00
	00		 je	 $LN36@SkillWheel
  000b8	eb 44		 jmp	 SHORT $LN10@SkillWheel
$LN37@SkillWheel:
  000ba	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
$LN11@SkillWheel:

; 1837 : 				{
; 1838 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000bd	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 1839 : 
; 1840 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000c3	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  000c8	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  000cb	75 14		 jne	 SHORT $LN14@SkillWheel
  000cd	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  000d4	85 c0		 test	 eax, eax
  000d6	78 09		 js	 SHORT $LN14@SkillWheel

; 1841 : 					{
; 1842 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000d8	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000de	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN14@SkillWheel:

; 1843 : 					}
; 1844 : 
; 1845 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000e1	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  000e7	03 c1		 add	 eax, ecx
  000e9	50		 push	 eax
  000ea	57		 push	 edi
  000eb	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000f0	83 c4 08	 add	 esp, 8
  000f3	83 f8 01	 cmp	 eax, 1
  000f6	75 5a		 jne	 SHORT $LN35@SkillWheel
  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillWheel:

; 1846 : 					{
; 1847 : 						EnableAttack = 1;
; 1848 : 					}
; 1849 : 				}
; 1850 : 
; 1851 : 				if(EnableAttack != 0)
; 1852 : 				{
; 1853 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 3)

  000fe	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  00104	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00107	50		 push	 eax
  00108	57		 push	 edi
  00109	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0010e	83 c4 08	 add	 esp, 8
  00111	83 f8 03	 cmp	 eax, 3
  00114	7d 3c		 jge	 SHORT $LN35@SkillWheel

; 1854 : 					{
; 1855 : 						bAttack = 0;
; 1856 : 
; 1857 : 						if(HitCount > 15)
; 1858 : 						{
; 1859 : 							bAttack = 0;
; 1860 : 						}
; 1861 : 
; 1862 : 						if(HitCount >= 10)
; 1863 : 						{
; 1864 : 							if(rand()%2)
; 1865 : 							{
; 1866 : 								bAttack = 1;
; 1867 : 							}
; 1868 : 						}
; 1869 : 						else
; 1870 : 						{
; 1871 : 							bAttack = 1;
; 1872 : 						}
; 1873 : 
; 1874 : 						if(bAttack != 0)
; 1875 : 						{
; 1876 : 
; 1877 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,0,1,0,isCombo,0,0);

  00116	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011b	6a 00		 push	 0
  0011d	6a 00		 push	 0
  0011f	ff 75 14	 push	 DWORD PTR _isCombo$[ebp]
  00122	03 c6		 add	 eax, esi
  00124	6a 00		 push	 0
  00126	6a 01		 push	 1
  00128	6a 00		 push	 0
  0012a	ff 75 0c	 push	 DWORD PTR _lpMagic$[ebp]
  0012d	50		 push	 eax
  0012e	57		 push	 edi
  0012f	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00134	83 c4 24	 add	 esp, 36			; 00000024H

; 1878 : 
; 1879 : 							if(isCombo != 0)

  00137	83 7d 14 00	 cmp	 DWORD PTR _isCombo$[ebp], 0
  0013b	74 15		 je	 SHORT $LN35@SkillWheel

; 1880 : 							{
; 1881 : 								GCMagicAttackNumberSend(lpObj,AT_SKILL_COMBO,gObj[tObjNum].m_Index,1);

  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00142	6a 01		 push	 1
  00144	ff 34 06	 push	 DWORD PTR [esi+eax]
  00147	6a 3b		 push	 59			; 0000003bH
  00149	57		 push	 edi
  0014a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0014f	83 c4 10	 add	 esp, 16			; 00000010H
$LN35@SkillWheel:
  00152	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN36@SkillWheel:
  00158	8b 45 fc	 mov	 eax, DWORD PTR tv448[ebp]
$LN23@SkillWheel:

; 1882 : 							}
; 1883 : 						}
; 1884 : 					}
; 1885 : 				}
; 1886 : 			}
; 1887 : 		}
; 1888 : 
; 1889 : 		count++;

  0015b	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1890 : 		if(count > MAX_VIEWPORT -1)

  0015e	83 e8 01	 sub	 eax, 1
  00161	89 45 fc	 mov	 DWORD PTR tv448[ebp], eax
  00164	0f 85 c8 fe ff
	ff		 jne	 $LL2@SkillWheel
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx

; 1891 : 		{
; 1892 : 			break;
; 1893 : 		}
; 1894 : 	}
; 1895 : }

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 10 00	 ret	 16			; 00000010H
?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z ENDP	; CObjUseSkill::SkillWheel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -12					; size = 4
tv451 = -8						; size = 4
tv450 = -4						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
_isCombo$ = 36						; size = 4
?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z PROC ; CObjUseSkill::SkillBlowOfFury, COMDAT
; _this$ = ecx

; 1704 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1705 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  00011	53		 push	 ebx
  00012	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  00019	03 d9		 add	 ebx, ecx
  0001b	89 55 f8	 mov	 DWORD PTR tv451[ebp], edx
  0001e	56		 push	 esi
  0001f	57		 push	 edi

; 1706 : 	int tObjNum;
; 1707 : 	int count = 0;
; 1708 : 	int DuelIndex = lpObj->m_iDuelUser;

  00020	8b bb 50 12 00
	00		 mov	 edi, DWORD PTR [ebx+4688]
  00026	8d 83 4c 0c 00
	00		 lea	 eax, DWORD PTR [ebx+3148]
  0002c	89 7d f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], edi
  0002f	89 45 fc	 mov	 DWORD PTR tv450[ebp], eax
$LL2@SkillBlowO:

; 1709 : 	int HitCount = 0;
; 1710 : 	int bAttack = 0;
; 1711 : 	int EnableAttack;
; 1712 : 
; 1713 : 	while ( true )
; 1714 : 	{
; 1715 : 		if(lpObj->VpPlayer2[count].state != 0)

  00032	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  00036	0f 84 0d 01 00
	00		 je	 $LN23@SkillBlowO

; 1716 : 		{
; 1717 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003c	0f bf 70 fe	 movsx	 esi, WORD PTR [eax-2]

; 1718 : 
; 1719 : 			if(tObjNum >= 0)

  00040	85 f6		 test	 esi, esi
  00042	0f 88 01 01 00
	00		 js	 $LN23@SkillBlowO

; 1720 : 			{
; 1721 : 				EnableAttack = 0;
; 1722 : 
; 1723 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00048	8a 10		 mov	 dl, BYTE PTR [eax]
  0004a	80 fa 02	 cmp	 dl, 2
  0004d	75 14		 jne	 SHORT $LN6@SkillBlowO
  0004f	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00055	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0005d	0f 8c 91 00 00
	00		 jl	 $LN10@SkillBlowO
$LN6@SkillBlowO:

; 1724 : 				{
; 1725 : 					EnableAttack = 1;
; 1726 : 				}
; 1727 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00063	3b 75 20	 cmp	 esi, DWORD PTR _aTargetIndex$[ebp]
  00066	0f 84 88 00 00
	00		 je	 $LN10@SkillBlowO
  0006c	3b fe		 cmp	 edi, esi
  0006e	0f 84 80 00 00
	00		 je	 $LN10@SkillBlowO

; 1728 : 				{
; 1729 : 					EnableAttack = 1;
; 1730 : 				}
; 1731 : #if (GS_CASTLE == 1)
; 1732 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  00074	80 fa 03	 cmp	 dl, 3
  00077	74 3a		 je	 SHORT $LN11@SkillBlowO
  00079	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0007f	80 bc 0f 23 01
	00 00 1e	 cmp	 BYTE PTR [edi+ecx+291], 30 ; 0000001eH
  00087	75 2a		 jne	 SHORT $LN11@SkillBlowO
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0008e	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 1733 : 				{
; 1734 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00099	83 f8 07	 cmp	 eax, 7
  0009c	75 15		 jne	 SHORT $LN11@SkillBlowO
  0009e	8a 83 5a 20 00
	00		 mov	 al, BYTE PTR [ebx+8282]
  000a4	3a 84 0f 5a 20
	00 00		 cmp	 al, BYTE PTR [edi+ecx+8282]
  000ab	0f 84 8f 00 00
	00		 je	 $LN36@SkillBlowO

; 1735 : 						EnableAttack = 1;
; 1736 : 				}
; 1737 : #endif
; 1738 : 				else

  000b1	eb 41		 jmp	 SHORT $LN10@SkillBlowO
$LN11@SkillBlowO:

; 1739 : 				{
; 1740 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000b3	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 1741 : 
; 1742 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000b9	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  000be	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  000c1	75 14		 jne	 SHORT $LN14@SkillBlowO
  000c3	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  000ca	85 c0		 test	 eax, eax
  000cc	78 09		 js	 SHORT $LN14@SkillBlowO

; 1743 : 					{
; 1744 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000ce	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000d4	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN14@SkillBlowO:

; 1745 : 					}
; 1746 : 
; 1747 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000d7	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  000dd	03 c1		 add	 eax, ecx
  000df	50		 push	 eax
  000e0	53		 push	 ebx
  000e1	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000e6	83 c4 08	 add	 esp, 8
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	75 4c		 jne	 SHORT $LN35@SkillBlowO
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SkillBlowO:

; 1748 : 					{
; 1749 : 						EnableAttack = 1;
; 1750 : 					}
; 1751 : 				}
; 1752 : 
; 1753 : 				if(EnableAttack != 0)
; 1754 : 				{
; 1755 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) < 4)

  000f4	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  000fa	03 c1		 add	 eax, ecx
  000fc	50		 push	 eax
  000fd	53		 push	 ebx
  000fe	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00103	83 c4 08	 add	 esp, 8
  00106	83 f8 04	 cmp	 eax, 4
  00109	7d 2f		 jge	 SHORT $LN35@SkillBlowO

; 1756 : 					{
; 1757 : 						bAttack = 0;
; 1758 : 
; 1759 : 						if(HitCount > 15)
; 1760 : 						{
; 1761 : 							bAttack = 0;
; 1762 : 						}
; 1763 : 
; 1764 : 						if(HitCount >= 10)
; 1765 : 						{
; 1766 : 							if(rand()%2)
; 1767 : 							{
; 1768 : 								bAttack = 1;
; 1769 : 							}
; 1770 : 						}
; 1771 : 						else
; 1772 : 						{
; 1773 : 							bAttack = 1;
; 1774 : 						}
; 1775 : 
; 1776 : 						if(bAttack != 0)
; 1777 : 						{
; 1778 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,500,lpMagic->m_Skill,isCombo);

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0010e	8b 7d 24	 mov	 edi, DWORD PTR _isCombo$[ebp]
  00111	57		 push	 edi
  00112	ff 70 08	 push	 DWORD PTR [eax+8]
  00115	68 f4 01 00 00	 push	 500			; 000001f4H
  0011a	56		 push	 esi
  0011b	6a 32		 push	 50			; 00000032H
  0011d	53		 push	 ebx
  0011e	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00123	83 c4 18	 add	 esp, 24			; 00000018H

; 1779 : 
; 1780 : 							if(isCombo != 0)

  00126	85 ff		 test	 edi, edi
  00128	74 10		 je	 SHORT $LN35@SkillBlowO

; 1781 : 							{
; 1782 : 								GCMagicAttackNumberSend(lpObj,AT_SKILL_COMBO,aIndex,1);

  0012a	6a 01		 push	 1
  0012c	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0012f	6a 3b		 push	 59			; 0000003bH
  00131	53		 push	 ebx
  00132	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00137	83 c4 10	 add	 esp, 16			; 00000010H
$LN35@SkillBlowO:
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN36@SkillBlowO:
  00140	8b 45 fc	 mov	 eax, DWORD PTR tv450[ebp]
  00143	8b 55 f8	 mov	 edx, DWORD PTR tv451[ebp]
  00146	8b 7d f4	 mov	 edi, DWORD PTR _DuelIndex$1$[ebp]
$LN23@SkillBlowO:

; 1783 : 							}
; 1784 : 						}
; 1785 : 					}
; 1786 : 				}
; 1787 : 			}
; 1788 : 		}
; 1789 : 
; 1790 : 		count++;

  00149	83 c0 0c	 add	 eax, 12			; 0000000cH

; 1791 : 		if(count > MAX_VIEWPORT -1)

  0014c	83 ea 01	 sub	 edx, 1
  0014f	89 45 fc	 mov	 DWORD PTR tv450[ebp], eax
  00152	89 55 f8	 mov	 DWORD PTR tv451[ebp], edx
  00155	0f 85 d7 fe ff
	ff		 jne	 $LL2@SkillBlowO
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx

; 1792 : 		{
; 1793 : 			break;
; 1794 : 		}
; 1795 : 	}
; 1796 : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 20 00	 ret	 32			; 00000020H
?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z ENDP ; CObjUseSkill::SkillBlowOfFury
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_DuelIndex$1$ = -8					; size = 4
tv448 = -4						; size = 4
tv443 = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillHellFire2, COMDAT
; _this$ = ecx

; 2193 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2194 : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	57		 push	 edi
  0000a	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  00010	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2195 : 	int tObjNum;
; 2196 : 
; 2197 : 	if(lpObj->SkillHellFire2State == 0)

  00016	80 bf a8 14 00
	00 00		 cmp	 BYTE PTR [edi+5288], 0
  0001d	75 10		 jne	 SHORT $LN4@SkillHellF

; 2198 : 	{
; 2199 : 		return SkillHellFire2Start(aIndex,lpMagic);

  0001f	ff 75 10	 push	 DWORD PTR _lpMagic$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2Start
  00028	5f		 pop	 edi

; 2269 : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SkillHellF:
  0002f	53		 push	 ebx

; 2200 : 	}
; 2201 : 
; 2202 : 	lpObj->SkillHellFire2State = 0;
; 2203 : 	int count = 0;
; 2204 : 	lpObj->SkillHellFire2Time = 0;
; 2205 : 
; 2206 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 2207 : 	int DuelIndex = lpObj->m_iDuelUser;

  00030	8b 9f 50 12 00
	00		 mov	 ebx, DWORD PTR [edi+4688]
  00036	8d 87 4c 0c 00
	00		 lea	 eax, DWORD PTR [edi+3148]
  0003c	c6 87 a8 14 00
	00 00		 mov	 BYTE PTR [edi+5288], 0
  00043	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  00048	c7 87 ac 14 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+5292], 0
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	56		 push	 esi
  00059	89 5d f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], ebx
  0005c	89 45 08	 mov	 DWORD PTR tv443[ebp], eax
  0005f	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv448[ebp], 75 ; 0000004bH
  00066	eb 0b		 jmp	 SHORT $LN2@SkillHellF
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL33@SkillHellF:
  00070	8b 5d f8	 mov	 ebx, DWORD PTR _DuelIndex$1$[ebp]
$LN2@SkillHellF:

; 2208 : 	int EnableAttack;
; 2209 : 
; 2210 : 	while ( true )
; 2211 : 	{
; 2212 : 		if(lpObj->VpPlayer2[count].state != 0)

  00073	80 78 fc 00	 cmp	 BYTE PTR [eax-4], 0
  00077	0f 84 02 01 00
	00		 je	 $LN32@SkillHellF

; 2213 : 		{
; 2214 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0007d	0f bf 70 fe	 movsx	 esi, WORD PTR [eax-2]

; 2215 : 
; 2216 : 			if(tObjNum >= 0)

  00081	85 f6		 test	 esi, esi
  00083	0f 88 f6 00 00
	00		 js	 $LN32@SkillHellF

; 2217 : 			{
; 2218 : 				EnableAttack = 0;
; 2219 : 
; 2220 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00089	8a 10		 mov	 dl, BYTE PTR [eax]
  0008b	80 fa 02	 cmp	 dl, 2
  0008e	75 14		 jne	 SHORT $LN7@SkillHellF
  00090	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00096	83 bc 08 30 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1584], 0
  0009e	0f 8c 91 00 00
	00		 jl	 $LN11@SkillHellF
$LN7@SkillHellF:

; 2221 : 				{
; 2222 : 					EnableAttack = 1;
; 2223 : 				}
; 2224 : 				else if(aTargetIndex == tObjNum || DuelIndex == tObjNum)

  000a4	39 75 0c	 cmp	 DWORD PTR _aTargetIndex$[ebp], esi
  000a7	0f 84 88 00 00
	00		 je	 $LN11@SkillHellF
  000ad	3b de		 cmp	 ebx, esi
  000af	0f 84 80 00 00
	00		 je	 $LN11@SkillHellF

; 2225 : 				{
; 2226 : 					EnableAttack = 1;
; 2227 : 				}
; 2228 : #if (GS_CASTLE == 1)
; 2229 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  000b5	80 fa 03	 cmp	 dl, 3
  000b8	74 3a		 je	 SHORT $LN12@SkillHellF
  000ba	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  000c0	80 bc 0b 23 01
	00 00 1e	 cmp	 BYTE PTR [ebx+ecx+291], 30 ; 0000001eH
  000c8	75 2a		 jne	 SHORT $LN12@SkillHellF
  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000cf	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 2230 : 				{
; 2231 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000da	83 f8 07	 cmp	 eax, 7
  000dd	75 15		 jne	 SHORT $LN12@SkillHellF
  000df	8a 87 5a 20 00
	00		 mov	 al, BYTE PTR [edi+8282]
  000e5	3a 84 0b 5a 20
	00 00		 cmp	 al, BYTE PTR [ebx+ecx+8282]
  000ec	0f 84 87 00 00
	00		 je	 $LN30@SkillHellF

; 2232 : 						EnableAttack = 1;
; 2233 : 				}
; 2234 : #endif
; 2235 : 				else

  000f2	eb 41		 jmp	 SHORT $LN11@SkillHellF
$LN12@SkillHellF:

; 2236 : 				{
; 2237 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000f4	69 c6 40 27 00
	00		 imul	 eax, esi, 10048

; 2238 : 
; 2239 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000fa	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  000ff	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  00102	75 14		 jne	 SHORT $LN15@SkillHellF
  00104	8b 84 08 30 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1584]
  0010b	85 c0		 test	 eax, eax
  0010d	78 09		 js	 SHORT $LN15@SkillHellF

; 2240 : 					{
; 2241 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  0010f	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00115	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
$LN15@SkillHellF:

; 2242 : 					}
; 2243 : 
; 2244 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  00118	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  0011e	03 c1		 add	 eax, ecx
  00120	50		 push	 eax
  00121	57		 push	 edi
  00122	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00127	83 c4 08	 add	 esp, 8
  0012a	83 f8 01	 cmp	 eax, 1
  0012d	75 44		 jne	 SHORT $LN29@SkillHellF
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN11@SkillHellF:

; 2245 : 					{
; 2246 : 						EnableAttack = 1;
; 2247 : 					}
; 2248 : 				}
; 2249 : 
; 2250 : 				if(EnableAttack != 0)
; 2251 : 				{
; 2252 : 					if(gObjCalDistance(lpObj,&gObj[tObjNum]) <= 6)

  00135	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  0013b	03 c1		 add	 eax, ecx
  0013d	50		 push	 eax
  0013e	57		 push	 edi
  0013f	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00144	83 c4 08	 add	 esp, 8
  00147	83 f8 06	 cmp	 eax, 6
  0014a	7f 27		 jg	 SHORT $LN29@SkillHellF

; 2253 : 					{
; 2254 : 						gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,600,lpMagic->m_Skill,0);

  0014c	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  0014f	6a 00		 push	 0
  00151	ff 73 08	 push	 DWORD PTR [ebx+8]
  00154	68 58 02 00 00	 push	 600			; 00000258H
  00159	56		 push	 esi
  0015a	6a 32		 push	 50			; 00000032H
  0015c	57		 push	 edi
  0015d	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00162	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00168	83 c4 18	 add	 esp, 24			; 00000018H
  0016b	8b 45 08	 mov	 eax, DWORD PTR tv443[ebp]
  0016e	8b 55 fc	 mov	 edx, DWORD PTR tv448[ebp]
  00171	eb 0f		 jmp	 SHORT $LN18@SkillHellF
$LN29@SkillHellF:
  00173	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN30@SkillHellF:
  00179	8b 55 fc	 mov	 edx, DWORD PTR tv448[ebp]
  0017c	8b 45 08	 mov	 eax, DWORD PTR tv443[ebp]
$LN32@SkillHellF:
  0017f	8b 5d 10	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
$LN18@SkillHellF:

; 2255 : 					}
; 2256 : 				}
; 2257 : 			}
; 2258 : 		}
; 2259 : 
; 2260 : 		count++;

  00182	83 c0 0c	 add	 eax, 12			; 0000000cH

; 2261 : 		if(count > MAX_VIEWPORT -1)

  00185	83 ea 01	 sub	 edx, 1
  00188	89 45 08	 mov	 DWORD PTR tv443[ebp], eax
  0018b	89 55 fc	 mov	 DWORD PTR tv448[ebp], edx
  0018e	0f 85 dc fe ff
	ff		 jne	 $LL33@SkillHellF

; 2262 : 		{
; 2263 : 			break;
; 2264 : 		}
; 2265 : 	}
; 2266 : 
; 2267 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpObj->m_Index,1);

  00194	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  00198	6a 01		 push	 1
  0019a	ff 37		 push	 DWORD PTR [edi]
  0019c	50		 push	 eax
  0019d	57		 push	 edi
  0019e	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  001a3	83 c4 10	 add	 esp, 16			; 00000010H

; 2268 : 	return true;

  001a6	b8 01 00 00 00	 mov	 eax, 1
  001ab	5e		 pop	 esi
  001ac	5b		 pop	 ebx
  001ad	5f		 pop	 edi

; 2269 : }

  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c2 0c 00	 ret	 12			; 0000000cH
?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillHellFire2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::SkillHellFire2Start, COMDAT
; _this$ = ecx

; 2275 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2276 : 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0000e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2277 : 
; 2278 : 	if(lpObj->SkillHellFire2State != 0)

  00014	80 be a8 14 00
	00 00		 cmp	 BYTE PTR [esi+5288], 0
  0001b	74 1e		 je	 SHORT $LN2@SkillHellF

; 2279 : 	{
; 2280 : 		LogAddTD("[%s][%s] SkillHellFire2 error on start",lpObj->AccountID,lpObj->Name);

  0001d	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00020	50		 push	 eax
  00021	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FEMHONHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5SkillHellFire2?5error?5on@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2281 : 		return false;

  00033	33 c0		 xor	 eax, eax
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 2290 : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN2@SkillHellF:

; 2282 : 	}
; 2283 : 
; 2284 : 	lpObj->SkillHellFire2Time = GetTickCount();

  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 2285 : 	lpObj->SkillHellFire2State = 1;
; 2286 : 	lpObj->SkillHellFire2Count = 0;
; 2287 : 
; 2288 : 	GCMagicAttackNumberSend(lpObj,AT_SKILL_EXPHELL_START,aIndex,1);

  00041	6a 01		 push	 1
  00043	57		 push	 edi
  00044	6a 3a		 push	 58			; 0000003aH
  00046	56		 push	 esi
  00047	89 86 ac 14 00
	00		 mov	 DWORD PTR [esi+5292], eax
  0004d	66 c7 86 a8 14
	00 00 01 00	 mov	 WORD PTR [esi+5288], 1
  00056	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0005b	83 c4 10	 add	 esp, 16			; 00000010H

; 2289 : 	return true;

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 2290 : }

  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
?SkillHellFire2Start@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::SkillHellFire2Start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
tv456 = -12						; size = 4
_DuelIndex$1$ = -8					; size = 4
tv457 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillSuddenIce, COMDAT
; _this$ = ecx

; 2096 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2097 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	69 55 08 40 27
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 10048
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	03 d6		 add	 edx, esi
  00017	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx
  0001a	57		 push	 edi
  0001b	89 55 08	 mov	 DWORD PTR _lpObj$1$[ebp], edx

; 2098 : 	int tObjNum;
; 2099 : 	int count = 0;
; 2100 : 	int FirstHit = 0;
; 2101 : 	int HitCount = 0;
; 2102 : 	int bAttack;
; 2103 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 2104 : 	int DuelIndex = lpObj->m_iDuelUser;

  0001e	8b 82 50 12 00
	00		 mov	 eax, DWORD PTR [edx+4688]
  00024	8d 9a 4c 0c 00
	00		 lea	 ebx, DWORD PTR [edx+3148]
  0002a	89 45 f8	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  0002d	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00032	89 45 fc	 mov	 DWORD PTR tv457[ebp], eax
$LL2@SkillSudde:

; 2105 : 	int EnableAttack;
; 2106 : 
; 2107 : 	while ( true )
; 2108 : 	{
; 2109 : 		if(lpObj->VpPlayer2[count].state != 0)

  00035	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00039	0f 84 24 01 00
	00		 je	 $LN22@SkillSudde

; 2110 : 		{
; 2111 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0003f	0f bf 7b fe	 movsx	 edi, WORD PTR [ebx-2]

; 2112 : 
; 2113 : 			if(tObjNum >= 0)

  00043	85 ff		 test	 edi, edi
  00045	0f 88 18 01 00
	00		 js	 $LN22@SkillSudde

; 2114 : 			{
; 2115 : 				EnableAttack = 0;
; 2116 : 
; 2117 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  0004b	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0004d	80 f9 02	 cmp	 cl, 2
  00050	75 14		 jne	 SHORT $LN6@SkillSudde
  00052	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  00058	83 bc 30 30 06
	00 00 00	 cmp	 DWORD PTR [eax+esi+1584], 0
  00060	0f 8c 9b 00 00
	00		 jl	 $LN10@SkillSudde
$LN6@SkillSudde:

; 2118 : 				{
; 2119 : 					EnableAttack = 1;
; 2120 : 				}
; 2121 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00066	3b 7d 20	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  00069	0f 84 92 00 00
	00		 je	 $LN10@SkillSudde
  0006f	39 7d f8	 cmp	 DWORD PTR _DuelIndex$1$[ebp], edi
  00072	0f 84 89 00 00
	00		 je	 $LN10@SkillSudde

; 2122 : 				{
; 2123 : 					EnableAttack = 1;
; 2124 : 				}
; 2125 : #if (GS_CASTLE == 1)
; 2126 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  00078	80 f9 03	 cmp	 cl, 3
  0007b	74 43		 je	 SHORT $LN11@SkillSudde
  0007d	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  00083	89 45 f4	 mov	 DWORD PTR tv456[ebp], eax
  00086	80 bc 30 23 01
	00 00 1e	 cmp	 BYTE PTR [eax+esi+291], 30 ; 0000001eH
  0008e	75 30		 jne	 SHORT $LN11@SkillSudde
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00095	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 2127 : 				{
; 2128 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  0009a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  0009d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a3	83 f8 07	 cmp	 eax, 7
  000a6	75 18		 jne	 SHORT $LN11@SkillSudde
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR tv456[ebp]
  000ab	8a 82 5a 20 00
	00		 mov	 al, BYTE PTR [edx+8282]
  000b1	3a 84 31 5a 20
	00 00		 cmp	 al, BYTE PTR [ecx+esi+8282]
  000b8	0f 84 a2 00 00
	00		 je	 $LN36@SkillSudde

; 2129 : 						EnableAttack = 1;
; 2130 : 				}
; 2131 : #endif
; 2132 : 				else

  000be	eb 41		 jmp	 SHORT $LN10@SkillSudde
$LN11@SkillSudde:

; 2133 : 				{
; 2134 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000c0	69 c7 40 27 00
	00		 imul	 eax, edi, 10048

; 2135 : 
; 2136 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000c6	80 7c 30 50 02	 cmp	 BYTE PTR [eax+esi+80], 2
  000cb	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]
  000ce	75 14		 jne	 SHORT $LN14@SkillSudde
  000d0	8b 84 30 30 06
	00 00		 mov	 eax, DWORD PTR [eax+esi+1584]
  000d7	85 c0		 test	 eax, eax
  000d9	78 09		 js	 SHORT $LN14@SkillSudde

; 2137 : 					{
; 2138 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000db	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000e1	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]
$LN14@SkillSudde:

; 2139 : 					}
; 2140 : 
; 2141 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000e4	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  000ea	03 c6		 add	 eax, esi
  000ec	50		 push	 eax
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000f3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f9	83 c4 08	 add	 esp, 8
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	75 5c		 jne	 SHORT $LN35@SkillSudde
$LN10@SkillSudde:

; 2142 : 					{
; 2143 : 						EnableAttack = 1;
; 2144 : 					}
; 2145 : 				}
; 2146 : 
; 2147 : 				if(EnableAttack != 0)
; 2148 : 				{
; 2149 : 					if(CalDistance(x,y,gObj[tObjNum].X,gObj[tObjNum].Y) < 4)

  00101	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00104	69 ff 40 27 00
	00		 imul	 edi, edi, 10048
  0010a	0f b6 84 37 21
	01 00 00	 movzx	 eax, BYTE PTR [edi+esi+289]
  00112	50		 push	 eax
  00113	0f b6 84 37 20
	01 00 00	 movzx	 eax, BYTE PTR [edi+esi+288]
  0011b	50		 push	 eax
  0011c	0f b6 45 14	 movzx	 eax, BYTE PTR _y$[ebp]
  00120	50		 push	 eax
  00121	0f b6 45 10	 movzx	 eax, BYTE PTR _x$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  0012b	83 f8 04	 cmp	 eax, 4
  0012e	7d 2d		 jge	 SHORT $LN35@SkillSudde

; 2150 : 					{
; 2151 : 						bAttack = 0;
; 2152 : 
; 2153 : 						if(HitCount > 10)
; 2154 : 						{
; 2155 : 							bAttack = 0;
; 2156 : 						}
; 2157 : 						
; 2158 : 						if(HitCount >= 5)
; 2159 : 						{
; 2160 : 							if(rand()%2)
; 2161 : 							{
; 2162 : 								bAttack = 1;
; 2163 : 							}
; 2164 : 						}
; 2165 : 						else
; 2166 : 						{
; 2167 : 							bAttack = 1;
; 2168 : 						}
; 2169 : 
; 2170 : 						if(bAttack != 0)
; 2171 : 						{
; 2172 : 							int delay = rand()%500;

  00130	e8 00 00 00 00	 call	 _rand

; 2173 : 							gObjAttack(lpObj,&gObj[tObjNum],lpMagic,1,1,0,0,0,0);

  00135	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013a	6a 00		 push	 0
  0013c	6a 00		 push	 0
  0013e	6a 00		 push	 0
  00140	6a 00		 push	 0
  00142	6a 01		 push	 1
  00144	6a 01		 push	 1
  00146	ff 75 0c	 push	 DWORD PTR _lpMagic$[ebp]
  00149	03 c7		 add	 eax, edi
  0014b	50		 push	 eax
  0014c	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  0014f	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00154	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015a	83 c4 24	 add	 esp, 36			; 00000024H
$LN35@SkillSudde:
  0015d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
$LN36@SkillSudde:
  00160	8b 45 fc	 mov	 eax, DWORD PTR tv457[ebp]
$LN22@SkillSudde:

; 2174 : 						}
; 2175 : 					}
; 2176 : 				}
; 2177 : 			}
; 2178 : 		}
; 2179 : 
; 2180 : 		count++;

  00163	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 2181 : 		if(count > MAX_VIEWPORT -1)

  00166	83 e8 01	 sub	 eax, 1
  00169	89 45 fc	 mov	 DWORD PTR tv457[ebp], eax
  0016c	0f 85 c3 fe ff
	ff		 jne	 $LL2@SkillSudde

; 2182 : 		{
; 2183 : 			break;
; 2184 : 		}
; 2185 : 	}
; 2186 : 	return true;

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	b8 01 00 00 00	 mov	 eax, 1
  00179	5b		 pop	 ebx

; 2187 : }

  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c2 1c 00	 ret	 28			; 0000001cH
?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillSuddenIce
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_DuelIndex$1$ = -12					; size = 4
tv455 = -8						; size = 4
tv449 = -4						; size = 4
_lpObj$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z PROC ; CObjUseSkill::SkillDeathPoison, COMDAT
; _this$ = ecx

; 1998 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1999 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	69 55 08 40 27
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 10048
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	03 d6		 add	 edx, esi
  00017	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx
  0001a	57		 push	 edi
  0001b	89 55 08	 mov	 DWORD PTR _lpObj$1$[ebp], edx

; 2000 : 	int tObjNum;
; 2001 : 	int count = 0;
; 2002 : 	int FirstHit = 0;
; 2003 : 	int HitCount = 0;
; 2004 : 	int bAttack;
; 2005 : 	int DuelIndex = lpObj->m_iDuelUser;

  0001e	8b 82 50 12 00
	00		 mov	 eax, DWORD PTR [edx+4688]
  00024	8d 9a 4c 0c 00
	00		 lea	 ebx, DWORD PTR [edx+3148]
  0002a	89 45 f4	 mov	 DWORD PTR _DuelIndex$1$[ebp], eax
  0002d	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00032	89 5d fc	 mov	 DWORD PTR tv449[ebp], ebx
  00035	89 45 f8	 mov	 DWORD PTR tv455[ebp], eax
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@SkillDeath:

; 2006 : 	int EnableAttack;
; 2007 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 2008 : 
; 2009 : 
; 2010 : 	while ( true )
; 2011 : 	{
; 2012 : 		if(lpObj->VpPlayer2[count].state != 0)

  00040	80 7b fc 00	 cmp	 BYTE PTR [ebx-4], 0
  00044	0f 84 23 01 00
	00		 je	 $LN22@SkillDeath

; 2013 : 		{
; 2014 : 			tObjNum = lpObj->VpPlayer2[count].number;

  0004a	0f bf 7b fe	 movsx	 edi, WORD PTR [ebx-2]

; 2015 : 
; 2016 : 			if(tObjNum >= 0)

  0004e	85 ff		 test	 edi, edi
  00050	0f 88 17 01 00
	00		 js	 $LN22@SkillDeath

; 2017 : 			{
; 2018 : 				EnableAttack = 0;
; 2019 : 
; 2020 : 				if(lpObj->VpPlayer2[count].type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon < 0)

  00056	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00058	80 f9 02	 cmp	 cl, 2
  0005b	75 14		 jne	 SHORT $LN6@SkillDeath
  0005d	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  00063	83 bc 30 30 06
	00 00 00	 cmp	 DWORD PTR [eax+esi+1584], 0
  0006b	0f 8c 9a 00 00
	00		 jl	 $LN10@SkillDeath
$LN6@SkillDeath:

; 2021 : 				{
; 2022 : 					EnableAttack = 1;
; 2023 : 				}
; 2024 : 				else if(tObjNum == aTargetIndex || DuelIndex == tObjNum)

  00071	3b 7d 20	 cmp	 edi, DWORD PTR _aTargetIndex$[ebp]
  00074	0f 84 91 00 00
	00		 je	 $LN10@SkillDeath
  0007a	39 7d f4	 cmp	 DWORD PTR _DuelIndex$1$[ebp], edi
  0007d	0f 84 88 00 00
	00		 je	 $LN10@SkillDeath

; 2025 : 				{
; 2026 : 					EnableAttack = 1;
; 2027 : 				}
; 2028 : #if (GS_CASTLE == 1)
; 2029 : 				else if(lpObj->VpPlayer2[count].type != OBJ_NPC && gObj[tObjNum].MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == 7)

  00083	80 f9 03	 cmp	 cl, 3
  00086	74 42		 je	 SHORT $LN11@SkillDeath
  00088	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  0008e	80 bc 33 23 01
	00 00 1e	 cmp	 BYTE PTR [ebx+esi+291], 30 ; 0000001eH
  00096	75 2f		 jne	 SHORT $LN37@SkillDeath
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0009d	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState

; 2030 : 				{
; 2031 : 					if( lpObj->m_btCsJoinSide != gObj[tObjNum].m_btCsJoinSide )

  000a2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  000a5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ab	83 f8 07	 cmp	 eax, 7
  000ae	75 17		 jne	 SHORT $LN37@SkillDeath
  000b0	8a 82 5a 20 00
	00		 mov	 al, BYTE PTR [edx+8282]
  000b6	3a 84 33 5a 20
	00 00		 cmp	 al, BYTE PTR [ebx+esi+8282]
  000bd	75 4c		 jne	 SHORT $LN10@SkillDeath
  000bf	8b 5d fc	 mov	 ebx, DWORD PTR tv449[ebp]
  000c2	e9 a3 00 00 00	 jmp	 $LN39@SkillDeath
$LN37@SkillDeath:
  000c7	8b 5d fc	 mov	 ebx, DWORD PTR tv449[ebp]
$LN11@SkillDeath:

; 2032 : 						EnableAttack = 1;
; 2033 : 				}
; 2034 : #endif
; 2035 : 				else
; 2036 : 				{
; 2037 : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000ca	69 c7 40 27 00
	00		 imul	 eax, edi, 10048

; 2038 : 
; 2039 : 					if(gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0)

  000d0	80 7c 30 50 02	 cmp	 BYTE PTR [eax+esi+80], 2
  000d5	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]
  000d8	75 14		 jne	 SHORT $LN14@SkillDeath
  000da	8b 84 30 30 06
	00 00		 mov	 eax, DWORD PTR [eax+esi+1584]
  000e1	85 c0		 test	 eax, eax
  000e3	78 09		 js	 SHORT $LN14@SkillDeath

; 2040 : 					{
; 2041 : 						CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  000e5	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000eb	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]
$LN14@SkillDeath:

; 2042 : 					}
; 2043 : 
; 2044 : 					if(gObjTargetGuildWarCheck(lpObj,&gObj[CallMonIndex])==1)

  000ee	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  000f4	03 c6		 add	 eax, esi
  000f6	50		 push	 eax
  000f7	52		 push	 edx
  000f8	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  000fd	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00103	83 c4 08	 add	 esp, 8
  00106	83 f8 01	 cmp	 eax, 1
  00109	75 5c		 jne	 SHORT $LN38@SkillDeath
$LN10@SkillDeath:

; 2045 : 					{
; 2046 : 						EnableAttack = 1;
; 2047 : 					}
; 2048 : 				}
; 2049 : 
; 2050 : 				if(EnableAttack != 0)
; 2051 : 				{
; 2052 : 					if(CalDistance(x,y,gObj[tObjNum].X,gObj[tObjNum].Y) < 4)

  0010b	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00111	0f b6 84 31 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+289]
  00119	50		 push	 eax
  0011a	0f b6 84 31 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+288]
  00122	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00125	50		 push	 eax
  00126	0f b6 45 14	 movzx	 eax, BYTE PTR _y$[ebp]
  0012a	50		 push	 eax
  0012b	0f b6 45 10	 movzx	 eax, BYTE PTR _x$[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ?CalDistance@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::CalDistance
  00135	83 f8 04	 cmp	 eax, 4
  00138	7d 2a		 jge	 SHORT $LN36@SkillDeath

; 2053 : 					{
; 2054 : 						bAttack = 0;
; 2055 : 
; 2056 : 						if(HitCount > 10)
; 2057 : 						{
; 2058 : 							bAttack = 0;
; 2059 : 						}
; 2060 : 						
; 2061 : 						if(HitCount >= 5)
; 2062 : 						{
; 2063 : 							if(rand()%2)
; 2064 : 							{
; 2065 : 								bAttack = 1;
; 2066 : 							}
; 2067 : 						}
; 2068 : 						else
; 2069 : 						{
; 2070 : 							bAttack = 1;
; 2071 : 						}
; 2072 : 
; 2073 : 						if(bAttack != 0)
; 2074 : 						{
; 2075 : 							int delay = rand()%500;

  0013a	e8 00 00 00 00	 call	 _rand
  0013f	99		 cdq
  00140	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  00145	f7 f9		 idiv	 ecx

; 2076 : 							gObjAddAttackProcMsgSendDelay(lpObj,50,tObjNum,delay,lpMagic->m_Skill,0);

  00147	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0014a	6a 00		 push	 0
  0014c	ff 70 08	 push	 DWORD PTR [eax+8]
  0014f	52		 push	 edx
  00150	57		 push	 edi
  00151	6a 32		 push	 50			; 00000032H
  00153	ff 75 08	 push	 DWORD PTR _lpObj$1$[ebp]
  00156	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  0015b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00161	83 c4 18	 add	 esp, 24			; 00000018H
$LN36@SkillDeath:
  00164	8b 5d fc	 mov	 ebx, DWORD PTR tv449[ebp]
$LN38@SkillDeath:
  00167	8b 55 08	 mov	 edx, DWORD PTR _lpObj$1$[ebp]
$LN39@SkillDeath:
  0016a	8b 45 f8	 mov	 eax, DWORD PTR tv455[ebp]
$LN22@SkillDeath:

; 2077 : 						}
; 2078 : 					}
; 2079 : 				}
; 2080 : 			}
; 2081 : 		}
; 2082 : 
; 2083 : 		count++;

  0016d	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 2084 : 		if(count > MAX_VIEWPORT -1)

  00170	83 e8 01	 sub	 eax, 1
  00173	89 5d fc	 mov	 DWORD PTR tv449[ebp], ebx
  00176	89 45 f8	 mov	 DWORD PTR tv455[ebp], eax
  00179	0f 85 c1 fe ff
	ff		 jne	 $LL2@SkillDeath

; 2085 : 		{
; 2086 : 			break;
; 2087 : 		}
; 2088 : 	}
; 2089 : 	return true;

  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	b8 01 00 00 00	 mov	 eax, 1
  00186	5b		 pop	 ebx

; 2090 : }

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c2 1c 00	 ret	 28			; 0000001cH
?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ENDP ; CObjUseSkill::SkillDeathPoison
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z
_TEXT	SEGMENT
_result$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_MonsterType$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z PROC		; CObjUseSkill::SkillMonsterCall, COMDAT
; _this$ = ecx

; 1637 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1638 : 	if(gObj[aIndex].MapNumber == MAP_INDEX_ICARUS)

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000d	57		 push	 edi
  0000e	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00014	8a 84 0f 23 01
	00 00		 mov	 al, BYTE PTR [edi+ecx+291]
  0001b	3c 0a		 cmp	 al, 10			; 0000000aH
  0001d	74 30		 je	 SHORT $LN14@SkillMonst

; 1639 : 	{
; 1640 : 		return false;
; 1641 : 	}
; 1642 : 
; 1643 : 	if(CC_MAP_RANGE(gObj[aIndex].MapNumber))

  0001f	3c 35		 cmp	 al, 53			; 00000035H
  00021	74 2c		 je	 SHORT $LN14@SkillMonst
  00023	3c 12		 cmp	 al, 18			; 00000012H
  00025	72 0b		 jb	 SHORT $LN3@SkillMonst
  00027	b2 17		 mov	 dl, 23			; 00000017H
  00029	3a d0		 cmp	 dl, al
  0002b	1b c0		 sbb	 eax, eax
  0002d	83 c0 01	 add	 eax, 1
  00030	75 1d		 jne	 SHORT $LN14@SkillMonst
$LN3@SkillMonst:

; 1646 : 	}
; 1647 : 
; 1648 : 	if(gObj[aIndex].m_RecallMon >= 0)

  00032	83 bc 0f 30 06
	00 00 00	 cmp	 DWORD PTR [edi+ecx+1584], 0
  0003a	7c 1b		 jl	 SHORT $LN4@SkillMonst

; 1649 : 	{
; 1650 : 		GCRecallMonLife(aIndex,60,0);

  0003c	6a 00		 push	 0
  0003e	6a 3c		 push	 60			; 0000003cH
  00040	53		 push	 ebx
  00041	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 1651 : 		gObjMonsterCallKill(aIndex);

  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@SkillMonst:

; 1644 : 	{
; 1645 : 		return false;

  0004f	5f		 pop	 edi
  00050	33 c0		 xor	 eax, eax
  00052	5b		 pop	 ebx

; 1696 : 	}
; 1697 : 	return false;
; 1698 : }

  00053	5d		 pop	 ebp
  00054	c2 10 00	 ret	 16			; 00000010H
$LN4@SkillMonst:

; 1652 : 		return false;
; 1653 : 	}
; 1654 : 
; 1655 : 	int result = gObjAddCallMon();

  00057	e8 00 00 00 00	 call	 ?gObjAddCallMon@@YAFXZ	; gObjAddCallMon
  0005c	98		 cwde
  0005d	89 45 08	 mov	 DWORD PTR _result$1$[ebp], eax

; 1656 : 
; 1657 : 	if(result >= 0)

  00060	85 c0		 test	 eax, eax
  00062	78 eb		 js	 SHORT $LN14@SkillMonst

; 1658 : 	{
; 1659 : 		gObj[result].X = x;

  00064	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]

; 1660 : 		gObj[result].Y = y;

  00067	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  0006a	56		 push	 esi
  0006b	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1661 : 		gObj[result].MTX = x;
; 1662 : 		gObj[result].MTY = y;
; 1663 : 		gObj[result].Dir = 2;
; 1664 : 		gObj[result].MapNumber = gObj[aIndex].MapNumber;
; 1665 : 		gObjSetMonster(result,MonsterType);

  00076	ff 75 0c	 push	 DWORD PTR _MonsterType$[ebp]
  00079	ff 75 08	 push	 DWORD PTR _result$1$[ebp]
  0007c	88 94 06 20 01
	00 00		 mov	 BYTE PTR [esi+eax+288], dl
  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00088	88 8c 06 21 01
	00 00		 mov	 BYTE PTR [esi+eax+289], cl
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00094	88 94 06 54 01
	00 00		 mov	 BYTE PTR [esi+eax+340], dl
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	88 8c 06 55 01
	00 00		 mov	 BYTE PTR [esi+eax+341], cl
  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ac	c6 84 06 22 01
	00 00 02	 mov	 BYTE PTR [esi+eax+290], 2
  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ba	8a 84 0f 23 01
	00 00		 mov	 al, BYTE PTR [edi+ecx+291]
  000c1	88 84 0e 23 01
	00 00		 mov	 BYTE PTR [esi+ecx+291], al
  000c8	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1666 : 		gObj[result].m_RecallMon = aIndex;

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1667 : 		gObj[result].m_Attribute = 100;

  000d2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H

; 1668 : 		gObj[result].TargetNumber = (WORD)-1;
; 1669 : 		gObj[result].m_ActState.Emotion = 0;
; 1670 : 		gObj[result].m_ActState.Attack = 0;
; 1671 : 		gObj[result].m_ActState.EmotionCount = 0;
; 1672 : 		gObj[result].PathCount = 0;
; 1673 : 
; 1674 : 		gObj[aIndex].m_RecallMon = result;
; 1675 : 		gObj[result].m_MoveRange = 15;
; 1676 : 
; 1677 : 		if( gObj[aIndex].m_MPSkillOpt.MpsSummonMonster1 > 0.0f )

  000d7	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@42c80000
  000df	0f 57 e4	 xorps	 xmm4, xmm4
  000e2	83 c4 08	 add	 esp, 8
  000e5	89 9c 06 30 06
	00 00		 mov	 DWORD PTR [esi+eax+1584], ebx
  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	66 89 8c 06 96
	06 00 00	 mov	 WORD PTR [esi+eax+1686], cx
  000f9	83 c9 ff	 or	 ecx, -1
  000fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00101	66 89 8c 06 38
	06 00 00	 mov	 WORD PTR [esi+eax+1592], cx
  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010e	8b 4d 08	 mov	 ecx, DWORD PTR _result$1$[ebp]
  00111	81 a4 06 c8 01
	00 00 0f ff ff
	ff		 and	 DWORD PTR [esi+eax+456], -241 ; ffffff0fH
  0011c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00121	83 a4 06 c8 01
	00 00 fd	 and	 DWORD PTR [esi+eax+456], -3 ; fffffffdH
  00129	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012e	c6 84 06 c9 01
	00 00 00	 mov	 BYTE PTR [esi+eax+457], 0
  00136	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013b	c7 84 06 58 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+344], 0
  00146	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014b	89 8c 07 30 06
	00 00		 mov	 DWORD PTR [edi+eax+1584], ecx
  00152	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00157	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015c	66 89 8c 06 8e
	06 00 00	 mov	 WORD PTR [esi+eax+1678], cx
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016a	f3 0f 10 9c 0f
	58 07 00 00	 movss	 xmm3, DWORD PTR [edi+ecx+1880]
  00173	0f 2f dc	 comiss	 xmm3, xmm4
  00176	76 52		 jbe	 SHORT $LN6@SkillMonst

; 1678 : 		{
; 1679 : 			gObj[result].MaxLife += gObj[result].MaxLife/100.0f*gObj[aIndex].m_MPSkillOpt.MpsSummonMonster1;

  00178	f3 0f 10 8c 0e
	dc 00 00 00	 movss	 xmm1, DWORD PTR [esi+ecx+220]
  00181	0f 28 c1	 movaps	 xmm0, xmm1
  00184	f3 0f 5e c2	 divss	 xmm0, xmm2
  00188	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0018c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00190	f3 0f 11 84 0e
	dc 00 00 00	 movss	 DWORD PTR [esi+ecx+220], xmm0

; 1680 : 			gObj[result].Life += gObj[result].Life/100.0f*gObj[aIndex].m_MPSkillOpt.MpsSummonMonster1;

  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019e	f3 0f 10 8c 06
	d8 00 00 00	 movss	 xmm1, DWORD PTR [esi+eax+216]
  001a7	0f 28 c1	 movaps	 xmm0, xmm1
  001aa	f3 0f 5e c2	 divss	 xmm0, xmm2
  001ae	f3 0f 59 84 07
	58 07 00 00	 mulss	 xmm0, DWORD PTR [edi+eax+1880]
  001b7	f3 0f 58 c1	 addss	 xmm0, xmm1
  001bb	f3 0f 11 84 06
	d8 00 00 00	 movss	 DWORD PTR [esi+eax+216], xmm0
  001c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN6@SkillMonst:

; 1681 : 		}
; 1682 : 
; 1683 : 		if( gObj[aIndex].m_MPSkillOpt.MpsSummonMonster2 > 0.0f )

  001ca	f3 0f 10 9c 0f
	5c 07 00 00	 movss	 xmm3, DWORD PTR [edi+ecx+1884]
  001d3	0f 2f dc	 comiss	 xmm3, xmm4
  001d6	76 2c		 jbe	 SHORT $LN7@SkillMonst

; 1684 : 		{
; 1685 : 			gObj[result].m_Defense += gObj[result].m_Defense/100.0f*gObj[aIndex].m_MPSkillOpt.MpsSummonMonster2;

  001d8	66 0f 6e 8c 0e
	74 06 00 00	 movd	 xmm1, DWORD PTR [esi+ecx+1652]
  001e1	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001e4	0f 28 c1	 movaps	 xmm0, xmm1
  001e7	f3 0f 5e c2	 divss	 xmm0, xmm2
  001eb	f3 0f 59 c3	 mulss	 xmm0, xmm3
  001ef	f3 0f 58 c1	 addss	 xmm0, xmm1
  001f3	f3 0f 2c c0	 cvttss2si eax, xmm0
  001f7	89 84 0e 74 06
	00 00		 mov	 DWORD PTR [esi+ecx+1652], eax
  001fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN7@SkillMonst:

; 1686 : 		}
; 1687 : 
; 1688 : 		if( gObj[aIndex].m_MPSkillOpt.MpsSummonMonster3 > 0.0f )

  00204	f3 0f 10 9c 0f
	60 07 00 00	 movss	 xmm3, DWORD PTR [edi+ecx+1888]
  0020d	0f 2f dc	 comiss	 xmm3, xmm4
  00210	76 5d		 jbe	 SHORT $LN8@SkillMonst

; 1689 : 		{
; 1690 : 			gObj[result].m_AttackDamageMax += gObj[result].m_AttackDamageMax/100.0f*gObj[aIndex].m_MPSkillOpt.MpsSummonMonster3;

  00212	66 0f 6e 8c 0e
	44 06 00 00	 movd	 xmm1, DWORD PTR [esi+ecx+1604]
  0021b	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0021e	0f 28 c1	 movaps	 xmm0, xmm1
  00221	f3 0f 5e c2	 divss	 xmm0, xmm2
  00225	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00229	f3 0f 58 c1	 addss	 xmm0, xmm1
  0022d	f3 0f 2c c0	 cvttss2si eax, xmm0
  00231	89 84 0e 44 06
	00 00		 mov	 DWORD PTR [esi+ecx+1604], eax

; 1691 : 			gObj[result].m_AttackDamageMin += gObj[result].m_AttackDamageMin/100.0f*gObj[aIndex].m_MPSkillOpt.MpsSummonMonster3;

  00238	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0023e	66 0f 6e 8c 0e
	40 06 00 00	 movd	 xmm1, DWORD PTR [esi+ecx+1600]
  00247	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0024a	0f 28 c1	 movaps	 xmm0, xmm1
  0024d	f3 0f 5e c2	 divss	 xmm0, xmm2
  00251	f3 0f 59 84 0f
	60 07 00 00	 mulss	 xmm0, DWORD PTR [edi+ecx+1888]
  0025a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0025e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00262	89 84 0e 40 06
	00 00		 mov	 DWORD PTR [esi+ecx+1600], eax
  00269	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN8@SkillMonst:

; 1692 : 		}
; 1693 : 
; 1694 : 		GCRecallMonLife(gObj[result].m_RecallMon,(int)gObj[result].MaxLife,(int)gObj[result].Life);

  0026f	f3 0f 2c 84 0e
	d8 00 00 00	 cvttss2si eax, DWORD PTR [esi+ecx+216]
  00278	50		 push	 eax
  00279	f3 0f 2c 84 0e
	dc 00 00 00	 cvttss2si eax, DWORD PTR [esi+ecx+220]
  00282	50		 push	 eax
  00283	ff b4 0e 30 06
	00 00		 push	 DWORD PTR [esi+ecx+1584]
  0028a	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1695 : 		return true;

  00292	b8 01 00 00 00	 mov	 eax, 1
  00297	5e		 pop	 esi
  00298	5f		 pop	 edi
  00299	5b		 pop	 ebx

; 1696 : 	}
; 1697 : 	return false;
; 1698 : }

  0029a	5d		 pop	 ebp
  0029b	c2 10 00	 ret	 16			; 00000010H
?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ENDP		; CObjUseSkill::SkillMonsterCall
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillHealing@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpObj$1$ = -4						; size = 4
tv479 = 8						; size = 4
_aIndex$ = 8						; size = 4
_lpTargetObj$1$ = 12					; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillHealing@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillHealing, COMDAT
; _this$ = ecx

; 1575 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1576 : 	int skillSuccess = true;
; 1577 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	53		 push	 ebx

; 1578 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000a	69 5d 0c 40 27
	00 00		 imul	 ebx, DWORD PTR _aTargetIndex$[ebp], 10048
  00011	57		 push	 edi
  00012	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00019	03 d8		 add	 ebx, eax
  0001b	89 5d 0c	 mov	 DWORD PTR _lpTargetObj$1$[ebp], ebx
  0001e	03 f8		 add	 edi, eax
  00020	89 7d fc	 mov	 DWORD PTR _lpObj$1$[ebp], edi

; 1579 : 
; 1580 : 	if(lpTargetObj->Type != OBJ_USER && lpTargetObj->m_RecallMon == -1)

  00023	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  00027	74 0d		 je	 SHORT $LN5@SkillHeali
  00029	83 bb 30 06 00
	00 ff		 cmp	 DWORD PTR [ebx+1584], -1
  00030	0f 84 91 01 00
	00		 je	 $LN1@SkillHeali
$LN5@SkillHeali:

; 1581 : 	{
; 1582 : 		return;
; 1583 : 	}
; 1584 : 
; 1585 : 	if(lpObj->Class != CLASS_ELF)

  00036	66 83 bf 90 00
	00 00 02	 cmp	 WORD PTR [edi+144], 2
  0003e	0f 85 83 01 00
	00		 jne	 $LN1@SkillHeali

; 1586 : 	{
; 1587 : 		return;
; 1588 : 	}
; 1589 : 
; 1590 : 	if(CC_MAP_RANGE(lpObj->MapNumber) && lpObj->m_Index != lpTargetObj->m_Index)

  00044	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  0004a	3c 35		 cmp	 al, 53			; 00000035H
  0004c	74 0f		 je	 SHORT $LN24@SkillHeali
  0004e	3c 12		 cmp	 al, 18			; 00000012H
  00050	72 15		 jb	 SHORT $LN7@SkillHeali
  00052	b1 17		 mov	 cl, 23			; 00000017H
  00054	3a c8		 cmp	 cl, al
  00056	1b c0		 sbb	 eax, eax
  00058	83 c0 01	 add	 eax, 1
  0005b	74 0a		 je	 SHORT $LN7@SkillHeali
$LN24@SkillHeali:
  0005d	8b 07		 mov	 eax, DWORD PTR [edi]
  0005f	3b 03		 cmp	 eax, DWORD PTR [ebx]
  00061	0f 85 60 01 00
	00		 jne	 $LN1@SkillHeali
$LN7@SkillHeali:

; 1591 : 	{
; 1592 : 		return;
; 1593 : 	}
; 1594 : 	
; 1595 : 
; 1596 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00067	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  0006f	ff 70 08	 push	 DWORD PTR [eax+8]
  00072	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect

; 1597 : 
; 1598 : 	if( !lpInfo )

  00077	85 c0		 test	 eax, eax
  00079	0f 84 48 01 00
	00		 je	 $LN1@SkillHeali

; 1599 : 	{
; 1600 : 		return;
; 1601 : 	}
; 1602 : 
; 1603 : 	int addlife = (lpInfo->m_Arg1 + (lpObj->Energy + lpObj->AddEnergy) / lpInfo->m_Arg2);

  0007f	0f b7 97 02 01
	00 00		 movzx	 edx, WORD PTR [edi+258]
  00086	0f b7 8f d6 00
	00 00		 movzx	 ecx, WORD PTR [edi+214]
  0008d	03 d1		 add	 edx, ecx
  0008f	66 0f 6e 8b 24
	01 00 00	 movd	 xmm1, DWORD PTR [ebx+292]

; 1604 : 
; 1605 : 	lpTargetObj->Life = addlife + lpTargetObj->Life;
; 1606 : 
; 1607 : 	if((lpTargetObj->MaxLife + lpTargetObj->AddLife) < lpTargetObj->Life)

  00097	f3 0f 10 93 dc
	00 00 00	 movss	 xmm2, DWORD PTR [ebx+220]
  0009f	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000a2	66 0f 6e c2	 movd	 xmm0, edx
  000a6	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a9	f3 0f 58 ca	 addss	 xmm1, xmm2
  000ad	f3 0f 5e 40 08	 divss	 xmm0, DWORD PTR [eax+8]
  000b2	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  000b7	f3 0f 2c c0	 cvttss2si eax, xmm0
  000bb	66 0f 6e c0	 movd	 xmm0, eax
  000bf	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000c2	f3 0f 58 83 d8
	00 00 00	 addss	 xmm0, DWORD PTR [ebx+216]
  000ca	0f 2f c1	 comiss	 xmm0, xmm1
  000cd	f3 0f 11 83 d8
	00 00 00	 movss	 DWORD PTR [ebx+216], xmm0
  000d5	76 08		 jbe	 SHORT $LN9@SkillHeali

; 1608 : 	{
; 1609 : 		lpTargetObj->Life = lpTargetObj->MaxLife + lpTargetObj->AddLife;

  000d7	f3 0f 11 8b d8
	00 00 00	 movss	 DWORD PTR [ebx+216], xmm1
$LN9@SkillHeali:

; 1610 : 	}
; 1611 : 
; 1612 : 	if(lpTargetObj->Type == OBJ_USER)

  000df	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  000e3	0f 85 a8 00 00
	00		 jne	 $LN10@SkillHeali

; 1613 : 	{
; 1614 : 		GCReFillSend(lpTargetObj->m_Index,(WORD)lpTargetObj->Life,0xFF,0,lpTargetObj->iShield);

  000e9	0f b7 83 2c 01
	00 00		 movzx	 eax, WORD PTR [ebx+300]
  000f0	56		 push	 esi
  000f1	50		 push	 eax
  000f2	f3 0f 2c 83 d8
	00 00 00	 cvttss2si eax, DWORD PTR [ebx+216]
  000fa	6a 00		 push	 0
  000fc	68 ff 00 00 00	 push	 255			; 000000ffH
  00101	0f b7 c0	 movzx	 eax, ax
  00104	50		 push	 eax
  00105	ff 33		 push	 DWORD PTR [ebx]
  00107	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  0010c	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00111	8d b7 48 0c 00
	00		 lea	 esi, DWORD PTR [edi+3144]
  00117	83 c4 14	 add	 esp, 20			; 00000014H
  0011a	89 4d 08	 mov	 DWORD PTR tv479[ebp], ecx
  0011d	8b df		 mov	 ebx, edi
  0011f	90		 npad	 1
$LL4@SkillHeali:

; 1617 : 		{
; 1618 : 			if(lpObj->VpPlayer2[n].type == OBJ_MONSTER && lpObj->VpPlayer2[n].state != 0)

  00120	80 7e 04 02	 cmp	 BYTE PTR [esi+4], 2
  00124	75 57		 jne	 SHORT $LN2@SkillHeali
  00126	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00129	74 52		 je	 SHORT $LN2@SkillHeali

; 1619 : 			{
; 1620 : 				LPOBJ lpMonster = &gObj[lpObj->VpPlayer2[n].number];

  0012b	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  0012f	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  00135	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1621 : 				if(lpMonster->m_iCurrentAI != 0)

  0013b	83 bf d0 20 00
	00 00		 cmp	 DWORD PTR [edi+8400], 0
  00142	74 39		 je	 SHORT $LN2@SkillHeali

; 1622 : 				{
; 1623 : 					lpMonster->m_Agro.IncAgro(lpObj->m_Index,(lpObj->Energy / 5)/40);

  00144	0f b7 8b d6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+214]
  0014b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00150	f7 e9		 imul	 ecx
  00152	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00157	d1 fa		 sar	 edx, 1
  00159	8b ca		 mov	 ecx, edx
  0015b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0015e	03 ca		 add	 ecx, edx
  00160	f7 e9		 imul	 ecx
  00162	8d 8f ec 20 00
	00		 lea	 ecx, DWORD PTR [edi+8428]
  00168	c1 fa 04	 sar	 edx, 4
  0016b	8b c2		 mov	 eax, edx
  0016d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00170	03 c2		 add	 eax, edx
  00172	50		 push	 eax
  00173	ff 33		 push	 DWORD PTR [ebx]
  00175	e8 00 00 00 00	 call	 ?IncAgro@TMonsterAIAgro@@QAEHHH@Z ; TMonsterAIAgro::IncAgro
  0017a	8b 4d 08	 mov	 ecx, DWORD PTR tv479[ebp]
$LN2@SkillHeali:

; 1615 : 
; 1616 : 		for(int n = 0; n < MAX_VIEWPORT; n++)

  0017d	83 c6 0c	 add	 esi, 12			; 0000000cH
  00180	83 e9 01	 sub	 ecx, 1
  00183	89 4d 08	 mov	 DWORD PTR tv479[ebp], ecx
  00186	75 98		 jne	 SHORT $LL4@SkillHeali

; 1624 : 				}
; 1625 : 			}
; 1626 : 		}
; 1627 : 	}
; 1628 : 	else if(lpTargetObj->m_RecallMon >= 0)

  00188	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTargetObj$1$[ebp]
  0018b	8b 7d fc	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  0018e	5e		 pop	 esi
  0018f	eb 21		 jmp	 SHORT $LN14@SkillHeali
$LN10@SkillHeali:
  00191	8b 8b 30 06 00
	00		 mov	 ecx, DWORD PTR [ebx+1584]
  00197	85 c9		 test	 ecx, ecx
  00199	78 17		 js	 SHORT $LN14@SkillHeali

; 1629 : 	{
; 1630 : 		GCRecallMonLife(lpTargetObj->m_RecallMon,(int)lpTargetObj->MaxLife,(int)lpTargetObj->Life);

  0019b	f3 0f 2c 83 d8
	00 00 00	 cvttss2si eax, DWORD PTR [ebx+216]
  001a3	50		 push	 eax
  001a4	f3 0f 2c c2	 cvttss2si eax, xmm2
  001a8	50		 push	 eax
  001a9	51		 push	 ecx
  001aa	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@SkillHeali:

; 1631 : 	}
; 1632 : 
; 1633 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpTargetObj->m_Index,skillSuccess);

  001b2	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001b5	6a 01		 push	 1
  001b7	ff 33		 push	 DWORD PTR [ebx]
  001b9	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  001bd	50		 push	 eax
  001be	57		 push	 edi
  001bf	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  001c4	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@SkillHeali:
  001c7	5f		 pop	 edi
  001c8	5b		 pop	 ebx

; 1634 : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 0c 00	 ret	 12			; 0000000cH
?SkillHealing@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillHealing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillChangeUse@CObjUseSkill@@QAEHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
?SkillChangeUse@CObjUseSkill@@QAEHH@Z PROC		; CObjUseSkill::SkillChangeUse, COMDAT
; _this$ = ecx

; 1360 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1361 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048

; 1362 : 
; 1363 : 	int skill_level = -1;

  00012	83 ce ff	 or	 esi, -1
  00015	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1364 : 
; 1365 : 	if(lpObj->Type != OBJ_USER)

  0001b	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0001f	75 6e		 jne	 SHORT $LN74@SkillChang

; 1366 : 	{
; 1367 : 		return false;
; 1368 : 	}
; 1369 : 
; 1370 : 	if(		lpObj->pInventory[10].IsItem() 
; 1371 : 		&&	lpObj->pInventory[10].m_Durability >= 1.0f 
; 1372 : 		&&	!lpObj->pInventory[10].m_bExpired )

  00021	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00027	81 c1 48 08 00
	00		 add	 ecx, 2120		; 00000848H
  0002d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00032	85 c0		 test	 eax, eax
  00034	0f 84 ab 00 00
	00		 je	 $LN2@SkillChang
  0003a	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00040	f3 0f 10 81 6c
	08 00 00	 movss	 xmm0, DWORD PTR [ecx+2156]
  00048	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0004f	0f 82 90 00 00
	00		 jb	 $LN2@SkillChang
  00055	80 b9 18 09 00
	00 00		 cmp	 BYTE PTR [ecx+2328], 0
  0005c	0f 85 83 00 00
	00		 jne	 $LN2@SkillChang

; 1373 : 	{
; 1374 : 		switch(lpObj->pInventory[10].m_Type)

  00062	0f bf 81 4e 08
	00 00		 movsx	 eax, WORD PTR [ecx+2126]
  00069	05 f6 e5 ff ff	 add	 eax, -6666		; ffffe5f6H
  0006e	3d 9c 00 00 00	 cmp	 eax, 156		; 0000009cH
  00073	77 70		 ja	 SHORT $LN2@SkillChang
  00075	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN72@SkillChang[eax]
  0007c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN76@SkillChang[eax*4]
$LN10@SkillChang:

; 1375 : 		{
; 1376 : 		case ITEMGET(13, 10):
; 1377 : 			skill_level = lpObj->pInventory[10].m_Level;

  00083	0f bf b1 50 08
	00 00		 movsx	 esi, WORD PTR [ecx+2128]

; 1378 : 			if( skill_level > 7 )

  0008a	83 fe 07	 cmp	 esi, 7
  0008d	7e 56		 jle	 SHORT $LN2@SkillChang
$LN74@SkillChang:
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi

; 1379 : 				return false;

  00091	33 c0		 xor	 eax, eax
  00093	5b		 pop	 ebx

; 1569 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
$LN12@SkillChang:

; 1380 : 			break;
; 1381 : 		case ITEMGET(13, 39):
; 1382 : 			skill_level = 372;

  0009a	be 74 01 00 00	 mov	 esi, 372		; 00000174H

; 1383 : 			break;

  0009f	eb 44		 jmp	 SHORT $LN2@SkillChang
$LN13@SkillChang:

; 1384 : 		case ITEMGET(13, 40):
; 1385 : 			skill_level = 373;

  000a1	be 75 01 00 00	 mov	 esi, 373		; 00000175H

; 1386 : 			break;

  000a6	eb 3d		 jmp	 SHORT $LN2@SkillChang
$LN14@SkillChang:

; 1387 : 		case ITEMGET(13, 41):
; 1388 : 			skill_level = 374;

  000a8	be 76 01 00 00	 mov	 esi, 374		; 00000176H

; 1389 : 			break;

  000ad	eb 36		 jmp	 SHORT $LN2@SkillChang
$LN15@SkillChang:

; 1390 : 		case ITEMGET(13, 42):
; 1391 : 			//if((lpObj->Authority & 32) != 32)
; 1392 : 			//{
; 1393 : 			//	return false;
; 1394 : 			//}
; 1395 : 			skill_level = 378;

  000af	be 7a 01 00 00	 mov	 esi, 378		; 0000017aH

; 1396 : 			break;

  000b4	eb 2f		 jmp	 SHORT $LN2@SkillChang
$LN16@SkillChang:

; 1397 : 		case ITEMGET(13, 68):
; 1398 : 			skill_level = 477;

  000b6	be dd 01 00 00	 mov	 esi, 477		; 000001ddH

; 1399 : 			break;

  000bb	eb 28		 jmp	 SHORT $LN2@SkillChang
$LN17@SkillChang:

; 1400 : 		case ITEMGET(13, 76):
; 1401 : 			skill_level = 503;

  000bd	be f7 01 00 00	 mov	 esi, 503		; 000001f7H

; 1402 : 			break;

  000c2	eb 21		 jmp	 SHORT $LN2@SkillChang
$LN20@SkillChang:

; 1403 : 		case ITEMGET(13, 77):
; 1404 : 			skill_level = 503;
; 1405 : 			break;
; 1406 : 		case ITEMGET(13, 78):
; 1407 : 			skill_level = 503;
; 1408 : 			break;
; 1409 : 		case ITEMGET(13, 122):
; 1410 : 			skill_level = 548;

  000c4	be 24 02 00 00	 mov	 esi, 548		; 00000224H

; 1411 : 			break;

  000c9	eb 1a		 jmp	 SHORT $LN2@SkillChang
$LN21@SkillChang:

; 1412 : 		case ITEMGET(13, 163):
; 1413 : 			skill_level = 625;

  000cb	be 71 02 00 00	 mov	 esi, 625		; 00000271H

; 1414 : 			break;

  000d0	eb 13		 jmp	 SHORT $LN2@SkillChang
$LN22@SkillChang:

; 1415 : 		case ITEMGET(13, 164):
; 1416 : 			skill_level = 626;

  000d2	be 72 02 00 00	 mov	 esi, 626		; 00000272H

; 1417 : 			break;

  000d7	eb 0c		 jmp	 SHORT $LN2@SkillChang
$LN23@SkillChang:

; 1418 : 		case ITEMGET(13, 165):
; 1419 : 			skill_level = 642;

  000d9	be 82 02 00 00	 mov	 esi, 642		; 00000282H

; 1420 : 			break;

  000de	eb 05		 jmp	 SHORT $LN2@SkillChang
$LN24@SkillChang:

; 1421 : 		case ITEMGET(13, 166):
; 1422 : 			skill_level = 646;

  000e0	be 86 02 00 00	 mov	 esi, 646		; 00000286H
$LN2@SkillChang:

; 1423 : 			break;
; 1424 : 		}
; 1425 : 	}
; 1426 : 
; 1427 : 	if(		lpObj->pInventory[11].IsItem() 
; 1428 : 		&&	skill_level == -1 
; 1429 : 		&&	lpObj->pInventory[11].m_Durability >= 1.0f 
; 1430 : 		&&	!lpObj->pInventory[11].m_bExpired )

  000e5	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  000eb	81 c1 1c 09 00
	00		 add	 ecx, 2332		; 0000091cH
  000f1	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000f6	85 c0		 test	 eax, eax
  000f8	0f 84 b4 00 00
	00		 je	 $LN4@SkillChang
  000fe	83 fe ff	 cmp	 esi, -1
  00101	0f 85 ab 00 00
	00		 jne	 $LN4@SkillChang
  00107	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  0010d	f3 0f 10 81 40
	09 00 00	 movss	 xmm0, DWORD PTR [ecx+2368]
  00115	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0011c	0f 82 90 00 00
	00		 jb	 $LN4@SkillChang
  00122	80 b9 ec 09 00
	00 00		 cmp	 BYTE PTR [ecx+2540], 0
  00129	0f 85 83 00 00
	00		 jne	 $LN4@SkillChang

; 1431 : 	{
; 1432 : 		switch(lpObj->pInventory[11].m_Type)

  0012f	0f bf 81 22 09
	00 00		 movsx	 eax, WORD PTR [ecx+2338]
  00136	05 f6 e5 ff ff	 add	 eax, -6666		; ffffe5f6H
  0013b	3d 9c 00 00 00	 cmp	 eax, 156		; 0000009cH
  00140	77 70		 ja	 SHORT $LN4@SkillChang
  00142	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN73@SkillChang[eax]
  00149	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN77@SkillChang[eax*4]
$LN26@SkillChang:

; 1433 : 		{
; 1434 : 		case ITEMGET(13,10):
; 1435 : 			skill_level = lpObj->pInventory[11].m_Level;

  00150	0f bf b1 24 09
	00 00		 movsx	 esi, WORD PTR [ecx+2340]

; 1436 : 			if( skill_level > 7 )

  00157	83 fe 07	 cmp	 esi, 7
  0015a	7e 56		 jle	 SHORT $LN4@SkillChang

; 1437 : 				return false;

  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	33 c0		 xor	 eax, eax
  00160	5b		 pop	 ebx

; 1569 : }

  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c2 04 00	 ret	 4
$LN28@SkillChang:

; 1438 : 			break;
; 1439 : 		case ITEMGET(13,39):
; 1440 : 			skill_level = 372;

  00167	be 74 01 00 00	 mov	 esi, 372		; 00000174H

; 1441 : 			break;

  0016c	eb 44		 jmp	 SHORT $LN4@SkillChang
$LN29@SkillChang:

; 1442 : 		case ITEMGET(13,40):
; 1443 : 			skill_level = 373;

  0016e	be 75 01 00 00	 mov	 esi, 373		; 00000175H

; 1444 : 			break;

  00173	eb 3d		 jmp	 SHORT $LN4@SkillChang
$LN30@SkillChang:

; 1445 : 		case ITEMGET(13,41):
; 1446 : 			skill_level = 374;

  00175	be 76 01 00 00	 mov	 esi, 374		; 00000176H

; 1447 : 			break;

  0017a	eb 36		 jmp	 SHORT $LN4@SkillChang
$LN31@SkillChang:

; 1448 : 		case ITEMGET(13,42):
; 1449 : 			//if((lpObj->Authority & 32) != 32)
; 1450 : 			//{
; 1451 : 			//	return false;
; 1452 : 			//}
; 1453 : 			skill_level = 378;

  0017c	be 7a 01 00 00	 mov	 esi, 378		; 0000017aH

; 1454 : 			break;

  00181	eb 2f		 jmp	 SHORT $LN4@SkillChang
$LN32@SkillChang:

; 1455 : 		case ITEMGET(13,68):
; 1456 : 			skill_level = 477;

  00183	be dd 01 00 00	 mov	 esi, 477		; 000001ddH

; 1457 : 			break;

  00188	eb 28		 jmp	 SHORT $LN4@SkillChang
$LN33@SkillChang:

; 1458 : 		case ITEMGET(13,76):
; 1459 : 			skill_level = 503;

  0018a	be f7 01 00 00	 mov	 esi, 503		; 000001f7H

; 1460 : 			break;

  0018f	eb 21		 jmp	 SHORT $LN4@SkillChang
$LN36@SkillChang:

; 1461 : 		case ITEMGET(13,77):
; 1462 : 			skill_level = 503;
; 1463 : 			break;
; 1464 : 		case ITEMGET(13,78):
; 1465 : 			skill_level = 503;
; 1466 : 			break;
; 1467 : 		case ITEMGET(13,122):
; 1468 : 			skill_level = 548;

  00191	be 24 02 00 00	 mov	 esi, 548		; 00000224H

; 1469 : 			break;

  00196	eb 1a		 jmp	 SHORT $LN4@SkillChang
$LN37@SkillChang:

; 1470 : 		case ITEMGET(13, 163):
; 1471 : 			skill_level = 625;

  00198	be 71 02 00 00	 mov	 esi, 625		; 00000271H

; 1472 : 			break;

  0019d	eb 13		 jmp	 SHORT $LN4@SkillChang
$LN38@SkillChang:

; 1473 : 		case ITEMGET(13, 164):
; 1474 : 			skill_level = 626;

  0019f	be 72 02 00 00	 mov	 esi, 626		; 00000272H

; 1475 : 			break;

  001a4	eb 0c		 jmp	 SHORT $LN4@SkillChang
$LN39@SkillChang:

; 1476 : 		case ITEMGET(13, 165):
; 1477 : 			skill_level = 642;

  001a6	be 82 02 00 00	 mov	 esi, 642		; 00000282H

; 1478 : 			break;

  001ab	eb 05		 jmp	 SHORT $LN4@SkillChang
$LN40@SkillChang:

; 1479 : 		case ITEMGET(13, 166):
; 1480 : 			skill_level = 646;

  001ad	be 86 02 00 00	 mov	 esi, 646		; 00000286H
$LN4@SkillChang:

; 1481 : 			break;
; 1482 : 		}
; 1483 : 	}
; 1484 : 
; 1485 : 	if( IT_MAP_RANGE(lpObj->MapNumber) )

  001b2	8a 8f 23 01 00
	00		 mov	 cl, BYTE PTR [edi+291]
  001b8	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  001bb	72 4b		 jb	 SHORT $LN45@SkillChang
  001bd	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  001c2	3a c1		 cmp	 al, cl
  001c4	1b c0		 sbb	 eax, eax
  001c6	83 c0 01	 add	 eax, 1
  001c9	74 3d		 je	 SHORT $LN45@SkillChang

; 1486 : 	{
; 1487 : 		if( g_IllusionTemple.GetState(lpObj->MapNumber) != IT_STATE_CLOSED )

  001cb	51		 push	 ecx
  001cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  001d1	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  001d6	84 c0		 test	 al, al
  001d8	74 2e		 je	 SHORT $LN45@SkillChang

; 1488 : 		{
; 1489 : 			int TEAM = g_IllusionTemple.GetTeam(lpObj->MapNumber,lpObj->m_Index);

  001da	ff 37		 push	 DWORD PTR [edi]
  001dc	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  001e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 ?GetTeam@CIllusionTempleEvent@@QAEEEH@Z ; CIllusionTempleEvent::GetTeam
  001ee	0f b6 c0	 movzx	 eax, al

; 1490 : 
; 1491 : 			if( TEAM == 0 )

  001f1	85 c0		 test	 eax, eax
  001f3	75 07		 jne	 SHORT $LN43@SkillChang

; 1492 : 			{
; 1493 : 				skill_level = 404;

  001f5	be 94 01 00 00	 mov	 esi, 404		; 00000194H
  001fa	eb 4a		 jmp	 SHORT $LN6@SkillChang
$LN43@SkillChang:

; 1494 : 			}
; 1495 : 			else if( TEAM == 1 )

  001fc	83 f8 01	 cmp	 eax, 1
  001ff	75 07		 jne	 SHORT $LN45@SkillChang

; 1496 : 			{
; 1497 : 				skill_level = 405;

  00201	be 95 01 00 00	 mov	 esi, 405		; 00000195H

; 1498 : 			}
; 1499 : 		}
; 1500 : 	}
; 1501 : 
; 1502 : 	int change = -1;
; 1503 : 
; 1504 : 	if( skill_level > 15 )

  00206	eb 3e		 jmp	 SHORT $LN6@SkillChang
$LN45@SkillChang:
  00208	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0020b	7f 39		 jg	 SHORT $LN6@SkillChang

; 1505 : 	{
; 1506 : 		change = skill_level;
; 1507 : 	}
; 1508 : 	else
; 1509 : 	{
; 1510 : 		switch(skill_level)

  0020d	83 fe 05	 cmp	 esi, 5
  00210	77 31		 ja	 SHORT $LN54@SkillChang
  00212	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN78@SkillChang[esi*4]
$LN48@SkillChang:

; 1511 : 		{
; 1512 : 		case 0: change = 2;		break;

  00219	be 02 00 00 00	 mov	 esi, 2
  0021e	eb 26		 jmp	 SHORT $LN6@SkillChang
$LN49@SkillChang:

; 1513 : 		case 1: change = 7;		break;

  00220	be 07 00 00 00	 mov	 esi, 7
  00225	eb 1f		 jmp	 SHORT $LN6@SkillChang
$LN50@SkillChang:

; 1514 : 		case 2: change = 14;	break;

  00227	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH
  0022c	eb 18		 jmp	 SHORT $LN6@SkillChang
$LN51@SkillChang:

; 1515 : 		case 3: change = 8;		break;

  0022e	be 08 00 00 00	 mov	 esi, 8
  00233	eb 11		 jmp	 SHORT $LN6@SkillChang
$LN52@SkillChang:

; 1516 : 		case 4:	change = 9;		break;

  00235	be 09 00 00 00	 mov	 esi, 9
  0023a	eb 0a		 jmp	 SHORT $LN6@SkillChang
$LN53@SkillChang:

; 1517 : 		case 5:	change = 41;	break;

  0023c	be 29 00 00 00	 mov	 esi, 41			; 00000029H
  00241	eb 03		 jmp	 SHORT $LN6@SkillChang
$LN54@SkillChang:

; 1518 : 			default: change = -1;	break;

  00243	83 ce ff	 or	 esi, -1
$LN6@SkillChang:

; 1519 : 		}
; 1520 : 	}
; 1521 : 
; 1522 : 	if(lpObj->m_Change >= 0 && lpObj->m_Change == change)

  00246	8b 87 34 06 00
	00		 mov	 eax, DWORD PTR [edi+1588]
  0024c	85 c0		 test	 eax, eax
  0024e	78 08		 js	 SHORT $LN55@SkillChang
  00250	3b c6		 cmp	 eax, esi
  00252	0f 84 37 fe ff
	ff		 je	 $LN74@SkillChang
$LN55@SkillChang:

; 1523 : 	{
; 1524 : 		return false;
; 1525 : 	}
; 1526 : 
; 1527 : 	if(lpObj->m_Change == 41 && change != 41)

  00258	83 f8 29	 cmp	 eax, 41			; 00000029H
  0025b	75 6e		 jne	 SHORT $LN56@SkillChang
  0025d	3b f0		 cmp	 esi, eax
  0025f	74 6a		 je	 SHORT $LN56@SkillChang

; 1528 : 	{
; 1529 : 		lpObj->AddLife = 0;
; 1530 : 
; 1531 : 		GCReFillSend(lpObj->m_Index,(WORD)lpObj->Life,0xFF,0,lpObj->iShield);

  00261	0f b7 87 2c 01
	00 00		 movzx	 eax, WORD PTR [edi+300]
  00268	50		 push	 eax
  00269	f3 0f 2c 87 d8
	00 00 00	 cvttss2si eax, DWORD PTR [edi+216]
  00271	6a 00		 push	 0
  00273	68 ff 00 00 00	 push	 255			; 000000ffH
  00278	c7 87 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+292], 0
  00282	0f b7 c0	 movzx	 eax, ax
  00285	50		 push	 eax
  00286	ff 37		 push	 DWORD PTR [edi]
  00288	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  0028d	66 0f 6e 87 24
	01 00 00	 movd	 xmm0, DWORD PTR [edi+292]

; 1532 : 		GCReFillSend(lpObj->m_Index,(WORD)(lpObj->MaxLife + lpObj->AddLife),0xFE,0,lpObj->iMaxShield + lpObj->iAddShield);

  00295	66 8b 87 34 01
	00 00		 mov	 ax, WORD PTR [edi+308]
  0029c	66 03 87 30 01
	00 00		 add	 ax, WORD PTR [edi+304]
  002a3	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002a6	0f b7 c0	 movzx	 eax, ax
  002a9	50		 push	 eax
  002aa	6a 00		 push	 0
  002ac	68 fe 00 00 00	 push	 254			; 000000feH
  002b1	f3 0f 58 87 dc
	00 00 00	 addss	 xmm0, DWORD PTR [edi+220]
  002b9	f3 0f 2c c0	 cvttss2si eax, xmm0
  002bd	0f b7 c0	 movzx	 eax, ax
  002c0	50		 push	 eax
  002c1	ff 37		 push	 DWORD PTR [edi]
  002c3	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  002c8	83 c4 28	 add	 esp, 40			; 00000028H
$LN56@SkillChang:

; 1533 : 	}
; 1534 : 
; 1535 : 	if(lpObj->m_Change == 372 && change != 372)

  002cb	81 bf 34 06 00
	00 74 01 00 00	 cmp	 DWORD PTR [edi+1588], 372 ; 00000174H
  002d5	75 79		 jne	 SHORT $LN57@SkillChang
  002d7	81 fe 74 01 00
	00		 cmp	 esi, 372		; 00000174H
  002dd	74 71		 je	 SHORT $LN57@SkillChang

; 1536 : 	{
; 1537 : 		lpObj->AddLife = 0;
; 1538 : 		gObjCalCharacter(lpObj->m_Index);

  002df	ff 37		 push	 DWORD PTR [edi]
  002e1	c7 87 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+292], 0
  002eb	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 1539 : 
; 1540 : 		GCReFillSend(lpObj->m_Index,(WORD)lpObj->Life,0xFF,0,lpObj->iShield);

  002f0	0f b7 87 2c 01
	00 00		 movzx	 eax, WORD PTR [edi+300]
  002f7	50		 push	 eax
  002f8	f3 0f 2c 87 d8
	00 00 00	 cvttss2si eax, DWORD PTR [edi+216]
  00300	6a 00		 push	 0
  00302	68 ff 00 00 00	 push	 255			; 000000ffH
  00307	0f b7 c0	 movzx	 eax, ax
  0030a	50		 push	 eax
  0030b	ff 37		 push	 DWORD PTR [edi]
  0030d	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  00312	66 0f 6e 87 24
	01 00 00	 movd	 xmm0, DWORD PTR [edi+292]

; 1541 : 		GCReFillSend(lpObj->m_Index,(WORD)(lpObj->MaxLife + lpObj->AddLife),0xFE,0,lpObj->iMaxShield + lpObj->iAddShield);

  0031a	66 8b 87 34 01
	00 00		 mov	 ax, WORD PTR [edi+308]
  00321	66 03 87 30 01
	00 00		 add	 ax, WORD PTR [edi+304]
  00328	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0032b	0f b7 c0	 movzx	 eax, ax
  0032e	50		 push	 eax
  0032f	6a 00		 push	 0
  00331	68 fe 00 00 00	 push	 254			; 000000feH
  00336	f3 0f 58 87 dc
	00 00 00	 addss	 xmm0, DWORD PTR [edi+220]
  0033e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00342	0f b7 c0	 movzx	 eax, ax
  00345	50		 push	 eax
  00346	ff 37		 push	 DWORD PTR [edi]
  00348	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  0034d	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN57@SkillChang:

; 1542 : 	}
; 1543 : 
; 1544 : 	if(lpObj->m_Change == 374 && change != 374)

  00350	81 bf 34 06 00
	00 76 01 00 00	 cmp	 DWORD PTR [edi+1588], 374 ; 00000176H
  0035a	75 32		 jne	 SHORT $LN58@SkillChang
  0035c	81 fe 76 01 00
	00		 cmp	 esi, 374		; 00000176H
  00362	74 2a		 je	 SHORT $LN58@SkillChang

; 1545 : 	{
; 1546 : 		lpObj->m_AttackDamageMaxLeft -= 20;

  00364	83 87 58 06 00
	00 ec		 add	 DWORD PTR [edi+1624], -20 ; ffffffecH
  0036b	83 87 5c 06 00
	00 ec		 add	 DWORD PTR [edi+1628], -20 ; ffffffecH
  00372	83 87 60 06 00
	00 ec		 add	 DWORD PTR [edi+1632], -20 ; ffffffecH
  00379	83 87 64 06 00
	00 ec		 add	 DWORD PTR [edi+1636], -20 ; ffffffecH

; 1547 : 		lpObj->m_AttackDamageMinLeft -= 20;
; 1548 : 		lpObj->m_AttackDamageMaxRight -= 20;
; 1549 : 		lpObj->m_AttackDamageMinRight -= 20;
; 1550 : 		lpObj->m_MagicDamageMin -= 20;

  00380	83 87 48 06 00
	00 ec		 add	 DWORD PTR [edi+1608], -20 ; ffffffecH

; 1551 : 		lpObj->m_MagicDamageMax -= 20;

  00387	83 87 4c 06 00
	00 ec		 add	 DWORD PTR [edi+1612], -20 ; ffffffecH
$LN58@SkillChang:

; 1552 : 	}
; 1553 : 
; 1554 : 	lpObj->m_Change = change;
; 1555 : 	gObjViewportListProtocolCreate(lpObj);

  0038e	57		 push	 edi
  0038f	89 b7 34 06 00
	00		 mov	 DWORD PTR [edi+1588], esi
  00395	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  0039a	83 c4 04	 add	 esp, 4

; 1556 : 
; 1557 : #if (GS_CASTLE == 1)
; 1558 : 	g_CastleSiege.NotifySelfCsJoinSide(lpObj->m_Index);

  0039d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  003a2	ff 37		 push	 DWORD PTR [edi]
  003a4	e8 00 00 00 00	 call	 ?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifySelfCsJoinSide

; 1559 : #endif
; 1560 : 
; 1561 : 	PMSG_KILLCOUNT pMsg = {0};
; 1562 : 
; 1563 : 	PHeadSubSetB((LPBYTE)&pMsg,0xB8,0x01,sizeof(pMsg));

  003a9	6a 05		 push	 5
  003ab	6a 01		 push	 1
  003ad	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003b0	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  003b4	68 b8 00 00 00	 push	 184			; 000000b8H
  003b9	50		 push	 eax
  003ba	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  003c1	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1564 : 
; 1565 : 	pMsg.btKillCount = lpObj->m_btKillCount;

  003c6	8a 87 64 20 00
	00		 mov	 al, BYTE PTR [edi+8292]
  003cc	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 1566 : 
; 1567 : 	DataSend(aIndex,(PBYTE)&pMsg,sizeof(pMsg));

  003cf	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003d2	6a 05		 push	 5
  003d4	50		 push	 eax
  003d5	53		 push	 ebx
  003d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003db	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1568 : 	return true;

  003de	b8 01 00 00 00	 mov	 eax, 1
  003e3	5f		 pop	 edi
  003e4	5e		 pop	 esi
  003e5	5b		 pop	 ebx

; 1569 : }

  003e6	8b e5		 mov	 esp, ebp
  003e8	5d		 pop	 ebp
  003e9	c2 04 00	 ret	 4
$LN76@SkillChang:
  003ec	00 00 00 00	 DD	 $LN10@SkillChang
  003f0	00 00 00 00	 DD	 $LN12@SkillChang
  003f4	00 00 00 00	 DD	 $LN13@SkillChang
  003f8	00 00 00 00	 DD	 $LN14@SkillChang
  003fc	00 00 00 00	 DD	 $LN15@SkillChang
  00400	00 00 00 00	 DD	 $LN16@SkillChang
  00404	00 00 00 00	 DD	 $LN17@SkillChang
  00408	00 00 00 00	 DD	 $LN20@SkillChang
  0040c	00 00 00 00	 DD	 $LN21@SkillChang
  00410	00 00 00 00	 DD	 $LN22@SkillChang
  00414	00 00 00 00	 DD	 $LN23@SkillChang
  00418	00 00 00 00	 DD	 $LN24@SkillChang
  0041c	00 00 00 00	 DD	 $LN2@SkillChang
$LN72@SkillChang:
  00420	00		 DB	 0
  00421	0c		 DB	 12			; 0000000cH
  00422	0c		 DB	 12			; 0000000cH
  00423	0c		 DB	 12			; 0000000cH
  00424	0c		 DB	 12			; 0000000cH
  00425	0c		 DB	 12			; 0000000cH
  00426	0c		 DB	 12			; 0000000cH
  00427	0c		 DB	 12			; 0000000cH
  00428	0c		 DB	 12			; 0000000cH
  00429	0c		 DB	 12			; 0000000cH
  0042a	0c		 DB	 12			; 0000000cH
  0042b	0c		 DB	 12			; 0000000cH
  0042c	0c		 DB	 12			; 0000000cH
  0042d	0c		 DB	 12			; 0000000cH
  0042e	0c		 DB	 12			; 0000000cH
  0042f	0c		 DB	 12			; 0000000cH
  00430	0c		 DB	 12			; 0000000cH
  00431	0c		 DB	 12			; 0000000cH
  00432	0c		 DB	 12			; 0000000cH
  00433	0c		 DB	 12			; 0000000cH
  00434	0c		 DB	 12			; 0000000cH
  00435	0c		 DB	 12			; 0000000cH
  00436	0c		 DB	 12			; 0000000cH
  00437	0c		 DB	 12			; 0000000cH
  00438	0c		 DB	 12			; 0000000cH
  00439	0c		 DB	 12			; 0000000cH
  0043a	0c		 DB	 12			; 0000000cH
  0043b	0c		 DB	 12			; 0000000cH
  0043c	0c		 DB	 12			; 0000000cH
  0043d	01		 DB	 1
  0043e	02		 DB	 2
  0043f	03		 DB	 3
  00440	04		 DB	 4
  00441	0c		 DB	 12			; 0000000cH
  00442	0c		 DB	 12			; 0000000cH
  00443	0c		 DB	 12			; 0000000cH
  00444	0c		 DB	 12			; 0000000cH
  00445	0c		 DB	 12			; 0000000cH
  00446	0c		 DB	 12			; 0000000cH
  00447	0c		 DB	 12			; 0000000cH
  00448	0c		 DB	 12			; 0000000cH
  00449	0c		 DB	 12			; 0000000cH
  0044a	0c		 DB	 12			; 0000000cH
  0044b	0c		 DB	 12			; 0000000cH
  0044c	0c		 DB	 12			; 0000000cH
  0044d	0c		 DB	 12			; 0000000cH
  0044e	0c		 DB	 12			; 0000000cH
  0044f	0c		 DB	 12			; 0000000cH
  00450	0c		 DB	 12			; 0000000cH
  00451	0c		 DB	 12			; 0000000cH
  00452	0c		 DB	 12			; 0000000cH
  00453	0c		 DB	 12			; 0000000cH
  00454	0c		 DB	 12			; 0000000cH
  00455	0c		 DB	 12			; 0000000cH
  00456	0c		 DB	 12			; 0000000cH
  00457	0c		 DB	 12			; 0000000cH
  00458	0c		 DB	 12			; 0000000cH
  00459	0c		 DB	 12			; 0000000cH
  0045a	05		 DB	 5
  0045b	0c		 DB	 12			; 0000000cH
  0045c	0c		 DB	 12			; 0000000cH
  0045d	0c		 DB	 12			; 0000000cH
  0045e	0c		 DB	 12			; 0000000cH
  0045f	0c		 DB	 12			; 0000000cH
  00460	0c		 DB	 12			; 0000000cH
  00461	0c		 DB	 12			; 0000000cH
  00462	06		 DB	 6
  00463	06		 DB	 6
  00464	06		 DB	 6
  00465	0c		 DB	 12			; 0000000cH
  00466	0c		 DB	 12			; 0000000cH
  00467	0c		 DB	 12			; 0000000cH
  00468	0c		 DB	 12			; 0000000cH
  00469	0c		 DB	 12			; 0000000cH
  0046a	0c		 DB	 12			; 0000000cH
  0046b	0c		 DB	 12			; 0000000cH
  0046c	0c		 DB	 12			; 0000000cH
  0046d	0c		 DB	 12			; 0000000cH
  0046e	0c		 DB	 12			; 0000000cH
  0046f	0c		 DB	 12			; 0000000cH
  00470	0c		 DB	 12			; 0000000cH
  00471	0c		 DB	 12			; 0000000cH
  00472	0c		 DB	 12			; 0000000cH
  00473	0c		 DB	 12			; 0000000cH
  00474	0c		 DB	 12			; 0000000cH
  00475	0c		 DB	 12			; 0000000cH
  00476	0c		 DB	 12			; 0000000cH
  00477	0c		 DB	 12			; 0000000cH
  00478	0c		 DB	 12			; 0000000cH
  00479	0c		 DB	 12			; 0000000cH
  0047a	0c		 DB	 12			; 0000000cH
  0047b	0c		 DB	 12			; 0000000cH
  0047c	0c		 DB	 12			; 0000000cH
  0047d	0c		 DB	 12			; 0000000cH
  0047e	0c		 DB	 12			; 0000000cH
  0047f	0c		 DB	 12			; 0000000cH
  00480	0c		 DB	 12			; 0000000cH
  00481	0c		 DB	 12			; 0000000cH
  00482	0c		 DB	 12			; 0000000cH
  00483	0c		 DB	 12			; 0000000cH
  00484	0c		 DB	 12			; 0000000cH
  00485	0c		 DB	 12			; 0000000cH
  00486	0c		 DB	 12			; 0000000cH
  00487	0c		 DB	 12			; 0000000cH
  00488	0c		 DB	 12			; 0000000cH
  00489	0c		 DB	 12			; 0000000cH
  0048a	0c		 DB	 12			; 0000000cH
  0048b	0c		 DB	 12			; 0000000cH
  0048c	0c		 DB	 12			; 0000000cH
  0048d	0c		 DB	 12			; 0000000cH
  0048e	0c		 DB	 12			; 0000000cH
  0048f	0c		 DB	 12			; 0000000cH
  00490	07		 DB	 7
  00491	0c		 DB	 12			; 0000000cH
  00492	0c		 DB	 12			; 0000000cH
  00493	0c		 DB	 12			; 0000000cH
  00494	0c		 DB	 12			; 0000000cH
  00495	0c		 DB	 12			; 0000000cH
  00496	0c		 DB	 12			; 0000000cH
  00497	0c		 DB	 12			; 0000000cH
  00498	0c		 DB	 12			; 0000000cH
  00499	0c		 DB	 12			; 0000000cH
  0049a	0c		 DB	 12			; 0000000cH
  0049b	0c		 DB	 12			; 0000000cH
  0049c	0c		 DB	 12			; 0000000cH
  0049d	0c		 DB	 12			; 0000000cH
  0049e	0c		 DB	 12			; 0000000cH
  0049f	0c		 DB	 12			; 0000000cH
  004a0	0c		 DB	 12			; 0000000cH
  004a1	0c		 DB	 12			; 0000000cH
  004a2	0c		 DB	 12			; 0000000cH
  004a3	0c		 DB	 12			; 0000000cH
  004a4	0c		 DB	 12			; 0000000cH
  004a5	0c		 DB	 12			; 0000000cH
  004a6	0c		 DB	 12			; 0000000cH
  004a7	0c		 DB	 12			; 0000000cH
  004a8	0c		 DB	 12			; 0000000cH
  004a9	0c		 DB	 12			; 0000000cH
  004aa	0c		 DB	 12			; 0000000cH
  004ab	0c		 DB	 12			; 0000000cH
  004ac	0c		 DB	 12			; 0000000cH
  004ad	0c		 DB	 12			; 0000000cH
  004ae	0c		 DB	 12			; 0000000cH
  004af	0c		 DB	 12			; 0000000cH
  004b0	0c		 DB	 12			; 0000000cH
  004b1	0c		 DB	 12			; 0000000cH
  004b2	0c		 DB	 12			; 0000000cH
  004b3	0c		 DB	 12			; 0000000cH
  004b4	0c		 DB	 12			; 0000000cH
  004b5	0c		 DB	 12			; 0000000cH
  004b6	0c		 DB	 12			; 0000000cH
  004b7	0c		 DB	 12			; 0000000cH
  004b8	0c		 DB	 12			; 0000000cH
  004b9	08		 DB	 8
  004ba	09		 DB	 9
  004bb	0a		 DB	 10			; 0000000aH
  004bc	0b		 DB	 11			; 0000000bH
  004bd	0f 1f 00	 npad	 3
$LN77@SkillChang:
  004c0	00 00 00 00	 DD	 $LN26@SkillChang
  004c4	00 00 00 00	 DD	 $LN28@SkillChang
  004c8	00 00 00 00	 DD	 $LN29@SkillChang
  004cc	00 00 00 00	 DD	 $LN30@SkillChang
  004d0	00 00 00 00	 DD	 $LN31@SkillChang
  004d4	00 00 00 00	 DD	 $LN32@SkillChang
  004d8	00 00 00 00	 DD	 $LN33@SkillChang
  004dc	00 00 00 00	 DD	 $LN36@SkillChang
  004e0	00 00 00 00	 DD	 $LN37@SkillChang
  004e4	00 00 00 00	 DD	 $LN38@SkillChang
  004e8	00 00 00 00	 DD	 $LN39@SkillChang
  004ec	00 00 00 00	 DD	 $LN40@SkillChang
  004f0	00 00 00 00	 DD	 $LN4@SkillChang
$LN73@SkillChang:
  004f4	00		 DB	 0
  004f5	0c		 DB	 12			; 0000000cH
  004f6	0c		 DB	 12			; 0000000cH
  004f7	0c		 DB	 12			; 0000000cH
  004f8	0c		 DB	 12			; 0000000cH
  004f9	0c		 DB	 12			; 0000000cH
  004fa	0c		 DB	 12			; 0000000cH
  004fb	0c		 DB	 12			; 0000000cH
  004fc	0c		 DB	 12			; 0000000cH
  004fd	0c		 DB	 12			; 0000000cH
  004fe	0c		 DB	 12			; 0000000cH
  004ff	0c		 DB	 12			; 0000000cH
  00500	0c		 DB	 12			; 0000000cH
  00501	0c		 DB	 12			; 0000000cH
  00502	0c		 DB	 12			; 0000000cH
  00503	0c		 DB	 12			; 0000000cH
  00504	0c		 DB	 12			; 0000000cH
  00505	0c		 DB	 12			; 0000000cH
  00506	0c		 DB	 12			; 0000000cH
  00507	0c		 DB	 12			; 0000000cH
  00508	0c		 DB	 12			; 0000000cH
  00509	0c		 DB	 12			; 0000000cH
  0050a	0c		 DB	 12			; 0000000cH
  0050b	0c		 DB	 12			; 0000000cH
  0050c	0c		 DB	 12			; 0000000cH
  0050d	0c		 DB	 12			; 0000000cH
  0050e	0c		 DB	 12			; 0000000cH
  0050f	0c		 DB	 12			; 0000000cH
  00510	0c		 DB	 12			; 0000000cH
  00511	01		 DB	 1
  00512	02		 DB	 2
  00513	03		 DB	 3
  00514	04		 DB	 4
  00515	0c		 DB	 12			; 0000000cH
  00516	0c		 DB	 12			; 0000000cH
  00517	0c		 DB	 12			; 0000000cH
  00518	0c		 DB	 12			; 0000000cH
  00519	0c		 DB	 12			; 0000000cH
  0051a	0c		 DB	 12			; 0000000cH
  0051b	0c		 DB	 12			; 0000000cH
  0051c	0c		 DB	 12			; 0000000cH
  0051d	0c		 DB	 12			; 0000000cH
  0051e	0c		 DB	 12			; 0000000cH
  0051f	0c		 DB	 12			; 0000000cH
  00520	0c		 DB	 12			; 0000000cH
  00521	0c		 DB	 12			; 0000000cH
  00522	0c		 DB	 12			; 0000000cH
  00523	0c		 DB	 12			; 0000000cH
  00524	0c		 DB	 12			; 0000000cH
  00525	0c		 DB	 12			; 0000000cH
  00526	0c		 DB	 12			; 0000000cH
  00527	0c		 DB	 12			; 0000000cH
  00528	0c		 DB	 12			; 0000000cH
  00529	0c		 DB	 12			; 0000000cH
  0052a	0c		 DB	 12			; 0000000cH
  0052b	0c		 DB	 12			; 0000000cH
  0052c	0c		 DB	 12			; 0000000cH
  0052d	0c		 DB	 12			; 0000000cH
  0052e	05		 DB	 5
  0052f	0c		 DB	 12			; 0000000cH
  00530	0c		 DB	 12			; 0000000cH
  00531	0c		 DB	 12			; 0000000cH
  00532	0c		 DB	 12			; 0000000cH
  00533	0c		 DB	 12			; 0000000cH
  00534	0c		 DB	 12			; 0000000cH
  00535	0c		 DB	 12			; 0000000cH
  00536	06		 DB	 6
  00537	06		 DB	 6
  00538	06		 DB	 6
  00539	0c		 DB	 12			; 0000000cH
  0053a	0c		 DB	 12			; 0000000cH
  0053b	0c		 DB	 12			; 0000000cH
  0053c	0c		 DB	 12			; 0000000cH
  0053d	0c		 DB	 12			; 0000000cH
  0053e	0c		 DB	 12			; 0000000cH
  0053f	0c		 DB	 12			; 0000000cH
  00540	0c		 DB	 12			; 0000000cH
  00541	0c		 DB	 12			; 0000000cH
  00542	0c		 DB	 12			; 0000000cH
  00543	0c		 DB	 12			; 0000000cH
  00544	0c		 DB	 12			; 0000000cH
  00545	0c		 DB	 12			; 0000000cH
  00546	0c		 DB	 12			; 0000000cH
  00547	0c		 DB	 12			; 0000000cH
  00548	0c		 DB	 12			; 0000000cH
  00549	0c		 DB	 12			; 0000000cH
  0054a	0c		 DB	 12			; 0000000cH
  0054b	0c		 DB	 12			; 0000000cH
  0054c	0c		 DB	 12			; 0000000cH
  0054d	0c		 DB	 12			; 0000000cH
  0054e	0c		 DB	 12			; 0000000cH
  0054f	0c		 DB	 12			; 0000000cH
  00550	0c		 DB	 12			; 0000000cH
  00551	0c		 DB	 12			; 0000000cH
  00552	0c		 DB	 12			; 0000000cH
  00553	0c		 DB	 12			; 0000000cH
  00554	0c		 DB	 12			; 0000000cH
  00555	0c		 DB	 12			; 0000000cH
  00556	0c		 DB	 12			; 0000000cH
  00557	0c		 DB	 12			; 0000000cH
  00558	0c		 DB	 12			; 0000000cH
  00559	0c		 DB	 12			; 0000000cH
  0055a	0c		 DB	 12			; 0000000cH
  0055b	0c		 DB	 12			; 0000000cH
  0055c	0c		 DB	 12			; 0000000cH
  0055d	0c		 DB	 12			; 0000000cH
  0055e	0c		 DB	 12			; 0000000cH
  0055f	0c		 DB	 12			; 0000000cH
  00560	0c		 DB	 12			; 0000000cH
  00561	0c		 DB	 12			; 0000000cH
  00562	0c		 DB	 12			; 0000000cH
  00563	0c		 DB	 12			; 0000000cH
  00564	07		 DB	 7
  00565	0c		 DB	 12			; 0000000cH
  00566	0c		 DB	 12			; 0000000cH
  00567	0c		 DB	 12			; 0000000cH
  00568	0c		 DB	 12			; 0000000cH
  00569	0c		 DB	 12			; 0000000cH
  0056a	0c		 DB	 12			; 0000000cH
  0056b	0c		 DB	 12			; 0000000cH
  0056c	0c		 DB	 12			; 0000000cH
  0056d	0c		 DB	 12			; 0000000cH
  0056e	0c		 DB	 12			; 0000000cH
  0056f	0c		 DB	 12			; 0000000cH
  00570	0c		 DB	 12			; 0000000cH
  00571	0c		 DB	 12			; 0000000cH
  00572	0c		 DB	 12			; 0000000cH
  00573	0c		 DB	 12			; 0000000cH
  00574	0c		 DB	 12			; 0000000cH
  00575	0c		 DB	 12			; 0000000cH
  00576	0c		 DB	 12			; 0000000cH
  00577	0c		 DB	 12			; 0000000cH
  00578	0c		 DB	 12			; 0000000cH
  00579	0c		 DB	 12			; 0000000cH
  0057a	0c		 DB	 12			; 0000000cH
  0057b	0c		 DB	 12			; 0000000cH
  0057c	0c		 DB	 12			; 0000000cH
  0057d	0c		 DB	 12			; 0000000cH
  0057e	0c		 DB	 12			; 0000000cH
  0057f	0c		 DB	 12			; 0000000cH
  00580	0c		 DB	 12			; 0000000cH
  00581	0c		 DB	 12			; 0000000cH
  00582	0c		 DB	 12			; 0000000cH
  00583	0c		 DB	 12			; 0000000cH
  00584	0c		 DB	 12			; 0000000cH
  00585	0c		 DB	 12			; 0000000cH
  00586	0c		 DB	 12			; 0000000cH
  00587	0c		 DB	 12			; 0000000cH
  00588	0c		 DB	 12			; 0000000cH
  00589	0c		 DB	 12			; 0000000cH
  0058a	0c		 DB	 12			; 0000000cH
  0058b	0c		 DB	 12			; 0000000cH
  0058c	0c		 DB	 12			; 0000000cH
  0058d	08		 DB	 8
  0058e	09		 DB	 9
  0058f	0a		 DB	 10			; 0000000aH
  00590	0b		 DB	 11			; 0000000bH
  00591	0f 1f 00	 npad	 3
$LN78@SkillChang:
  00594	00 00 00 00	 DD	 $LN48@SkillChang
  00598	00 00 00 00	 DD	 $LN49@SkillChang
  0059c	00 00 00 00	 DD	 $LN50@SkillChang
  005a0	00 00 00 00	 DD	 $LN51@SkillChang
  005a4	00 00 00 00	 DD	 $LN52@SkillChang
  005a8	00 00 00 00	 DD	 $LN53@SkillChang
?SkillChangeUse@CObjUseSkill@@QAEHH@Z ENDP		; CObjUseSkill::SkillChangeUse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillAttack@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpTargetObj$1$ = -4					; size = 4
tv433 = 8						; size = 4
_aIndex$ = 8						; size = 4
tv425 = 12						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillAttack@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillAttack, COMDAT
; _this$ = ecx

; 1299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1300 : 	int skillSuccess = true;
; 1301 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	53		 push	 ebx

; 1302 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000a	69 5d 0c 40 27
	00 00		 imul	 ebx, DWORD PTR _aTargetIndex$[ebp], 10048
  00011	57		 push	 edi
  00012	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00019	03 d8		 add	 ebx, eax
  0001b	89 5d fc	 mov	 DWORD PTR _lpTargetObj$1$[ebp], ebx
  0001e	03 f8		 add	 edi, eax

; 1303 : 
; 1304 : 	if(lpTargetObj->Type != OBJ_USER && lpTargetObj->m_RecallMon == -1)

  00020	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  00024	74 0d		 je	 SHORT $LN5@SkillAttac
  00026	83 bb 30 06 00
	00 ff		 cmp	 DWORD PTR [ebx+1584], -1
  0002d	0f 84 2b 01 00
	00		 je	 $LN1@SkillAttac
$LN5@SkillAttac:

; 1305 : 	{
; 1306 : 		return;
; 1307 : 	}
; 1308 : 
; 1309 : 	if(lpObj->Class != CLASS_ELF)

  00033	66 83 bf 90 00
	00 00 02	 cmp	 WORD PTR [edi+144], 2
  0003b	0f 85 1d 01 00
	00		 jne	 $LN1@SkillAttac

; 1310 : 	{
; 1311 : 		return;
; 1312 : 	}
; 1313 : 
; 1314 : 	if(CC_MAP_RANGE(lpObj->MapNumber) && lpObj->m_Index != lpTargetObj->m_Index)

  00041	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  00047	3c 35		 cmp	 al, 53			; 00000035H
  00049	74 0f		 je	 SHORT $LN22@SkillAttac
  0004b	3c 12		 cmp	 al, 18			; 00000012H
  0004d	72 15		 jb	 SHORT $LN7@SkillAttac
  0004f	b1 17		 mov	 cl, 23			; 00000017H
  00051	3a c8		 cmp	 cl, al
  00053	1b c0		 sbb	 eax, eax
  00055	83 c0 01	 add	 eax, 1
  00058	74 0a		 je	 SHORT $LN7@SkillAttac
$LN22@SkillAttac:
  0005a	8b 07		 mov	 eax, DWORD PTR [edi]
  0005c	3b 03		 cmp	 eax, DWORD PTR [ebx]
  0005e	0f 85 fa 00 00
	00		 jne	 $LN1@SkillAttac
$LN7@SkillAttac:

; 1315 : 	{
; 1316 : 		return;
; 1317 : 	}
; 1318 : 
; 1319 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00064	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  0006c	ff 70 08	 push	 DWORD PTR [eax+8]
  0006f	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect

; 1320 : 
; 1321 : 	if( !lpInfo )

  00074	85 c0		 test	 eax, eax
  00076	0f 84 e2 00 00
	00		 je	 $LN1@SkillAttac

; 1322 : 	{
; 1323 : 		return;
; 1324 : 	}
; 1325 : 
; 1326 : 	float skill_attack = (float)lpInfo->m_Arg1 + (lpObj->Energy + lpObj->AddEnergy) / lpInfo->m_Arg2;

  0007c	0f b7 97 02 01
	00 00		 movzx	 edx, WORD PTR [edi+258]
  00083	0f b7 8f d6 00
	00 00		 movzx	 ecx, WORD PTR [edi+214]
  0008a	03 d1		 add	 edx, ecx

; 1327 : 
; 1328 : 	if( skill_attack > lpInfo->m_Arg3 )

  0008c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00091	66 0f 6e ca	 movd	 xmm1, edx
  00095	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00098	f3 0f 5e 48 08	 divss	 xmm1, DWORD PTR [eax+8]
  0009d	f3 0f 58 48 04	 addss	 xmm1, DWORD PTR [eax+4]
  000a2	0f 2f c8	 comiss	 xmm1, xmm0
  000a5	76 03		 jbe	 SHORT $LN9@SkillAttac

; 1329 : 	{
; 1330 : 		skill_attack = lpInfo->m_Arg3;

  000a7	0f 28 c8	 movaps	 xmm1, xmm0
$LN9@SkillAttac:

; 1331 : 	}
; 1332 : 
; 1333 : 	if(lpTargetObj->Class == CLASS_KNIGHT)

  000aa	66 83 bb 90 00
	00 00 01	 cmp	 WORD PTR [ebx+144], 1
  000b2	75 0f		 jne	 SHORT $LN10@SkillAttac

; 1334 : 	{
; 1335 : 		skill_attack += skill_attack/10.0f;

  000b4	0f 28 c1	 movaps	 xmm0, xmm1
  000b7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  000bf	f3 0f 58 c8	 addss	 xmm1, xmm0
$LN10@SkillAttac:

; 1336 : 	}
; 1337 : 
; 1338 : 	gObjAddBuffEffect(lpTargetObj,BUFF_ADD_ATTACK,ADD_OPTION_ATTACK_DAMAGE,(int)skill_attack,0,0,lpInfo->m_Arg4);

  000c3	f3 0f 2c 40 10	 cvttss2si eax, DWORD PTR [eax+16]
  000c8	56		 push	 esi
  000c9	f3 0f 2c c9	 cvttss2si ecx, xmm1
  000cd	50		 push	 eax
  000ce	6a 00		 push	 0
  000d0	6a 00		 push	 0
  000d2	51		 push	 ecx
  000d3	6a 02		 push	 2
  000d5	6a 01		 push	 1
  000d7	53		 push	 ebx
  000d8	89 4d 0c	 mov	 DWORD PTR tv425[ebp], ecx
  000db	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  000e0	8b 5d 0c	 mov	 ebx, DWORD PTR tv425[ebp]
  000e3	8d b7 48 0c 00
	00		 lea	 esi, DWORD PTR [edi+3144]
  000e9	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  000ee	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f1	89 55 08	 mov	 DWORD PTR tv433[ebp], edx
$LL4@SkillAttac:

; 1342 : 	{
; 1343 : 		if(lpObj->VpPlayer2[n].type == OBJ_MONSTER && lpObj->VpPlayer2[n].state != 0)

  000f4	80 7e 04 02	 cmp	 BYTE PTR [esi+4], 2
  000f8	75 40		 jne	 SHORT $LN2@SkillAttac
  000fa	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000fd	74 3b		 je	 SHORT $LN2@SkillAttac

; 1344 : 		{
; 1345 : 			LPOBJ lpMonster = &gObj[lpObj->VpPlayer2[n].number];

  000ff	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  00103	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00109	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1346 : 			if(lpMonster->m_iCurrentAI != 0)

  0010f	83 b9 d0 20 00
	00 00		 cmp	 DWORD PTR [ecx+8400], 0
  00116	74 22		 je	 SHORT $LN2@SkillAttac

; 1347 : 			{
; 1348 : 				lpMonster->m_Agro.IncAgro(lpObj->m_Index,int(skill_attack)/10);

  00118	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0011d	81 c1 ec 20 00
	00		 add	 ecx, 8428		; 000020ecH
  00123	f7 eb		 imul	 ebx
  00125	c1 fa 02	 sar	 edx, 2
  00128	8b c2		 mov	 eax, edx
  0012a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0012d	03 c2		 add	 eax, edx
  0012f	50		 push	 eax
  00130	ff 37		 push	 DWORD PTR [edi]
  00132	e8 00 00 00 00	 call	 ?IncAgro@TMonsterAIAgro@@QAEHHH@Z ; TMonsterAIAgro::IncAgro
  00137	8b 55 08	 mov	 edx, DWORD PTR tv433[ebp]
$LN2@SkillAttac:

; 1339 : 
; 1340 : 
; 1341 : 	for(int n = 0; n < MAX_VIEWPORT; n++)

  0013a	83 c6 0c	 add	 esi, 12			; 0000000cH
  0013d	83 ea 01	 sub	 edx, 1
  00140	89 55 08	 mov	 DWORD PTR tv433[ebp], edx
  00143	75 af		 jne	 SHORT $LL4@SkillAttac

; 1349 : 			}
; 1350 : 		}
; 1351 : 	}
; 1352 : 
; 1353 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpTargetObj->m_Index,skillSuccess);

  00145	8b 5d fc	 mov	 ebx, DWORD PTR _lpTargetObj$1$[ebp]
  00148	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0014b	6a 01		 push	 1
  0014d	ff 33		 push	 DWORD PTR [ebx]
  0014f	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00153	50		 push	 eax
  00154	57		 push	 edi
  00155	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0015a	83 c4 10	 add	 esp, 16			; 00000010H
  0015d	5e		 pop	 esi
$LN1@SkillAttac:
  0015e	5f		 pop	 edi
  0015f	5b		 pop	 ebx

; 1354 : }

  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 0c 00	 ret	 12			; 0000000cH
?SkillAttack@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpTargetObj$1$ = -4					; size = 4
tv433 = 8						; size = 4
_aIndex$ = 8						; size = 4
tv426 = 12						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?SkillDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::SkillDefense, COMDAT
; _this$ = ecx

; 1238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1239 : 	int skillSuccess = true;
; 1240 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	53		 push	 ebx

; 1241 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000a	69 5d 0c 40 27
	00 00		 imul	 ebx, DWORD PTR _aTargetIndex$[ebp], 10048
  00011	57		 push	 edi
  00012	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00019	03 d8		 add	 ebx, eax
  0001b	89 5d fc	 mov	 DWORD PTR _lpTargetObj$1$[ebp], ebx
  0001e	03 f8		 add	 edi, eax

; 1242 : 
; 1243 : 	if(lpTargetObj->Type != OBJ_USER && lpTargetObj->m_RecallMon == -1)

  00020	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  00024	74 0d		 je	 SHORT $LN5@SkillDefen
  00026	83 bb 30 06 00
	00 ff		 cmp	 DWORD PTR [ebx+1584], -1
  0002d	0f 84 2b 01 00
	00		 je	 $LN1@SkillDefen
$LN5@SkillDefen:

; 1244 : 	{
; 1245 : 		return;
; 1246 : 	}
; 1247 : 
; 1248 : 	if(lpObj->Class != CLASS_ELF)

  00033	66 83 bf 90 00
	00 00 02	 cmp	 WORD PTR [edi+144], 2
  0003b	0f 85 1d 01 00
	00		 jne	 $LN1@SkillDefen

; 1249 : 	{
; 1250 : 		return;
; 1251 : 	}
; 1252 : 
; 1253 : 	if(CC_MAP_RANGE(lpObj->MapNumber) && lpObj->m_Index != lpTargetObj->m_Index)

  00041	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  00047	3c 35		 cmp	 al, 53			; 00000035H
  00049	74 0f		 je	 SHORT $LN22@SkillDefen
  0004b	3c 12		 cmp	 al, 18			; 00000012H
  0004d	72 15		 jb	 SHORT $LN7@SkillDefen
  0004f	b1 17		 mov	 cl, 23			; 00000017H
  00051	3a c8		 cmp	 cl, al
  00053	1b c0		 sbb	 eax, eax
  00055	83 c0 01	 add	 eax, 1
  00058	74 0a		 je	 SHORT $LN7@SkillDefen
$LN22@SkillDefen:
  0005a	8b 07		 mov	 eax, DWORD PTR [edi]
  0005c	3b 03		 cmp	 eax, DWORD PTR [ebx]
  0005e	0f 85 fa 00 00
	00		 jne	 $LN1@SkillDefen
$LN7@SkillDefen:

; 1254 : 	{
; 1255 : 		return;
; 1256 : 	}
; 1257 : 
; 1258 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00064	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  0006c	ff 70 08	 push	 DWORD PTR [eax+8]
  0006f	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect

; 1259 : 
; 1260 : 	if( !lpInfo )

  00074	85 c0		 test	 eax, eax
  00076	0f 84 e2 00 00
	00		 je	 $LN1@SkillDefen

; 1261 : 	{
; 1262 : 		return;
; 1263 : 	}
; 1264 : 	
; 1265 : 	float skill_defense = (float)( lpInfo->m_Arg1+ (lpObj->Energy + lpObj->AddEnergy) / lpInfo->m_Arg2);

  0007c	0f b7 97 02 01
	00 00		 movzx	 edx, WORD PTR [edi+258]
  00083	0f b7 8f d6 00
	00 00		 movzx	 ecx, WORD PTR [edi+214]
  0008a	03 d1		 add	 edx, ecx

; 1266 : 	
; 1267 : 	if( skill_defense > lpInfo->m_Arg3 )

  0008c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00091	66 0f 6e ca	 movd	 xmm1, edx
  00095	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00098	f3 0f 5e 48 08	 divss	 xmm1, DWORD PTR [eax+8]
  0009d	f3 0f 58 48 04	 addss	 xmm1, DWORD PTR [eax+4]
  000a2	0f 2f c8	 comiss	 xmm1, xmm0
  000a5	76 03		 jbe	 SHORT $LN9@SkillDefen

; 1268 : 	{
; 1269 : 		skill_defense = lpInfo->m_Arg3;

  000a7	0f 28 c8	 movaps	 xmm1, xmm0
$LN9@SkillDefen:

; 1270 : 	}
; 1271 : 
; 1272 : 	if(lpTargetObj->Class == CLASS_KNIGHT)

  000aa	66 83 bb 90 00
	00 00 01	 cmp	 WORD PTR [ebx+144], 1
  000b2	75 0f		 jne	 SHORT $LN10@SkillDefen

; 1273 : 	{
; 1274 : 		skill_defense += skill_defense/10.0f;

  000b4	0f 28 c1	 movaps	 xmm0, xmm1
  000b7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  000bf	f3 0f 58 c8	 addss	 xmm1, xmm0
$LN10@SkillDefen:

; 1275 : 	}
; 1276 : 
; 1277 : 	gObjAddBuffEffect(lpTargetObj,BUFF_ADD_DEFENSE,ADD_OPTION_DEFENSE,(int)skill_defense,0,0,lpInfo->m_Arg4);

  000c3	f3 0f 2c 40 10	 cvttss2si eax, DWORD PTR [eax+16]
  000c8	56		 push	 esi
  000c9	f3 0f 2c c9	 cvttss2si ecx, xmm1
  000cd	50		 push	 eax
  000ce	6a 00		 push	 0
  000d0	6a 00		 push	 0
  000d2	51		 push	 ecx
  000d3	6a 03		 push	 3
  000d5	6a 02		 push	 2
  000d7	53		 push	 ebx
  000d8	89 4d 0c	 mov	 DWORD PTR tv426[ebp], ecx
  000db	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect
  000e0	8b 5d 0c	 mov	 ebx, DWORD PTR tv426[ebp]
  000e3	8d b7 48 0c 00
	00		 lea	 esi, DWORD PTR [edi+3144]
  000e9	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  000ee	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f1	89 55 08	 mov	 DWORD PTR tv433[ebp], edx
$LL4@SkillDefen:

; 1281 : 	{
; 1282 : 		if(lpObj->VpPlayer2[n].type == OBJ_MONSTER && lpObj->VpPlayer2[n].state != 0)

  000f4	80 7e 04 02	 cmp	 BYTE PTR [esi+4], 2
  000f8	75 40		 jne	 SHORT $LN2@SkillDefen
  000fa	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000fd	74 3b		 je	 SHORT $LN2@SkillDefen

; 1283 : 		{
; 1284 : 			LPOBJ lpMonster = &gObj[lpObj->VpPlayer2[n].number];

  000ff	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  00103	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00109	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1285 : 			if(lpMonster->m_iCurrentAI != 0)

  0010f	83 b9 d0 20 00
	00 00		 cmp	 DWORD PTR [ecx+8400], 0
  00116	74 22		 je	 SHORT $LN2@SkillDefen

; 1286 : 			{
; 1287 : 				lpMonster->m_Agro.IncAgro(lpObj->m_Index,int(skill_defense)/10);

  00118	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0011d	81 c1 ec 20 00
	00		 add	 ecx, 8428		; 000020ecH
  00123	f7 eb		 imul	 ebx
  00125	c1 fa 02	 sar	 edx, 2
  00128	8b c2		 mov	 eax, edx
  0012a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0012d	03 c2		 add	 eax, edx
  0012f	50		 push	 eax
  00130	ff 37		 push	 DWORD PTR [edi]
  00132	e8 00 00 00 00	 call	 ?IncAgro@TMonsterAIAgro@@QAEHHH@Z ; TMonsterAIAgro::IncAgro
  00137	8b 55 08	 mov	 edx, DWORD PTR tv433[ebp]
$LN2@SkillDefen:

; 1278 : 
; 1279 : 
; 1280 : 	for(int n = 0; n < MAX_VIEWPORT; n++)

  0013a	83 c6 0c	 add	 esi, 12			; 0000000cH
  0013d	83 ea 01	 sub	 edx, 1
  00140	89 55 08	 mov	 DWORD PTR tv433[ebp], edx
  00143	75 af		 jne	 SHORT $LL4@SkillDefen

; 1288 : 			}
; 1289 : 		}
; 1290 : 	}
; 1291 : 
; 1292 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpTargetObj->m_Index,skillSuccess);

  00145	8b 5d fc	 mov	 ebx, DWORD PTR _lpTargetObj$1$[ebp]
  00148	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0014b	6a 01		 push	 1
  0014d	ff 33		 push	 DWORD PTR [ebx]
  0014f	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00153	50		 push	 eax
  00154	57		 push	 edi
  00155	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0015a	83 c4 10	 add	 esp, 16			; 00000010H
  0015d	5e		 pop	 esi
$LN1@SkillDefen:
  0015e	5f		 pop	 edi
  0015f	5b		 pop	 ebx

; 1293 : }

  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 0c 00	 ret	 12			; 0000000cH
?SkillDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::SkillDefense
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?WizardMagicDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?WizardMagicDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::WizardMagicDefense, COMDAT
; _this$ = ecx

; 1192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1193 : 	int skillSuccess = true;
; 1194 : 
; 1195 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0000b	57		 push	 edi

; 1196 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000c	69 7d 0c 40 27
	00 00		 imul	 edi, DWORD PTR _aTargetIndex$[ebp], 10048
  00013	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1197 : 
; 1198 : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon== -1)

  0001f	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00023	74 0d		 je	 SHORT $LN2@WizardMagi
  00025	83 be 30 06 00
	00 ff		 cmp	 DWORD PTR [esi+1584], -1
  0002c	0f 84 e0 00 00
	00		 je	 $LN1@WizardMagi
$LN2@WizardMagi:

; 1199 : 	{
; 1200 : 		return;
; 1201 : 	}
; 1202 : 
; 1203 : 	if(lpObj->Class != CLASS_WIZARD && lpObj->Class != CLASS_MAGUMSA)

  00032	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  00039	66 85 c0	 test	 ax, ax
  0003c	74 09		 je	 SHORT $LN3@WizardMagi
  0003e	83 f8 03	 cmp	 eax, 3
  00041	0f 85 cb 00 00
	00		 jne	 $LN1@WizardMagi
$LN3@WizardMagi:

; 1204 : 	{
; 1205 : 		return;
; 1206 : 	}
; 1207 : 
; 1208 : 	if(lpObj->PartyNumber != lpTargetObj->PartyNumber)

  00047	8b 86 0c 06 00
	00		 mov	 eax, DWORD PTR [esi+1548]
  0004d	3b 87 0c 06 00
	00		 cmp	 eax, DWORD PTR [edi+1548]
  00053	0f 85 b9 00 00
	00		 jne	 $LN1@WizardMagi

; 1209 : 	{
; 1210 : 		return;
; 1211 : 	}
; 1212 : 
; 1213 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00059	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0005c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  00061	53		 push	 ebx
  00062	ff 70 08	 push	 DWORD PTR [eax+8]
  00065	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  0006a	8b d8		 mov	 ebx, eax

; 1214 : 
; 1215 : 	if( !lpInfo )

  0006c	85 db		 test	 ebx, ebx
  0006e	0f 84 9d 00 00
	00		 je	 $LN9@WizardMagi

; 1216 : 	{
; 1217 : 		return;
; 1218 : 	}
; 1219 : 
; 1220 : 	float iShieldPower = (float)(lpInfo->m_Arg1 + (lpObj->Dexterity + lpObj->AddDexterity) / lpInfo->m_Arg2 + (lpObj->Energy + lpObj->AddEnergy) / lpInfo->m_Arg3);

  00074	0f b7 8e d6 00
	00 00		 movzx	 ecx, WORD PTR [esi+214]
  0007b	0f b7 96 02 01
	00 00		 movzx	 edx, WORD PTR [esi+258]
  00082	0f b7 86 d2 00
	00 00		 movzx	 eax, WORD PTR [esi+210]
  00089	03 d1		 add	 edx, ecx
  0008b	0f b7 8e fe 00
	00 00		 movzx	 ecx, WORD PTR [esi+254]
  00092	03 c8		 add	 ecx, eax
  00094	66 0f 6e d2	 movd	 xmm2, edx
  00098	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0009b	66 0f 6e c9	 movd	 xmm1, ecx
  0009f	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000a2	0f 28 c2	 movaps	 xmm0, xmm2
  000a5	f3 0f 5e 4b 08	 divss	 xmm1, DWORD PTR [ebx+8]
  000aa	f3 0f 5e 43 0c	 divss	 xmm0, DWORD PTR [ebx+12]
  000af	f3 0f 58 4b 04	 addss	 xmm1, DWORD PTR [ebx+4]
  000b4	f3 0f 58 c8	 addss	 xmm1, xmm0

; 1221 : 
; 1222 : 	if( iShieldPower > lpInfo->m_Arg4 )

  000b8	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR [ebx+16]
  000bd	0f 2f c8	 comiss	 xmm1, xmm0
  000c0	76 03		 jbe	 SHORT $LN6@WizardMagi

; 1223 : 		iShieldPower = (float)lpInfo->m_Arg4;

  000c2	0f 28 c8	 movaps	 xmm1, xmm0
$LN6@WizardMagi:

; 1224 : 
; 1225 : 	int iShieldTime = lpInfo->m_Arg5 + (lpObj->Energy + lpObj->AddEnergy) / lpInfo->m_Arg6;

  000c5	f3 0f 5e 53 18	 divss	 xmm2, DWORD PTR [ebx+24]
  000ca	f3 0f 58 53 14	 addss	 xmm2, DWORD PTR [ebx+20]
  000cf	f3 0f 2c c2	 cvttss2si eax, xmm2

; 1226 : 
; 1227 : 	if( iShieldTime > lpInfo->m_Arg7)

  000d3	f3 0f 10 53 1c	 movss	 xmm2, DWORD PTR [ebx+28]
  000d8	66 0f 6e c0	 movd	 xmm0, eax
  000dc	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000df	0f 2f c2	 comiss	 xmm0, xmm2
  000e2	76 04		 jbe	 SHORT $LN7@WizardMagi

; 1228 : 		iShieldTime = lpInfo->m_Arg7;

  000e4	f3 0f 2c c2	 cvttss2si eax, xmm2
$LN7@WizardMagi:

; 1229 : 
; 1230 : 	gObjAddBuffEffect(lpTargetObj,BUFF_MANASHIELD,ADD_OPTION_MSDECREASE,(int)iShieldPower,0,0,iShieldTime);

  000e8	50		 push	 eax
  000e9	f3 0f 2c c1	 cvttss2si eax, xmm1
  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	50		 push	 eax
  000f2	6a 15		 push	 21			; 00000015H
  000f4	6a 04		 push	 4
  000f6	57		 push	 edi
  000f7	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 1231 : 	GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpTargetObj->m_Index,skillSuccess);

  000fc	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000ff	6a 01		 push	 1
  00101	ff 37		 push	 DWORD PTR [edi]
  00103	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00107	50		 push	 eax
  00108	56		 push	 esi
  00109	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0010e	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN9@WizardMagi:
  00111	5b		 pop	 ebx
$LN1@WizardMagi:
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi

; 1232 : }

  00114	5d		 pop	 ebp
  00115	c2 0c 00	 ret	 12			; 0000000cH
?WizardMagicDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::WizardMagicDefense
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?KnightSkillAddLife@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_partynum$1$ = -40					; size = 4
_lpMagic$GSCopy$1$ = -36				; size = 4
_iaddLifepower$1$ = -32					; size = 4
tv514 = -32						; size = 4
_iLifeTime$1$ = -28					; size = 4
_viewplayer$1$ = -28					; size = 4
_ApplyPartyIndex$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_skill_level$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?KnightSkillAddLife@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::KnightSkillAddLife, COMDAT
; _this$ = ecx

; 1057 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00016	57		 push	 edi

; 1058 : 	int skillSuccess = true;
; 1059 : 	LPOBJ lpObj = &gObj[aIndex];

  00017	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  0001d	89 4d dc	 mov	 DWORD PTR _lpMagic$GSCopy$1$[ebp], ecx
  00020	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1060 : 
; 1061 : 	if(lpObj->Type != OBJ_USER && lpObj->m_RecallMon == -1)

  00026	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0002a	74 0d		 je	 SHORT $LN8@KnightSkil
  0002c	83 bf 30 06 00
	00 ff		 cmp	 DWORD PTR [edi+1584], -1
  00033	0f 84 39 02 00
	00		 je	 $LN6@KnightSkil
$LN8@KnightSkil:

; 1062 : 	{
; 1063 : 		return;
; 1064 : 	}
; 1065 : 
; 1066 : 	if(lpObj->Class != CLASS_KNIGHT && lpObj->Class != CLASS_MAGUMSA)

  00039	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  00040	83 f8 01	 cmp	 eax, 1
  00043	74 09		 je	 SHORT $LN9@KnightSkil
  00045	83 f8 03	 cmp	 eax, 3
  00048	0f 85 24 02 00
	00		 jne	 $LN6@KnightSkil
$LN9@KnightSkil:

; 1067 : 	{
; 1068 : 		return;
; 1069 : 	}
; 1070 : 
; 1071 : 	int number;
; 1072 : 	int partynum = 0;
; 1073 : 	int totallevel = 0;
; 1074 : 	int partycount;
; 1075 : 	int dis;
; 1076 : 
; 1077 : 	int ApplyPartyIndex[MAX_USER_IN_PARTY];
; 1078 : 
; 1079 : 	int viewplayer = 0;
; 1080 : 	int viewpercent = 0;
; 1081 : 
; 1082 : 	LPOBJ lpPartyObj;
; 1083 : 
; 1084 : 	memset(ApplyPartyIndex,-1,sizeof(ApplyPartyIndex));
; 1085 : 
; 1086 : 	partynum = lpObj->PartyNumber;

  0004e	8b 97 0c 06 00
	00		 mov	 edx, DWORD PTR [edi+1548]
  00054	33 c9		 xor	 ecx, ecx
  00056	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  0005d	53		 push	 ebx
  0005e	33 db		 xor	 ebx, ebx
  00060	89 4d e4	 mov	 DWORD PTR _viewplayer$1$[ebp], ecx
  00063	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _ApplyPartyIndex$[ebp+16], -1
  0006a	89 55 d8	 mov	 DWORD PTR _partynum$1$[ebp], edx
  0006d	56		 push	 esi
  0006e	0f 11 45 e8	 movups	 XMMWORD PTR _ApplyPartyIndex$[ebp], xmm0

; 1087 : 
; 1088 : 	if(partynum != -1)

  00072	83 fa ff	 cmp	 edx, -1
  00075	0f 84 8d 00 00
	00		 je	 $LN19@KnightSkil

; 1089 : 	{
; 1090 : 		partycount = gParty.m_PartyS[partynum].Count;
; 1091 : 
; 1092 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  0007b	8b c2		 mov	 eax, edx
  0007d	33 f6		 xor	 esi, esi
  0007f	c1 e0 04	 shl	 eax, 4
  00082	2b c2		 sub	 eax, edx
  00084	8d 14 85 0c 00
	00 00		 lea	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  0008b	89 55 e0	 mov	 DWORD PTR tv514[ebp], edx
  0008e	66 90		 npad	 2
$LL4@KnightSkil:

; 1093 : 		{
; 1094 : 			number = gParty.m_PartyS[partynum].Number[n];

  00090	8b 02		 mov	 eax, DWORD PTR [edx]

; 1095 : 
; 1096 : 			if(number >= 0)

  00092	85 c0		 test	 eax, eax
  00094	78 3e		 js	 SHORT $LN2@KnightSkil

; 1097 : 			{
; 1098 : 				lpPartyObj = &gObj[number];

  00096	69 d8 40 27 00
	00		 imul	 ebx, eax, 10048

; 1099 : 
; 1100 : 				if(lpObj->MapNumber == lpPartyObj->MapNumber)

  0009c	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  000a2	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a8	3a 83 23 01 00
	00		 cmp	 al, BYTE PTR [ebx+291]
  000ae	75 21		 jne	 SHORT $LN38@KnightSkil

; 1101 : 				{
; 1102 : 					dis = gObjCalDistance(lpObj,&gObj[number]);

  000b0	53		 push	 ebx
  000b1	57		 push	 edi
  000b2	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance

; 1103 : 
; 1104 : 					if(dis < 10)
; 1105 : 					{
; 1106 : 						ApplyPartyIndex[n] = lpPartyObj->m_Index;
; 1107 : 						viewplayer++;

  000b7	8b 4d e4	 mov	 ecx, DWORD PTR _viewplayer$1$[ebp]
  000ba	83 c4 08	 add	 esp, 8
  000bd	8b 55 e0	 mov	 edx, DWORD PTR tv514[ebp]
  000c0	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000c3	7d 0f		 jge	 SHORT $LN2@KnightSkil
  000c5	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c7	41		 inc	 ecx
  000c8	89 44 b5 e8	 mov	 DWORD PTR _ApplyPartyIndex$[ebp+esi*4], eax
  000cc	89 4d e4	 mov	 DWORD PTR _viewplayer$1$[ebp], ecx
  000cf	eb 03		 jmp	 SHORT $LN2@KnightSkil
$LN38@KnightSkil:
  000d1	8b 4d e4	 mov	 ecx, DWORD PTR _viewplayer$1$[ebp]
$LN2@KnightSkil:

; 1089 : 	{
; 1090 : 		partycount = gParty.m_PartyS[partynum].Count;
; 1091 : 
; 1092 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  000d4	46		 inc	 esi
  000d5	83 c2 04	 add	 edx, 4
  000d8	89 55 e0	 mov	 DWORD PTR tv514[ebp], edx
  000db	83 fe 05	 cmp	 esi, 5
  000de	7c b0		 jl	 SHORT $LL4@KnightSkil

; 1108 : 					}
; 1109 : 				}
; 1110 : 			}
; 1111 : 		}
; 1112 : 	}
; 1113 : 
; 1114 : 	if(viewplayer > 1)

  000e0	83 f9 01	 cmp	 ecx, 1
  000e3	7e 21		 jle	 SHORT $LN39@KnightSkil

; 1115 : 	{
; 1116 : 		if(viewplayer == 2)

  000e5	83 f9 02	 cmp	 ecx, 2
  000e8	75 05		 jne	 SHORT $LN15@KnightSkil

; 1117 : 		{
; 1118 : 			viewpercent = 1;

  000ea	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]
  000ed	eb 19		 jmp	 SHORT $LN19@KnightSkil
$LN15@KnightSkil:

; 1119 : 		}
; 1120 : 		else if(viewplayer == 3)

  000ef	83 f9 03	 cmp	 ecx, 3
  000f2	75 05		 jne	 SHORT $LN17@KnightSkil

; 1121 : 		{
; 1122 : 			viewpercent = 2;

  000f4	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]
  000f7	eb 0f		 jmp	 SHORT $LN19@KnightSkil
$LN17@KnightSkil:

; 1123 : 		}
; 1124 : 		else if(viewplayer == 4)

  000f9	33 db		 xor	 ebx, ebx
  000fb	83 f9 04	 cmp	 ecx, 4
  000fe	0f 95 c3	 setne	 bl
  00101	83 c3 03	 add	 ebx, 3
  00104	eb 02		 jmp	 SHORT $LN19@KnightSkil
$LN39@KnightSkil:
  00106	33 db		 xor	 ebx, ebx
$LN19@KnightSkil:

; 1125 : 		{
; 1126 : 			viewpercent = 3;
; 1127 : 		}
; 1128 : 		else
; 1129 : 		{
; 1130 : 			viewpercent = 4;
; 1131 : 		}
; 1132 : 	}
; 1133 : 
; 1134 : 	BuffSkillEffectInfo* lpInfo = g_BuffSkillEffect.GetEffect(lpMagic->m_Skill);

  00108	8b 45 dc	 mov	 eax, DWORD PTR _lpMagic$GSCopy$1$[ebp]
  0010b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BuffSkillEffect@@3VBuffSkillEffect@@A ; g_BuffSkillEffect
  00110	ff 70 08	 push	 DWORD PTR [eax+8]
  00113	e8 00 00 00 00	 call	 ?GetEffect@BuffSkillEffect@@QAEPAUBuffSkillEffectInfo@@H@Z ; BuffSkillEffect::GetEffect
  00118	8b f0		 mov	 esi, eax

; 1135 : 
; 1136 : 	if( !lpInfo )

  0011a	85 f6		 test	 esi, esi
  0011c	0f 84 4e 01 00
	00		 je	 $LN40@KnightSkil

; 1137 : 	{
; 1138 : 		return;
; 1139 : 	}
; 1140 : 	
; 1141 : 	float iaddLifepower = (float)(lpInfo->m_Arg1 + (lpObj->Vitality + lpObj->AddVitality) / lpInfo->m_Arg2 + (lpObj->Energy + lpObj->AddEnergy)/lpInfo->m_Arg3 + viewpercent);

  00122	0f b7 8f d6 00
	00 00		 movzx	 ecx, WORD PTR [edi+214]
  00129	0f b7 97 02 01
	00 00		 movzx	 edx, WORD PTR [edi+258]
  00130	0f b7 87 d4 00
	00 00		 movzx	 eax, WORD PTR [edi+212]
  00137	03 d1		 add	 edx, ecx
  00139	0f b7 8f 00 01
	00 00		 movzx	 ecx, WORD PTR [edi+256]
  00140	03 c8		 add	 ecx, eax
  00142	66 0f 6e d2	 movd	 xmm2, edx
  00146	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00149	66 0f 6e c9	 movd	 xmm1, ecx
  0014d	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00150	0f 28 c2	 movaps	 xmm0, xmm2
  00153	f3 0f 5e 4e 08	 divss	 xmm1, DWORD PTR [esi+8]
  00158	f3 0f 5e 46 0c	 divss	 xmm0, DWORD PTR [esi+12]
  0015d	f3 0f 58 4e 04	 addss	 xmm1, DWORD PTR [esi+4]
  00162	f3 0f 58 c8	 addss	 xmm1, xmm0
  00166	66 0f 6e c3	 movd	 xmm0, ebx
  0016a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0016d	f3 0f 58 c8	 addss	 xmm1, xmm0

; 1142 : 
; 1143 : 	if( iaddLifepower > lpInfo->m_Arg4 )

  00171	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  00176	0f 2f c8	 comiss	 xmm1, xmm0
  00179	f3 0f 11 4d e0	 movss	 DWORD PTR _iaddLifepower$1$[ebp], xmm1
  0017e	76 08		 jbe	 SHORT $LN22@KnightSkil

; 1144 : 		iaddLifepower = (float)lpInfo->m_Arg4;

  00180	0f 28 c8	 movaps	 xmm1, xmm0
  00183	f3 0f 11 4d e0	 movss	 DWORD PTR _iaddLifepower$1$[ebp], xmm1
$LN22@KnightSkil:

; 1145 : 
; 1146 : 	int iLifeTime = lpInfo->m_Arg5 + (lpObj->Energy + lpObj->AddEnergy) / lpInfo->m_Arg6;

  00188	f3 0f 5e 56 18	 divss	 xmm2, DWORD PTR [esi+24]
  0018d	f3 0f 58 56 14	 addss	 xmm2, DWORD PTR [esi+20]
  00192	f3 0f 2c ca	 cvttss2si ecx, xmm2

; 1147 : 
; 1148 : 	if( iLifeTime > lpInfo->m_Arg7 )

  00196	f3 0f 10 56 1c	 movss	 xmm2, DWORD PTR [esi+28]
  0019b	89 4d e4	 mov	 DWORD PTR _iLifeTime$1$[ebp], ecx
  0019e	66 0f 6e c1	 movd	 xmm0, ecx
  001a2	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001a5	0f 2f c2	 comiss	 xmm0, xmm2
  001a8	76 07		 jbe	 SHORT $LN23@KnightSkil

; 1149 : 		iLifeTime = lpInfo->m_Arg7;

  001aa	f3 0f 2c ca	 cvttss2si ecx, xmm2
  001ae	89 4d e4	 mov	 DWORD PTR _iLifeTime$1$[ebp], ecx
$LN23@KnightSkil:

; 1150 : 
; 1151 : 	int iaddlife;
; 1152 : 
; 1153 : 	if(partynum == -1)

  001b1	83 7d d8 ff	 cmp	 DWORD PTR _partynum$1$[ebp], -1
  001b5	75 50		 jne	 SHORT $LN24@KnightSkil

; 1154 : 	{
; 1155 : 		iaddlife = (int)(lpObj->MaxLife*iaddLifepower / 100.0f);

  001b7	f3 0f 10 87 dc
	00 00 00	 movss	 xmm0, DWORD PTR [edi+220]
  001bf	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 1156 : 
; 1157 : 		/*if( gObjCheckPowerfulEffect(lpObj,BuffNumber,iaddlife,iaddmana,iaddbp) )
; 1158 : 		{
; 1159 : 			GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpObj->m_Index,0);
; 1160 : 			return;
; 1161 : 		}*/
; 1162 : 
; 1163 : 		gObjAddBuffEffect(lpObj,BUFF_SWELL_LIFE,ADD_OPTION_LIFE,iaddlife,0,0,iLifeTime);

  001c3	51		 push	 ecx
  001c4	6a 00		 push	 0
  001c6	6a 00		 push	 0
  001c8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  001d0	f3 0f 2c c0	 cvttss2si eax, xmm0
  001d4	50		 push	 eax
  001d5	6a 04		 push	 4
  001d7	6a 08		 push	 8
  001d9	57		 push	 edi
  001da	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 1164 : 		GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpObj->m_Index,skillSuccess);

  001df	8b 45 dc	 mov	 eax, DWORD PTR _lpMagic$GSCopy$1$[ebp]
  001e2	6a 01		 push	 1
  001e4	ff 37		 push	 DWORD PTR [edi]
  001e6	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  001ea	50		 push	 eax
  001eb	57		 push	 edi
  001ec	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  001f1	83 c4 2c	 add	 esp, 44			; 0000002cH
  001f4	5e		 pop	 esi
  001f5	5b		 pop	 ebx
  001f6	5f		 pop	 edi

; 1183 : 			}
; 1184 : 		}
; 1185 : 	}
; 1186 : }

  001f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fa	33 cd		 xor	 ecx, ebp
  001fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00201	8b e5		 mov	 esp, ebp
  00203	5d		 pop	 ebp
  00204	c2 0c 00	 ret	 12			; 0000000cH
$LN24@KnightSkil:

; 1165 : 	}
; 1166 : 	else
; 1167 : 	{
; 1168 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00207	33 db		 xor	 ebx, ebx
  00209	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@KnightSkil:

; 1169 : 		{
; 1170 : 			if(ApplyPartyIndex[n]!= -1)

  00210	8b 44 9d e8	 mov	 eax, DWORD PTR _ApplyPartyIndex$[ebp+ebx*4]
  00214	83 f8 ff	 cmp	 eax, -1
  00217	74 49		 je	 SHORT $LN5@KnightSkil

; 1171 : 			{
; 1172 : 				lpPartyObj = &gObj[ApplyPartyIndex[n]];

  00219	69 f0 40 27 00
	00		 imul	 esi, eax, 10048

; 1173 : 				iaddlife = (int)(lpPartyObj->MaxLife*iaddLifepower/100.0f);
; 1174 : 
; 1175 : 				/*if( gObjCheckPowerfulEffect(lpPartyObj,BuffNumber,iaddlife,iaddmana,iaddbp) )
; 1176 : 				{
; 1177 : 					GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpPartyObj->m_Index,0);
; 1178 : 					return;
; 1179 : 				}*/
; 1180 : 
; 1181 : 				gObjAddBuffEffect(lpPartyObj,BUFF_SWELL_LIFE,ADD_OPTION_LIFE,iaddlife,0,0,iLifeTime);

  0021f	51		 push	 ecx
  00220	6a 00		 push	 0
  00222	6a 00		 push	 0
  00224	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022a	f3 0f 10 86 dc
	00 00 00	 movss	 xmm0, DWORD PTR [esi+220]
  00232	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00236	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0023e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00242	50		 push	 eax
  00243	6a 04		 push	 4
  00245	6a 08		 push	 8
  00247	56		 push	 esi
  00248	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 1182 : 				GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpPartyObj->m_Index,skillSuccess);

  0024d	8b 45 dc	 mov	 eax, DWORD PTR _lpMagic$GSCopy$1$[ebp]
  00250	6a 01		 push	 1
  00252	ff 36		 push	 DWORD PTR [esi]
  00254	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00258	50		 push	 eax
  00259	57		 push	 edi
  0025a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  0025f	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN5@KnightSkil:

; 1165 : 	}
; 1166 : 	else
; 1167 : 	{
; 1168 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00262	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _iaddLifepower$1$[ebp]
  00267	43		 inc	 ebx
  00268	8b 4d e4	 mov	 ecx, DWORD PTR _iLifeTime$1$[ebp]
  0026b	83 fb 05	 cmp	 ebx, 5
  0026e	7c a0		 jl	 SHORT $LL7@KnightSkil
$LN40@KnightSkil:
  00270	5e		 pop	 esi
  00271	5b		 pop	 ebx
$LN6@KnightSkil:

; 1183 : 			}
; 1184 : 		}
; 1185 : 	}
; 1186 : }

  00272	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00275	33 cd		 xor	 ecx, ebp
  00277	5f		 pop	 edi
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	8b e5		 mov	 esp, ebp
  0027f	5d		 pop	 ebp
  00280	c2 0c 00	 ret	 12			; 0000000cH
?KnightSkillAddLife@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::KnightSkillAddLife
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC ; CObjUseSkill::MaGumSkillDefenseDown, COMDAT
; _this$ = ecx

; 1036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1037 : 	int skillSuccess = 1;
; 1038 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0000b	57		 push	 edi

; 1039 : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];

  0000c	69 7d 0c 40 27
	00 00		 imul	 edi, DWORD PTR _aTargetIndex$[ebp], 10048
  00013	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1040 : 
; 1041 : 	if(lpObj->Type == OBJ_USER && lpObj->Class != CLASS_MAGUMSA)

  0001f	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00023	75 0a		 jne	 SHORT $LN2@MaGumSkill
  00025	66 83 be 90 00
	00 00 03	 cmp	 WORD PTR [esi+144], 3
  0002d	75 36		 jne	 SHORT $LN3@MaGumSkill
$LN2@MaGumSkill:

; 1042 : 	{
; 1043 : 		return;
; 1044 : 	}
; 1045 : 
; 1046 : 	if( retCalcSkillResistance(lpTargetObj,1) )

  0002f	6a 01		 push	 1
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ?retCalcSkillResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retCalcSkillResistance
  00037	83 c4 08	 add	 esp, 8
  0003a	85 c0		 test	 eax, eax
  0003c	74 27		 je	 SHORT $LN3@MaGumSkill

; 1047 : 	{
; 1048 : 		gObjAddBuffEffect(lpTargetObj,BUFF_DEFENSEDOWN,ADD_OPTION_DEFENSEDOWN,10,0,0,10);

  0003e	6a 0a		 push	 10			; 0000000aH
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 0a		 push	 10			; 0000000aH
  00046	6a 17		 push	 23			; 00000017H
  00048	6a 3a		 push	 58			; 0000003aH
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 1049 : 		GCMagicAttackNumberSend(lpObj,lpMagic->m_Skill,lpTargetObj->m_Index,skillSuccess);

  00050	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00053	6a 01		 push	 1
  00055	ff 37		 push	 DWORD PTR [edi]
  00057	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  0005b	50		 push	 eax
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
  00062	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN3@MaGumSkill:
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 1050 : 	}
; 1051 : }

  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP ; CObjUseSkill::MaGumSkillDefenseDown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SkillFrustrum3@CObjUseSkill@@QAEXHEMMMM@Z
_TEXT	SEGMENT
tv392 = -168						; size = 4
_lpObj$1$ = -164					; size = 4
_vFrustrum$ = -160					; size = 48
_Matrix$ = -112						; size = 48
_p$ = -64						; size = 48
_Angle$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetPos$ = 12					; size = 1
_f1$ = 16						; size = 4
_f2$ = 20						; size = 4
_f3$ = 24						; size = 4
_f4$ = 28						; size = 4
?SkillFrustrum3@CObjUseSkill@@QAEXHEMMMM@Z PROC		; CObjUseSkill::SkillFrustrum3, COMDAT
; _this$ = ecx

; 5771 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 5772 : 	LPOBJ lpObj = &gObj[aIndex];
; 5773 : 
; 5774 : 	float p[MAX_ARRAY_FRUSTRUM][3];
; 5775 : 
; 5776 : 	p[0][0] = -f1;

  00016	f3 0f 10 55 10	 movss	 xmm2, DWORD PTR _f1$[ebp]
  0001b	56		 push	 esi
  0001c	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  00022	0f 28 c2	 movaps	 xmm0, xmm2

; 5777 : 	p[0][1] = f2;
; 5778 : 	p[0][2] = 0;
; 5779 : 	p[1][0] = f1;
; 5780 : 	p[1][1] = f2;
; 5781 : 	p[1][2] = 0;
; 5782 : 	p[2][0] = f3;
; 5783 : 	p[2][1] = f4;
; 5784 : 	p[2][2] = 0;
; 5785 : 	p[3][0] = -f3;
; 5786 : 	p[3][1] = f4;
; 5787 : 	p[3][2] = 0;
; 5788 : 
; 5789 : 	float Angle[3];
; 5790 : 
; 5791 : 	Angle[0] = 0;
; 5792 : 	Angle[1] = 0;
; 5793 : 	Angle[2] = (float)(aTargetPos * 360 / 255);

  00025	0f b6 45 0c	 movzx	 eax, BYTE PTR _aTargetPos$[ebp]
  00029	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00030	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _f2$[ebp]
  00035	69 c8 68 01 00
	00		 imul	 ecx, eax, 360
  0003b	b8 81 80 80 80	 mov	 eax, -2139062143	; 80808081H
  00040	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	f3 0f 11 45 c0	 movss	 DWORD PTR _p$[ebp], xmm0
  0004b	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _f4$[ebp]
  00050	f3 0f 11 45 dc	 movss	 DWORD PTR _p$[ebp+28], xmm0
  00055	f7 e9		 imul	 ecx
  00057	f3 0f 11 45 e8	 movss	 DWORD PTR _p$[ebp+40], xmm0
  0005c	f3 0f 11 4d c4	 movss	 DWORD PTR _p$[ebp+4], xmm1
  00061	f3 0f 11 4d d0	 movss	 DWORD PTR _p$[ebp+16], xmm1
  00066	f3 0f 10 4d 18	 movss	 xmm1, DWORD PTR _f3$[ebp]
  0006b	57		 push	 edi
  0006c	03 d1		 add	 edx, ecx
  0006e	f3 0f 11 4d d8	 movss	 DWORD PTR _p$[ebp+24], xmm1
  00073	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  0007a	c1 fa 07	 sar	 edx, 7
  0007d	8b c2		 mov	 eax, edx
  0007f	89 b5 5c ff ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], esi
  00085	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00088	03 c2		 add	 eax, edx
  0008a	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+8], 0
  00091	f3 0f 11 55 cc	 movss	 DWORD PTR _p$[ebp+12], xmm2
  00096	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+20], 0
  0009d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+32], 0
  000a4	66 0f 6e c0	 movd	 xmm0, eax

; 5794 : 
; 5795 : 	float Matrix[3][MAX_ARRAY_FRUSTRUM];
; 5796 : 	float vFrustrum[MAX_ARRAY_FRUSTRUM][3];
; 5797 : 
; 5798 : 	AngleMatrix(Angle,Matrix);

  000a8	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000ab	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ae	50		 push	 eax
  000af	8d 45 f0	 lea	 eax, DWORD PTR _Angle$[ebp]
  000b2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+44], 0
  000b9	50		 push	 eax
  000ba	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Angle$[ebp], 0
  000c1	f3 0f 11 4d e4	 movss	 DWORD PTR _p$[ebp+36], xmm1
  000c6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Angle$[ebp+4], 0
  000cd	f3 0f 11 45 f8	 movss	 DWORD PTR _Angle$[ebp+8], xmm0
  000d2	e8 00 00 00 00	 call	 ?AngleMatrix@@YAXPBMPAY03M@Z ; AngleMatrix
  000d7	8d 86 98 14 00
	00		 lea	 eax, DWORD PTR [esi+5272]
  000dd	83 c4 08	 add	 esp, 8
  000e0	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv392[ebp], eax

; 5799 : 
; 5800 : 	for(int i = 0; i < MAX_ARRAY_FRUSTRUM; i++)

  000e6	33 ff		 xor	 edi, edi
  000e8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@SkillFrust:

; 5801 : 	{
; 5802 : 		VectorRotate((const float *)&p[i],(const float *)&Matrix[0],(float *)&vFrustrum[i]);

  000f0	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _vFrustrum$[ebp]
  000f6	03 f7		 add	 esi, edi
  000f8	8d 45 90	 lea	 eax, DWORD PTR _Matrix$[ebp]
  000fb	56		 push	 esi
  000fc	50		 push	 eax
  000fd	8d 45 c0	 lea	 eax, DWORD PTR _p$[ebp]
  00100	03 c7		 add	 eax, edi
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?VectorRotate@@YAXQBM0QAM@Z ; VectorRotate

; 5803 : 
; 5804 : 		lpObj->fSkillFrustrumX[i] = (int)vFrustrum[i][0] + lpObj->X;

  00108	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv392[ebp]
  00117	0f b6 88 20 01
	00 00		 movzx	 ecx, BYTE PTR [eax+288]
  0011e	f3 0f 2c 06	 cvttss2si eax, DWORD PTR [esi]
  00122	03 c8		 add	 ecx, eax

; 5805 : 		lpObj->fSkillFrustrumY[i] = (int)vFrustrum[i][1] + lpObj->Y;

  00124	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  0012a	89 4a f0	 mov	 DWORD PTR [edx-16], ecx
  0012d	f3 0f 2c 8c 3d
	64 ff ff ff	 cvttss2si ecx, DWORD PTR _vFrustrum$[ebp+edi+4]
  00136	83 c7 0c	 add	 edi, 12			; 0000000cH
  00139	0f b6 80 21 01
	00 00		 movzx	 eax, BYTE PTR [eax+289]
  00140	03 c8		 add	 ecx, eax
  00142	89 0a		 mov	 DWORD PTR [edx], ecx
  00144	83 c2 04	 add	 edx, 4
  00147	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv392[ebp], edx
  0014d	83 ff 30	 cmp	 edi, 48			; 00000030H
  00150	7c 9e		 jl	 SHORT $LL4@SkillFrust

; 5806 : 	}
; 5807 : }

  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	5f		 pop	 edi
  00156	33 cd		 xor	 ecx, ebp
  00158	5e		 pop	 esi
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 18 00	 ret	 24			; 00000018H
?SkillFrustrum3@CObjUseSkill@@QAEXHEMMMM@Z ENDP		; CObjUseSkill::SkillFrustrum3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z
_TEXT	SEGMENT
_lpTargetObj$1$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_MagicNumber$1$ = 16					; size = 4
_lpMagic$ = 16						; size = 4
_bCombo$ = 20						; size = 4
?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z PROC ; CObjUseSkill::RunningSkill, COMDAT
; _this$ = ecx

; 885  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 886  : 	LPOBJ lpObj = &gObj[aIndex];

  00005	69 5d 08 40 27
	00 00		 imul	 ebx, DWORD PTR _aIndex$[ebp], 10048
  0000c	56		 push	 esi

; 887  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 888  : 	int  MagicNumber = lpMagic->m_Skill;

  0000d	8b 75 10	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	69 4d 0c 40 27
	00 00		 imul	 ecx, DWORD PTR _aTargetIndex$[ebp], 10048
  0001a	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 889  : 
; 890  : 	lpObj->m_SkillNumber = MagicNumber;
; 891  : 
; 892  : 	if( gObjCheckUsedBuffEffect(lpObj,BUFF_INVISIBILITY) == TRUE )

  00023	6a 12		 push	 18			; 00000012H
  00025	53		 push	 ebx
  00026	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	89 4d fc	 mov	 DWORD PTR _lpTargetObj$1$[ebp], ecx
  0002f	89 45 10	 mov	 DWORD PTR _MagicNumber$1$[ebp], eax
  00032	66 89 83 b8 05
	00 00		 mov	 WORD PTR [ebx+1464], ax
  00039	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0003e	83 c4 08	 add	 esp, 8
  00041	3c 01		 cmp	 al, 1
  00043	75 12		 jne	 SHORT $LN5@RunningSki

; 893  : 	{
; 894  : 		if( (lpObj->Authority & 32) != 32 )

  00045	f6 83 bc 01 00
	00 20		 test	 BYTE PTR [ebx+444], 32	; 00000020H
  0004c	75 09		 jne	 SHORT $LN5@RunningSki

; 895  : 		{
; 896  : 			RemoveCloakingEffect(lpObj->m_Index);

  0004e	ff 33		 push	 DWORD PTR [ebx]
  00050	8b cf		 mov	 ecx, edi
  00052	e8 00 00 00 00	 call	 ?RemoveCloakingEffect@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::RemoveCloakingEffect
$LN5@RunningSki:

; 897  : 		}
; 898  : 	}
; 899  : 
; 900  : 	if( g_MasterSkillSystem.CheckMasterLevelSkill(lpMagic->m_Skill) )

  00057	ff 76 08	 push	 DWORD PTR [esi+8]
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0005f	e8 00 00 00 00	 call	 ?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
  00064	85 c0		 test	 eax, eax
  00066	74 23		 je	 SHORT $LN6@RunningSki

; 901  : 	{
; 902  : 		return g_MasterSkillSystem.RunningSkill_MLS(lpObj,aTargetIndex,lpMagic,bCombo,0,0,0,0);

  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	ff 75 14	 push	 DWORD PTR _bCombo$[ebp]
  00073	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00078	56		 push	 esi
  00079	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0007c	53		 push	 ebx
  0007d	e8 00 00 00 00	 call	 ?RunningSkill_MLS@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@HPAVCMagicInf@@HEEEE@Z ; CMasterLevelSkillTreeSystem::RunningSkill_MLS
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 1030 : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 10 00	 ret	 16			; 00000010H
$LN6@RunningSki:

; 903  : 	}
; 904  : 
; 905  : 	switch(MagicNumber)

  0008b	8b 45 10	 mov	 eax, DWORD PTR _MagicNumber$1$[ebp]
  0008e	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00093	0f 8f 59 05 00
	00		 jg	 $LN60@RunningSki
  00099	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0009e	0f 8d 32 05 00
	00		 jge	 $LN55@RunningSki
  000a4	48		 dec	 eax
  000a5	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  000aa	0f 87 a1 05 00
	00		 ja	 $LN58@RunningSki
  000b0	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN61@RunningSki[eax]
  000b7	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@RunningSki[eax*4]
$LN7@RunningSki:

; 906  : 	{
; 907  : 	case AT_SKILL_BLOCKING:
; 908  : 		if(lpObj->pInventory[1].IsItem() == 1)

  000be	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  000c4	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  000ca	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000cf	83 f8 01	 cmp	 eax, 1
  000d2	0f 85 92 05 00
	00		 jne	 $LN2@RunningSki

; 909  : 		{
; 910  : 			if(lpObj->pInventory[1].m_Type >= ITEMGET(6,4) && lpObj->pInventory[1].m_Type < ITEMGET(7,0))

  000d8	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  000de	ba 04 0c 00 00	 mov	 edx, 3076		; 00000c04H
  000e3	0f b7 88 da 00
	00 00		 movzx	 ecx, WORD PTR [eax+218]
  000ea	66 3b ca	 cmp	 cx, dx
  000ed	0f 8c 77 05 00
	00		 jl	 $LN2@RunningSki
  000f3	ba 00 0e 00 00	 mov	 edx, 3584		; 00000e00H
  000f8	66 3b ca	 cmp	 cx, dx
  000fb	0f 8d 69 05 00
	00		 jge	 $LN2@RunningSki

; 911  : 			{
; 912  : 				if(lpObj->pInventory[1].m_Option1 != 0)

  00101	80 b8 64 01 00
	00 00		 cmp	 BYTE PTR [eax+356], 0
  00108	0f 84 5c 05 00
	00		 je	 $LN2@RunningSki

; 913  : 				{
; 914  : 					lpObj->m_SkillTime = GetTickCount() + 4000;

  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 915  : 					GCActionSend(lpObj,18,lpObj->m_Index,aTargetIndex);

  00114	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00117	05 a0 0f 00 00	 add	 eax, 4000		; 00000fa0H
  0011c	ff 33		 push	 DWORD PTR [ebx]
  0011e	89 83 bc 05 00
	00		 mov	 DWORD PTR [ebx+1468], eax
  00124	6a 12		 push	 18			; 00000012H
  00126	53		 push	 ebx
  00127	e8 00 00 00 00	 call	 ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ; GCActionSend
  0012c	83 c4 10	 add	 esp, 16			; 00000010H

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0012f	b8 01 00 00 00	 mov	 eax, 1
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5b		 pop	 ebx

; 1030 : }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 10 00	 ret	 16			; 00000010H
$LN12@RunningSki:

; 916  : 				}
; 917  : 			}
; 918  : 		}
; 919  : 		break;
; 920  : 	case AT_SKILL_POISON:
; 921  : 	case AT_SKILL_METEO:
; 922  : 	case AT_SKILL_THUNDER:
; 923  : 	case AT_SKILL_FIREBALL:
; 924  : 	case AT_SKILL_FLAME:
; 925  : 	case AT_SKILL_SLOW:
; 926  : 	case AT_SKILL_ENERGYBALL:
; 927  : 	case AT_SKILL_SWORD1:
; 928  : 	case AT_SKILL_SWORD2:
; 929  : 	case AT_SKILL_SWORD3:
; 930  : 	case AT_SKILL_SWORD4:
; 931  : 	case AT_SKILL_SWORD5:
; 932  : 	case AT_SKILL_CROSSBOW:
; 933  : 	case AT_SKILL_BOW:
; 934  : 	case AT_SKILL_WHEEL:
; 935  : 	case AT_SKILL_BLOWOFFURY:
; 936  : 	case AT_SKILL_KNIGHTSPEAR:
; 937  : 	case AT_SKILL_PENETRATION:
; 938  : 	case AT_SKILL_SWORD6:
; 939  : 		gObjAttack(lpObj,lpTargetObj,lpMagic,1,0,0,0,0,0);
; 940  : 		break;
; 941  : 	case AT_SKILL_HEALING:	
; 942  : 		SkillHealing(aIndex,aTargetIndex,lpMagic);break;

  0013d	56		 push	 esi
  0013e	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00141	8b cf		 mov	 ecx, edi
  00143	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00146	e8 00 00 00 00	 call	 ?SkillHealing@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHealing
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0014d	b8 01 00 00 00	 mov	 eax, 1
  00152	5b		 pop	 ebx

; 1030 : }

  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 10 00	 ret	 16			; 00000010H
$LN13@RunningSki:

; 943  : 	case AT_SKILL_MAGICDEFENSE:	
; 944  : 		WizardMagicDefense(aIndex,aTargetIndex,lpMagic);break;

  00159	56		 push	 esi
  0015a	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0015d	8b cf		 mov	 ecx, edi
  0015f	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00162	e8 00 00 00 00	 call	 ?WizardMagicDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::WizardMagicDefense
  00167	5f		 pop	 edi
  00168	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00169	b8 01 00 00 00	 mov	 eax, 1
  0016e	5b		 pop	 ebx

; 1030 : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 10 00	 ret	 16			; 00000010H
$LN14@RunningSki:

; 945  : 	case AT_SKILL_KNIGHTADDLIFE:	
; 946  : 		KnightSkillAddLife(aIndex,lpMagic->m_Level,lpMagic);break;

  00175	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00179	8b cf		 mov	 ecx, edi
  0017b	56		 push	 esi
  0017c	50		 push	 eax
  0017d	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00180	e8 00 00 00 00	 call	 ?KnightSkillAddLife@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::KnightSkillAddLife
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00187	b8 01 00 00 00	 mov	 eax, 1
  0018c	5b		 pop	 ebx

; 1030 : }

  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c2 10 00	 ret	 16			; 00000010H
$LN15@RunningSki:

; 947  : 	case AT_SKILL_DEFENSE:	
; 948  : 		SkillDefense(aIndex,aTargetIndex,lpMagic);break;

  00193	56		 push	 esi
  00194	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00197	8b cf		 mov	 ecx, edi
  00199	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0019c	e8 00 00 00 00	 call	 ?SkillDefense@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDefense
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	5b		 pop	 ebx

; 1030 : }

  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c2 10 00	 ret	 16			; 00000010H
$LN16@RunningSki:

; 949  : 	case AT_SKILL_ATTACK:	
; 950  : 		SkillAttack(aIndex,aTargetIndex,lpMagic);break;

  001af	56		 push	 esi
  001b0	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  001b3	8b cf		 mov	 ecx, edi
  001b5	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  001b8	e8 00 00 00 00	 call	 ?SkillAttack@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAttack
  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  001bf	b8 01 00 00 00	 mov	 eax, 1
  001c4	5b		 pop	 ebx

; 1030 : }

  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c2 10 00	 ret	 16			; 00000010H
$LN17@RunningSki:

; 951  : 
; 952  : 	case AT_SKILL_CALLMON1:	return SkillMonsterCall(lpObj->m_Index,26,lpObj->X-1,lpObj->Y+1);

  001cb	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  001d2	8b cf		 mov	 ecx, edi
  001d4	40		 inc	 eax
  001d5	50		 push	 eax
  001d6	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  001dd	48		 dec	 eax
  001de	50		 push	 eax
  001df	6a 1a		 push	 26			; 0000001aH
  001e1	ff 33		 push	 DWORD PTR [ebx]
  001e3	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  001e8	5f		 pop	 edi
  001e9	5e		 pop	 esi
  001ea	5b		 pop	 ebx

; 1030 : }

  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 10 00	 ret	 16			; 00000010H
$LN18@RunningSki:

; 953  : 	case AT_SKILL_CALLMON2:	return SkillMonsterCall(lpObj->m_Index,32,lpObj->X-1,lpObj->Y+1);

  001f1	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  001f8	8b cf		 mov	 ecx, edi
  001fa	40		 inc	 eax
  001fb	50		 push	 eax
  001fc	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00203	48		 dec	 eax
  00204	50		 push	 eax
  00205	6a 20		 push	 32			; 00000020H
  00207	ff 33		 push	 DWORD PTR [ebx]
  00209	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx

; 1030 : }

  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c2 10 00	 ret	 16			; 00000010H
$LN19@RunningSki:

; 954  : 	case AT_SKILL_CALLMON3:	return SkillMonsterCall(lpObj->m_Index,21,lpObj->X-1,lpObj->Y+1);

  00217	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  0021e	8b cf		 mov	 ecx, edi
  00220	40		 inc	 eax
  00221	50		 push	 eax
  00222	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00229	48		 dec	 eax
  0022a	50		 push	 eax
  0022b	6a 15		 push	 21			; 00000015H
  0022d	ff 33		 push	 DWORD PTR [ebx]
  0022f	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	5b		 pop	 ebx

; 1030 : }

  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	c2 10 00	 ret	 16			; 00000010H
$LN20@RunningSki:

; 955  : 	case AT_SKILL_CALLMON4:	return SkillMonsterCall(lpObj->m_Index,20,lpObj->X-1,lpObj->Y+1);

  0023d	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00244	8b cf		 mov	 ecx, edi
  00246	40		 inc	 eax
  00247	50		 push	 eax
  00248	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  0024f	48		 dec	 eax
  00250	50		 push	 eax
  00251	6a 14		 push	 20			; 00000014H
  00253	ff 33		 push	 DWORD PTR [ebx]
  00255	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx

; 1030 : }

  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c2 10 00	 ret	 16			; 00000010H
$LN21@RunningSki:

; 956  : 	case AT_SKILL_CALLMON5:	return SkillMonsterCall(lpObj->m_Index,10,lpObj->X-1,lpObj->Y+1);

  00263	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  0026a	8b cf		 mov	 ecx, edi
  0026c	40		 inc	 eax
  0026d	50		 push	 eax
  0026e	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00275	48		 dec	 eax
  00276	50		 push	 eax
  00277	6a 0a		 push	 10			; 0000000aH
  00279	ff 33		 push	 DWORD PTR [ebx]
  0027b	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  00280	5f		 pop	 edi
  00281	5e		 pop	 esi
  00282	5b		 pop	 ebx

; 1030 : }

  00283	8b e5		 mov	 esp, ebp
  00285	5d		 pop	 ebp
  00286	c2 10 00	 ret	 16			; 00000010H
$LN22@RunningSki:

; 957  : 	case AT_SKILL_CALLMON6:	return SkillMonsterCall(lpObj->m_Index,150,lpObj->X-1,lpObj->Y+1);

  00289	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00290	8b cf		 mov	 ecx, edi
  00292	40		 inc	 eax
  00293	50		 push	 eax
  00294	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  0029b	48		 dec	 eax
  0029c	50		 push	 eax
  0029d	68 96 00 00 00	 push	 150			; 00000096H
  002a2	ff 33		 push	 DWORD PTR [ebx]
  002a4	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  002a9	5f		 pop	 edi
  002aa	5e		 pop	 esi
  002ab	5b		 pop	 ebx

; 1030 : }

  002ac	8b e5		 mov	 esp, ebp
  002ae	5d		 pop	 ebp
  002af	c2 10 00	 ret	 16			; 00000010H
$LN23@RunningSki:

; 958  : 	case AT_SKILL_CALLMON7:	return SkillMonsterCall(lpObj->m_Index,151,lpObj->X-1,lpObj->Y+1);

  002b2	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  002b9	8b cf		 mov	 ecx, edi
  002bb	40		 inc	 eax
  002bc	50		 push	 eax
  002bd	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  002c4	48		 dec	 eax
  002c5	50		 push	 eax
  002c6	68 97 00 00 00	 push	 151			; 00000097H
  002cb	ff 33		 push	 DWORD PTR [ebx]
  002cd	e8 00 00 00 00	 call	 ?SkillMonsterCall@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::SkillMonsterCall
  002d2	5f		 pop	 edi
  002d3	5e		 pop	 esi
  002d4	5b		 pop	 ebx

; 1030 : }

  002d5	8b e5		 mov	 esp, ebp
  002d7	5d		 pop	 ebp
  002d8	c2 10 00	 ret	 16			; 00000010H
$LN24@RunningSki:

; 959  : 	//case AT_MSKILL_FE_SUMMONSATYROS: return SkillMonsterCall(lpObj->m_Index,597,lpObj->X-1,lpObj->Y+1);
; 960  : 
; 961  : 	case AT_SKILL_EXPHELL:
; 962  : 		return SkillHellFire2(lpObj->m_Index,aTargetIndex,lpMagic);

  002db	56		 push	 esi
  002dc	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  002df	8b cf		 mov	 ecx, edi
  002e1	ff 33		 push	 DWORD PTR [ebx]
  002e3	e8 00 00 00 00	 call	 ?SkillHellFire2@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillHellFire2
  002e8	5f		 pop	 edi
  002e9	5e		 pop	 esi
  002ea	5b		 pop	 ebx

; 1030 : }

  002eb	8b e5		 mov	 esp, ebp
  002ed	5d		 pop	 ebp
  002ee	c2 10 00	 ret	 16			; 00000010H
$LN25@RunningSki:

; 963  : 	case AT_SKILL_STRIKE:	
; 964  : 		return SkillKnightBlow(lpObj->m_Index,aTargetIndex,lpMagic,bCombo);

  002f1	ff 75 14	 push	 DWORD PTR _bCombo$[ebp]
  002f4	8b cf		 mov	 ecx, edi
  002f6	56		 push	 esi
  002f7	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  002fa	ff 33		 push	 DWORD PTR [ebx]
  002fc	e8 00 00 00 00	 call	 ?SkillKnightBlow@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillKnightBlow
  00301	5f		 pop	 edi
  00302	5e		 pop	 esi
  00303	5b		 pop	 ebx

; 1030 : }

  00304	8b e5		 mov	 esp, ebp
  00306	5d		 pop	 ebp
  00307	c2 10 00	 ret	 16			; 00000010H
$LN26@RunningSki:

; 965  : 
; 966  : 	case AT_SKILL_SPEAR:	return SkillSpear(lpObj->m_Index,aTargetIndex,lpMagic);

  0030a	56		 push	 esi
  0030b	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0030e	8b cf		 mov	 ecx, edi
  00310	ff 33		 push	 DWORD PTR [ebx]
  00312	e8 00 00 00 00	 call	 ?SkillSpear@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSpear
  00317	5f		 pop	 edi
  00318	5e		 pop	 esi
  00319	5b		 pop	 ebx

; 1030 : }

  0031a	8b e5		 mov	 esp, ebp
  0031c	5d		 pop	 ebp
  0031d	c2 10 00	 ret	 16			; 00000010H
$LN27@RunningSki:

; 967  : 	case AT_SKILL_FIREBURST:	
; 968  : 		return SkillFireBurst(lpObj->m_Index,aTargetIndex,lpMagic);

  00320	56		 push	 esi
  00321	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00324	8b cf		 mov	 ecx, edi
  00326	ff 33		 push	 DWORD PTR [ebx]
  00328	e8 00 00 00 00	 call	 ?SkillFireBurst@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireBurst
  0032d	5f		 pop	 edi
  0032e	5e		 pop	 esi
  0032f	5b		 pop	 ebx

; 1030 : }

  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c2 10 00	 ret	 16			; 00000010H
$LN28@RunningSki:

; 969  : 	case AT_SKILL_DARKHORSE_ATTACK:	return SkillDarkHorseAttack(lpObj->m_Index,aTargetIndex,lpMagic);

  00336	56		 push	 esi
  00337	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0033a	8b cf		 mov	 ecx, edi
  0033c	ff 33		 push	 DWORD PTR [ebx]
  0033e	e8 00 00 00 00	 call	 ?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarkHorseAttack
  00343	5f		 pop	 edi
  00344	5e		 pop	 esi
  00345	5b		 pop	 ebx

; 1030 : }

  00346	8b e5		 mov	 esp, ebp
  00348	5d		 pop	 ebp
  00349	c2 10 00	 ret	 16			; 00000010H
$LN29@RunningSki:

; 970  : 	case AT_SKILL_RECALL_PARTY:	SkillRecallParty(aIndex,lpMagic->m_Level);break;

  0034c	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00350	8b cf		 mov	 ecx, edi
  00352	50		 push	 eax
  00353	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00356	e8 00 00 00 00	 call	 ?SkillRecallParty@CObjUseSkill@@QAEXHH@Z ; CObjUseSkill::SkillRecallParty
  0035b	5f		 pop	 edi
  0035c	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0035d	b8 01 00 00 00	 mov	 eax, 1
  00362	5b		 pop	 ebx

; 1030 : }

  00363	8b e5		 mov	 esp, ebp
  00365	5d		 pop	 ebp
  00366	c2 10 00	 ret	 16			; 00000010H
$LN30@RunningSki:

; 971  : 	case AT_SKILL_ADD_CRITICALDAMAGE:
; 972  : 		SkillAddCriticalDamage(aIndex,lpMagic);break;

  00369	56		 push	 esi
  0036a	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0036d	8b cf		 mov	 ecx, edi
  0036f	e8 00 00 00 00	 call	 ?SkillAddCriticalDamage@CObjUseSkill@@QAEXHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAddCriticalDamage
  00374	5f		 pop	 edi
  00375	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00376	b8 01 00 00 00	 mov	 eax, 1
  0037b	5b		 pop	 ebx

; 1030 : }

  0037c	8b e5		 mov	 esp, ebp
  0037e	5d		 pop	 ebp
  0037f	c2 10 00	 ret	 16			; 00000010H
$LN31@RunningSki:

; 973  : 
; 974  : 	case AT_SKILL_DEFENSEDOWN:	
; 975  : 		MaGumSkillDefenseDown(lpObj->m_Index,aTargetIndex,lpMagic);break;

  00382	56		 push	 esi
  00383	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00386	8b cf		 mov	 ecx, edi
  00388	ff 33		 push	 DWORD PTR [ebx]
  0038a	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::MaGumSkillDefenseDown
  0038f	5f		 pop	 edi
  00390	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00391	b8 01 00 00 00	 mov	 eax, 1
  00396	5b		 pop	 ebx

; 1030 : }

  00397	8b e5		 mov	 esp, ebp
  00399	5d		 pop	 ebp
  0039a	c2 10 00	 ret	 16			; 00000010H
$LN32@RunningSki:

; 976  : 
; 977  : 	case AT_SKILL_SUMMON:SkillSummon(lpObj->m_Index,aTargetIndex,lpMagic);break;

  0039d	56		 push	 esi
  0039e	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  003a1	8b cf		 mov	 ecx, edi
  003a3	ff 33		 push	 DWORD PTR [ebx]
  003a5	e8 00 00 00 00	 call	 ?SkillSummon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSummon
  003aa	5f		 pop	 edi
  003ab	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  003ac	b8 01 00 00 00	 mov	 eax, 1
  003b1	5b		 pop	 ebx

; 1030 : }

  003b2	8b e5		 mov	 esp, ebp
  003b4	5d		 pop	 ebp
  003b5	c2 10 00	 ret	 16			; 00000010H
$LN33@RunningSki:

; 978  : 	case AT_SKILL_IMMUNE_TO_MAGIC:	SkillImmuneToMagic(lpObj->m_Index,lpMagic);break;

  003b8	56		 push	 esi
  003b9	ff 33		 push	 DWORD PTR [ebx]
  003bb	8b cf		 mov	 ecx, edi
  003bd	e8 00 00 00 00	 call	 ?SkillImmuneToMagic@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToMagic
  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  003c4	b8 01 00 00 00	 mov	 eax, 1
  003c9	5b		 pop	 ebx

; 1030 : }

  003ca	8b e5		 mov	 esp, ebp
  003cc	5d		 pop	 ebp
  003cd	c2 10 00	 ret	 16			; 00000010H
$LN34@RunningSki:

; 979  : 	case AT_SKILL_IMMUNE_TO_HARM:	SkillImmuneToHarm(lpObj->m_Index,lpMagic);break;

  003d0	56		 push	 esi
  003d1	ff 33		 push	 DWORD PTR [ebx]
  003d3	8b cf		 mov	 ecx, edi
  003d5	e8 00 00 00 00	 call	 ?SkillImmuneToHarm@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillImmuneToHarm
  003da	5f		 pop	 edi
  003db	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  003dc	b8 01 00 00 00	 mov	 eax, 1
  003e1	5b		 pop	 ebx

; 1030 : }

  003e2	8b e5		 mov	 esp, ebp
  003e4	5d		 pop	 ebp
  003e5	c2 10 00	 ret	 16			; 00000010H
$LN35@RunningSki:

; 980  : 
; 981  : 	case AT_SKILL_RUSH:	SkillKnightRush(lpObj->m_Index,aTargetIndex,lpMagic);break;

  003e8	56		 push	 esi
  003e9	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  003ec	8b cf		 mov	 ecx, edi
  003ee	ff 33		 push	 DWORD PTR [ebx]
  003f0	e8 00 00 00 00	 call	 ?SkillKnightRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillKnightRush
  003f5	5f		 pop	 edi
  003f6	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  003f7	b8 01 00 00 00	 mov	 eax, 1
  003fc	5b		 pop	 ebx

; 1030 : }

  003fd	8b e5		 mov	 esp, ebp
  003ff	5d		 pop	 ebp
  00400	c2 10 00	 ret	 16			; 00000010H
$LN36@RunningSki:

; 982  : 	case AT_SKILL_JAVALIN:	SkillWizardJavalin(lpObj->m_Index,aTargetIndex,lpMagic);break;

  00403	56		 push	 esi
  00404	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00407	8b cf		 mov	 ecx, edi
  00409	ff 33		 push	 DWORD PTR [ebx]
  0040b	e8 00 00 00 00	 call	 ?SkillWizardJavalin@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillWizardJavalin
  00410	5f		 pop	 edi
  00411	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00412	b8 01 00 00 00	 mov	 eax, 1
  00417	5b		 pop	 ebx

; 1030 : }

  00418	8b e5		 mov	 esp, ebp
  0041a	5d		 pop	 ebp
  0041b	c2 10 00	 ret	 16			; 00000010H
$LN37@RunningSki:

; 983  : 	case AT_SKILL_DEEPIMPACT:	SkillElfRush(lpObj->m_Index,aTargetIndex,lpMagic);break;

  0041e	56		 push	 esi
  0041f	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00422	8b cf		 mov	 ecx, edi
  00424	ff 33		 push	 DWORD PTR [ebx]
  00426	e8 00 00 00 00	 call	 ?SkillElfRush@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillElfRush
  0042b	5f		 pop	 edi
  0042c	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0042d	b8 01 00 00 00	 mov	 eax, 1
  00432	5b		 pop	 ebx

; 1030 : }

  00433	8b e5		 mov	 esp, ebp
  00435	5d		 pop	 ebp
  00436	c2 10 00	 ret	 16			; 00000010H
$LN38@RunningSki:

; 984  : 	case AT_SKILL_ONE_FLASH:	SkillMagumOneFlash(lpObj->m_Index,aTargetIndex,lpMagic);break;

  00439	56		 push	 esi
  0043a	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0043d	8b cf		 mov	 ecx, edi
  0043f	ff 33		 push	 DWORD PTR [ebx]
  00441	e8 00 00 00 00	 call	 ?SkillMagumOneFlash@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumOneFlash
  00446	5f		 pop	 edi
  00447	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00448	b8 01 00 00 00	 mov	 eax, 1
  0044d	5b		 pop	 ebx

; 1030 : }

  0044e	8b e5		 mov	 esp, ebp
  00450	5d		 pop	 ebp
  00451	c2 10 00	 ret	 16			; 00000010H
$LN39@RunningSki:

; 985  : 	case AT_SKILL_DEATH_CANNON:	SkillMagumDeathCannon(lpObj->m_Index,aTargetIndex,lpMagic);break;

  00454	56		 push	 esi
  00455	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00458	8b cf		 mov	 ecx, edi
  0045a	ff 33		 push	 DWORD PTR [ebx]
  0045c	e8 00 00 00 00	 call	 ?SkillMagumDeathCannon@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMagumDeathCannon
  00461	5f		 pop	 edi
  00462	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00463	b8 01 00 00 00	 mov	 eax, 1
  00468	5b		 pop	 ebx

; 1030 : }

  00469	8b e5		 mov	 esp, ebp
  0046b	5d		 pop	 ebp
  0046c	c2 10 00	 ret	 16			; 00000010H
$LN40@RunningSki:

; 986  : 	case AT_SKILL_SPACE_SPLIT:	SkillDarklordSpaceSplit(lpObj->m_Index,aTargetIndex,lpMagic);break;

  0046f	56		 push	 esi
  00470	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00473	8b cf		 mov	 ecx, edi
  00475	ff 33		 push	 DWORD PTR [ebx]
  00477	e8 00 00 00 00	 call	 ?SkillDarklordSpaceSplit@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarklordSpaceSplit
  0047c	5f		 pop	 edi
  0047d	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0047e	b8 01 00 00 00	 mov	 eax, 1
  00483	5b		 pop	 ebx

; 1030 : }

  00484	8b e5		 mov	 esp, ebp
  00486	5d		 pop	 ebp
  00487	c2 10 00	 ret	 16			; 00000010H
$LN41@RunningSki:

; 987  : 
; 988  : 	case AT_SKILL_BRAND_OF_SKILL:	SkillBrandOfSkill(aIndex,aTargetIndex,lpMagic);break;

  0048a	56		 push	 esi
  0048b	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0048e	8b cf		 mov	 ecx, edi
  00490	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00493	e8 00 00 00 00	 call	 ?SkillBrandOfSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillBrandOfSkill
  00498	5f		 pop	 edi
  00499	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0049a	b8 01 00 00 00	 mov	 eax, 1
  0049f	5b		 pop	 ebx

; 1030 : }

  004a0	8b e5		 mov	 esp, ebp
  004a2	5d		 pop	 ebp
  004a3	c2 10 00	 ret	 16			; 00000010H
$LN42@RunningSki:

; 989  : 
; 990  : 	case AT_SKILL_REMOVAL_STUN:	SkillRemoveStun(aIndex,aTargetIndex,lpMagic);break;

  004a6	56		 push	 esi
  004a7	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  004aa	8b cf		 mov	 ecx, edi
  004ac	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  004af	e8 00 00 00 00	 call	 ?SkillRemoveStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveStun
  004b4	5f		 pop	 edi
  004b5	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  004b6	b8 01 00 00 00	 mov	 eax, 1
  004bb	5b		 pop	 ebx

; 1030 : }

  004bc	8b e5		 mov	 esp, ebp
  004be	5d		 pop	 ebp
  004bf	c2 10 00	 ret	 16			; 00000010H
$LN43@RunningSki:

; 991  : 	case AT_SKILL_ADD_MANA:	SkillAddMana(aIndex,aTargetIndex,lpMagic);break;

  004c2	56		 push	 esi
  004c3	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  004c6	8b cf		 mov	 ecx, edi
  004c8	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  004cb	e8 00 00 00 00	 call	 ?SkillAddMana@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillAddMana
  004d0	5f		 pop	 edi
  004d1	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  004d2	b8 01 00 00 00	 mov	 eax, 1
  004d7	5b		 pop	 ebx

; 1030 : }

  004d8	8b e5		 mov	 esp, ebp
  004da	5d		 pop	 ebp
  004db	c2 10 00	 ret	 16			; 00000010H
$LN44@RunningSki:

; 992  : 	case AT_SKILL_INVISIBLE:	SkillCloaking(aIndex,aTargetIndex,lpMagic);break;

  004de	56		 push	 esi
  004df	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  004e2	8b cf		 mov	 ecx, edi
  004e4	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  004e7	e8 00 00 00 00	 call	 ?SkillCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillCloaking
  004ec	5f		 pop	 edi
  004ed	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  004ee	b8 01 00 00 00	 mov	 eax, 1
  004f3	5b		 pop	 ebx

; 1030 : }

  004f4	8b e5		 mov	 esp, ebp
  004f6	5d		 pop	 ebp
  004f7	c2 10 00	 ret	 16			; 00000010H
$LN45@RunningSki:

; 993  : 	case AT_SKILL_REMOVAL_INVISIBLE:	SkillRemoveCloaking(aIndex,aTargetIndex,lpMagic);break;

  004fa	56		 push	 esi
  004fb	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  004fe	8b cf		 mov	 ecx, edi
  00500	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00503	e8 00 00 00 00	 call	 ?SkillRemoveCloaking@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveCloaking
  00508	5f		 pop	 edi
  00509	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0050a	b8 01 00 00 00	 mov	 eax, 1
  0050f	5b		 pop	 ebx

; 1030 : }

  00510	8b e5		 mov	 esp, ebp
  00512	5d		 pop	 ebp
  00513	c2 10 00	 ret	 16			; 00000010H
$LN46@RunningSki:

; 994  : 	case AT_SKILL_REMOVAL_MAGIC:	SkillRemoveMagic(aIndex,aTargetIndex,lpMagic);break;

  00516	56		 push	 esi
  00517	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0051a	8b cf		 mov	 ecx, edi
  0051c	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0051f	e8 00 00 00 00	 call	 ?SkillRemoveMagic@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRemoveMagic
  00524	5f		 pop	 edi
  00525	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00526	b8 01 00 00 00	 mov	 eax, 1
  0052b	5b		 pop	 ebx

; 1030 : }

  0052c	8b e5		 mov	 esp, ebp
  0052e	5d		 pop	 ebp
  0052f	c2 10 00	 ret	 16			; 00000010H
$LN47@RunningSki:

; 995  : 
; 996  : 	case AT_SKILL_INFINITY_ARROW:	
; 997  : 		SkillInfinityArrow(aIndex,aTargetIndex,lpMagic);break;

  00532	56		 push	 esi
  00533	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00536	8b cf		 mov	 ecx, edi
  00538	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0053b	e8 00 00 00 00	 call	 ?SkillInfinityArrow@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillInfinityArrow
  00540	5f		 pop	 edi
  00541	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00542	b8 01 00 00 00	 mov	 eax, 1
  00547	5b		 pop	 ebx

; 1030 : }

  00548	8b e5		 mov	 esp, ebp
  0054a	5d		 pop	 ebp
  0054b	c2 10 00	 ret	 16			; 00000010H
$LN48@RunningSki:

; 998  : 	case AT_SKILL_DAMAGEREFLECT:	SkillDamageReflect(aIndex,aTargetIndex,lpMagic);break;

  0054e	56		 push	 esi
  0054f	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00552	8b cf		 mov	 ecx, edi
  00554	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00557	e8 00 00 00 00	 call	 ?SkillDamageReflect@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDamageReflect
  0055c	5f		 pop	 edi
  0055d	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0055e	b8 01 00 00 00	 mov	 eax, 1
  00563	5b		 pop	 ebx

; 1030 : }

  00564	8b e5		 mov	 esp, ebp
  00566	5d		 pop	 ebp
  00567	c2 10 00	 ret	 16			; 00000010H
$LN49@RunningSki:

; 999  : 	case AT_SKILL_SLEEP:
; 1000 : 		SkillSleep(aIndex,aTargetIndex,lpMagic);	break;

  0056a	56		 push	 esi
  0056b	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0056e	8b cf		 mov	 ecx, edi
  00570	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00573	e8 00 00 00 00	 call	 ?SkillSleep@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillSleep
  00578	5f		 pop	 edi
  00579	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0057a	b8 01 00 00 00	 mov	 eax, 1
  0057f	5b		 pop	 ebx

; 1030 : }

  00580	8b e5		 mov	 esp, ebp
  00582	5d		 pop	 ebp
  00583	c2 10 00	 ret	 16			; 00000010H
$LN50@RunningSki:

; 1001 : 	case AT_SKILL_BERSERKER:
; 1002 : 		SkillBerserker(lpObj->m_Index,lpMagic);break;

  00586	56		 push	 esi
  00587	ff 33		 push	 DWORD PTR [ebx]
  00589	8b cf		 mov	 ecx, edi
  0058b	e8 00 00 00 00	 call	 ?SkillBerserker@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillBerserker
  00590	5f		 pop	 edi
  00591	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00592	b8 01 00 00 00	 mov	 eax, 1
  00597	5b		 pop	 ebx

; 1030 : }

  00598	8b e5		 mov	 esp, ebp
  0059a	5d		 pop	 ebp
  0059b	c2 10 00	 ret	 16			; 00000010H
$LN51@RunningSki:

; 1003 : 	case AT_SKILL_RECOVERY:	SkillRecovery(aIndex,aTargetIndex,lpMagic);	break;

  0059e	56		 push	 esi
  0059f	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  005a2	8b cf		 mov	 ecx, edi
  005a4	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  005a7	e8 00 00 00 00	 call	 ?SkillRecovery@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillRecovery
  005ac	5f		 pop	 edi
  005ad	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  005ae	b8 01 00 00 00	 mov	 eax, 1
  005b3	5b		 pop	 ebx

; 1030 : }

  005b4	8b e5		 mov	 esp, ebp
  005b6	5d		 pop	 ebp
  005b7	c2 10 00	 ret	 16			; 00000010H
$LN52@RunningSki:

; 1004 : 	case AT_SKILL_EXPWIZARDRY:
; 1005 : 		SkillExpWizard(aIndex,aTargetIndex,lpMagic);break;

  005ba	56		 push	 esi
  005bb	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  005be	8b cf		 mov	 ecx, edi
  005c0	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  005c3	e8 00 00 00 00	 call	 ?SkillExpWizard@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillExpWizard
  005c8	5f		 pop	 edi
  005c9	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  005ca	b8 01 00 00 00	 mov	 eax, 1
  005cf	5b		 pop	 ebx

; 1030 : }

  005d0	8b e5		 mov	 esp, ebp
  005d2	5d		 pop	 ebp
  005d3	c2 10 00	 ret	 16			; 00000010H
$LN55@RunningSki:

; 1012 : 		break;
; 1013 : 	case AT_SKILL_RAGEFIGHTER_WEAPON1:
; 1014 : 	case AT_SKILL_RAGEFIGHTER_WEAPON2:
; 1015 : 	case AT_SKILL_RAGEFIGHTER_CHAINDRIVE:
; 1016 : 	//case AT_SKILL_RAGEFIGHTER_DARKSIDE:
; 1017 : 		SkillMonkBarrageJustOneTarget(aIndex,lpMagic,aTargetIndex);

  005d6	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  005d9	8b cf		 mov	 ecx, edi
  005db	56		 push	 esi
  005dc	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  005df	e8 00 00 00 00	 call	 ?SkillMonkBarrageJustOneTarget@CObjUseSkill@@QAEXHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillMonkBarrageJustOneTarget
  005e4	5f		 pop	 edi
  005e5	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  005e6	b8 01 00 00 00	 mov	 eax, 1
  005eb	5b		 pop	 ebx

; 1030 : }

  005ec	8b e5		 mov	 esp, ebp
  005ee	5d		 pop	 ebp
  005ef	c2 10 00	 ret	 16			; 00000010H
$LN60@RunningSki:

; 903  : 	}
; 904  : 
; 905  : 	switch(MagicNumber)

  005f2	05 f7 fe ff ff	 add	 eax, -265		; fffffef7H
  005f7	83 f8 04	 cmp	 eax, 4
  005fa	77 55		 ja	 SHORT $LN58@RunningSki
  005fc	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN65@RunningSki[eax*4]
$LN53@RunningSki:

; 1006 : 	case AT_SKILL_RAGEFIGHTER_REDARMOR:
; 1007 : 		SkillMonkBuff(aIndex,lpMagic);

  00603	56		 push	 esi
  00604	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00607	8b cf		 mov	 ecx, edi
  00609	e8 00 00 00 00	 call	 ?SkillMonkBuff@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMonkBuff
  0060e	5f		 pop	 edi
  0060f	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00610	b8 01 00 00 00	 mov	 eax, 1
  00615	5b		 pop	 ebx

; 1030 : }

  00616	8b e5		 mov	 esp, ebp
  00618	5d		 pop	 ebp
  00619	c2 10 00	 ret	 16			; 00000010H
$LN54@RunningSki:

; 1008 : 		break;
; 1009 : 	case AT_SKILL_RAGEFIGHTER_FITNESS:
; 1010 : 	case AT_SKILL_RAGEFIGHTER_DEFRATE:
; 1011 : 		SkillMonkBuffApplyParty(aIndex,lpMagic);

  0061c	56		 push	 esi
  0061d	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00620	8b cf		 mov	 ecx, edi
  00622	e8 00 00 00 00	 call	 ?SkillMonkBuffApplyParty@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillMonkBuffApplyParty
  00627	5f		 pop	 edi
  00628	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00629	b8 01 00 00 00	 mov	 eax, 1
  0062e	5b		 pop	 ebx

; 1030 : }

  0062f	8b e5		 mov	 esp, ebp
  00631	5d		 pop	 ebp
  00632	c2 10 00	 ret	 16			; 00000010H
$LN57@RunningSki:

; 1018 : 		break;
; 1019 : 	case AT_SKILL_RAGEFIGHTER_DRAGONSLAYER:
; 1020 : 		gObjAttack(lpObj,lpTargetObj,lpMagic,1,0,0,0,0,0);
; 1021 : 		break;
; 1022 : 	case AT_SKILL_RAGEFIGHTER_SIEGE:
; 1023 : 		SkillCharge(aIndex,lpMagic,aTargetIndex);

  00635	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  00638	8b cf		 mov	 ecx, edi
  0063a	56		 push	 esi
  0063b	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0063e	e8 00 00 00 00	 call	 ?SkillCharge@CObjUseSkill@@QAEHHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillCharge
  00643	5f		 pop	 edi
  00644	5e		 pop	 esi

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  00645	b8 01 00 00 00	 mov	 eax, 1
  0064a	5b		 pop	 ebx

; 1030 : }

  0064b	8b e5		 mov	 esp, ebp
  0064d	5d		 pop	 ebp
  0064e	c2 10 00	 ret	 16			; 00000010H
$LN58@RunningSki:

; 1024 : 		break;
; 1025 : 
; 1026 : 	default:	gObjAttack(lpObj,lpTargetObj,lpMagic,1,0,0,0,0,0);break;

  00651	6a 00		 push	 0
  00653	6a 00		 push	 0
  00655	6a 00		 push	 0
  00657	6a 00		 push	 0
  00659	6a 00		 push	 0
  0065b	6a 01		 push	 1
  0065d	56		 push	 esi
  0065e	ff 75 fc	 push	 DWORD PTR _lpTargetObj$1$[ebp]
  00661	53		 push	 ebx
  00662	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00667	83 c4 24	 add	 esp, 36			; 00000024H
$LN2@RunningSki:

; 1027 : 	}
; 1028 : 
; 1029 : 	return true;

  0066a	5f		 pop	 edi
  0066b	5e		 pop	 esi
  0066c	b8 01 00 00 00	 mov	 eax, 1
  00671	5b		 pop	 ebx

; 1030 : }

  00672	8b e5		 mov	 esp, ebp
  00674	5d		 pop	 ebp
  00675	c2 10 00	 ret	 16			; 00000010H
$LN64@RunningSki:
  00678	00 00 00 00	 DD	 $LN58@RunningSki
  0067c	00 00 00 00	 DD	 $LN13@RunningSki
  00680	00 00 00 00	 DD	 $LN7@RunningSki
  00684	00 00 00 00	 DD	 $LN12@RunningSki
  00688	00 00 00 00	 DD	 $LN15@RunningSki
  0068c	00 00 00 00	 DD	 $LN16@RunningSki
  00690	00 00 00 00	 DD	 $LN17@RunningSki
  00694	00 00 00 00	 DD	 $LN18@RunningSki
  00698	00 00 00 00	 DD	 $LN19@RunningSki
  0069c	00 00 00 00	 DD	 $LN20@RunningSki
  006a0	00 00 00 00	 DD	 $LN21@RunningSki
  006a4	00 00 00 00	 DD	 $LN22@RunningSki
  006a8	00 00 00 00	 DD	 $LN23@RunningSki
  006ac	00 00 00 00	 DD	 $LN24@RunningSki
  006b0	00 00 00 00	 DD	 $LN25@RunningSki
  006b4	00 00 00 00	 DD	 $LN35@RunningSki
  006b8	00 00 00 00	 DD	 $LN36@RunningSki
  006bc	00 00 00 00	 DD	 $LN37@RunningSki
  006c0	00 00 00 00	 DD	 $LN14@RunningSki
  006c4	00 00 00 00	 DD	 $LN31@RunningSki
  006c8	00 00 00 00	 DD	 $LN38@RunningSki
  006cc	00 00 00 00	 DD	 $LN26@RunningSki
  006d0	00 00 00 00	 DD	 $LN27@RunningSki
  006d4	00 00 00 00	 DD	 $LN28@RunningSki
  006d8	00 00 00 00	 DD	 $LN29@RunningSki
  006dc	00 00 00 00	 DD	 $LN30@RunningSki
  006e0	00 00 00 00	 DD	 $LN42@RunningSki
  006e4	00 00 00 00	 DD	 $LN43@RunningSki
  006e8	00 00 00 00	 DD	 $LN44@RunningSki
  006ec	00 00 00 00	 DD	 $LN45@RunningSki
  006f0	00 00 00 00	 DD	 $LN46@RunningSki
  006f4	00 00 00 00	 DD	 $LN39@RunningSki
  006f8	00 00 00 00	 DD	 $LN40@RunningSki
  006fc	00 00 00 00	 DD	 $LN41@RunningSki
  00700	00 00 00 00	 DD	 $LN47@RunningSki
  00704	00 00 00 00	 DD	 $LN32@RunningSki
  00708	00 00 00 00	 DD	 $LN33@RunningSki
  0070c	00 00 00 00	 DD	 $LN34@RunningSki
  00710	00 00 00 00	 DD	 $LN48@RunningSki
  00714	00 00 00 00	 DD	 $LN50@RunningSki
  00718	00 00 00 00	 DD	 $LN49@RunningSki
  0071c	00 00 00 00	 DD	 $LN52@RunningSki
  00720	00 00 00 00	 DD	 $LN51@RunningSki
  00724	00 00 00 00	 DD	 $LN58@RunningSki
$LN61@RunningSki:
  00728	00		 DB	 0
  00729	00		 DB	 0
  0072a	00		 DB	 0
  0072b	00		 DB	 0
  0072c	00		 DB	 0
  0072d	2b		 DB	 43			; 0000002bH
  0072e	00		 DB	 0
  0072f	2b		 DB	 43			; 0000002bH
  00730	2b		 DB	 43			; 0000002bH
  00731	2b		 DB	 43			; 0000002bH
  00732	2b		 DB	 43			; 0000002bH
  00733	2b		 DB	 43			; 0000002bH
  00734	2b		 DB	 43			; 0000002bH
  00735	2b		 DB	 43			; 0000002bH
  00736	2b		 DB	 43			; 0000002bH
  00737	01		 DB	 1
  00738	00		 DB	 0
  00739	02		 DB	 2
  0073a	00		 DB	 0
  0073b	00		 DB	 0
  0073c	00		 DB	 0
  0073d	00		 DB	 0
  0073e	00		 DB	 0
  0073f	00		 DB	 0
  00740	00		 DB	 0
  00741	03		 DB	 3
  00742	04		 DB	 4
  00743	05		 DB	 5
  00744	2b		 DB	 43			; 0000002bH
  00745	06		 DB	 6
  00746	07		 DB	 7
  00747	08		 DB	 8
  00748	09		 DB	 9
  00749	0a		 DB	 10			; 0000000aH
  0074a	0b		 DB	 11			; 0000000bH
  0074b	0c		 DB	 12			; 0000000cH
  0074c	2b		 DB	 43			; 0000002bH
  0074d	2b		 DB	 43			; 0000002bH
  0074e	2b		 DB	 43			; 0000002bH
  0074f	0d		 DB	 13			; 0000000dH
  00750	00		 DB	 0
  00751	00		 DB	 0
  00752	0e		 DB	 14			; 0000000eH
  00753	0f		 DB	 15			; 0000000fH
  00754	10		 DB	 16			; 00000010H
  00755	11		 DB	 17			; 00000011H
  00756	00		 DB	 0
  00757	12		 DB	 18			; 00000012H
  00758	2b		 DB	 43			; 0000002bH
  00759	2b		 DB	 43			; 0000002bH
  0075a	2b		 DB	 43			; 0000002bH
  0075b	00		 DB	 0
  0075c	2b		 DB	 43			; 0000002bH
  0075d	2b		 DB	 43			; 0000002bH
  0075e	13		 DB	 19			; 00000013H
  0075f	00		 DB	 0
  00760	14		 DB	 20			; 00000014H
  00761	2b		 DB	 43			; 0000002bH
  00762	2b		 DB	 43			; 0000002bH
  00763	15		 DB	 21			; 00000015H
  00764	16		 DB	 22			; 00000016H
  00765	17		 DB	 23			; 00000017H
  00766	18		 DB	 24			; 00000018H
  00767	19		 DB	 25			; 00000019H
  00768	2b		 DB	 43			; 0000002bH
  00769	2b		 DB	 43			; 0000002bH
  0076a	2b		 DB	 43			; 0000002bH
  0076b	1a		 DB	 26			; 0000001aH
  0076c	1b		 DB	 27			; 0000001bH
  0076d	1c		 DB	 28			; 0000001cH
  0076e	1d		 DB	 29			; 0000001dH
  0076f	1e		 DB	 30			; 0000001eH
  00770	1f		 DB	 31			; 0000001fH
  00771	20		 DB	 32			; 00000020H
  00772	21		 DB	 33			; 00000021H
  00773	2b		 DB	 43			; 0000002bH
  00774	22		 DB	 34			; 00000022H
  00775	2b		 DB	 43			; 0000002bH
  00776	2b		 DB	 43			; 0000002bH
  00777	2b		 DB	 43			; 0000002bH
  00778	2b		 DB	 43			; 0000002bH
  00779	2b		 DB	 43			; 0000002bH
  0077a	2b		 DB	 43			; 0000002bH
  0077b	2b		 DB	 43			; 0000002bH
  0077c	2b		 DB	 43			; 0000002bH
  0077d	2b		 DB	 43			; 0000002bH
  0077e	2b		 DB	 43			; 0000002bH
  0077f	2b		 DB	 43			; 0000002bH
  00780	2b		 DB	 43			; 0000002bH
  00781	2b		 DB	 43			; 0000002bH
  00782	2b		 DB	 43			; 0000002bH
  00783	2b		 DB	 43			; 0000002bH
  00784	2b		 DB	 43			; 0000002bH
  00785	2b		 DB	 43			; 0000002bH
  00786	2b		 DB	 43			; 0000002bH
  00787	2b		 DB	 43			; 0000002bH
  00788	2b		 DB	 43			; 0000002bH
  00789	2b		 DB	 43			; 0000002bH
  0078a	2b		 DB	 43			; 0000002bH
  0078b	2b		 DB	 43			; 0000002bH
  0078c	2b		 DB	 43			; 0000002bH
  0078d	2b		 DB	 43			; 0000002bH
  0078e	2b		 DB	 43			; 0000002bH
  0078f	2b		 DB	 43			; 0000002bH
  00790	2b		 DB	 43			; 0000002bH
  00791	2b		 DB	 43			; 0000002bH
  00792	2b		 DB	 43			; 0000002bH
  00793	2b		 DB	 43			; 0000002bH
  00794	2b		 DB	 43			; 0000002bH
  00795	2b		 DB	 43			; 0000002bH
  00796	2b		 DB	 43			; 0000002bH
  00797	2b		 DB	 43			; 0000002bH
  00798	2b		 DB	 43			; 0000002bH
  00799	2b		 DB	 43			; 0000002bH
  0079a	2b		 DB	 43			; 0000002bH
  0079b	2b		 DB	 43			; 0000002bH
  0079c	2b		 DB	 43			; 0000002bH
  0079d	2b		 DB	 43			; 0000002bH
  0079e	2b		 DB	 43			; 0000002bH
  0079f	2b		 DB	 43			; 0000002bH
  007a0	2b		 DB	 43			; 0000002bH
  007a1	2b		 DB	 43			; 0000002bH
  007a2	2b		 DB	 43			; 0000002bH
  007a3	2b		 DB	 43			; 0000002bH
  007a4	2b		 DB	 43			; 0000002bH
  007a5	2b		 DB	 43			; 0000002bH
  007a6	2b		 DB	 43			; 0000002bH
  007a7	2b		 DB	 43			; 0000002bH
  007a8	2b		 DB	 43			; 0000002bH
  007a9	2b		 DB	 43			; 0000002bH
  007aa	2b		 DB	 43			; 0000002bH
  007ab	2b		 DB	 43			; 0000002bH
  007ac	2b		 DB	 43			; 0000002bH
  007ad	2b		 DB	 43			; 0000002bH
  007ae	2b		 DB	 43			; 0000002bH
  007af	2b		 DB	 43			; 0000002bH
  007b0	2b		 DB	 43			; 0000002bH
  007b1	2b		 DB	 43			; 0000002bH
  007b2	2b		 DB	 43			; 0000002bH
  007b3	2b		 DB	 43			; 0000002bH
  007b4	2b		 DB	 43			; 0000002bH
  007b5	2b		 DB	 43			; 0000002bH
  007b6	2b		 DB	 43			; 0000002bH
  007b7	2b		 DB	 43			; 0000002bH
  007b8	2b		 DB	 43			; 0000002bH
  007b9	2b		 DB	 43			; 0000002bH
  007ba	2b		 DB	 43			; 0000002bH
  007bb	2b		 DB	 43			; 0000002bH
  007bc	2b		 DB	 43			; 0000002bH
  007bd	2b		 DB	 43			; 0000002bH
  007be	2b		 DB	 43			; 0000002bH
  007bf	2b		 DB	 43			; 0000002bH
  007c0	2b		 DB	 43			; 0000002bH
  007c1	2b		 DB	 43			; 0000002bH
  007c2	2b		 DB	 43			; 0000002bH
  007c3	2b		 DB	 43			; 0000002bH
  007c4	2b		 DB	 43			; 0000002bH
  007c5	2b		 DB	 43			; 0000002bH
  007c6	2b		 DB	 43			; 0000002bH
  007c7	2b		 DB	 43			; 0000002bH
  007c8	2b		 DB	 43			; 0000002bH
  007c9	2b		 DB	 43			; 0000002bH
  007ca	2b		 DB	 43			; 0000002bH
  007cb	2b		 DB	 43			; 0000002bH
  007cc	2b		 DB	 43			; 0000002bH
  007cd	2b		 DB	 43			; 0000002bH
  007ce	2b		 DB	 43			; 0000002bH
  007cf	2b		 DB	 43			; 0000002bH
  007d0	2b		 DB	 43			; 0000002bH
  007d1	2b		 DB	 43			; 0000002bH
  007d2	2b		 DB	 43			; 0000002bH
  007d3	2b		 DB	 43			; 0000002bH
  007d4	2b		 DB	 43			; 0000002bH
  007d5	2b		 DB	 43			; 0000002bH
  007d6	2b		 DB	 43			; 0000002bH
  007d7	2b		 DB	 43			; 0000002bH
  007d8	2b		 DB	 43			; 0000002bH
  007d9	2b		 DB	 43			; 0000002bH
  007da	2b		 DB	 43			; 0000002bH
  007db	2b		 DB	 43			; 0000002bH
  007dc	2b		 DB	 43			; 0000002bH
  007dd	2b		 DB	 43			; 0000002bH
  007de	2b		 DB	 43			; 0000002bH
  007df	2b		 DB	 43			; 0000002bH
  007e0	2b		 DB	 43			; 0000002bH
  007e1	2b		 DB	 43			; 0000002bH
  007e2	2b		 DB	 43			; 0000002bH
  007e3	2b		 DB	 43			; 0000002bH
  007e4	2b		 DB	 43			; 0000002bH
  007e5	2b		 DB	 43			; 0000002bH
  007e6	2b		 DB	 43			; 0000002bH
  007e7	2b		 DB	 43			; 0000002bH
  007e8	2b		 DB	 43			; 0000002bH
  007e9	2b		 DB	 43			; 0000002bH
  007ea	2b		 DB	 43			; 0000002bH
  007eb	2b		 DB	 43			; 0000002bH
  007ec	2b		 DB	 43			; 0000002bH
  007ed	2b		 DB	 43			; 0000002bH
  007ee	2b		 DB	 43			; 0000002bH
  007ef	23		 DB	 35			; 00000023H
  007f0	24		 DB	 36			; 00000024H
  007f1	25		 DB	 37			; 00000025H
  007f2	2b		 DB	 43			; 0000002bH
  007f3	2b		 DB	 43			; 0000002bH
  007f4	2b		 DB	 43			; 0000002bH
  007f5	2b		 DB	 43			; 0000002bH
  007f6	2b		 DB	 43			; 0000002bH
  007f7	2b		 DB	 43			; 0000002bH
  007f8	2b		 DB	 43			; 0000002bH
  007f9	2b		 DB	 43			; 0000002bH
  007fa	2b		 DB	 43			; 0000002bH
  007fb	2b		 DB	 43			; 0000002bH
  007fc	2b		 DB	 43			; 0000002bH
  007fd	2b		 DB	 43			; 0000002bH
  007fe	2b		 DB	 43			; 0000002bH
  007ff	2b		 DB	 43			; 0000002bH
  00800	26		 DB	 38			; 00000026H
  00801	27		 DB	 39			; 00000027H
  00802	28		 DB	 40			; 00000028H
  00803	2b		 DB	 43			; 0000002bH
  00804	2b		 DB	 43			; 0000002bH
  00805	2b		 DB	 43			; 0000002bH
  00806	2b		 DB	 43			; 0000002bH
  00807	2b		 DB	 43			; 0000002bH
  00808	2b		 DB	 43			; 0000002bH
  00809	2b		 DB	 43			; 0000002bH
  0080a	2b		 DB	 43			; 0000002bH
  0080b	2b		 DB	 43			; 0000002bH
  0080c	2b		 DB	 43			; 0000002bH
  0080d	2b		 DB	 43			; 0000002bH
  0080e	2b		 DB	 43			; 0000002bH
  0080f	2b		 DB	 43			; 0000002bH
  00810	29		 DB	 41			; 00000029H
  00811	2a		 DB	 42			; 0000002aH
  00812	66 90		 npad	 2
$LN65@RunningSki:
  00814	00 00 00 00	 DD	 $LN58@RunningSki
  00818	00 00 00 00	 DD	 $LN53@RunningSki
  0081c	00 00 00 00	 DD	 $LN54@RunningSki
  00820	00 00 00 00	 DD	 $LN54@RunningSki
  00824	00 00 00 00	 DD	 $LN57@RunningSki
?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ENDP ; CObjUseSkill::RunningSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z
_TEXT	SEGMENT
_bCombo$2$ = -48					; size = 4
_usebp$1$ = -44						; size = 4
_pMsg$1 = -44						; size = 7
tv885 = -36						; size = 4
_usemana$1$ = -36					; size = 4
tv884 = -32						; size = 4
_lpObj$1$ = -28						; size = 4
_aIndex$GSCopy$1$ = -24					; size = 4
_this$GSCopy$1$ = -20					; size = 4
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_dir$ = 24						; size = 1
_TargetPos$ = 28					; size = 1
_aTargetIndex$ = 32					; size = 4
?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z PROC	; CObjUseSkill::UseSkill, COMDAT
; _this$ = ecx

; 617  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 20	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _lpMagic$[ebp]
  00018	89 4d ec	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001e	57		 push	 edi

; 618  : 	LPOBJ lpObj = &gObj[aIndex];
; 619  : 
; 620  : 	int bCombo = 0;
; 621  : 
; 622  : 	if(gComboAttack.CheckCombo(aIndex,lpMagic->m_Skill))

  0001f	ff 76 08	 push	 DWORD PTR [esi+8]
  00022	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  0002e	89 4d e8	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], ecx
  00031	51		 push	 ecx
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  00037	03 fa		 add	 edi, edx
  00039	89 55 e0	 mov	 DWORD PTR tv884[ebp], edx
  0003c	89 7d e4	 mov	 DWORD PTR _lpObj$1$[ebp], edi
  0003f	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo
  00044	85 c0		 test	 eax, eax
  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	b8 00 00 00 00	 mov	 eax, 0
  00050	0f 45 c1	 cmovne	 eax, ecx

; 623  : 	{
; 624  : 		bCombo = 1;
; 625  : 	}
; 626  : 
; 627  : 	if(lpObj->SkillHellFire2State && lpMagic->m_Skill != AT_SKILL_EXPHELL && lpMagic->m_Skill != AT_MSKILL_DW_NOVA1)

  00053	80 bf a8 14 00
	00 00		 cmp	 BYTE PTR [edi+5288], 0
  0005a	89 45 d0	 mov	 DWORD PTR _bCombo$2$[ebp], eax
  0005d	0f 84 87 00 00
	00		 je	 $LN8@UseSkill
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	83 f8 28	 cmp	 eax, 40			; 00000028H
  00069	74 7f		 je	 SHORT $LN8@UseSkill
  0006b	3d 88 01 00 00	 cmp	 eax, 392		; 00000188H
  00070	74 78		 je	 SHORT $LN8@UseSkill

; 628  : 	{
; 629  : 		CMagicInf * lpMagic = gObjGetMagicSearch(lpObj,AT_MSKILL_DW_NOVA1);

  00072	68 88 01 00 00	 push	 392			; 00000188H
  00077	57		 push	 edi
  00078	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0007d	83 c4 08	 add	 esp, 8

; 630  : 
; 631  : 		if(lpMagic == NULL )

  00080	85 c0		 test	 eax, eax
  00082	75 13		 jne	 SHORT $LN95@UseSkill

; 632  : 		{
; 633  : 			lpMagic = gObjGetMagicSearch(lpObj,AT_SKILL_EXPHELL);

  00084	6a 28		 push	 40			; 00000028H
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0008c	83 c4 08	 add	 esp, 8

; 634  : 		}
; 635  : 
; 636  : 		if(lpMagic != 0)

  0008f	85 c0		 test	 eax, eax
  00091	0f 84 d7 07 00
	00		 je	 $LN79@UseSkill
$LN95@UseSkill:

; 637  : 		{
; 638  : 			if( lpMagic->m_Skill == AT_SKILL_EXPHELL )

  00097	83 78 08 28	 cmp	 DWORD PTR [eax+8], 40	; 00000028H

; 639  : 				gObjUseSkill.RunningSkill(lpObj->m_Index,0,lpMagic,0);

  0009b	6a 00		 push	 0
  0009d	75 22		 jne	 SHORT $LN11@UseSkill
  0009f	50		 push	 eax
  000a0	6a 00		 push	 0
  000a2	ff 37		 push	 DWORD PTR [edi]
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000a9	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	33 cd		 xor	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 1c 00	 ret	 28			; 0000001cH
$LN11@UseSkill:

; 640  : 			else
; 641  : 				g_MasterSkillSystem.RunningSkill_MLS(lpObj,0,lpMagic,0,0,0,0,0);

  000c1	6a 00		 push	 0
  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	6a 00		 push	 0
  000c9	50		 push	 eax
  000ca	6a 00		 push	 0
  000cc	57		 push	 edi
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  000d2	e8 00 00 00 00	 call	 ?RunningSkill_MLS@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@HPAVCMagicInf@@HEEEE@Z ; CMasterLevelSkillTreeSystem::RunningSkill_MLS
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 cd		 xor	 ecx, ebp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 1c 00	 ret	 28			; 0000001cH
$LN8@UseSkill:

; 642  : 		}
; 643  : 		return;
; 644  : 	}
; 645  : 
; 646  : 	int usemana = GetUseMana(aIndex,lpMagic);

  000ea	8b 7d e8	 mov	 edi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000f0	56		 push	 esi
  000f1	57		 push	 edi
  000f2	e8 00 00 00 00	 call	 ?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::GetUseMana

; 647  : 
; 648  : 	if( lpMagic->m_Skill == 62 )

  000f7	83 7e 08 3e	 cmp	 DWORD PTR [esi+8], 62	; 0000003eH
  000fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 649  : 	{
; 650  : 		usemana = (int)gObj[aIndex].Mana;

  00101	8b 4d e0	 mov	 ecx, DWORD PTR tv884[ebp]
  00104	89 45 dc	 mov	 DWORD PTR _usemana$1$[ebp], eax
  00107	75 0c		 jne	 SHORT $LN13@UseSkill
  00109	f3 0f 2c 84 11
	ec 00 00 00	 cvttss2si eax, DWORD PTR [ecx+edx+236]
  00112	89 45 dc	 mov	 DWORD PTR _usemana$1$[ebp], eax
$LN13@UseSkill:

; 651  : 	}
; 652  : 
; 653  : 	PMSG_DURATION_MAGIC_SEND pMsg;
; 654  : 
; 655  : 	if(usemana >= 0)

  00115	85 c0		 test	 eax, eax
  00117	0f 88 51 07 00
	00		 js	 $LN79@UseSkill

; 656  : 	{
; 657  : 		if(!gObj[aIndex].SkillDelay.Check(lpMagic->m_Skill))

  0011d	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  00121	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00127	50		 push	 eax
  00128	03 ca		 add	 ecx, edx
  0012a	e8 00 00 00 00	 call	 ?Check@CSkillDelay@@QAEHE@Z ; CSkillDelay::Check
  0012f	85 c0		 test	 eax, eax

; 658  : 		{
; 659  : 			LogAddTD("[%s] Skill delay error!",gObj[aIndex].AccountID);

  00131	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00136	75 28		 jne	 SHORT $LN15@UseSkill
  00138	83 c0 52	 add	 eax, 82			; 00000052H
  0013b	03 45 e0	 add	 eax, DWORD PTR tv884[ebp]
  0013e	50		 push	 eax
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HDEGKDLO@?$FL?$CFs?$FN?5Skill?5delay?5error?$CB?$AA@
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014a	83 c4 08	 add	 esp, 8
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00150	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 1c 00	 ret	 28			; 0000001cH
$LN15@UseSkill:

; 660  : 			return;
; 661  : 		}
; 662  : 
; 663  : 		int usebp = gObjMagicBPUse(&gObj[aIndex],lpMagic);

  00160	03 45 e0	 add	 eax, DWORD PTR tv884[ebp]
  00163	56		 push	 esi
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  0016a	83 c4 08	 add	 esp, 8
  0016d	89 45 d4	 mov	 DWORD PTR _usebp$1$[ebp], eax

; 664  : 
; 665  : 		if(usebp >= 0)

  00170	85 c0		 test	 eax, eax
  00172	0f 88 14 01 00
	00		 js	 $LN19@UseSkill

; 666  : 		{
; 667  : 			lpObj->UseMagicNumber = lpMagic->m_Skill;

  00178	8b 7d e4	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  0017b	66 8b 4e 08	 mov	 cx, WORD PTR [esi+8]
  0017f	66 89 8f ae 06
	00 00		 mov	 WORD PTR [edi+1710], cx

; 668  : 			lpObj->UseMagicTime = GetTickCount();

  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0018c	66 0f 6e 45 dc	 movd	 xmm0, DWORD PTR _usemana$1$[ebp]
  00191	89 87 b0 06 00
	00		 mov	 DWORD PTR [edi+1712], eax

; 669  : 			lpObj->UseMagicCount = 0;
; 670  : 
; 671  : 			lpObj->Mana = (float)usemana;
; 672  : 			lpObj->BP = usebp;

  00197	8b 45 d4	 mov	 eax, DWORD PTR _usebp$1$[ebp]
  0019a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0019d	89 87 04 01 00
	00		 mov	 DWORD PTR [edi+260], eax

; 673  : 
; 674  : 			GCManaSend(lpObj->m_Index,(WORD)lpObj->Mana,0xFF,0,lpObj->BP);

  001a3	0f b7 c0	 movzx	 eax, ax
  001a6	50		 push	 eax
  001a7	6a 00		 push	 0
  001a9	68 ff 00 00 00	 push	 255			; 000000ffH
  001ae	f3 0f 2c c0	 cvttss2si eax, xmm0
  001b2	c6 87 b4 06 00
	00 00		 mov	 BYTE PTR [edi+1716], 0
  001b9	f3 0f 11 87 ec
	00 00 00	 movss	 DWORD PTR [edi+236], xmm0
  001c1	0f b7 c0	 movzx	 eax, ax
  001c4	50		 push	 eax
  001c5	ff 37		 push	 DWORD PTR [edi]
  001c7	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend

; 675  : 
; 676  : 			PHeadSetBE((PBYTE)&pMsg,0x1E,sizeof(pMsg));

  001cc	6a 0a		 push	 10			; 0000000aH
  001ce	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001d1	6a 1e		 push	 30			; 0000001eH
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 677  : 
; 678  : 			pMsg.MagicNumberH = SET_NUMBERH(lpMagic->m_Skill);

  001d9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001dc	83 c4 20	 add	 esp, 32			; 00000020H

; 679  : 			pMsg.MagicNumberL = SET_NUMBERL(lpMagic->m_Skill);
; 680  : 
; 681  : 			pMsg.X = x;
; 682  : 			pMsg.Y = y;
; 683  : 			pMsg.Dir = dir;
; 684  : 			pMsg.NumberH = SET_NUMBERH(aIndex);

  001df	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$1$[ebp]
  001e2	c1 e8 08	 shr	 eax, 8
  001e5	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+6], al
  001e8	8a 46 08	 mov	 al, BYTE PTR [esi+8]
  001eb	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+8], al
  001ee	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  001f1	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al
  001f4	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  001f7	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al
  001fa	8b 45 18	 mov	 eax, DWORD PTR _dir$[ebp]
  001fd	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00200	8b c1		 mov	 eax, ecx
  00202	c1 e8 08	 shr	 eax, 8
  00205	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 685  : 			pMsg.NumberL = SET_NUMBERL(aIndex);

  00208	88 4d f9	 mov	 BYTE PTR _pMsg$[ebp+9], cl

; 686  : 
; 687  : 			if(lpObj->Type == OBJ_USER)

  0020b	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0020f	75 13		 jne	 SHORT $LN17@UseSkill

; 688  : 			{
; 689  : 				DataSend(lpObj->m_Index,(PBYTE)&pMsg,pMsg.h.size);

  00211	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00215	50		 push	 eax
  00216	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00219	50		 push	 eax
  0021a	ff 37		 push	 DWORD PTR [edi]
  0021c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@UseSkill:

; 690  : 			}
; 691  : 
; 692  : 			if(CC_MAP_RANGE(lpObj->MapNumber))

  00224	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  0022a	3c 35		 cmp	 al, 53			; 00000035H
  0022c	74 0f		 je	 SHORT $LN96@UseSkill
  0022e	3c 12		 cmp	 al, 18			; 00000012H
  00230	72 45		 jb	 SHORT $LN21@UseSkill
  00232	b1 17		 mov	 cl, 23			; 00000017H
  00234	3a c8		 cmp	 cl, al
  00236	1b c0		 sbb	 eax, eax
  00238	83 c0 01	 add	 eax, 1
  0023b	74 3a		 je	 SHORT $LN21@UseSkill
$LN96@UseSkill:

; 693  : 			{
; 694  : 				switch(lpMagic->m_Skill)

  0023d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00240	3d 64 01 00 00	 cmp	 eax, 356		; 00000164H
  00245	7f 18		 jg	 SHORT $LN86@UseSkill
  00247	74 40		 je	 SHORT $LN103@UseSkill
  00249	83 e8 10	 sub	 eax, 16			; 00000010H
  0024c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0024f	77 26		 ja	 SHORT $LN21@UseSkill
  00251	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN99@UseSkill[eax]
  00258	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN106@UseSkill[eax*4]
$LN86@UseSkill:
  0025f	2d 68 01 00 00	 sub	 eax, 360		; 00000168H
  00264	83 f8 49	 cmp	 eax, 73			; 00000049H
  00267	77 0e		 ja	 SHORT $LN21@UseSkill
  00269	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN100@UseSkill[eax]
  00270	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN107@UseSkill[eax*4]
$LN21@UseSkill:

; 695  : 				{
; 696  : 				case AT_SKILL_MAGICDEFENSE:
; 697  : 				case AT_SKILL_HEALING:
; 698  : 				case AT_SKILL_DEFENSE:
; 699  : 				case AT_SKILL_ATTACK:
; 700  : 				case AT_SKILL_KNIGHTADDLIFE:
; 701  : 					//MSKILL
; 702  : 				case AT_MSKILL_DW_MANASHIELD1:
; 703  : 				case AT_MSKILL_DW_MANASHIELD2:
; 704  : 				case AT_MSKILL_DW_MANASHIELD3:
; 705  : 				case AT_MSKILL_FE_HEAL1:
; 706  : 				case AT_MSKILL_FE_DEFENSEBUFF1:
; 707  : 				case AT_MSKILL_FE_DEFENSEBUFF2:
; 708  : 				case AT_MSKILL_FE_CURE:
; 709  : 				case AT_MSKILL_FE_BLESS:
; 710  : 				case AT_MSKILL_FE_BLESS1:
; 711  : 				case AT_MSKILL_FE_ATTACKBUFF1:
; 712  : 				case AT_MSKILL_FE_ATTACKBUFF2:
; 713  : 				case AT_MSKILL_DK_SWELLLIFE1:
; 714  : 				case AT_MSKILL_DK_SWELLLIFE2:
; 715  : 				case AT_MSKILL_DK_SWELLLIFE3:
; 716  : 					break;
; 717  : 				default: 
; 718  : 					MsgSendV2(lpObj,(PBYTE)&pMsg,pMsg.h.size);

  00277	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0027b	50		 push	 eax
  0027c	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0027f	50		 push	 eax
  00280	57		 push	 edi
  00281	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00286	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN103@UseSkill:
  00289	8b 7d e8	 mov	 edi, DWORD PTR _aIndex$GSCopy$1$[ebp]
$LN19@UseSkill:

; 719  : 				}
; 720  : 			}
; 721  : 			else
; 722  : 			{
; 723  : 				MsgSendV2(lpObj,(PBYTE)&pMsg,pMsg.h.size);
; 724  : 			}
; 725  : 		}
; 726  : 
; 727  : 		if( g_MasterSkillSystem.CheckMasterLevelSkill(lpMagic->m_Skill) )

  0028c	ff 76 08	 push	 DWORD PTR [esi+8]
  0028f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00294	e8 00 00 00 00	 call	 ?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
  00299	85 c0		 test	 eax, eax
  0029b	74 33		 je	 SHORT $LN22@UseSkill

; 728  : 		{
; 729  : 			g_MasterSkillSystem.RunningSkill_MLS(lpObj,aTargetIndex,lpMagic,bCombo,x,y,dir,TargetPos);

  0029d	ff 75 1c	 push	 DWORD PTR _TargetPos$[ebp]
  002a0	8b 45 d0	 mov	 eax, DWORD PTR _bCombo$2$[ebp]
  002a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  002a8	ff 75 18	 push	 DWORD PTR _dir$[ebp]
  002ab	ff 75 14	 push	 DWORD PTR _y$[ebp]
  002ae	ff 75 10	 push	 DWORD PTR _x$[ebp]
  002b1	50		 push	 eax
  002b2	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  002b5	56		 push	 esi
  002b6	53		 push	 ebx
  002b7	50		 push	 eax
  002b8	e8 00 00 00 00	 call	 ?RunningSkill_MLS@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@HPAVCMagicInf@@HEEEE@Z ; CMasterLevelSkillTreeSystem::RunningSkill_MLS
  002bd	5f		 pop	 edi
  002be	5e		 pop	 esi
  002bf	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  002c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c3	33 cd		 xor	 ecx, ebp
  002c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ca	8b e5		 mov	 esp, ebp
  002cc	5d		 pop	 ebp
  002cd	c2 1c 00	 ret	 28			; 0000001cH
$LN22@UseSkill:

; 730  : 			return;
; 731  : 		}
; 732  : 
; 733  : 		if( lpMagic->m_Skill == AT_SKILL_SWORD6 )

  002d0	83 7e 08 38	 cmp	 DWORD PTR [esi+8], 56	; 00000038H
  002d4	8b 4d 1c	 mov	 ecx, DWORD PTR _TargetPos$[ebp]
  002d7	75 18		 jne	 SHORT $LN23@UseSkill

; 734  : 		{
; 735  : 			SkillPowerSlash(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  002d9	53		 push	 ebx
  002da	51		 push	 ecx
  002db	ff 75 18	 push	 DWORD PTR _dir$[ebp]
  002de	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  002e1	ff 75 14	 push	 DWORD PTR _y$[ebp]
  002e4	ff 75 10	 push	 DWORD PTR _x$[ebp]
  002e7	56		 push	 esi
  002e8	57		 push	 edi
  002e9	e8 00 00 00 00	 call	 ?SkillPowerSlash@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillPowerSlash
  002ee	8b 4d 1c	 mov	 ecx, DWORD PTR _TargetPos$[ebp]
$LN23@UseSkill:

; 736  : 		}
; 737  : 
; 738  : 		if( lpMagic->m_Skill == AT_SKILL_EXPPOISON )

  002f1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002f4	83 f8 26	 cmp	 eax, 38			; 00000026H
  002f7	75 5c		 jne	 SHORT $LN24@UseSkill

; 739  : 		{
; 740  : 			if(	lpObj->Class == 561	) //Medusa Ok

  002f9	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  002fc	ba 31 02 00 00	 mov	 edx, 561		; 00000231H

; 741  : 			{
; 742  : 				SkillDeathPoisonForMeDusa(aIndex, lpMagic, x, y, aTargetIndex);

  00301	53		 push	 ebx
  00302	66 39 90 90 00
	00 00		 cmp	 WORD PTR [eax+144], dx
  00309	75 23		 jne	 SHORT $LN26@UseSkill
  0030b	ff 75 14	 push	 DWORD PTR _y$[ebp]
  0030e	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00311	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00314	56		 push	 esi
  00315	57		 push	 edi
  00316	e8 00 00 00 00	 call	 ?SkillDeathPoisonForMeDusa@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillDeathPoisonForMeDusa
  0031b	5f		 pop	 edi
  0031c	5e		 pop	 esi
  0031d	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0031e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00321	33 cd		 xor	 ecx, ebp
  00323	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00328	8b e5		 mov	 esp, ebp
  0032a	5d		 pop	 ebp
  0032b	c2 1c 00	 ret	 28			; 0000001cH
$LN26@UseSkill:

; 743  : 			}
; 744  : 			else
; 745  : 			{
; 746  : 				SkillDeathPoison(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  0032e	51		 push	 ecx
  0032f	ff 75 18	 push	 DWORD PTR _dir$[ebp]
  00332	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00335	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00338	ff 75 10	 push	 DWORD PTR _x$[ebp]
  0033b	56		 push	 esi
  0033c	57		 push	 edi
  0033d	e8 00 00 00 00	 call	 ?SkillDeathPoison@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillDeathPoison
  00342	5f		 pop	 edi
  00343	5e		 pop	 esi
  00344	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00345	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00348	33 cd		 xor	 ecx, ebp
  0034a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c2 1c 00	 ret	 28			; 0000001cH
$LN24@UseSkill:

; 747  : 			}
; 748  : 		}
; 749  : 		else if( lpMagic->m_Skill == AT_SKILL_EXPICE )

  00355	83 f8 27	 cmp	 eax, 39			; 00000027H
  00358	75 28		 jne	 SHORT $LN28@UseSkill

; 750  : 		{
; 751  : 			SkillSuddenIce(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  0035a	53		 push	 ebx
  0035b	51		 push	 ecx
  0035c	ff 75 18	 push	 DWORD PTR _dir$[ebp]
  0035f	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00362	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00365	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00368	56		 push	 esi
  00369	57		 push	 edi
  0036a	e8 00 00 00 00	 call	 ?SkillSuddenIce@CObjUseSkill@@QAEHHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillSuddenIce
  0036f	5f		 pop	 edi
  00370	5e		 pop	 esi
  00371	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00372	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00375	33 cd		 xor	 ecx, ebp
  00377	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037c	8b e5		 mov	 esp, ebp
  0037e	5d		 pop	 ebp
  0037f	c2 1c 00	 ret	 28			; 0000001cH
$LN28@UseSkill:

; 752  : 		}
; 753  : 		else if( lpMagic->m_Skill == AT_SKILL_BLOWOFFURY )

  00382	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00385	75 2c		 jne	 SHORT $LN30@UseSkill

; 754  : 		{
; 755  : 			SkillBlowOfFury(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex,bCombo);

  00387	8b 45 d0	 mov	 eax, DWORD PTR _bCombo$2$[ebp]
  0038a	50		 push	 eax
  0038b	53		 push	 ebx
  0038c	51		 push	 ecx
  0038d	ff 75 18	 push	 DWORD PTR _dir$[ebp]
  00390	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00393	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00396	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00399	56		 push	 esi
  0039a	57		 push	 edi
  0039b	e8 00 00 00 00	 call	 ?SkillBlowOfFury@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEHH@Z ; CObjUseSkill::SkillBlowOfFury
  003a0	5f		 pop	 edi
  003a1	5e		 pop	 esi
  003a2	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  003a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a6	33 cd		 xor	 ecx, ebp
  003a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ad	8b e5		 mov	 esp, ebp
  003af	5d		 pop	 ebp
  003b0	c2 1c 00	 ret	 28			; 0000001cH
$LN30@UseSkill:

; 756  : 		}
; 757  : 		else if( lpMagic->m_Skill == AT_SKILL_WHEEL )

  003b3	83 f8 29	 cmp	 eax, 41			; 00000029H
  003b6	75 22		 jne	 SHORT $LN32@UseSkill

; 758  : 		{
; 759  : 			SkillWheel(aIndex,lpMagic,aTargetIndex,bCombo);

  003b8	8b 45 d0	 mov	 eax, DWORD PTR _bCombo$2$[ebp]
  003bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003be	50		 push	 eax
  003bf	53		 push	 ebx
  003c0	56		 push	 esi
  003c1	57		 push	 edi
  003c2	e8 00 00 00 00	 call	 ?SkillWheel@CObjUseSkill@@QAEXHPAVCMagicInf@@HH@Z ; CObjUseSkill::SkillWheel
  003c7	5f		 pop	 edi
  003c8	5e		 pop	 esi
  003c9	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  003ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003cd	33 cd		 xor	 ecx, ebp
  003cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	c2 1c 00	 ret	 28			; 0000001cH
$LN32@UseSkill:

; 760  : 		}
; 761  : 		else if( lpMagic->m_Skill == AT_SKILL_ELECTRICSPARK )

  003da	83 f8 41	 cmp	 eax, 65			; 00000041H
  003dd	75 28		 jne	 SHORT $LN34@UseSkill

; 762  : 		{
; 763  : 			SkillElectricSpark(aIndex,lpMagic,x,y,dir,TargetPos,aTargetIndex);

  003df	53		 push	 ebx
  003e0	51		 push	 ecx
  003e1	ff 75 18	 push	 DWORD PTR _dir$[ebp]
  003e4	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003e7	ff 75 14	 push	 DWORD PTR _y$[ebp]
  003ea	ff 75 10	 push	 DWORD PTR _x$[ebp]
  003ed	56		 push	 esi
  003ee	57		 push	 edi
  003ef	e8 00 00 00 00	 call	 ?SkillElectricSpark@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::SkillElectricSpark
  003f4	5f		 pop	 edi
  003f5	5e		 pop	 esi
  003f6	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  003f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fa	33 cd		 xor	 ecx, ebp
  003fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00401	8b e5		 mov	 esp, ebp
  00403	5d		 pop	 ebp
  00404	c2 1c 00	 ret	 28			; 0000001cH
$LN34@UseSkill:

; 764  : 		}
; 765  : 		else if( lpMagic->m_Skill == AT_SKILL_DARKHORSE_ATTACK )

  00407	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  0040a	75 22		 jne	 SHORT $LN36@UseSkill

; 766  : 		{
; 767  : 			SkillDarkHorseAttack(lpObj->m_Index,aTargetIndex,lpMagic);

  0040c	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  0040f	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00412	56		 push	 esi
  00413	53		 push	 ebx
  00414	ff 30		 push	 DWORD PTR [eax]
  00416	e8 00 00 00 00	 call	 ?SkillDarkHorseAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDarkHorseAttack
  0041b	5f		 pop	 edi
  0041c	5e		 pop	 esi
  0041d	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0041e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00421	33 cd		 xor	 ecx, ebp
  00423	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00428	8b e5		 mov	 esp, ebp
  0042a	5d		 pop	 ebp
  0042b	c2 1c 00	 ret	 28			; 0000001cH
$LN36@UseSkill:

; 768  : 		}
; 769  : 		else if( lpMagic->m_Skill == AT_SKILL_STUN )

  0042e	83 f8 43	 cmp	 eax, 67			; 00000043H
  00431	75 28		 jne	 SHORT $LN38@UseSkill

; 770  : 		{
; 771  : 			SkillStun(aIndex,aTargetIndex,lpMagic,x,y,dir,TargetPos);

  00433	51		 push	 ecx
  00434	ff 75 18	 push	 DWORD PTR _dir$[ebp]
  00437	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0043a	ff 75 14	 push	 DWORD PTR _y$[ebp]
  0043d	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00440	56		 push	 esi
  00441	53		 push	 ebx
  00442	57		 push	 edi
  00443	e8 00 00 00 00	 call	 ?SkillStun@CObjUseSkill@@QAEHHHPAVCMagicInf@@EEEE@Z ; CObjUseSkill::SkillStun
  00448	5f		 pop	 edi
  00449	5e		 pop	 esi
  0044a	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0044b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044e	33 cd		 xor	 ecx, ebp
  00450	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00455	8b e5		 mov	 esp, ebp
  00457	5d		 pop	 ebp
  00458	c2 1c 00	 ret	 28			; 0000001cH
$LN38@UseSkill:

; 772  : 		}
; 773  : 		else if( lpMagic->m_Skill == AT_SKILL_FENRIR_ATTACK )

  0045b	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  0045e	75 1e		 jne	 SHORT $LN40@UseSkill

; 774  : 		{
; 775  : 			SkillFenrirAttack(aIndex,aTargetIndex,lpMagic);

  00460	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00463	56		 push	 esi
  00464	53		 push	 ebx
  00465	57		 push	 edi
  00466	e8 00 00 00 00	 call	 ?SkillFenrirAttack@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFenrirAttack
  0046b	5f		 pop	 edi
  0046c	5e		 pop	 esi
  0046d	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0046e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00471	33 cd		 xor	 ecx, ebp
  00473	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00478	8b e5		 mov	 esp, ebp
  0047a	5d		 pop	 ebp
  0047b	c2 1c 00	 ret	 28			; 0000001cH
$LN40@UseSkill:

; 776  : 		}
; 777  : 		else if( lpMagic->m_Skill == AT_SKILL_LIGHTEXPLODE )

  0047e	3d d8 00 00 00	 cmp	 eax, 216		; 000000d8H
  00483	75 1e		 jne	 SHORT $LN42@UseSkill

; 778  : 		{
; 779  : 			SkillLightExplode(aIndex,aTargetIndex,lpMagic);

  00485	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00488	56		 push	 esi
  00489	53		 push	 ebx
  0048a	57		 push	 edi
  0048b	e8 00 00 00 00	 call	 ?SkillLightExplode@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillLightExplode
  00490	5f		 pop	 edi
  00491	5e		 pop	 esi
  00492	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00493	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00496	33 cd		 xor	 ecx, ebp
  00498	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0049d	8b e5		 mov	 esp, ebp
  0049f	5d		 pop	 ebp
  004a0	c2 1c 00	 ret	 28			; 0000001cH
$LN42@UseSkill:

; 780  : 		}
; 781  : 		else if( lpMagic->m_Skill == AT_SKILL_DRAINLIFE )

  004a3	3d d6 00 00 00	 cmp	 eax, 214		; 000000d6H
  004a8	75 1e		 jne	 SHORT $LN44@UseSkill

; 782  : 		{
; 783  : 			SkillDrainLife(aIndex,aTargetIndex,lpMagic);

  004aa	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004ad	56		 push	 esi
  004ae	53		 push	 ebx
  004af	57		 push	 edi
  004b0	e8 00 00 00 00	 call	 ?SkillDrainLife@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillDrainLife
  004b5	5f		 pop	 edi
  004b6	5e		 pop	 esi
  004b7	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  004b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bb	33 cd		 xor	 ecx, ebp
  004bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c2	8b e5		 mov	 esp, ebp
  004c4	5d		 pop	 ebp
  004c5	c2 1c 00	 ret	 28			; 0000001cH
$LN44@UseSkill:

; 784  : 		}
; 785  : 		else if( lpMagic->m_Skill == AT_SKILL_CHAINLIGHTING )

  004c8	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  004cd	75 1e		 jne	 SHORT $LN46@UseSkill

; 786  : 		{
; 787  : 			SkillChainLightning(aIndex,aTargetIndex,lpMagic);

  004cf	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004d2	56		 push	 esi
  004d3	53		 push	 ebx
  004d4	57		 push	 edi
  004d5	e8 00 00 00 00	 call	 ?SkillChainLightning@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillChainLightning
  004da	5f		 pop	 edi
  004db	5e		 pop	 esi
  004dc	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  004dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004e0	33 cd		 xor	 ecx, ebp
  004e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e7	8b e5		 mov	 esp, ebp
  004e9	5d		 pop	 ebp
  004ea	c2 1c 00	 ret	 28			; 0000001cH
$LN46@UseSkill:

; 788  : 		}
; 789  : 		else if( lpMagic->m_Skill == AT_SKILL_SAHAMUT || lpMagic->m_Skill == AT_SKILL_NEIL )

  004ed	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  004f2	0f 84 65 03 00
	00		 je	 $LN50@UseSkill
  004f8	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  004fd	0f 84 5a 03 00
	00		 je	 $LN50@UseSkill

; 792  : 		}
; 793  : 		else if( lpMagic->m_Skill == AT_SKILL_INNOVATION )

  00503	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  00508	75 24		 jne	 SHORT $LN51@UseSkill

; 794  : 		{
; 795  : 			SkillInnovation(aIndex,lpMagic,x,y,aTargetIndex);

  0050a	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0050d	53		 push	 ebx
  0050e	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00511	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00514	56		 push	 esi
  00515	57		 push	 edi
  00516	e8 00 00 00 00	 call	 ?SkillInnovation@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillInnovation
  0051b	5f		 pop	 edi
  0051c	5e		 pop	 esi
  0051d	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0051e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00521	33 cd		 xor	 ecx, ebp
  00523	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c2 1c 00	 ret	 28			; 0000001cH
$LN51@UseSkill:

; 796  : 		}
; 797  : 		else if( lpMagic->m_Skill == AT_SKILL_WEAKNESS )

  0052e	3d dd 00 00 00	 cmp	 eax, 221		; 000000ddH
  00533	75 24		 jne	 SHORT $LN53@UseSkill

; 798  : 		{
; 799  : 			SkillWeakness(aIndex,lpMagic,x,y,aTargetIndex);

  00535	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00538	53		 push	 ebx
  00539	ff 75 14	 push	 DWORD PTR _y$[ebp]
  0053c	ff 75 10	 push	 DWORD PTR _x$[ebp]
  0053f	56		 push	 esi
  00540	57		 push	 edi
  00541	e8 00 00 00 00	 call	 ?SkillWeakness@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillWeakness
  00546	5f		 pop	 edi
  00547	5e		 pop	 esi
  00548	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00549	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054c	33 cd		 xor	 ecx, ebp
  0054e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00553	8b e5		 mov	 esp, ebp
  00555	5d		 pop	 ebp
  00556	c2 1c 00	 ret	 28			; 0000001cH
$LN53@UseSkill:

; 800  : 		}
; 801  : 		else if( lpMagic->m_Skill == AT_SKILL_LAGLE )

  00559	3d e1 00 00 00	 cmp	 eax, 225		; 000000e1H
  0055e	75 26		 jne	 SHORT $LN55@UseSkill

; 802  : 		{
; 803  : 			SkillLagle(aIndex,lpMagic,x,y,aTargetIndex,59);

  00560	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00563	6a 3b		 push	 59			; 0000003bH
  00565	53		 push	 ebx
  00566	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00569	ff 75 10	 push	 DWORD PTR _x$[ebp]
  0056c	56		 push	 esi
  0056d	57		 push	 edi
  0056e	e8 00 00 00 00	 call	 ?SkillLagle@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHH@Z ; CObjUseSkill::SkillLagle
  00573	5f		 pop	 edi
  00574	5e		 pop	 esi
  00575	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00576	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00579	33 cd		 xor	 ecx, ebp
  0057b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00580	8b e5		 mov	 esp, ebp
  00582	5d		 pop	 ebp
  00583	c2 1c 00	 ret	 28			; 0000001cH
$LN55@UseSkill:

; 804  : 		}
; 805  : 		else if( lpMagic->m_Skill == AT_SKILL_LIGHTSHOCK )

  00586	3d e6 00 00 00	 cmp	 eax, 230		; 000000e6H
  0058b	75 1e		 jne	 SHORT $LN57@UseSkill

; 806  : 		{
; 807  : 			SkillLightShock(aIndex,aTargetIndex,lpMagic);

  0058d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00590	56		 push	 esi
  00591	53		 push	 ebx
  00592	57		 push	 edi
  00593	e8 00 00 00 00	 call	 ?SkillLightShock@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillLightShock
  00598	5f		 pop	 edi
  00599	5e		 pop	 esi
  0059a	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0059b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0059e	33 cd		 xor	 ecx, ebp
  005a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a5	8b e5		 mov	 esp, ebp
  005a7	5d		 pop	 ebp
  005a8	c2 1c 00	 ret	 28			; 0000001cH
$LN57@UseSkill:

; 808  : 		}
; 809  : 		else if( lpMagic->m_Skill == AT_SKILL_DESTRUCT )

  005ab	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  005b0	75 24		 jne	 SHORT $LN59@UseSkill

; 810  : 		{
; 811  : 			SkillDestruct(aIndex,lpMagic,x,y,aTargetIndex);

  005b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  005b5	53		 push	 ebx
  005b6	ff 75 14	 push	 DWORD PTR _y$[ebp]
  005b9	ff 75 10	 push	 DWORD PTR _x$[ebp]
  005bc	56		 push	 esi
  005bd	57		 push	 edi
  005be	e8 00 00 00 00	 call	 ?SkillDestruct@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillDestruct
  005c3	5f		 pop	 edi
  005c4	5e		 pop	 esi
  005c5	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  005c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c9	33 cd		 xor	 ecx, ebp
  005cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d0	8b e5		 mov	 esp, ebp
  005d2	5d		 pop	 ebp
  005d3	c2 1c 00	 ret	 28			; 0000001cH
$LN59@UseSkill:

; 812  : 		}
; 813  : 		else if( lpMagic->m_Skill == AT_SKILL_FLAMESTRIKE )

  005d6	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  005db	75 1f		 jne	 SHORT $LN61@UseSkill

; 814  : 		{
; 815  : 			SkillFlameStrike(aIndex,lpMagic,TargetPos,aTargetIndex);

  005dd	53		 push	 ebx
  005de	51		 push	 ecx
  005df	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  005e2	56		 push	 esi
  005e3	57		 push	 edi
  005e4	e8 00 00 00 00	 call	 ?SkillFlameStrike@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ; CObjUseSkill::SkillFlameStrike
  005e9	5f		 pop	 edi
  005ea	5e		 pop	 esi
  005eb	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  005ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ef	33 cd		 xor	 ecx, ebp
  005f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f6	8b e5		 mov	 esp, ebp
  005f8	5d		 pop	 ebp
  005f9	c2 1c 00	 ret	 28			; 0000001cH
$LN61@UseSkill:

; 816  : 		}
; 817  : 		else if( lpMagic->m_Skill == AT_SKILL_GIGANTICSTORM  )

  005fc	3d ed 00 00 00	 cmp	 eax, 237		; 000000edH
  00601	75 24		 jne	 SHORT $LN63@UseSkill

; 818  : 		{
; 819  : 			SkillGiganticStorm(aIndex,lpMagic,x,y,aTargetIndex);

  00603	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00606	53		 push	 ebx
  00607	ff 75 14	 push	 DWORD PTR _y$[ebp]
  0060a	ff 75 10	 push	 DWORD PTR _x$[ebp]
  0060d	56		 push	 esi
  0060e	57		 push	 edi
  0060f	e8 00 00 00 00	 call	 ?SkillGiganticStorm@CObjUseSkill@@QAEXHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillGiganticStorm
  00614	5f		 pop	 edi
  00615	5e		 pop	 esi
  00616	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00617	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0061a	33 cd		 xor	 ecx, ebp
  0061c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00621	8b e5		 mov	 esp, ebp
  00623	5d		 pop	 ebp
  00624	c2 1c 00	 ret	 28			; 0000001cH
$LN63@UseSkill:

; 820  : 		}
; 821  : 		else if( lpMagic->m_Skill == AT_SKILL_MULTISHOT  )

  00627	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  0062c	75 1f		 jne	 SHORT $LN65@UseSkill

; 822  : 		{
; 823  : 			SkillMultiShot(aIndex,lpMagic,TargetPos,aTargetIndex);

  0062e	53		 push	 ebx
  0062f	51		 push	 ecx
  00630	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00633	56		 push	 esi
  00634	57		 push	 edi
  00635	e8 00 00 00 00	 call	 ?SkillMultiShot@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ; CObjUseSkill::SkillMultiShot
  0063a	5f		 pop	 edi
  0063b	5e		 pop	 esi
  0063c	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0063d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00640	33 cd		 xor	 ecx, ebp
  00642	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00647	8b e5		 mov	 esp, ebp
  00649	5d		 pop	 ebp
  0064a	c2 1c 00	 ret	 28			; 0000001cH
$LN65@UseSkill:

; 824  : 		}
; 825  : 		else if( lpMagic->m_Skill == AT_SKILL_CHAOTICDISEIER )

  0064d	3d ee 00 00 00	 cmp	 eax, 238		; 000000eeH
  00652	75 1f		 jne	 SHORT $LN67@UseSkill

; 826  : 		{
; 827  : 			SkillChaoticDesier(aIndex,lpMagic,TargetPos,aTargetIndex);

  00654	53		 push	 ebx
  00655	51		 push	 ecx
  00656	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00659	56		 push	 esi
  0065a	57		 push	 edi
  0065b	e8 00 00 00 00	 call	 ?SkillChaoticDesier@CObjUseSkill@@QAEXHPAVCMagicInf@@EH@Z ; CObjUseSkill::SkillChaoticDesier
  00660	5f		 pop	 edi
  00661	5e		 pop	 esi
  00662	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00663	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00666	33 cd		 xor	 ecx, ebp
  00668	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066d	8b e5		 mov	 esp, ebp
  0066f	5d		 pop	 ebp
  00670	c2 1c 00	 ret	 28			; 0000001cH
$LN67@UseSkill:

; 828  : 		}
; 829  : 		else if (lpMagic->m_Skill == 9) // Medusa OK 

  00673	83 f8 09	 cmp	 eax, 9
  00676	75 39		 jne	 SHORT $LN69@UseSkill

; 830  : 		{
; 831  : 			if( gObj[aIndex].Class == 561 )	//Added Leee

  00678	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0067d	ba 31 02 00 00	 mov	 edx, 561		; 00000231H
  00682	8b 4d e0	 mov	 ecx, DWORD PTR tv884[ebp]
  00685	66 39 94 01 90
	00 00 00	 cmp	 WORD PTR [ecx+eax+144], dx
  0068d	0f 85 db 01 00
	00		 jne	 $LN79@UseSkill

; 832  : 			{
; 833  : 				this->SkillEvilMonster(aIndex, aTargetIndex, lpMagic);

  00693	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00696	56		 push	 esi
  00697	53		 push	 ebx
  00698	57		 push	 edi
  00699	e8 00 00 00 00	 call	 ?SkillEvilMonster@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillEvilMonster
  0069e	5f		 pop	 edi
  0069f	5e		 pop	 esi
  006a0	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  006a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006a4	33 cd		 xor	 ecx, ebp
  006a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006ab	8b e5		 mov	 esp, ebp
  006ad	5d		 pop	 ebp
  006ae	c2 1c 00	 ret	 28			; 0000001cH
$LN69@UseSkill:

; 834  : 			}
; 835  : 		}
; 836  : 		else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DARKSIDE )

  006b1	3d 07 01 00 00	 cmp	 eax, 263		; 00000107H
  006b6	0f 85 8f 00 00
	00		 jne	 $LN72@UseSkill

; 837  : 		{
; 838  : 			PMSG_MONK_DARKSIDE_RECV pMsg = {0};

  006bc	33 c0		 xor	 eax, eax
  006be	c6 45 d4 00	 mov	 BYTE PTR _pMsg$1[ebp], 0
  006c2	89 45 d5	 mov	 DWORD PTR _pMsg$1[ebp+1], eax
  006c5	66 89 45 d9	 mov	 WORD PTR _pMsg$1[ebp+5], ax

; 839  : 			pMsg.NumberH = SET_NUMBERH(aTargetIndex);

  006c9	8b c3		 mov	 eax, ebx
  006cb	c1 e8 08	 shr	 eax, 8
  006ce	88 45 d9	 mov	 BYTE PTR _pMsg$1[ebp+5], al

; 840  : 			pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 841  : 
; 842  : 			pMsg.MagicNumberH = SET_NUMBERH(lpMagic->m_Skill);
; 843  : 			pMsg.MagicNumberL = SET_NUMBERL(lpMagic->m_Skill);

  006d1	8a 46 08	 mov	 al, BYTE PTR [esi+8]
  006d4	88 5d da	 mov	 BYTE PTR _pMsg$1[ebp+6], bl

; 844  : 
; 845  : 			GCMonkDarkSideTargetSelect(&pMsg,aIndex);

  006d7	8b 5d e8	 mov	 ebx, DWORD PTR _aIndex$GSCopy$1$[ebp]
  006da	88 45 d8	 mov	 BYTE PTR _pMsg$1[ebp+4], al
  006dd	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  006e0	53		 push	 ebx
  006e1	50		 push	 eax
  006e2	c6 45 d7 01	 mov	 BYTE PTR _pMsg$1[ebp+3], 1
  006e6	e8 00 00 00 00	 call	 ?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ; GCMonkDarkSideTargetSelect

; 846  : 
; 847  : 			if( lpObj->m_btDarkSideTargetCount )

  006eb	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  006ee	83 c4 08	 add	 esp, 8
  006f1	80 b8 c0 26 00
	00 00		 cmp	 BYTE PTR [eax+9920], 0
  006f8	0f 84 70 01 00
	00		 je	 $LN79@UseSkill

; 848  : 			{
; 849  : 				for(int i = 0; i < 5; i++)

  006fe	b9 05 00 00 00	 mov	 ecx, 5
  00703	8d b8 c2 26 00
	00		 lea	 edi, DWORD PTR [eax+9922]
  00709	89 4d dc	 mov	 DWORD PTR tv885[ebp], ecx
  0070c	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
$LL6@UseSkill:

; 850  : 				{
; 851  : 					if( lpObj->m_wDarkSideTarget[i] != 10000 )

  00711	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00714	66 3b c2	 cmp	 ax, dx
  00717	74 14		 je	 SHORT $LN4@UseSkill

; 852  : 						SkillMonkBarrageJustOneTarget(aIndex,lpMagic,lpObj->m_wDarkSideTarget[i]);

  00719	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0071c	98		 cwde
  0071d	50		 push	 eax
  0071e	56		 push	 esi
  0071f	53		 push	 ebx
  00720	e8 00 00 00 00	 call	 ?SkillMonkBarrageJustOneTarget@CObjUseSkill@@QAEXHPAVCMagicInf@@H@Z ; CObjUseSkill::SkillMonkBarrageJustOneTarget
  00725	8b 4d dc	 mov	 ecx, DWORD PTR tv885[ebp]
  00728	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
$LN4@UseSkill:

; 848  : 			{
; 849  : 				for(int i = 0; i < 5; i++)

  0072d	83 c7 02	 add	 edi, 2
  00730	83 e9 01	 sub	 ecx, 1
  00733	89 4d dc	 mov	 DWORD PTR tv885[ebp], ecx
  00736	75 d9		 jne	 SHORT $LL6@UseSkill
  00738	5f		 pop	 edi
  00739	5e		 pop	 esi
  0073a	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0073b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0073e	33 cd		 xor	 ecx, ebp
  00740	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00745	8b e5		 mov	 esp, ebp
  00747	5d		 pop	 ebp
  00748	c2 1c 00	 ret	 28			; 0000001cH
$LN72@UseSkill:

; 853  : 				}
; 854  : 			}
; 855  : 		}
; 856  : 		else if( lpMagic->m_Skill == AT_SKILL_RAGEFIGHTER_DRAGONLORE )

  0074b	3d 08 01 00 00	 cmp	 eax, 264		; 00000108H
  00750	0f 85 7e 00 00
	00		 jne	 $LN76@UseSkill

; 857  : 		{
; 858  : 			if( !OBJMAX_RANGE(aTargetIndex) )

  00756	85 db		 test	 ebx, ebx
  00758	78 51		 js	 SHORT $LN97@UseSkill
  0075a	33 c0		 xor	 eax, eax
  0075c	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00762	0f 9e c0	 setle	 al
  00765	85 c0		 test	 eax, eax
  00767	74 42		 je	 SHORT $LN97@UseSkill

; 861  : 					aIndex,lpObj->AccountID);
; 862  : 				return;
; 863  : 			}
; 864  : 
; 865  : 			SkillAreaMonsterAttack(aIndex,lpMagic,gObj[aTargetIndex].X,gObj[aTargetIndex].Y,aTargetIndex,3,1,0);

  00769	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0076f	6a 00		 push	 0
  00771	69 d3 40 27 00
	00		 imul	 edx, ebx, 10048
  00777	6a 01		 push	 1
  00779	6a 03		 push	 3
  0077b	53		 push	 ebx
  0077c	0f b6 84 0a 21
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+289]
  00784	50		 push	 eax
  00785	0f b6 84 0a 20
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+288]
  0078d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00790	50		 push	 eax
  00791	56		 push	 esi
  00792	57		 push	 edi
  00793	e8 00 00 00 00	 call	 ?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z ; CObjUseSkill::SkillAreaMonsterAttack
  00798	5f		 pop	 edi
  00799	5e		 pop	 esi
  0079a	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0079b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0079e	33 cd		 xor	 ecx, ebp
  007a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007a5	8b e5		 mov	 esp, ebp
  007a7	5d		 pop	 ebp
  007a8	c2 1c 00	 ret	 28			; 0000001cH
$LN97@UseSkill:

; 859  : 			{
; 860  : 				LogAddTD("[InvalidTargetIndex][CObjUseSkill.UseSkill][AT_SKILL_DRAGON_ROAR] Index :%d , AccountID : %s ",

  007ab	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  007ae	83 c0 52	 add	 eax, 82			; 00000052H
  007b1	50		 push	 eax
  007b2	57		 push	 edi
  007b3	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@IFELCABO@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@
  007b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007be	83 c4 0c	 add	 esp, 12			; 0000000cH
  007c1	5f		 pop	 edi
  007c2	5e		 pop	 esi
  007c3	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  007c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007c7	33 cd		 xor	 ecx, ebp
  007c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ce	8b e5		 mov	 esp, ebp
  007d0	5d		 pop	 ebp
  007d1	c2 1c 00	 ret	 28			; 0000001cH
$LN76@UseSkill:

; 866  : 		}
; 867  : 		else if( lpMagic->m_Skill == AT_SKILL_PHOENIXSHOT )

  007d4	3d 0e 01 00 00	 cmp	 eax, 270		; 0000010eH
  007d9	0f 85 8f 00 00
	00		 jne	 $LN79@UseSkill

; 868  : 		{
; 869  : 			if( !OBJMAX_RANGE(aTargetIndex) )

  007df	85 db		 test	 ebx, ebx
  007e1	78 51		 js	 SHORT $LN98@UseSkill
  007e3	33 c0		 xor	 eax, eax
  007e5	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  007eb	0f 9e c0	 setle	 al
  007ee	85 c0		 test	 eax, eax
  007f0	74 42		 je	 SHORT $LN98@UseSkill

; 872  : 					aIndex,lpObj->AccountID);
; 873  : 				return;
; 874  : 			}
; 875  : 
; 876  : 			SkillAreaMonsterAttack(aIndex,lpMagic,gObj[aTargetIndex].X,gObj[aTargetIndex].Y,aTargetIndex,2,1,0);

  007f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007f8	6a 00		 push	 0
  007fa	69 d3 40 27 00
	00		 imul	 edx, ebx, 10048
  00800	6a 01		 push	 1
  00802	6a 02		 push	 2
  00804	53		 push	 ebx
  00805	0f b6 84 0a 21
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+289]
  0080d	50		 push	 eax
  0080e	0f b6 84 0a 20
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+288]
  00816	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00819	50		 push	 eax
  0081a	56		 push	 esi
  0081b	57		 push	 edi
  0081c	e8 00 00 00 00	 call	 ?SkillAreaMonsterAttack@CObjUseSkill@@QAEHHPAVCMagicInf@@EEHHHH@Z ; CObjUseSkill::SkillAreaMonsterAttack
  00821	5f		 pop	 edi
  00822	5e		 pop	 esi
  00823	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  00824	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00827	33 cd		 xor	 ecx, ebp
  00829	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0082e	8b e5		 mov	 esp, ebp
  00830	5d		 pop	 ebp
  00831	c2 1c 00	 ret	 28			; 0000001cH
$LN98@UseSkill:

; 870  : 			{
; 871  : 				LogAddTD("[InvalidTargetIndex][CObjUseSkill.UseSkill][AT_SKILL_PHOENIXSHOT] Index :%d , AccountID : %s ",

  00834	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  00837	83 c0 52	 add	 eax, 82			; 00000052H
  0083a	50		 push	 eax
  0083b	57		 push	 edi
  0083c	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@JAMLMINI@?$FLInvalidTargetIndex?$FN?$FLCObjUseSkil@
  00841	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00847	83 c4 0c	 add	 esp, 12			; 0000000cH
  0084a	5f		 pop	 edi
  0084b	5e		 pop	 esi
  0084c	5b		 pop	 ebx

; 877  : 		}
; 878  : 	}
; 879  : }

  0084d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00850	33 cd		 xor	 ecx, ebp
  00852	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00857	8b e5		 mov	 esp, ebp
  00859	5d		 pop	 ebp
  0085a	c2 1c 00	 ret	 28			; 0000001cH
$LN50@UseSkill:

; 790  : 		{
; 791  : 			SkillCurse(aIndex,lpMagic,x,y,aTargetIndex);

  0085d	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00860	53		 push	 ebx
  00861	ff 75 14	 push	 DWORD PTR _y$[ebp]
  00864	ff 75 10	 push	 DWORD PTR _x$[ebp]
  00867	56		 push	 esi
  00868	57		 push	 edi
  00869	e8 00 00 00 00	 call	 ?SkillCurse@CObjUseSkill@@QAEHHPAVCMagicInf@@EEH@Z ; CObjUseSkill::SkillCurse
$LN79@UseSkill:

; 877  : 		}
; 878  : 	}
; 879  : }

  0086e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00871	5f		 pop	 edi
  00872	5e		 pop	 esi
  00873	33 cd		 xor	 ecx, ebp
  00875	5b		 pop	 ebx
  00876	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0087b	8b e5		 mov	 esp, ebp
  0087d	5d		 pop	 ebp
  0087e	c2 1c 00	 ret	 28			; 0000001cH
  00881	0f 1f 00	 npad	 3
$LN106@UseSkill:
  00884	00 00 00 00	 DD	 $LN103@UseSkill
  00888	00 00 00 00	 DD	 $LN21@UseSkill
$LN99@UseSkill:
  0088c	00		 DB	 0
  0088d	01		 DB	 1
  0088e	01		 DB	 1
  0088f	01		 DB	 1
  00890	01		 DB	 1
  00891	01		 DB	 1
  00892	01		 DB	 1
  00893	01		 DB	 1
  00894	01		 DB	 1
  00895	01		 DB	 1
  00896	00		 DB	 0
  00897	00		 DB	 0
  00898	00		 DB	 0
  00899	01		 DB	 1
  0089a	01		 DB	 1
  0089b	01		 DB	 1
  0089c	01		 DB	 1
  0089d	01		 DB	 1
  0089e	01		 DB	 1
  0089f	01		 DB	 1
  008a0	01		 DB	 1
  008a1	01		 DB	 1
  008a2	01		 DB	 1
  008a3	01		 DB	 1
  008a4	01		 DB	 1
  008a5	01		 DB	 1
  008a6	01		 DB	 1
  008a7	01		 DB	 1
  008a8	01		 DB	 1
  008a9	01		 DB	 1
  008aa	01		 DB	 1
  008ab	01		 DB	 1
  008ac	00		 DB	 0
  008ad	0f 1f 00	 npad	 3
$LN107@UseSkill:
  008b0	00 00 00 00	 DD	 $LN103@UseSkill
  008b4	00 00 00 00	 DD	 $LN21@UseSkill
$LN100@UseSkill:
  008b8	00		 DB	 0
  008b9	01		 DB	 1
  008ba	01		 DB	 1
  008bb	00		 DB	 0
  008bc	01		 DB	 1
  008bd	01		 DB	 1
  008be	01		 DB	 1
  008bf	01		 DB	 1
  008c0	01		 DB	 1
  008c1	01		 DB	 1
  008c2	01		 DB	 1
  008c3	01		 DB	 1
  008c4	01		 DB	 1
  008c5	01		 DB	 1
  008c6	01		 DB	 1
  008c7	01		 DB	 1
  008c8	01		 DB	 1
  008c9	01		 DB	 1
  008ca	01		 DB	 1
  008cb	01		 DB	 1
  008cc	01		 DB	 1
  008cd	01		 DB	 1
  008ce	01		 DB	 1
  008cf	01		 DB	 1
  008d0	01		 DB	 1
  008d1	01		 DB	 1
  008d2	01		 DB	 1
  008d3	01		 DB	 1
  008d4	01		 DB	 1
  008d5	01		 DB	 1
  008d6	01		 DB	 1
  008d7	01		 DB	 1
  008d8	01		 DB	 1
  008d9	01		 DB	 1
  008da	01		 DB	 1
  008db	01		 DB	 1
  008dc	01		 DB	 1
  008dd	01		 DB	 1
  008de	01		 DB	 1
  008df	01		 DB	 1
  008e0	01		 DB	 1
  008e1	01		 DB	 1
  008e2	01		 DB	 1
  008e3	00		 DB	 0
  008e4	00		 DB	 0
  008e5	01		 DB	 1
  008e6	00		 DB	 0
  008e7	01		 DB	 1
  008e8	01		 DB	 1
  008e9	01		 DB	 1
  008ea	01		 DB	 1
  008eb	01		 DB	 1
  008ec	01		 DB	 1
  008ed	00		 DB	 0
  008ee	01		 DB	 1
  008ef	01		 DB	 1
  008f0	01		 DB	 1
  008f1	00		 DB	 0
  008f2	01		 DB	 1
  008f3	01		 DB	 1
  008f4	00		 DB	 0
  008f5	01		 DB	 1
  008f6	00		 DB	 0
  008f7	00		 DB	 0
  008f8	01		 DB	 1
  008f9	00		 DB	 0
  008fa	01		 DB	 1
  008fb	01		 DB	 1
  008fc	01		 DB	 1
  008fd	01		 DB	 1
  008fe	00		 DB	 0
  008ff	01		 DB	 1
  00900	01		 DB	 1
  00901	00		 DB	 0
?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ENDP	; CObjUseSkill::UseSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv252 = 8						; size = 4
_usebp$1$ = 8						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_bCombo$2$ = 16						; size = 4
_lpMagic$ = 16						; size = 4
?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::UseSkill, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 555  : 	LPOBJ lpObj = &gObj[aIndex];

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00008	56		 push	 esi
  00009	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000f	57		 push	 edi

; 556  : 	LPOBJ lpTargetObj = &gObj[aTargetIndex];
; 557  : 
; 558  : 	int bCombo = 0;
; 559  : 
; 560  : 	if(gComboAttack.CheckCombo(aIndex,lpMagic->m_Skill))

  00010	8b 7d 10	 mov	 edi, DWORD PTR _lpMagic$[ebp]
  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  0001c	ff 77 08	 push	 DWORD PTR [edi+8]
  0001f	53		 push	 ebx
  00020	89 4d 08	 mov	 DWORD PTR tv252[ebp], ecx
  00023	03 f1		 add	 esi, ecx
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  0002a	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo
  0002f	85 c0		 test	 eax, eax
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	b8 00 00 00 00	 mov	 eax, 0
  0003b	0f 45 c1	 cmovne	 eax, ecx

; 561  : 	{
; 562  : 		bCombo = 1;
; 563  : 	}
; 564  : 
; 565  : 	if(lpObj->SkillHellFire2State && (lpMagic->m_Skill != AT_SKILL_EXPHELL && lpMagic->m_Skill != AT_MSKILL_DW_NOVA1) )

  0003e	80 be a8 14 00
	00 00		 cmp	 BYTE PTR [esi+5288], 0
  00045	89 45 10	 mov	 DWORD PTR _bCombo$2$[ebp], eax
  00048	74 73		 je	 SHORT $LN3@UseSkill
  0004a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004d	83 f8 28	 cmp	 eax, 40			; 00000028H
  00050	74 6b		 je	 SHORT $LN3@UseSkill
  00052	3d 88 01 00 00	 cmp	 eax, 392		; 00000188H
  00057	74 64		 je	 SHORT $LN3@UseSkill

; 566  : 	{
; 567  : 		CMagicInf * lpMagic = gObjGetMagicSearch(lpObj,AT_MSKILL_DW_NOVA1);

  00059	68 88 01 00 00	 push	 392			; 00000188H
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00064	83 c4 08	 add	 esp, 8

; 568  : 
; 569  : 		if( lpMagic == NULL )

  00067	85 c0		 test	 eax, eax
  00069	75 13		 jne	 SHORT $LN13@UseSkill

; 570  : 		{
; 571  : 			lpMagic = gObjGetMagicSearch(lpObj,AT_SKILL_EXPHELL);

  0006b	6a 28		 push	 40			; 00000028H
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00073	83 c4 08	 add	 esp, 8

; 572  : 		}
; 573  : 
; 574  : 		if(lpMagic != 0)

  00076	85 c0		 test	 eax, eax
  00078	0f 84 14 01 00
	00		 je	 $LN11@UseSkill
$LN13@UseSkill:

; 575  : 		{
; 576  : 			if( lpMagic->m_Skill == AT_SKILL_EXPHELL )

  0007e	83 78 08 28	 cmp	 DWORD PTR [eax+8], 40	; 00000028H

; 577  : 				gObjUseSkill.RunningSkill(lpObj->m_Index,0,lpMagic,0);

  00082	6a 00		 push	 0
  00084	75 18		 jne	 SHORT $LN6@UseSkill
  00086	50		 push	 eax
  00087	6a 00		 push	 0
  00089	ff 36		 push	 DWORD PTR [esi]
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00090	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 611  : 			}
; 612  : 		}
; 613  : 	}
; 614  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
$LN6@UseSkill:

; 578  : 			else
; 579  : 				g_MasterSkillSystem.RunningSkill_MLS(lpObj,0,lpMagic,0,0,0,0,0);

  0009e	6a 00		 push	 0
  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	6a 00		 push	 0
  000a6	50		 push	 eax
  000a7	6a 00		 push	 0
  000a9	56		 push	 esi
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  000af	e8 00 00 00 00	 call	 ?RunningSkill_MLS@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@HPAVCMagicInf@@HEEEE@Z ; CMasterLevelSkillTreeSystem::RunningSkill_MLS
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 611  : 			}
; 612  : 		}
; 613  : 	}
; 614  : }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 0c 00	 ret	 12			; 0000000cH
$LN3@UseSkill:

; 580  : 
; 581  : 		}
; 582  : 		return;
; 583  : 	}
; 584  : 
; 585  : 	int usemana = GetUseMana(aIndex,lpMagic);

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000c0	57		 push	 edi
  000c1	53		 push	 ebx
  000c2	e8 00 00 00 00	 call	 ?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::GetUseMana

; 586  : 
; 587  : 	if(usemana >= 0)

  000c7	85 c0		 test	 eax, eax
  000c9	0f 88 c3 00 00
	00		 js	 $LN11@UseSkill

; 588  : 	{
; 589  : 		if(!gObj[aIndex].SkillDelay.Check(lpMagic->m_Skill))

  000cf	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR tv252[ebp]
  000d6	50		 push	 eax
  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000dc	05 0c 16 00 00	 add	 eax, 5644		; 0000160cH
  000e1	03 c8		 add	 ecx, eax
  000e3	e8 00 00 00 00	 call	 ?Check@CSkillDelay@@QAEHE@Z ; CSkillDelay::Check
  000e8	85 c0		 test	 eax, eax
  000ea	75 23		 jne	 SHORT $LN9@UseSkill

; 590  : 		{
; 591  : 			LogAddTD("[%d] Skill delay error!",gObj[aIndex].AccountID);

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	83 c0 52	 add	 eax, 82			; 00000052H
  000f4	03 45 08	 add	 eax, DWORD PTR tv252[ebp]
  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LPGINHLP@?$FL?$CFd?$FN?5Skill?5delay?5error?$CB?$AA@
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00103	83 c4 08	 add	 esp, 8
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx

; 611  : 			}
; 612  : 		}
; 613  : 	}
; 614  : }

  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 0c 00	 ret	 12			; 0000000cH
$LN9@UseSkill:

; 592  : 			return;
; 593  : 		}
; 594  : 
; 595  : 		int usebp = GetUseBP(aIndex,lpMagic);

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00112	57		 push	 edi
  00113	53		 push	 ebx
  00114	e8 00 00 00 00	 call	 ?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::GetUseBP
  00119	89 45 08	 mov	 DWORD PTR _usebp$1$[ebp], eax

; 596  : 
; 597  : 		if(usebp >= 0)

  0011c	85 c0		 test	 eax, eax
  0011e	78 72		 js	 SHORT $LN11@UseSkill

; 598  : 		{
; 599  : 			if(RunningSkill(aIndex,aTargetIndex,lpMagic,bCombo)==1)

  00120	8b 45 10	 mov	 eax, DWORD PTR _bCombo$2$[ebp]
  00123	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00126	50		 push	 eax
  00127	57		 push	 edi
  00128	ff 75 0c	 push	 DWORD PTR _aTargetIndex$[ebp]
  0012b	53		 push	 ebx
  0012c	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
  00131	83 f8 01	 cmp	 eax, 1
  00134	75 5c		 jne	 SHORT $LN11@UseSkill

; 600  : 			{
; 601  : 				lpObj->UseMagicNumber = lpMagic->m_Skill;

  00136	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  0013a	66 89 86 ae 06
	00 00		 mov	 WORD PTR [esi+1710], ax

; 602  : 				lpObj->UseMagicTime = GetTickCount();

  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 603  : 				lpObj->UseMagicCount = 0;
; 604  : 				//Mana refill fix 2
; 605  : 				usemana = GetUseMana(aIndex,lpMagic);

  00147	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0014a	57		 push	 edi
  0014b	53		 push	 ebx
  0014c	89 86 b0 06 00
	00		 mov	 DWORD PTR [esi+1712], eax
  00152	c6 86 b4 06 00
	00 00		 mov	 BYTE PTR [esi+1716], 0
  00159	e8 00 00 00 00	 call	 ?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ; CObjUseSkill::GetUseMana
  0015e	66 0f 6e c0	 movd	 xmm0, eax

; 606  : 
; 607  : 				lpObj->Mana = (float)usemana;
; 608  : 				lpObj->BP = usebp;

  00162	8b 45 08	 mov	 eax, DWORD PTR _usebp$1$[ebp]
  00165	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00168	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax

; 609  : 
; 610  : 				GCManaSend(aIndex,(WORD)lpObj->Mana,0xFF,0,lpObj->BP);

  0016e	0f b7 c0	 movzx	 eax, ax
  00171	50		 push	 eax
  00172	6a 00		 push	 0
  00174	68 ff 00 00 00	 push	 255			; 000000ffH
  00179	f3 0f 2c c0	 cvttss2si eax, xmm0
  0017d	f3 0f 11 86 ec
	00 00 00	 movss	 DWORD PTR [esi+236], xmm0
  00185	0f b7 c0	 movzx	 eax, ax
  00188	50		 push	 eax
  00189	53		 push	 ebx
  0018a	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  0018f	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@UseSkill:
  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5b		 pop	 ebx

; 611  : 			}
; 612  : 		}
; 613  : 	}
; 614  : }

  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c2 0c 00	 ret	 12			; 0000000cH
?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::UseSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::GetUseBP, COMDAT
; _this$ = ecx

; 519  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 520  : 	LPOBJ lpObj = &gObj[aIndex];

  00004	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0000b	57		 push	 edi
  0000c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 521  : 
; 522  : 	int bp = lpObj->BP;
; 523  : 
; 524  : 	if(lpObj->Type != OBJ_USER)

  00012	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00016	8b be 04 01 00
	00		 mov	 edi, DWORD PTR [esi+260]
  0001c	74 08		 je	 SHORT $LN2@GetUseBP
$LN7@GetUseBP:
  0001e	5f		 pop	 edi

; 525  : 	{
; 526  : 		return 0;

  0001f	33 c0		 xor	 eax, eax
  00021	5e		 pop	 esi

; 546  : 	{
; 547  : 		return -1;
; 548  : 	}
; 549  : 
; 550  : 	return bp;
; 551  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN2@GetUseBP:

; 527  : 	}
; 528  : 
; 529  : 	if(lpMagic == 0)

  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 f1		 je	 SHORT $LN7@GetUseBP

; 530  : 	{
; 531  : 		return 0;
; 532  : 	}
; 533  : 
; 534  : 	int usingbp = MagicDamageC.SkillGetBP(lpMagic->m_Skill);

  0002d	53		 push	 ebx
  0002e	ff 70 08	 push	 DWORD PTR [eax+8]
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00036	e8 00 00 00 00	 call	 ?SkillGetBP@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetBP

; 535  : 
; 536  : 	usingbp -= usingbp * lpObj->SetOpDecreaseAG / 100;

  0003b	0f b6 8e d2 14
	00 00		 movzx	 ecx, BYTE PTR [esi+5330]
  00042	8b d8		 mov	 ebx, eax
  00044	0f af cb	 imul	 ecx, ebx
  00047	b8 e1 7a 14 ae	 mov	 eax, -1374389535	; ae147ae1H
  0004c	f7 e9		 imul	 ecx

; 537  : 
; 538  : 	if( lpObj->m_btSocketBPUseDec > 0 )

  0004e	8a 8e 96 25 00
	00		 mov	 cl, BYTE PTR [esi+9622]
  00054	c1 fa 05	 sar	 edx, 5
  00057	8b c2		 mov	 eax, edx
  00059	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005c	03 c2		 add	 eax, edx
  0005e	03 d8		 add	 ebx, eax
  00060	84 c9		 test	 cl, cl
  00062	74 19		 je	 SHORT $LN4@GetUseBP

; 539  : 	{
; 540  : 		usingbp -= usingbp * lpObj->m_btSocketBPUseDec / 100;

  00064	0f b6 c9	 movzx	 ecx, cl
  00067	b8 e1 7a 14 ae	 mov	 eax, -1374389535	; ae147ae1H
  0006c	0f af cb	 imul	 ecx, ebx
  0006f	f7 e9		 imul	 ecx
  00071	c1 fa 05	 sar	 edx, 5
  00074	8b ca		 mov	 ecx, edx
  00076	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00079	03 ca		 add	 ecx, edx
  0007b	03 d9		 add	 ebx, ecx
$LN4@GetUseBP:

; 541  : 	}
; 542  : 
; 543  : 	bp -= usingbp;

  0007d	2b fb		 sub	 edi, ebx

; 544  : 
; 545  : 	if(bp < 0)

  0007f	b8 ff ff ff ff	 mov	 eax, -1
  00084	5b		 pop	 ebx
  00085	0f 48 f8	 cmovs	 edi, eax
  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 546  : 	{
; 547  : 		return -1;
; 548  : 	}
; 549  : 
; 550  : 	return bp;
; 551  : }

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?GetUseBP@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::GetUseBP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z PROC ; CObjUseSkill::GetAddUseMana, COMDAT
; _this$ = ecx

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 454  : 	int iRetValue = 0;
; 455  : 
; 456  : 	if(lpObj->Class == CLASS_ELF && lpObj->Type == OBJ_USER && lpObj->ChangeUP == 1 &&

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	33 f6		 xor	 esi, esi
  0000a	66 83 bf 90 00
	00 00 02	 cmp	 WORD PTR [edi+144], 2
  00012	0f 85 61 01 00
	00		 jne	 $LN21@GetAddUseM
  00018	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0001c	0f 85 57 01 00
	00		 jne	 $LN21@GetAddUseM
  00022	80 bf 93 00 00
	00 01		 cmp	 BYTE PTR [edi+147], 1
  00029	0f 85 4a 01 00
	00		 jne	 $LN21@GetAddUseM
  0002f	6a 06		 push	 6
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00037	83 c4 08	 add	 esp, 8
  0003a	3c 01		 cmp	 al, 1
  0003c	74 16		 je	 SHORT $LN3@GetAddUseM
  0003e	68 8f 00 00 00	 push	 143			; 0000008fH
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00049	83 c4 08	 add	 esp, 8
  0004c	3c 01		 cmp	 al, 1
  0004e	0f 85 25 01 00
	00		 jne	 $LN21@GetAddUseM
$LN3@GetAddUseM:

; 457  : 		(gObjCheckUsedBuffEffect(lpObj,BUFF_INFINITY_ARROW) == TRUE || gObjCheckUsedBuffEffect(lpObj,BUFF_INFINITY_ARROW2)==TRUE ))
; 458  : 	{
; 459  : 		if(lpMagic->m_Skill == AT_SKILL_CROSSBOW
; 460  : 			|| lpMagic->m_Skill == AT_SKILL_BOW
; 461  : 			|| lpMagic->m_Skill == AT_SKILL_ELFHARDEN
; 462  : 			|| lpMagic->m_Skill == AT_SKILL_PENETRATION
; 463  : 			|| lpMagic->m_Skill == AT_SKILL_5CROSSBOW
; 464  : 			|| lpMagic->m_Skill == AT_MSKILL_FE_TRIPLESHOT1
; 465  : 			|| lpMagic->m_Skill == AT_MSKILL_FE_TRIPLESHOT2
; 466  : 			|| lpMagic->m_Skill == AT_MSKILL_FE_PENETRATION1
; 467  : 			|| lpMagic->m_Skill == AT_MSKILL_FE_ICEARROW1)

  00054	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00057	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005a	83 f8 18	 cmp	 eax, 24			; 00000018H
  0005d	74 34		 je	 SHORT $LN5@GetAddUseM
  0005f	83 f8 19	 cmp	 eax, 25			; 00000019H
  00062	74 2f		 je	 SHORT $LN5@GetAddUseM
  00064	83 f8 33	 cmp	 eax, 51			; 00000033H
  00067	74 2a		 je	 SHORT $LN5@GetAddUseM
  00069	83 f8 34	 cmp	 eax, 52			; 00000034H
  0006c	74 25		 je	 SHORT $LN5@GetAddUseM
  0006e	83 f8 36	 cmp	 eax, 54			; 00000036H
  00071	74 20		 je	 SHORT $LN5@GetAddUseM
  00073	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  00078	74 19		 je	 SHORT $LN5@GetAddUseM
  0007a	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  0007f	74 12		 je	 SHORT $LN5@GetAddUseM
  00081	3d a0 01 00 00	 cmp	 eax, 416		; 000001a0H
  00086	74 0b		 je	 SHORT $LN5@GetAddUseM
  00088	3d a8 01 00 00	 cmp	 eax, 424		; 000001a8H
  0008d	0f 85 e6 00 00
	00		 jne	 $LN21@GetAddUseM
$LN5@GetAddUseM:

; 468  : 		{
; 469  : 			int iArrowLevel = 0;
; 470  : 
; 471  : 			CItem * Right = &lpObj->pInventory[0];

  00093	8b 97 c0 11 00
	00		 mov	 edx, DWORD PTR [edi+4544]

; 472  : 			CItem * Left = &lpObj->pInventory[1];
; 473  : 
; 474  : 			if(Right->m_Type >= ITEMGET(4,8) && Right->m_Type <= ITEMGET(4,14)
; 475  : 				|| Right->m_Type == ITEMGET(4,16)
; 476  : 				|| Right->m_Type == ITEMGET(4,18)
; 477  : 				|| Right->m_Type == ITEMGET(4,19))

  00099	b8 08 08 00 00	 mov	 eax, 2056		; 00000808H
  0009e	0f b7 4a 06	 movzx	 ecx, WORD PTR [edx+6]
  000a2	66 3b c8	 cmp	 cx, ax
  000a5	7c 0a		 jl	 SHORT $LN9@GetAddUseM
  000a7	b8 0e 08 00 00	 mov	 eax, 2062		; 0000080eH
  000ac	66 3b c8	 cmp	 cx, ax
  000af	7e 71		 jle	 SHORT $LN8@GetAddUseM
$LN9@GetAddUseM:
  000b1	b8 10 08 00 00	 mov	 eax, 2064		; 00000810H
  000b6	66 3b c8	 cmp	 cx, ax
  000b9	74 67		 je	 SHORT $LN8@GetAddUseM
  000bb	b8 12 08 00 00	 mov	 eax, 2066		; 00000812H
  000c0	66 3b c8	 cmp	 cx, ax
  000c3	74 5d		 je	 SHORT $LN8@GetAddUseM
  000c5	b8 13 08 00 00	 mov	 eax, 2067		; 00000813H
  000ca	66 3b c8	 cmp	 cx, ax
  000cd	74 53		 je	 SHORT $LN8@GetAddUseM

; 482  : 				}
; 483  : 			}
; 484  : 			else if(Left->m_Type >= ITEMGET(4,0) && Left->m_Type <= ITEMGET(4,6)
; 485  : 				|| Left->m_Type == ITEMGET(4,17)
; 486  : 				|| Left->m_Type == ITEMGET(4,20)
; 487  : 				|| Left->m_Type == ITEMGET(4,21)
; 488  : 				|| Left->m_Type == ITEMGET(4,22)
; 489  : 				|| Left->m_Type == ITEMGET(4,22) )

  000cf	0f b7 82 da 00
	00 00		 movzx	 eax, WORD PTR [edx+218]
  000d6	bf 00 08 00 00	 mov	 edi, 2048		; 00000800H
  000db	66 3b c7	 cmp	 ax, di
  000de	7c 0a		 jl	 SHORT $LN13@GetAddUseM
  000e0	bf 06 08 00 00	 mov	 edi, 2054		; 00000806H
  000e5	66 3b c7	 cmp	 ax, di
  000e8	7e 28		 jle	 SHORT $LN12@GetAddUseM
$LN13@GetAddUseM:
  000ea	bf 11 08 00 00	 mov	 edi, 2065		; 00000811H
  000ef	66 3b c7	 cmp	 ax, di
  000f2	74 1e		 je	 SHORT $LN12@GetAddUseM
  000f4	bf 14 08 00 00	 mov	 edi, 2068		; 00000814H
  000f9	66 3b c7	 cmp	 ax, di
  000fc	74 14		 je	 SHORT $LN12@GetAddUseM
  000fe	bf 15 08 00 00	 mov	 edi, 2069		; 00000815H
  00103	66 3b c7	 cmp	 ax, di
  00106	74 0a		 je	 SHORT $LN12@GetAddUseM
  00108	bf 16 08 00 00	 mov	 edi, 2070		; 00000816H
  0010d	66 3b c7	 cmp	 ax, di
  00110	75 61		 jne	 SHORT $LN31@GetAddUseM
$LN12@GetAddUseM:

; 490  : 			{
; 491  : 				if(Right->m_Type == ITEMGET(4,15))

  00112	b8 0f 08 00 00	 mov	 eax, 2063		; 0000080fH
  00117	66 3b c8	 cmp	 cx, ax
  0011a	75 57		 jne	 SHORT $LN31@GetAddUseM

; 492  : 				{
; 493  : 					iArrowLevel = Right->m_Level;

  0011c	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00120	eb 15		 jmp	 SHORT $LN10@GetAddUseM
$LN8@GetAddUseM:

; 478  : 			{
; 479  : 				if(Left->m_Type == ITEMGET(4,7))

  00122	b8 07 08 00 00	 mov	 eax, 2055		; 00000807H
  00127	66 39 82 da 00
	00 00		 cmp	 WORD PTR [edx+218], ax
  0012e	75 43		 jne	 SHORT $LN31@GetAddUseM

; 480  : 				{
; 481  : 					iArrowLevel = Left->m_Level;

  00130	0f bf 82 dc 00
	00 00		 movsx	 eax, WORD PTR [edx+220]
$LN10@GetAddUseM:

; 494  : 				}
; 495  : 			}
; 496  : 
; 497  : 			if(iArrowLevel == 0)

  00137	85 c0		 test	 eax, eax
  00139	74 38		 je	 SHORT $LN31@GetAddUseM

; 498  : 			{
; 499  : 				iRetValue = g_SkillAdditionInfo.GetInfinityArrowMPConsumptionPlus0();
; 500  : 			}
; 501  : 			else if(iArrowLevel == 1)

  0013b	83 f8 01	 cmp	 eax, 1
  0013e	75 0e		 jne	 SHORT $LN17@GetAddUseM
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h

; 29   : 	int GetInfinityArrowMPConsumptionPlus1(){return this->m_iInfinityArrowMPConsumptionPlus1;}

  00140	8b 35 10 00 00
	00		 mov	 esi, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+16
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 515  : 	return iRetValue;

  00146	8b c6		 mov	 eax, esi
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi

; 516  : }

  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
$LN17@GetAddUseM:

; 502  : 			{
; 503  : 				iRetValue = g_SkillAdditionInfo.GetInfinityArrowMPConsumptionPlus1();
; 504  : 			}
; 505  : 			else if(iArrowLevel == 2)

  0014e	83 f8 02	 cmp	 eax, 2
  00151	75 0e		 jne	 SHORT $LN19@GetAddUseM
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h

; 31   : 	int GetInfinityArrowMPConsumptionPlus2(){return this->m_iInfinityArrowMPConsumptionPlus2;}

  00153	8b 35 14 00 00
	00		 mov	 esi, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+20
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 515  : 	return iRetValue;

  00159	8b c6		 mov	 eax, esi
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi

; 516  : }

  0015d	5d		 pop	 ebp
  0015e	c2 08 00	 ret	 8
$LN19@GetAddUseM:

; 506  : 			{
; 507  : 				iRetValue = g_SkillAdditionInfo.GetInfinityArrowMPConsumptionPlus2();
; 508  : 			}
; 509  : 			else if(iArrowLevel == 3)

  00161	83 f8 03	 cmp	 eax, 3
  00164	5f		 pop	 edi
  00165	0f 44 35 18 00
	00 00		 cmove	 esi, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+24

; 515  : 	return iRetValue;

  0016c	8b c6		 mov	 eax, esi
  0016e	5e		 pop	 esi

; 516  : }

  0016f	5d		 pop	 ebp
  00170	c2 08 00	 ret	 8
$LN31@GetAddUseM:
; File c:\users\michel\desktop\source\gameserver\source\skilladditioninfo.h

; 27   : 	int GetInfinityArrowMPConsumptionPlus0(){return this->m_iInfinityArrowMPConsumptionPlus0;}

  00173	8b 35 0c 00 00
	00		 mov	 esi, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+12
$LN21@GetAddUseM:
  00179	5f		 pop	 edi
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp

; 515  : 	return iRetValue;

  0017a	8b c6		 mov	 eax, esi
  0017c	5e		 pop	 esi

; 516  : }

  0017d	5d		 pop	 ebp
  0017e	c2 08 00	 ret	 8
?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ENDP ; CObjUseSkill::GetAddUseMana
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_mana$2$ = -8						; size = 4
_this$1$ = -4						; size = 4
tv224 = 8						; size = 4
tv204 = 8						; size = 4
_usemana$ = 8						; size = 4
_aIndex$ = 8						; size = 4
tv210 = 12						; size = 4
_lpMagic$ = 12						; size = 4
?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z PROC	; CObjUseSkill::GetUseMana, COMDAT
; _this$ = ecx

; 408  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 409  : 	LPOBJ lpObj =&gObj[aIndex];

  00008	69 7d 08 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  0000f	8b f1		 mov	 esi, ecx
  00011	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
  00014	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 410  : 	float mana = lpObj->Mana;
; 411  : 
; 412  : 	if ( lpObj->Type != OBJ_USER )

  0001a	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  0001e	f3 0f 10 87 ec
	00 00 00	 movss	 xmm0, DWORD PTR [edi+236]
  00026	f3 0f 11 45 f8	 movss	 DWORD PTR _mana$2$[ebp], xmm0
  0002b	74 0a		 je	 SHORT $LN2@GetUseMana

; 413  : 	{
; 414  : 		return 0;

  0002d	5f		 pop	 edi
  0002e	33 c0		 xor	 eax, eax
  00030	5e		 pop	 esi

; 450  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
$LN2@GetUseMana:
  00037	53		 push	 ebx

; 415  : 	}
; 416  : 
; 417  : 	if ( lpMagic == NULL )

  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  0003b	85 db		 test	 ebx, ebx
  0003d	75 0b		 jne	 SHORT $LN3@GetUseMana

; 418  : 	{
; 419  : 		return 0;

  0003f	5b		 pop	 ebx
  00040	5f		 pop	 edi
  00041	33 c0		 xor	 eax, eax
  00043	5e		 pop	 esi

; 450  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
$LN3@GetUseMana:

; 420  : 	}
; 421  : 
; 422  : 	float  usemana = 0;
; 423  : 
; 424  : 	if( g_MasterSkillSystem.CheckMasterLevelSkill(lpMagic->m_Skill) )

  0004a	ff 73 08	 push	 DWORD PTR [ebx+8]
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00052	e8 00 00 00 00	 call	 ?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill

; 425  : 	{
; 426  : 		int nMana = MagicDamageC.SkillGetMana(lpMagic->m_Skill);

  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0005c	ff 73 08	 push	 DWORD PTR [ebx+8]
  0005f	85 c0		 test	 eax, eax
  00061	74 57		 je	 SHORT $LN4@GetUseMana
  00063	e8 00 00 00 00	 call	 ?SkillGetMana@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetMana
  00068	8b f0		 mov	 esi, eax

; 427  : 		usemana = nMana;
; 428  : 		usemana += (nMana/100.0f)*g_MasterSkillSystem.GetMasterSkillManaIncRate(lpMagic->m_Level);

  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0006f	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00073	50		 push	 eax
  00074	66 0f 6e c6	 movd	 xmm0, esi
  00078	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0007b	f3 0f 11 45 0c	 movss	 DWORD PTR tv210[ebp], xmm0
  00080	e8 00 00 00 00	 call	 ?GetMasterSkillManaIncRate@CMasterLevelSkillTreeSystem@@QAEMH@Z ; CMasterLevelSkillTreeSystem::GetMasterSkillManaIncRate
  00085	66 0f 6e c6	 movd	 xmm0, esi
  00089	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 429  : 		usemana += GetAddUseMana(lpObj,lpMagic);

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0008f	53		 push	 ebx
  00090	57		 push	 edi
  00091	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00099	f3 0f 11 45 08	 movss	 DWORD PTR tv224[ebp], xmm0
  0009e	d8 4d 08	 fmul	 DWORD PTR tv224[ebp]
  000a1	d8 45 0c	 fadd	 DWORD PTR tv210[ebp]
  000a4	d9 5d 08	 fstp	 DWORD PTR _usemana$[ebp]
  000a7	e8 00 00 00 00	 call	 ?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; CObjUseSkill::GetAddUseMana
  000ac	66 0f 6e c8	 movd	 xmm1, eax
  000b0	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000b3	f3 0f 58 4d 08	 addss	 xmm1, DWORD PTR _usemana$[ebp]

; 430  : 	}
; 431  : 	else

  000b8	eb 26		 jmp	 SHORT $LN5@GetUseMana
$LN4@GetUseMana:

; 432  : 	{
; 433  : 		usemana = (float)MagicDamageC.SkillGetMana(lpMagic->m_Skill) + GetAddUseMana(lpObj,lpMagic);

  000ba	e8 00 00 00 00	 call	 ?SkillGetMana@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetMana
  000bf	53		 push	 ebx
  000c0	57		 push	 edi
  000c1	8b ce		 mov	 ecx, esi
  000c3	66 0f 6e c0	 movd	 xmm0, eax
  000c7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ca	f3 0f 11 45 08	 movss	 DWORD PTR tv204[ebp], xmm0
  000cf	e8 00 00 00 00	 call	 ?GetAddUseMana@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; CObjUseSkill::GetAddUseMana
  000d4	66 0f 6e c8	 movd	 xmm1, eax
  000d8	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000db	f3 0f 58 4d 08	 addss	 xmm1, DWORD PTR tv204[ebp]
$LN5@GetUseMana:

; 434  : 	}
; 435  : 
; 436  : 	usemana -= usemana*lpObj->m_MPSkillOpt.MpsDecreaseMana/100.0f;

  000e0	f3 0f 10 87 0c
	08 00 00	 movss	 xmm0, DWORD PTR [edi+2060]
  000e8	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000ec	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  000f4	f3 0f 5c c8	 subss	 xmm1, xmm0

; 437  : 
; 438  : 	if( usemana < 1 )

  000f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00100	0f 2f c1	 comiss	 xmm0, xmm1
  00103	76 03		 jbe	 SHORT $LN6@GetUseMana

; 439  : 	{
; 440  : 		usemana = 1;

  00105	0f 28 c8	 movaps	 xmm1, xmm0
$LN6@GetUseMana:

; 441  : 	}
; 442  : 
; 443  : 	mana -=usemana;

  00108	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR _mana$2$[ebp]
  0010d	0f 57 c0	 xorps	 xmm0, xmm0
  00110	f3 0f 5c d1	 subss	 xmm2, xmm1

; 444  : 
; 445  : 	if(mana < 0.0f)

  00114	0f 2f c2	 comiss	 xmm0, xmm2
  00117	76 0c		 jbe	 SHORT $LN7@GetUseMana

; 446  : 	{
; 447  : 		return -1;

  00119	5b		 pop	 ebx
  0011a	5f		 pop	 edi
  0011b	83 c8 ff	 or	 eax, -1
  0011e	5e		 pop	 esi

; 450  : }

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 08 00	 ret	 8
$LN7@GetUseMana:
  00125	5b		 pop	 ebx
  00126	5f		 pop	 edi

; 448  : 	}
; 449  : 	return (int)mana;

  00127	f3 0f 2c c2	 cvttss2si eax, xmm2
  0012b	5e		 pop	 esi

; 450  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 08 00	 ret	 8
?GetUseMana@CObjUseSkill@@QAEHHPAVCMagicInf@@@Z ENDP	; CObjUseSkill::GetUseMana
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Skill$ = 12						; size = 4
?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z PROC ; CObjUseSkill::CheckWeapon, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	switch(Skill)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Skill$[ebp]
  00006	83 c0 d7	 add	 eax, -41		; ffffffd7H
  00009	56		 push	 esi
  0000a	83 f8 02	 cmp	 eax, 2
  0000d	77 30		 ja	 SHORT $LN5@CheckWeapo

; 218  : 	{
; 219  : 	case AT_SKILL_WHEEL:
; 220  : 	case AT_SKILL_BLOWOFFURY:
; 221  : 	case AT_SKILL_STRIKE:
; 222  : 
; 223  : 		if( lpObj->pInventory[0].IsItem() != TRUE &&

  0000f	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00012	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00018	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001d	83 f8 01	 cmp	 eax, 1
  00020	74 1d		 je	 SHORT $LN5@CheckWeapo
  00022	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00028	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0002e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00033	83 f8 01	 cmp	 eax, 1
  00036	74 07		 je	 SHORT $LN5@CheckWeapo

; 224  : 			lpObj->pInventory[1].IsItem() != TRUE )
; 225  : 		{
; 226  : 			return FALSE;

  00038	33 c0		 xor	 eax, eax
  0003a	5e		 pop	 esi

; 232  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN5@CheckWeapo:

; 227  : 		}
; 228  : 
; 229  : 		break;
; 230  : 	}
; 231  : return TRUE;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	5e		 pop	 esi

; 232  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP ; CObjUseSkill::CheckWeapon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?EnableSkill@CObjUseSkill@@QAEHH@Z
_TEXT	SEGMENT
_Skill$ = 8						; size = 4
?EnableSkill@CObjUseSkill@@QAEHH@Z PROC			; CObjUseSkill::EnableSkill, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	switch( Skill )

  00003	8b 45 08	 mov	 eax, DWORD PTR _Skill$[ebp]
  00006	3d 08 01 00 00	 cmp	 eax, 264		; 00000108H
  0000b	7f 1f		 jg	 SHORT $LN6@EnableSkil
  0000d	3d 07 01 00 00	 cmp	 eax, 263		; 00000107H
  00012	7d 4d		 jge	 SHORT $LN4@EnableSkil
  00014	83 c0 fb	 add	 eax, -5			; fffffffbH
  00017	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  0001c	77 3d		 ja	 SHORT $LN2@EnableSkil
  0001e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN8@EnableSkil[eax]
  00025	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN11@EnableSkil[eax*4]
$LN6@EnableSkil:
  0002c	3d 31 02 00 00	 cmp	 eax, 561		; 00000231H
  00031	7f 21		 jg	 SHORT $LN7@EnableSkil
  00033	3d 2f 02 00 00	 cmp	 eax, 559		; 0000022fH
  00038	7d 27		 jge	 SHORT $LN4@EnableSkil
  0003a	05 f2 fe ff ff	 add	 eax, -270		; fffffef2H
  0003f	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00044	77 15		 ja	 SHORT $LN2@EnableSkil
  00046	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN9@EnableSkil[eax]
  0004d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@EnableSkil[eax*4]
$LN7@EnableSkil:
  00054	3d 33 02 00 00	 cmp	 eax, 563		; 00000233H
  00059	74 06		 je	 SHORT $LN4@EnableSkil
$LN2@EnableSkil:

; 399  : 	}
; 400  : 
; 401  : 	return false;

  0005b	33 c0		 xor	 eax, eax

; 402  : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN4@EnableSkil:

; 238  : 	{
; 239  : 	case AT_SKILL_STORM:
; 240  : 	case AT_SKILL_EVIL:
; 241  : 	case AT_SKILL_FLAME:
; 242  : 	case AT_SKILL_HELL:
; 243  : 	case AT_SKILL_BLAST:
; 244  : 	case AT_SKILL_INFERNO:
; 245  : 	case AT_SKILL_CROSSBOW:
; 246  : 	case AT_SKILL_DEVILFIRE:
; 247  : 	case AT_SKILL_FLASH:
; 248  : 	case AT_SKILL_WHEEL:
; 249  : 	case AT_SKILL_SWORD6:
; 250  : 	case AT_SKILL_KNIGHTSPEAR:
; 251  : 	case AT_SKILL_KNIGHTADDLIFE:
; 252  : 	case AT_SKILL_STRIKE:
; 253  : 	case AT_SKILL_ELFHARDEN:
; 254  : 	case AT_SKILL_PENETRATION:
; 255  : 	case AT_SKILL_DEFENSEDOWN:
; 256  : 	case AT_SKILL_MAGICDEFENSE:
; 257  : 	case AT_SKILL_BLOWOFFURY:
; 258  : 	case AT_SKILL_EXPPOISON:
; 259  : 	case AT_SKILL_EXPICE:
; 260  : 	case AT_SKILL_EXPHELL:
; 261  : 	case AT_SKILL_ELECTRICSPARK:
; 262  : 	case AT_SKILL_DARKHORSE_ATTACK:
; 263  : 	case AT_SKILL_BRAND_OF_SKILL:
; 264  : 	case AT_SKILL_STUN:
; 265  : 	case AT_SKILL_REMOVAL_STUN:
; 266  : 	case AT_SKILL_ADD_MANA:
; 267  : 	case AT_SKILL_INVISIBLE:
; 268  : 	case AT_SKILL_REMOVAL_MAGIC:
; 269  : 	case AT_SKILL_FENRIR_ATTACK:
; 270  : 	case AT_SKILL_INFINITY_ARROW:
; 271  : 	case AT_SKILL_FIRESCREAM:
; 272  : 	case AT_SKILL_DRAINLIFE:
; 273  : 	case AT_SKILL_CHAINLIGHTING:
; 274  : 	case AT_SKILL_LIGHTEXPLODE:
; 275  : 	case AT_SKILL_DAMAGEREFLECT:
; 276  : 	case AT_SKILL_BERSERKER:
; 277  : 	case AT_SKILL_SLEEP:
; 278  : 	case AT_SKILL_SAHAMUT:
; 279  : 	case AT_SKILL_NEIL:
; 280  : 	case AT_SKILL_LAGLE:
; 281  : 	case AT_SKILL_WEAKNESS:
; 282  : 	case AT_SKILL_INNOVATION:
; 283  : 	case AT_SKILL_LIGHTSHOCK:
; 284  : 	case AT_SKILL_DESTRUCT:
; 285  : 	case AT_SKILL_EXPWIZARDRY:
; 286  : 	case AT_SKILL_RECOVERY:
; 287  : 	case AT_SKILL_MULTISHOT:
; 288  : 	case AT_SKILL_FLAMESTRIKE:
; 289  : 	case AT_SKILL_GIGANTICSTORM:
; 290  : 	case AT_SKILL_CHAOTICDISEIER:
; 291  : 	case AT_SKILL_RAGEFIGHTER_DRAGONLORE:
; 292  : 	case AT_SKILL_PHOENIXSHOT:
; 293  : 	case AT_SKILL_RAGEFIGHTER_DARKSIDE:
; 294  : 		// MSKILL
; 295  : 	case AT_MSKILL_DK_CYCLONE1:
; 296  : 	case AT_MSKILL_DK_SLASH1:
; 297  : 	case AT_MSKILL_DK_FALLINGSLASH1:
; 298  : 	case AT_MSKILL_DK_LUNGE1:
; 299  : 	case AT_MSKILL_DK_TWISTINGSLASH1:
; 300  : 	case AT_MSKILL_DK_RAGEFULBLOW1:
; 301  : 	case AT_MSKILL_DK_TWISTINGSLASH2:
; 302  : 	case AT_MSKILL_DK_RAGEFULBLOW2:
; 303  : 	case AT_MSKILL_DK_DEATHSTAB1:
; 304  : 	case AT_MSKILL_DK_DEATHSTAB2:
; 305  : 	case AT_MSKILL_DK_DEATHSTAB3:
; 306  : 	case AT_MSKILL_DK_DESTRUCTION1:
; 307  : 	case AT_MSKILL_DK_DESTRUCTION2:
; 308  : 	case AT_MSKILL_DK_DESTRUCTION3:
; 309  : 	case AT_MSKILL_DK_BLOODSTORM:
; 310  : 	case AT_MSKILL_DK_BLOODSTORM1:
; 311  : 	case AT_MSKILL_DK_SWELLLIFE1:
; 312  : 	case AT_MSKILL_DK_SWELLLIFE2:
; 313  : 	case AT_MSKILL_DK_SWELLLIFE3:
; 314  : 	case AT_MSKILL_DW_FLAME1:
; 315  : 	case AT_MSKILL_DW_LIGHTNING1:
; 316  : 	case AT_MSKILL_DW_EXPWIZARDRY1:
; 317  : 	case AT_MSKILL_DW_INFERNO1:
; 318  : 	case AT_MSKILL_DW_BLAST1:
; 319  : 	case AT_MSKILL_DW_EXPWIZARDRY2:
; 320  : 	case AT_MSKILL_DW_POISON1:
; 321  : 	case AT_MSKILL_DW_EVILSPIRIT1:
; 322  : 	case AT_MSKILL_DW_DECAY1:
; 323  : 	case AT_MSKILL_DW_HELLFIRE1:
; 324  : 	case AT_MSKILL_DW_ICE1:
; 325  : 	case AT_MSKILL_DW_METEORIT1:
; 326  : 	case AT_MSKILL_DW_METEORIT2:
; 327  : 	case AT_MSKILL_DW_ICESTORM1:
; 328  : 	case AT_MSKILL_DW_ICESTORM2:
; 329  : 	case AT_MSKILL_DW_NOVA1:
; 330  : 	case AT_MSKILL_DW_MANASHIELD1:
; 331  : 	case AT_MSKILL_DW_MANASHIELD2:
; 332  : 	case AT_MSKILL_DW_MANASHIELD3:
; 333  : 	case AT_MSKILL_DW_EARTHPRISON:
; 334  : 	case AT_MSKILL_DW_EARTHPRISON1:
; 335  : 	case AT_MSKILL_FE_HEAL1:
; 336  : 	case AT_MSKILL_FE_TRIPLESHOT1:
; 337  : 	case AT_MSKILL_FE_PENETRATION1:
; 338  : 	case AT_MSKILL_FE_DEFENSEBUFF1:
; 339  : 	case AT_MSKILL_FE_TRIPLESHOT2:
; 340  : 	case AT_MSKILL_FE_ATTACKBUFF1:
; 341  : 	case AT_MSKILL_FE_ATTACKBUFF2:
; 342  : 	case AT_MSKILL_FE_DEFENSEBUFF2:
; 343  : 	case AT_MSKILL_FE_CURE:
; 344  : 	case AT_MSKILL_FE_PARTYHEAL:
; 345  : 	case AT_MSKILL_FE_PARTYHEAL1:
; 346  : 	case AT_MSKILL_FE_BLESS:
; 347  : 	case AT_MSKILL_FE_BLESS1:
; 348  : 	case AT_MSKILL_FE_ICEARROW1:
; 349  : 	case AT_MSKILL_FE_INFINITY1:
; 350  : 	case AT_MSKILL_FE_MULTISHOT1:
; 351  : 	case AT_MSKILL_FE_MULTISHOT2:
; 352  : 	case AT_MSKILL_SUM_SLEEP1:
; 353  : 	case AT_MSKILL_SUM_CHAINLIGHTNING1:
; 354  : 	case AT_MSKILL_SUM_LIGHTNSHOCK1:
; 355  : 	case AT_MSKILL_SUM_DRAINLIFE1:
; 356  : 	case AT_MSKILL_SUM_DRAINLIFE2:
; 357  : 	case AT_MSKILL_SUM_WEAKNESS1:
; 358  : 	case AT_MSKILL_SUM_INNOVATION1:
; 359  : 	case AT_MSKILL_SUM_BERSERK1:
; 360  : 	case AT_MSKILL_SUM_BERSERK2:
; 361  : 	case AT_MSKILL_SUM_BERSERK3:
; 362  : 	case AT_MSKILL_SUM_BLIND:
; 363  : 	case AT_MSKILL_SUM_BLIND1:
; 364  : 	case AT_MSKILL_MG_CYCLONE1:
; 365  : 	case AT_MSKILL_MG_LIGHTNING1:
; 366  : 	case AT_MSKILL_MG_TWISTINGSLASH1:
; 367  : 	case AT_MSKILL_MG_POWERSLASH1:
; 368  : 	case AT_MSKILL_MG_FLAME1:
; 369  : 	case AT_MSKILL_MG_BLAST1:
; 370  : 	case AT_MSKILL_MG_INFERNO1:
; 371  : 	case AT_MSKILL_MG_EVILSPIRIT1:
; 372  : 	case AT_MSKILL_MG_ICE1:
; 373  : 	case AT_MSKILL_MG_ICE2:
; 374  : 	case AT_MSKILL_MG_FIRESLASH1:
; 375  : 	case AT_MSKILL_MG_FIRESLASH2:
; 376  : 	case AT_MSKILL_MG_FLAMESTRIKE1:
; 377  : 	case AT_MSKILL_MG_FLAMESTRIKE2:
; 378  : 	case AT_MSKILL_MG_GIGANTICSTORM1:
; 379  : 	case AT_MSKILL_DL_FIREBURST1:
; 380  : 	case AT_MSKILL_DL_FORCEWAVE1:
; 381  : 	case AT_MSKILL_DL_CRITICALDAMAGE1:
; 382  : 	case AT_MSKILL_DL_EARTHSHAKE1:
; 383  : 	case AT_MSKILL_DL_FIREBURST2:
; 384  : 	case AT_MSKILL_DL_CRITICALDAMAGE2:
; 385  : 	case AT_MSKILL_DL_EARTHSHAKE2:
; 386  : 	case AT_MSKILL_DL_CRITICALDAMAGE3:
; 387  : 	case AT_MSKILL_DL_CRITICALDAMAGE4:
; 388  : 	case AT_MSKILL_DL_IRONDEFENSE:
; 389  : 	case AT_MSKILL_DL_IRONDEFENSE1:
; 390  : 	case AT_MSKILL_DL_FIRESCREAM1:
; 391  : 	case AT_MSKILL_DL_FIRESCREAM2:
; 392  : 	case AT_MSKILL_DL_ELECTRICSPARK1:
; 393  : 	case AT_MSKILL_DL_CHAOTICDESEAR1:
; 394  : 	case AT_MSKILL_RF_DARKSIDE1:
; 395  : 	case AT_MSKILL_RF_DARKSIDE2:
; 396  : 	case AT_MSKILL_RF_DRAGONRORE1:
; 397  : 	case AT_MSKILL_RF_DRAGONRORE2:
; 398  : 		return true;

  00061	b8 01 00 00 00	 mov	 eax, 1

; 402  : }

  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
  0006a	66 90		 npad	 2
$LN11@EnableSkil:
  0006c	00 00 00 00	 DD	 $LN4@EnableSkil
  00070	00 00 00 00	 DD	 $LN2@EnableSkil
$LN8@EnableSkil:
  00074	00		 DB	 0
  00075	01		 DB	 1
  00076	01		 DB	 1
  00077	00		 DB	 0
  00078	00		 DB	 0
  00079	00		 DB	 0
  0007a	01		 DB	 1
  0007b	00		 DB	 0
  0007c	00		 DB	 0
  0007d	00		 DB	 0
  0007e	01		 DB	 1
  0007f	00		 DB	 0
  00080	01		 DB	 1
  00081	01		 DB	 1
  00082	01		 DB	 1
  00083	01		 DB	 1
  00084	01		 DB	 1
  00085	01		 DB	 1
  00086	01		 DB	 1
  00087	00		 DB	 0
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
  0008b	01		 DB	 1
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	01		 DB	 1
  0008f	01		 DB	 1
  00090	01		 DB	 1
  00091	01		 DB	 1
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	00		 DB	 0
  00096	00		 DB	 0
  00097	00		 DB	 0
  00098	00		 DB	 0
  00099	00		 DB	 0
  0009a	00		 DB	 0
  0009b	01		 DB	 1
  0009c	01		 DB	 1
  0009d	01		 DB	 1
  0009e	00		 DB	 0
  0009f	00		 DB	 0
  000a0	01		 DB	 1
  000a1	00		 DB	 0
  000a2	00		 DB	 0
  000a3	00		 DB	 0
  000a4	01		 DB	 1
  000a5	01		 DB	 1
  000a6	00		 DB	 0
  000a7	00		 DB	 0
  000a8	01		 DB	 1
  000a9	01		 DB	 1
  000aa	01		 DB	 1
  000ab	01		 DB	 1
  000ac	01		 DB	 1
  000ad	00		 DB	 0
  000ae	01		 DB	 1
  000af	01		 DB	 1
  000b0	00		 DB	 0
  000b1	01		 DB	 1
  000b2	00		 DB	 0
  000b3	00		 DB	 0
  000b4	00		 DB	 0
  000b5	00		 DB	 0
  000b6	01		 DB	 1
  000b7	00		 DB	 0
  000b8	01		 DB	 1
  000b9	01		 DB	 1
  000ba	00		 DB	 0
  000bb	00		 DB	 0
  000bc	00		 DB	 0
  000bd	00		 DB	 0
  000be	01		 DB	 1
  000bf	01		 DB	 1
  000c0	01		 DB	 1
  000c1	01		 DB	 1
  000c2	01		 DB	 1
  000c3	01		 DB	 1
  000c4	01		 DB	 1
  000c5	01		 DB	 1
  000c6	01		 DB	 1
  000c7	01		 DB	 1
  000c8	01		 DB	 1
  000c9	01		 DB	 1
  000ca	01		 DB	 1
  000cb	01		 DB	 1
  000cc	01		 DB	 1
  000cd	01		 DB	 1
  000ce	01		 DB	 1
  000cf	01		 DB	 1
  000d0	01		 DB	 1
  000d1	01		 DB	 1
  000d2	01		 DB	 1
  000d3	01		 DB	 1
  000d4	01		 DB	 1
  000d5	01		 DB	 1
  000d6	01		 DB	 1
  000d7	01		 DB	 1
  000d8	01		 DB	 1
  000d9	01		 DB	 1
  000da	01		 DB	 1
  000db	01		 DB	 1
  000dc	01		 DB	 1
  000dd	01		 DB	 1
  000de	01		 DB	 1
  000df	01		 DB	 1
  000e0	01		 DB	 1
  000e1	01		 DB	 1
  000e2	01		 DB	 1
  000e3	01		 DB	 1
  000e4	01		 DB	 1
  000e5	01		 DB	 1
  000e6	01		 DB	 1
  000e7	01		 DB	 1
  000e8	01		 DB	 1
  000e9	01		 DB	 1
  000ea	01		 DB	 1
  000eb	01		 DB	 1
  000ec	01		 DB	 1
  000ed	01		 DB	 1
  000ee	01		 DB	 1
  000ef	01		 DB	 1
  000f0	01		 DB	 1
  000f1	01		 DB	 1
  000f2	01		 DB	 1
  000f3	01		 DB	 1
  000f4	01		 DB	 1
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	01		 DB	 1
  000ff	01		 DB	 1
  00100	01		 DB	 1
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	01		 DB	 1
  00106	01		 DB	 1
  00107	01		 DB	 1
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	01		 DB	 1
  00115	01		 DB	 1
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	01		 DB	 1
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	01		 DB	 1
  00124	01		 DB	 1
  00125	01		 DB	 1
  00126	01		 DB	 1
  00127	01		 DB	 1
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	01		 DB	 1
  0012f	01		 DB	 1
  00130	01		 DB	 1
  00131	01		 DB	 1
  00132	01		 DB	 1
  00133	01		 DB	 1
  00134	01		 DB	 1
  00135	01		 DB	 1
  00136	01		 DB	 1
  00137	01		 DB	 1
  00138	01		 DB	 1
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	01		 DB	 1
  0013c	01		 DB	 1
  0013d	01		 DB	 1
  0013e	01		 DB	 1
  0013f	01		 DB	 1
  00140	01		 DB	 1
  00141	01		 DB	 1
  00142	01		 DB	 1
  00143	01		 DB	 1
  00144	01		 DB	 1
  00145	00		 DB	 0
  00146	00		 DB	 0
  00147	00		 DB	 0
  00148	00		 DB	 0
  00149	00		 DB	 0
  0014a	00		 DB	 0
  0014b	01		 DB	 1
  0014c	00		 DB	 0
  0014d	00		 DB	 0
  0014e	00		 DB	 0
  0014f	00		 DB	 0
  00150	00		 DB	 0
  00151	01		 DB	 1
  00152	01		 DB	 1
  00153	01		 DB	 1
  00154	01		 DB	 1
  00155	00		 DB	 0
  00156	01		 DB	 1
  00157	00		 DB	 0
  00158	00		 DB	 0
  00159	00		 DB	 0
  0015a	00		 DB	 0
  0015b	00		 DB	 0
  0015c	00		 DB	 0
  0015d	00		 DB	 0
  0015e	66 90		 npad	 2
$LN12@EnableSkil:
  00160	00 00 00 00	 DD	 $LN4@EnableSkil
  00164	00 00 00 00	 DD	 $LN2@EnableSkil
$LN9@EnableSkil:
  00168	00		 DB	 0
  00169	01		 DB	 1
  0016a	01		 DB	 1
  0016b	01		 DB	 1
  0016c	01		 DB	 1
  0016d	01		 DB	 1
  0016e	01		 DB	 1
  0016f	01		 DB	 1
  00170	01		 DB	 1
  00171	01		 DB	 1
  00172	01		 DB	 1
  00173	01		 DB	 1
  00174	01		 DB	 1
  00175	01		 DB	 1
  00176	01		 DB	 1
  00177	01		 DB	 1
  00178	01		 DB	 1
  00179	01		 DB	 1
  0017a	01		 DB	 1
  0017b	01		 DB	 1
  0017c	01		 DB	 1
  0017d	01		 DB	 1
  0017e	01		 DB	 1
  0017f	01		 DB	 1
  00180	01		 DB	 1
  00181	01		 DB	 1
  00182	01		 DB	 1
  00183	01		 DB	 1
  00184	01		 DB	 1
  00185	01		 DB	 1
  00186	01		 DB	 1
  00187	01		 DB	 1
  00188	01		 DB	 1
  00189	01		 DB	 1
  0018a	01		 DB	 1
  0018b	01		 DB	 1
  0018c	01		 DB	 1
  0018d	01		 DB	 1
  0018e	01		 DB	 1
  0018f	01		 DB	 1
  00190	01		 DB	 1
  00191	01		 DB	 1
  00192	01		 DB	 1
  00193	01		 DB	 1
  00194	01		 DB	 1
  00195	01		 DB	 1
  00196	01		 DB	 1
  00197	01		 DB	 1
  00198	01		 DB	 1
  00199	01		 DB	 1
  0019a	01		 DB	 1
  0019b	01		 DB	 1
  0019c	01		 DB	 1
  0019d	01		 DB	 1
  0019e	01		 DB	 1
  0019f	01		 DB	 1
  001a0	00		 DB	 0
  001a1	00		 DB	 0
  001a2	00		 DB	 0
  001a3	00		 DB	 0
  001a4	00		 DB	 0
  001a5	00		 DB	 0
  001a6	00		 DB	 0
  001a7	00		 DB	 0
  001a8	01		 DB	 1
  001a9	01		 DB	 1
  001aa	00		 DB	 0
  001ab	00		 DB	 0
  001ac	01		 DB	 1
  001ad	00		 DB	 0
  001ae	00		 DB	 0
  001af	01		 DB	 1
  001b0	00		 DB	 0
  001b1	00		 DB	 0
  001b2	00		 DB	 0
  001b3	01		 DB	 1
  001b4	00		 DB	 0
  001b5	01		 DB	 1
  001b6	01		 DB	 1
  001b7	01		 DB	 1
  001b8	01		 DB	 1
  001b9	01		 DB	 1
  001ba	01		 DB	 1
  001bb	01		 DB	 1
  001bc	01		 DB	 1
  001bd	01		 DB	 1
  001be	00		 DB	 0
  001bf	01		 DB	 1
  001c0	01		 DB	 1
  001c1	01		 DB	 1
  001c2	00		 DB	 0
  001c3	01		 DB	 1
  001c4	01		 DB	 1
  001c5	00		 DB	 0
  001c6	01		 DB	 1
  001c7	01		 DB	 1
  001c8	01		 DB	 1
  001c9	01		 DB	 1
  001ca	01		 DB	 1
  001cb	01		 DB	 1
  001cc	01		 DB	 1
  001cd	01		 DB	 1
  001ce	01		 DB	 1
  001cf	01		 DB	 1
  001d0	01		 DB	 1
  001d1	01		 DB	 1
  001d2	01		 DB	 1
  001d3	01		 DB	 1
  001d4	00		 DB	 0
  001d5	00		 DB	 0
  001d6	00		 DB	 0
  001d7	00		 DB	 0
  001d8	00		 DB	 0
  001d9	00		 DB	 0
  001da	00		 DB	 0
  001db	00		 DB	 0
  001dc	01		 DB	 1
  001dd	00		 DB	 0
  001de	00		 DB	 0
  001df	00		 DB	 0
  001e0	00		 DB	 0
  001e1	00		 DB	 0
  001e2	00		 DB	 0
  001e3	00		 DB	 0
  001e4	00		 DB	 0
  001e5	01		 DB	 1
  001e6	01		 DB	 1
  001e7	01		 DB	 1
  001e8	01		 DB	 1
  001e9	01		 DB	 1
  001ea	01		 DB	 1
  001eb	01		 DB	 1
  001ec	01		 DB	 1
  001ed	00		 DB	 0
  001ee	00		 DB	 0
  001ef	01		 DB	 1
  001f0	00		 DB	 0
  001f1	01		 DB	 1
  001f2	01		 DB	 1
  001f3	01		 DB	 1
  001f4	01		 DB	 1
  001f5	00		 DB	 0
  001f6	01		 DB	 1
  001f7	00		 DB	 0
  001f8	00		 DB	 0
  001f9	01		 DB	 1
  001fa	00		 DB	 0
  001fb	00		 DB	 0
  001fc	00		 DB	 0
  001fd	01		 DB	 1
  001fe	00		 DB	 0
  001ff	01		 DB	 1
  00200	00		 DB	 0
  00201	00		 DB	 0
  00202	00		 DB	 0
  00203	00		 DB	 0
  00204	00		 DB	 0
  00205	01		 DB	 1
  00206	01		 DB	 1
  00207	00		 DB	 0
  00208	00		 DB	 0
  00209	00		 DB	 0
  0020a	01		 DB	 1
  0020b	00		 DB	 0
  0020c	01		 DB	 1
  0020d	01		 DB	 1
  0020e	01		 DB	 1
  0020f	01		 DB	 1
  00210	01		 DB	 1
  00211	01		 DB	 1
  00212	01		 DB	 1
  00213	00		 DB	 0
  00214	01		 DB	 1
  00215	01		 DB	 1
  00216	01		 DB	 1
  00217	01		 DB	 1
  00218	01		 DB	 1
  00219	01		 DB	 1
  0021a	01		 DB	 1
  0021b	01		 DB	 1
  0021c	01		 DB	 1
  0021d	01		 DB	 1
  0021e	01		 DB	 1
  0021f	01		 DB	 1
  00220	00		 DB	 0
  00221	00		 DB	 0
  00222	00		 DB	 0
  00223	01		 DB	 1
  00224	00		 DB	 0
  00225	00		 DB	 0
  00226	00		 DB	 0
  00227	00		 DB	 0
  00228	00		 DB	 0
  00229	00		 DB	 0
  0022a	01		 DB	 1
  0022b	01		 DB	 1
  0022c	01		 DB	 1
  0022d	01		 DB	 1
  0022e	01		 DB	 1
  0022f	00		 DB	 0
  00230	00		 DB	 0
  00231	01		 DB	 1
  00232	00		 DB	 0
  00233	01		 DB	 1
  00234	01		 DB	 1
  00235	01		 DB	 1
  00236	01		 DB	 1
  00237	01		 DB	 1
  00238	01		 DB	 1
  00239	00		 DB	 0
  0023a	00		 DB	 0
  0023b	00		 DB	 0
  0023c	00		 DB	 0
  0023d	00		 DB	 0
  0023e	00		 DB	 0
  0023f	01		 DB	 1
  00240	00		 DB	 0
  00241	00		 DB	 0
  00242	01		 DB	 1
  00243	00		 DB	 0
  00244	00		 DB	 0
  00245	00		 DB	 0
  00246	00		 DB	 0
  00247	00		 DB	 0
  00248	00		 DB	 0
  00249	00		 DB	 0
  0024a	00		 DB	 0
  0024b	00		 DB	 0
  0024c	01		 DB	 1
  0024d	01		 DB	 1
  0024e	01		 DB	 1
  0024f	01		 DB	 1
  00250	01		 DB	 1
  00251	01		 DB	 1
  00252	01		 DB	 1
  00253	01		 DB	 1
  00254	01		 DB	 1
  00255	01		 DB	 1
  00256	00		 DB	 0
  00257	00		 DB	 0
  00258	01		 DB	 1
  00259	00		 DB	 0
  0025a	00		 DB	 0
  0025b	01		 DB	 1
  0025c	00		 DB	 0
  0025d	00		 DB	 0
  0025e	00		 DB	 0
  0025f	00		 DB	 0
  00260	00		 DB	 0
  00261	00		 DB	 0
  00262	00		 DB	 0
  00263	00		 DB	 0
  00264	00		 DB	 0
  00265	00		 DB	 0
  00266	00		 DB	 0
?EnableSkill@CObjUseSkill@@QAEHH@Z ENDP			; CObjUseSkill::EnableSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?SpeedHackCheck@CObjUseSkill@@QAEHH@Z PROC		; CObjUseSkill::SpeedHackCheck, COMDAT
; _this$ = ecx

; 169  : 	return TRUE;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 170  : 	LPOBJ lpObj = &gObj[aIndex];
; 171  : 
; 172  : 
; 173  : 	int iTimeCalc = GetTickCount() - lpObj->m_LastAttackTime;
; 174  : 
; 175  : 	if(iTimeCalc < lpObj->m_DetectSpeedHackTime)
; 176  : 	{
; 177  : 		lpObj->m_DetectCount++;
; 178  : 		lpObj->m_SumLastAttackTime += iTimeCalc;
; 179  : 
; 180  : 		if(lpObj->m_DetectCount > gHackCheckCount)
; 181  : 		{
; 182  : 			lpObj->m_DetectedHackKickCount++;
; 183  : 
; 184  : 			if(gIsKickDetecHackCountLimit != 0 && lpObj->m_DetectedHackKickCount > gDetectedHackKickCount)
; 185  : 			{
; 186  : 				LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d",
; 187  : 					lpObj->AccountID,lpObj->Name,lMsg.Get(lpObj->Class+1900),lpObj->m_DetectedHackKickCount,lpObj->MapNumber);
; 188  : 				CloseClient(aIndex);
; 189  : 				return false;
; 190  : 			}
; 191  : 
; 192  : 			lpObj->m_SpeedHackPenalty = gSpeedHackPenalty;
; 193  : 			LogAddTD("[%s][%s] %s Attack Speed Is Wrong MagicSkill (%d)(%d) Penalty %d @%d",
; 194  : 				lpObj->AccountID,lpObj->Name,lMsg.Get(lpObj->Class+1900),lpObj->m_DetectSpeedHackTime,lpObj->m_SumLastAttackTime / lpObj->m_DetectCount,lpObj->m_SpeedHackPenalty,lpObj->MapNumber);
; 195  : 		}
; 196  : 	}
; 197  : 	else
; 198  : 	{
; 199  : 		lpObj->m_SumLastAttackTime = 0;
; 200  : 		lpObj->m_DetectCount = 0;
; 201  : 	}
; 202  : 
; 203  : 	lpObj->m_LastAttackTime = GetTickCount();
; 204  : 
; 205  : 	if(bIsIgnorePacketSpeedHackDetect != 0 && lpObj->m_SpeedHackPenalty > 0)
; 206  : 	{
; 207  : 		lpObj->m_SpeedHackPenalty--;
; 208  : 		LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left) @%d",
; 209  : 			lpObj->AccountID,lpObj->Name,lMsg.Get(lpObj->Class + 1900),lpObj->m_SpeedHackPenalty,lpObj->MapNumber);
; 210  : 		return false;
; 211  : 	}
; 212  : 	return true;
; 213  : }

  00005	c2 04 00	 ret	 4
?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ENDP		; CObjUseSkill::SpeedHackCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ??1CObjUseSkill@@UAE@XZ
_TEXT	SEGMENT
??1CObjUseSkill@@UAE@XZ PROC				; CObjUseSkill::~CObjUseSkill, COMDAT
; _this$ = ecx

; 34   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CObjUseSkill@@6B@

; 35   : }

  00006	c3		 ret	 0
??1CObjUseSkill@@UAE@XZ ENDP				; CObjUseSkill::~CObjUseSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ??0CObjUseSkill@@QAE@XZ
_TEXT	SEGMENT
??0CObjUseSkill@@QAE@XZ PROC				; CObjUseSkill::CObjUseSkill, COMDAT
; _this$ = ecx

; 30   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CObjUseSkill@@6B@

; 31   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CObjUseSkill@@QAE@XZ ENDP				; CObjUseSkill::CObjUseSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Xx$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 316  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 317  : 	return (_CSTD sqrtf(_Xx));

  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv65[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv65[esp+8]

; 318  : 	}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 745  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 746  :         return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 747  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\objuseskill.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 6738 : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
