; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\TMonsterAIGroup.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_bDataLoad@TMonsterAIGroup@@2HA		; TMonsterAIGroup::s_bDataLoad
PUBLIC	?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA ; TMonsterAIGroup::s_iMonsterAIGroupMemberCount
_BSS	SEGMENT
?s_bDataLoad@TMonsterAIGroup@@2HA DD 01H DUP (?)	; TMonsterAIGroup::s_bDataLoad
?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA DD 032H DUP (?) ; TMonsterAIGroup::s_iMonsterAIGroupMemberCount
_BSS	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0TMonsterAIGroup@@QAE@XZ			; TMonsterAIGroup::TMonsterAIGroup
PUBLIC	??1TMonsterAIGroup@@UAE@XZ			; TMonsterAIGroup::~TMonsterAIGroup
PUBLIC	?Init@TMonsterAIGroup@@SAXH@Z			; TMonsterAIGroup::Init
PUBLIC	?InitAll@TMonsterAIGroup@@SAXXZ			; TMonsterAIGroup::InitAll
PUBLIC	?LoadData@TMonsterAIGroup@@SAHPAD@Z		; TMonsterAIGroup::LoadData
PUBLIC	?DelAllGroupInfo@TMonsterAIGroup@@SAHXZ		; TMonsterAIGroup::DelAllGroupInfo
PUBLIC	?DelGroupInstance@TMonsterAIGroup@@SAHH@Z	; TMonsterAIGroup::DelGroupInstance
PUBLIC	?ChangeAIOrder@TMonsterAIGroup@@SAXHH@Z		; TMonsterAIGroup::ChangeAIOrder
PUBLIC	?FindGroupMember@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HH@Z ; TMonsterAIGroup::FindGroupMember
PUBLIC	?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z ; TMonsterAIGroup::FindGroupMemberToSommon
PUBLIC	?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z ; TMonsterAIGroup::FindGroupMemberToHeal
PUBLIC	?FindGroupLeader@TMonsterAIGroup@@SAHH@Z	; TMonsterAIGroup::FindGroupLeader
PUBLIC	?FindGroupMemberObjectIndex@TMonsterAIGroup@@SAHHH@Z ; TMonsterAIGroup::FindGroupMemberObjectIndex
PUBLIC	??_GTMonsterAIGroup@@UAEPAXI@Z			; TMonsterAIGroup::`scalar deleting destructor'
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A ; TMonsterAIGroup::s_MonsterAIGroupMemberArray
PUBLIC	??_7TMonsterAIGroup@@6B@			; TMonsterAIGroup::`vftable'
PUBLIC	??_C@_0DH@EJJEEGKC@?$FLMonster?5AI?5Group?$FN?5?9?5File?5load?5e@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CE@LNCDKEDF@?$FLMonster?5AI?5Group?$FN?5?9?5Can?8t?5Open?5@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CN@CNMPNCB@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@ ; `string'
PUBLIC	??_C@_0DC@LFNOMCBG@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@ ; `string'
PUBLIC	??_C@_0CI@CJPFLHBA@?$FLMonster?5AI?5Group?5?$FN?5?9?5?$CFs?5file?5is@ ; `string'
PUBLIC	??_R0K@8					; unsigned long `RTTI Type Descriptor'
PUBLIC	??_C@_0DJ@HODFGLNJ@?$FLMonster?5AI?5Group?$FN?5?9?5Loading?5Exc@ ; `string'
PUBLIC	??_C@_0DM@BFBHLGFI@?$FLMonster?5AI?5Group?$FN?5ChangeAIOrder@ ; `string'
PUBLIC	??_C@_0DH@OJFKHKGJ@?$FLMonster?5AI?5Group?$FN?5DelGroup?$CI?$CJ?5Er@ ; `string'
PUBLIC	??_C@_0DO@JGGBMAIA@?$FLMonster?5AI?5Group?$FN?5FindGroupLead@ ; `string'
PUBLIC	??_C@_0FB@IIFMNKGF@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@ ; `string'
PUBLIC	??_C@_0EI@PEHGDPOI@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@ ; `string'
PUBLIC	??_R4TMonsterAIGroup@@6B@			; TMonsterAIGroup::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIGroup@@@8			; TMonsterAIGroup `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIGroup@@8				; TMonsterAIGroup::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIGroup@@8				; TMonsterAIGroup::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIGroup@@8		; TMonsterAIGroup::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
PUBLIC	__real@42c80000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	??0TMonsterAIGroupMember@@QAE@XZ:PROC		; TMonsterAIGroupMember::TMonsterAIGroupMember
EXTRN	??1TMonsterAIGroupMember@@UAE@XZ:PROC		; TMonsterAIGroupMember::~TMonsterAIGroupMember
EXTRN	?Reset@TMonsterAIGroupMember@@QAEXXZ:PROC	; TMonsterAIGroupMember::Reset
EXTRN	??_ETMonsterAIGroup@@UAEPAXI@Z:PROC		; TMonsterAIGroup::`vector deleting destructor'
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjViewportClose
EXTRN	?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolDestroy
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A DB 04e200H DUP (?) ; TMonsterAIGroup::s_MonsterAIGroupMemberArray
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
CRT$XCU	SEGMENT
??s_MonsterAIGroupMemberArray$initializer$@TMonsterAIGroup@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ ; ??s_MonsterAIGroupMemberArray$initializer$@TMonsterAIGroup@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@TMonsterAIGroup@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIGroup@@8 DD FLAT:??_R0?AVTMonsterAIGroup@@@8 ; TMonsterAIGroup::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIGroup@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIGroup@@8
rdata$r	SEGMENT
??_R2TMonsterAIGroup@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIGroup@@8 ; TMonsterAIGroup::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIGroup@@8
rdata$r	SEGMENT
??_R3TMonsterAIGroup@@8 DD 00H				; TMonsterAIGroup::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIGroup@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIGroup@@@8
data$r	SEGMENT
??_R0?AVTMonsterAIGroup@@@8 DD FLAT:??_7type_info@@6B@	; TMonsterAIGroup `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIGroup@@', 00H
data$r	ENDS
;	COMDAT ??_R4TMonsterAIGroup@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIGroup@@6B@ DD 00H			; TMonsterAIGroup::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIGroup@@@8
	DD	FLAT:??_R3TMonsterAIGroup@@8
rdata$r	ENDS
;	COMDAT ??_C@_0EI@PEHGDPOI@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@
CONST	SEGMENT
??_C@_0EI@PEHGDPOI@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@ DB '[Monste'
	DB	'r AI Group] FindGroupMember() Error - (GroupNumber=%d)(Guid=%'
	DB	'd) ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@IIFMNKGF@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@
CONST	SEGMENT
??_C@_0FB@IIFMNKGF@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@ DB '[Monste'
	DB	'r AI Group] FindGroupMemberObjectIndex() Error - (GroupNumber'
	DB	'=%d Guid=%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JGGBMAIA@?$FLMonster?5AI?5Group?$FN?5FindGroupLead@
CONST	SEGMENT
??_C@_0DO@JGGBMAIA@?$FLMonster?5AI?5Group?$FN?5FindGroupLead@ DB '[Monste'
	DB	'r AI Group] FindGroupLeader() Error - (GroupNumber=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OJFKHKGJ@?$FLMonster?5AI?5Group?$FN?5DelGroup?$CI?$CJ?5Er@
CONST	SEGMENT
??_C@_0DH@OJFKHKGJ@?$FLMonster?5AI?5Group?$FN?5DelGroup?$CI?$CJ?5Er@ DB '['
	DB	'Monster AI Group] DelGroup() Error - (GroupNumber=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BFBHLGFI@?$FLMonster?5AI?5Group?$FN?5ChangeAIOrder@
CONST	SEGMENT
??_C@_0DM@BFBHLGFI@?$FLMonster?5AI?5Group?$FN?5ChangeAIOrder@ DB '[Monste'
	DB	'r AI Group] ChangeAIOrder() Error - (GroupNumber=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HODFGLNJ@?$FLMonster?5AI?5Group?$FN?5?9?5Loading?5Exc@
CONST	SEGMENT
??_C@_0DJ@HODFGLNJ@?$FLMonster?5AI?5Group?$FN?5?9?5Loading?5Exc@ DB '[Mon'
	DB	'ster AI Group] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0K@8
data$r	SEGMENT
??_R0K@8 DD	FLAT:??_7type_info@@6B@			; unsigned long `RTTI Type Descriptor'
	DD	00H
	DB	'.K', 00H
data$r	ENDS
;	COMDAT ??_C@_0CI@CJPFLHBA@?$FLMonster?5AI?5Group?5?$FN?5?9?5?$CFs?5file?5is@
CONST	SEGMENT
??_C@_0CI@CJPFLHBA@?$FLMonster?5AI?5Group?5?$FN?5?9?5?$CFs?5file?5is@ DB '['
	DB	'Monster AI Group ] - %s file is Loaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LFNOMCBG@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@
CONST	SEGMENT
??_C@_0DC@LFNOMCBG@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@ DB '[Mons'
	DB	'ter AI Group] Exceed Max GroupMember %d, %d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CNMPNCB@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@
CONST	SEGMENT
??_C@_0CN@CNMPNCB@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@ DB '[Monst'
	DB	'er AI Group] Exceed Max GroupNumber %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LNCDKEDF@?$FLMonster?5AI?5Group?$FN?5?9?5Can?8t?5Open?5@
CONST	SEGMENT
??_C@_0CE@LNCDKEDF@?$FLMonster?5AI?5Group?$FN?5?9?5Can?8t?5Open?5@ DB '[M'
	DB	'onster AI Group] - Can''t Open %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EJJEEGKC@?$FLMonster?5AI?5Group?$FN?5?9?5File?5load?5e@
CONST	SEGMENT
??_C@_0DH@EJJEEGKC@?$FLMonster?5AI?5Group?$FN?5?9?5File?5load?5e@ DB '[Mo'
	DB	'nster AI Group] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7TMonsterAIGroup@@6B@
CONST	SEGMENT
??_7TMonsterAIGroup@@6B@ DD FLAT:??_R4TMonsterAIGroup@@6B@ ; TMonsterAIGroup::`vftable'
	DD	FLAT:??_ETMonsterAIGroup@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterAIGroup@@SAHPAD@Z$2 DD 00H
	DD	FLAT:??_R0K@8
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterAIGroup@@SAHPAD@Z$0
__unwindtable$?LoadData@TMonsterAIGroup@@SAHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterAIGroup@@SAHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterAIGroup@@SAHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterAIGroup@@SAHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterAIGroup@@SAHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterAIGroup@@SAHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ
text$yd	SEGMENT
??__F?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'TMonsterAIGroup::s_MonsterAIGroupMemberArray'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIGroupMember@@UAE@XZ ; TMonsterAIGroupMember::~TMonsterAIGroupMember
  00005	68 88 13 00 00	 push	 5000			; 00001388H
  0000a	6a 40		 push	 64			; 00000040H
  0000c	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A ; TMonsterAIGroup::s_MonsterAIGroupMemberArray
  00011	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00016	c3		 ret	 0
??__F?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'TMonsterAIGroup::s_MonsterAIGroupMemberArray''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ??__E?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ
text$di	SEGMENT
??__E?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterAIGroup::s_MonsterAIGroupMemberArray'', COMDAT

; 15   : TMonsterAIGroupMember TMonsterAIGroup::s_MonsterAIGroupMemberArray[MAX_MONSTER_AI_GROUP][MAX_MONSTER_AI_GROUP_MEMBER];

  00000	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIGroupMember@@UAE@XZ ; TMonsterAIGroupMember::~TMonsterAIGroupMember
  00005	68 00 00 00 00	 push	 OFFSET ??0TMonsterAIGroupMember@@QAE@XZ ; TMonsterAIGroupMember::TMonsterAIGroupMember
  0000a	68 88 13 00 00	 push	 5000			; 00001388H
  0000f	6a 40		 push	 64			; 00000040H
  00011	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A ; TMonsterAIGroup::s_MonsterAIGroupMemberArray
  00016	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0001b	68 00 00 00 00	 push	 OFFSET ??__F?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ ; `dynamic atexit destructor for 'TMonsterAIGroup::s_MonsterAIGroupMemberArray''
  00020	e8 00 00 00 00	 call	 _atexit
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
??__E?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterAIGroup::s_MonsterAIGroupMemberArray''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	int ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA, 0
  00017	53		 push	 ebx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8b d8		 mov	 ebx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	83 fb ff	 cmp	 ebx, -1
  00033	74 5d		 je	 SHORT $LN43@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)
; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  00038	75 30		 jne	 SHORT $LN2@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00040	e8 00 00 00 00	 call	 _fgetc
  00045	8b d8		 mov	 ebx, eax
  00047	83 c4 04	 add	 esp, 4
  0004a	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  0004d	75 1b		 jne	 SHORT $LN2@GetToken
  0004f	90		 npad	 1
$LL5@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	83 fb ff	 cmp	 ebx, -1
  00053	74 3d		 je	 SHORT $LN43@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0005b	e8 00 00 00 00	 call	 _fgetc
  00060	8b d8		 mov	 ebx, eax
  00062	83 c4 04	 add	 esp, 4
  00065	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00068	75 e6		 jne	 SHORT $LL5@GetToken
$LN2@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _isspace
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	75 a9		 jne	 SHORT $LL4@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00077	8d 43 de	 lea	 eax, DWORD PTR [ebx-34]
  0007a	56		 push	 esi
  0007b	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  0007e	0f 87 89 01 00
	00		 ja	 $LN29@GetToken
  00084	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN58@GetToken[eax]
  0008b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@GetToken[eax*4]
$LN43@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE

  00092	b8 02 00 00 00	 mov	 eax, 2
  00097	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN20@GetToken:
  000a6	5e		 pop	 esi

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000a7	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  000b1	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b6	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN21@GetToken:
  000c5	5e		 pop	 esi

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000c6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  000d0	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000d5	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN22@GetToken:
  000e4	5e		 pop	 esi

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000e5	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  000ef	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000f4	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN23@GetToken:
  00103	5e		 pop	 esi

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00104	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0010e	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  00113	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN24@GetToken:
  00122	5e		 pop	 esi

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00123	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  0012d	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  00132	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
$LN25@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00141	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00147	53		 push	 ebx
  00148	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  0014d	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00153	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  00156	e8 00 00 00 00	 call	 _getc
  0015b	8b d8		 mov	 ebx, eax
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	83 fb ff	 cmp	 ebx, -1
  00163	74 2f		 je	 SHORT $LN59@GetToken
$LL9@GetToken:
  00165	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00168	74 12		 je	 SHORT $LN26@GetToken
  0016a	53		 push	 ebx
  0016b	e8 00 00 00 00	 call	 _isdigit
  00170	83 c4 04	 add	 esp, 4
  00173	85 c0		 test	 eax, eax
  00175	75 05		 jne	 SHORT $LN26@GetToken
  00177	83 fb 2d	 cmp	 ebx, 45			; 0000002dH
  0017a	75 18		 jne	 SHORT $LN59@GetToken
$LN26@GetToken:
  0017c	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00182	88 1e		 mov	 BYTE PTR [esi], bl

; 102  : 			p++;

  00184	46		 inc	 esi
  00185	e8 00 00 00 00	 call	 _getc
  0018a	8b d8		 mov	 ebx, eax
  0018c	83 c4 04	 add	 esp, 4
  0018f	83 fb ff	 cmp	 ebx, -1
  00192	75 d1		 jne	 SHORT $LL9@GetToken
$LN59@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = (float)atof( TempString);	// Select the first Byte as Main ID

  00194	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  00197	c6 06 00	 mov	 BYTE PTR [esi], 0
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _atof
  001a0	83 c4 04	 add	 esp, 4

; 106  : 		return CurrentToken  = NUMBER ;

  001a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  001ad	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA
  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN27@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  001c8	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  001ce	be 00 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA
  001d3	e8 00 00 00 00	 call	 _getc
  001d8	83 c4 04	 add	 esp, 4
  001db	83 f8 ff	 cmp	 eax, -1
  001de	74 1f		 je	 SHORT $LN12@GetToken
$LL11@GetToken:
  001e0	83 f8 22	 cmp	 eax, 34			; 00000022H
  001e3	0f 84 95 00 00
	00		 je	 $LN28@GetToken
  001e9	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 113  : 		{
; 114  : 			*p = ch;

  001ef	88 06		 mov	 BYTE PTR [esi], al

; 115  : 			p++;

  001f1	46		 inc	 esi
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	75 e1		 jne	 SHORT $LL11@GetToken
$LN12@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001ff	83 f8 22	 cmp	 eax, 34			; 00000022H
  00202	74 7a		 je	 SHORT $LN28@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00204	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0020a	50		 push	 eax

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  0020b	eb 69		 jmp	 SHORT $LN62@GetToken
$LN29@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0020d	53		 push	 ebx
  0020e	e8 00 00 00 00	 call	 _isalpha
  00213	83 c4 04	 add	 esp, 4
  00216	85 c0		 test	 eax, eax
  00218	0f 84 7f 00 00
	00		 je	 $LN30@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  0021e	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00224	88 1d 00 00 00
	00		 mov	 BYTE PTR ?TokenString@@3PADA, bl
  0022a	be 01 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA+1
  0022f	e8 00 00 00 00	 call	 _getc
  00234	8b d8		 mov	 ebx, eax
  00236	83 c4 04	 add	 esp, 4
  00239	83 fb ff	 cmp	 ebx, -1
  0023c	74 31		 je	 SHORT $LN60@GetToken
  0023e	66 90		 npad	 2
$LL13@GetToken:
  00240	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00243	74 12		 je	 SHORT $LN32@GetToken
  00245	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00248	74 0d		 je	 SHORT $LN32@GetToken
  0024a	53		 push	 ebx
  0024b	e8 00 00 00 00	 call	 _isalnum
  00250	83 c4 04	 add	 esp, 4
  00253	85 c0		 test	 eax, eax
  00255	74 18		 je	 SHORT $LN60@GetToken
$LN32@GetToken:
  00257	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 133  : 			{
; 134  : 				*p=ch;

  0025d	88 1e		 mov	 BYTE PTR [esi], bl

; 135  : 				p++;

  0025f	46		 inc	 esi
  00260	e8 00 00 00 00	 call	 _getc
  00265	8b d8		 mov	 ebx, eax
  00267	83 c4 04	 add	 esp, 4
  0026a	83 fb ff	 cmp	 ebx, -1
  0026d	75 d1		 jne	 SHORT $LL13@GetToken
$LN60@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0026f	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00275	53		 push	 ebx
$LN62@GetToken:
  00276	e8 00 00 00 00	 call	 _ungetc
  0027b	83 c4 08	 add	 esp, 8
$LN28@GetToken:

; 140  : 			*p=0;

  0027e	c6 06 00	 mov	 BYTE PTR [esi], 0

; 141  : 			CurrentToken=NAME;
; 142  : 			return CurrentToken;

  00281	33 c0		 xor	 eax, eax
  00283	5e		 pop	 esi
  00284	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0028e	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0028f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00292	33 cd		 xor	 ecx, ebp
  00294	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00299	8b e5		 mov	 esp, ebp
  0029b	5d		 pop	 ebp
  0029c	c3		 ret	 0
$LN30@GetToken:
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a0	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  002a5	5e		 pop	 esi
  002a6	33 cd		 xor	 ecx, ebp
  002a8	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  002b2	5b		 pop	 ebx
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
$LN64@GetToken:
  002bc	00 00 00 00	 DD	 $LN27@GetToken
  002c0	00 00 00 00	 DD	 $LN20@GetToken
  002c4	00 00 00 00	 DD	 $LN22@GetToken
  002c8	00 00 00 00	 DD	 $LN25@GetToken
  002cc	00 00 00 00	 DD	 $LN21@GetToken
  002d0	00 00 00 00	 DD	 $LN23@GetToken
  002d4	00 00 00 00	 DD	 $LN24@GetToken
  002d8	00 00 00 00	 DD	 $LN29@GetToken
$LN58@GetToken:
  002dc	00		 DB	 0
  002dd	01		 DB	 1
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	02		 DB	 2
  002e7	03		 DB	 3
  002e8	03		 DB	 3
  002e9	07		 DB	 7
  002ea	03		 DB	 3
  002eb	03		 DB	 3
  002ec	03		 DB	 3
  002ed	03		 DB	 3
  002ee	03		 DB	 3
  002ef	03		 DB	 3
  002f0	03		 DB	 3
  002f1	03		 DB	 3
  002f2	03		 DB	 3
  002f3	03		 DB	 3
  002f4	07		 DB	 7
  002f5	04		 DB	 4
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	07		 DB	 7
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	07		 DB	 7
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	07		 DB	 7
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	07		 DB	 7
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	07		 DB	 7
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	07		 DB	 7
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	07		 DB	 7
  00331	07		 DB	 7
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	05		 DB	 5
  00336	07		 DB	 7
  00337	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GTMonsterAIGroup@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTMonsterAIGroup@@UAEPAXI@Z PROC			; TMonsterAIGroup::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1TMonsterAIGroup@@UAE@XZ ; TMonsterAIGroup::~TMonsterAIGroup
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 04		 push	 4
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GTMonsterAIGroup@@UAEPAXI@Z ENDP			; TMonsterAIGroup::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?FindGroupMemberObjectIndex@TMonsterAIGroup@@SAHHH@Z
_TEXT	SEGMENT
_iGroupNumber$ = 8					; size = 4
_iGuid$ = 12						; size = 4
?FindGroupMemberObjectIndex@TMonsterAIGroup@@SAHHH@Z PROC ; TMonsterAIGroup::FindGroupMemberObjectIndex, COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 296  : 	if ( iGroupNumber < 0 || iGroupNumber >= MAX_MONSTER_AI_GROUP )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iGroupNumber$[ebp]
  00006	83 fa 31	 cmp	 edx, 49			; 00000031H
  00009	77 39		 ja	 SHORT $LN6@FindGroupM

; 300  : 	}
; 301  : 
; 302  : 	for ( int i=0;i<MAX_MONSTER_AI_GROUP_MEMBER;i++)

  0000b	69 c2 00 19 00
	00		 imul	 eax, edx, 6400
  00011	33 c9		 xor	 ecx, ecx
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _iGuid$[ebp]
  00017	05 08 00 00 00	 add	 eax, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+8
  0001c	0f 1f 40 00	 npad	 4
$LL4@FindGroupM:

; 303  : 	{
; 304  : 		if ( TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iGuid == iGuid )

  00020	39 30		 cmp	 DWORD PTR [eax], esi
  00022	74 0f		 je	 SHORT $LN10@FindGroupM

; 300  : 	}
; 301  : 
; 302  : 	for ( int i=0;i<MAX_MONSTER_AI_GROUP_MEMBER;i++)

  00024	41		 inc	 ecx
  00025	83 c0 40	 add	 eax, 64			; 00000040H
  00028	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0002b	7c f3		 jl	 SHORT $LL4@FindGroupM

; 307  : 		}
; 308  : 	}
; 309  : 
; 310  : 	return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	5e		 pop	 esi

; 311  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN10@FindGroupM:

; 305  : 		{
; 306  : 			return TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iObjIndex;

  00033	6b c2 64	 imul	 eax, edx, 100
  00036	5e		 pop	 esi
  00037	03 c1		 add	 eax, ecx
  00039	c1 e0 06	 shl	 eax, 6
  0003c	8b 80 3c 00 00
	00		 mov	 eax, DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+60]

; 311  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN6@FindGroupM:

; 297  : 	{
; 298  : 		LogAddTD("[Monster AI Group] FindGroupMemberObjectIndex() Error - (GroupNumber=%d Guid=%d)", iGroupNumber, iGuid);

  00044	ff 75 0c	 push	 DWORD PTR _iGuid$[ebp]
  00047	52		 push	 edx
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@IIFMNKGF@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 299  : 		return -1;

  00056	83 c8 ff	 or	 eax, -1

; 311  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?FindGroupMemberObjectIndex@TMonsterAIGroup@@SAHHH@Z ENDP ; TMonsterAIGroup::FindGroupMemberObjectIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?FindGroupLeader@TMonsterAIGroup@@SAHH@Z
_TEXT	SEGMENT
_iGroupNumber$ = 8					; size = 4
?FindGroupLeader@TMonsterAIGroup@@SAHH@Z PROC		; TMonsterAIGroup::FindGroupLeader, COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  : 	if ( iGroupNumber < 0 || iGroupNumber >= MAX_MONSTER_AI_GROUP )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iGroupNumber$[ebp]
  00006	83 fa 31	 cmp	 edx, 49			; 00000031H
  00009	77 30		 ja	 SHORT $LN6@FindGroupL

; 278  : 	}
; 279  : 
; 280  : 	for ( int i=0;i<MAX_MONSTER_AI_GROUP_MEMBER;i++)

  0000b	69 c2 00 19 00
	00		 imul	 eax, edx, 6400
  00011	33 c9		 xor	 ecx, ecx
  00013	05 10 00 00 00	 add	 eax, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+16
$LL4@FindGroupL:

; 281  : 	{
; 282  : 		if ( TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iRank == 0 )

  00018	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001b	74 0e		 je	 SHORT $LN10@FindGroupL

; 278  : 	}
; 279  : 
; 280  : 	for ( int i=0;i<MAX_MONSTER_AI_GROUP_MEMBER;i++)

  0001d	41		 inc	 ecx
  0001e	83 c0 40	 add	 eax, 64			; 00000040H
  00021	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00024	7c f2		 jl	 SHORT $LL4@FindGroupL

; 277  : 		return -1;

  00026	83 c8 ff	 or	 eax, -1

; 285  : 		}
; 286  : 	}
; 287  : 
; 288  : 	return -1;
; 289  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN10@FindGroupL:

; 283  : 		{
; 284  : 			return TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iObjIndex;

  0002b	6b c2 64	 imul	 eax, edx, 100
  0002e	03 c1		 add	 eax, ecx
  00030	c1 e0 06	 shl	 eax, 6
  00033	8b 80 3c 00 00
	00		 mov	 eax, DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+60]

; 285  : 		}
; 286  : 	}
; 287  : 
; 288  : 	return -1;
; 289  : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN6@FindGroupL:

; 275  : 	{
; 276  : 		LogAddTD("[Monster AI Group] FindGroupLeader() Error - (GroupNumber=%d)", iGroupNumber);

  0003b	52		 push	 edx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JGGBMAIA@?$FLMonster?5AI?5Group?$FN?5FindGroupLead@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00047	83 c4 08	 add	 esp, 8

; 277  : 		return -1;

  0004a	83 c8 ff	 or	 eax, -1

; 285  : 		}
; 286  : 	}
; 287  : 
; 288  : 	return -1;
; 289  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?FindGroupLeader@TMonsterAIGroup@@SAHH@Z ENDP		; TMonsterAIGroup::FindGroupLeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z
_TEXT	SEGMENT
_iMinHP$1$ = -8						; size = 4
_iMinHPGuid$1$ = -4					; size = 4
_iObjIndex$ = 8						; size = 4
_iGroupNumber$ = 12					; size = 4
_iGuid$ = 16						; size = 4
_iDistance$ = 20					; size = 4
?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z PROC ; TMonsterAIGroup::FindGroupMemberToHeal, COMDAT

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 339  : 	if ( TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber] == 0 )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iGroupNumber$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	8b 1c 85 00 00
	00 00		 mov	 ebx, DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[eax*4]
  00011	85 db		 test	 ebx, ebx
  00013	0f 84 de 00 00
	00		 je	 $LN12@FindGroupM

; 340  : 		return NULL;
; 341  : 
; 342  : 	int iMinHPGuid = -1;

  00019	83 c9 ff	 or	 ecx, -1

; 343  : 	int iMinHP = 100000000;

  0001c	ba 00 e1 f5 05	 mov	 edx, 100000000		; 05f5e100H
  00021	89 4d fc	 mov	 DWORD PTR _iMinHPGuid$1$[ebp], ecx
  00024	89 55 f8	 mov	 DWORD PTR _iMinHP$1$[ebp], edx

; 344  : 	int iCount = TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber];
; 345  : 
; 346  : 	for ( int i=0;i<iCount;i++)

  00027	85 db		 test	 ebx, ebx
  00029	0f 8e c8 00 00
	00		 jle	 $LN12@FindGroupM

; 340  : 		return NULL;
; 341  : 
; 342  : 	int iMinHPGuid = -1;

  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	69 f8 00 19 00
	00		 imul	 edi, eax, 6400
  00037	81 c7 3c 00 00
	00		 add	 edi, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+60
  0003d	0f 1f 00	 npad	 3
$LL4@FindGroupM:

; 347  : 	{
; 348  : 		if ( TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iGroupNumber == iGroupNumber )

  00040	39 47 c8	 cmp	 DWORD PTR [edi-56], eax
  00043	0f 85 89 00 00
	00		 jne	 $LN2@FindGroupM

; 349  : 		{
; 350  : 			LPOBJ lpTargetObj = &gObj[TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iObjIndex];

  00049	69 37 40 27 00
	00		 imul	 esi, DWORD PTR [edi], 10048
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	03 f1		 add	 esi, ecx

; 351  : 
; 352  : 			if ( lpTargetObj == NULL )

  00057	74 76		 je	 SHORT $LN22@FindGroupM

; 353  : 				continue;
; 354  : 
; 355  : 			if ( gObjCalDistance(&gObj[iObjIndex], lpTargetObj) > iDistance )

  00059	69 45 08 40 27
	00 00		 imul	 eax, DWORD PTR _iObjIndex$[ebp], 10048
  00060	56		 push	 esi
  00061	03 c1		 add	 eax, ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00069	83 c4 08	 add	 esp, 8
  0006c	3b 45 14	 cmp	 eax, DWORD PTR _iDistance$[ebp]
  0006f	7f 5b		 jg	 SHORT $LN21@FindGroupM

; 356  : 				continue;
; 357  : 
; 358  : 			int iMaxLife = (int)(lpTargetObj->MaxLife + 1.0f);

  00071	f3 0f 10 86 dc
	00 00 00	 movss	 xmm0, DWORD PTR [esi+220]
  00079	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000

; 359  : 			int iPercentHP = (int)(lpTargetObj->Life * 100.0f / iMaxLife);

  00081	f3 0f 10 8e d8
	00 00 00	 movss	 xmm1, DWORD PTR [esi+216]
  00089	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42c80000
  00091	f3 0f 2c c0	 cvttss2si eax, xmm0
  00095	66 0f 6e c0	 movd	 xmm0, eax
  00099	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0009c	f3 0f 5e c8	 divss	 xmm1, xmm0
  000a0	f3 0f 2c c1	 cvttss2si eax, xmm1

; 360  : 
; 361  : 			if ( iPercentHP < 60 )

  000a4	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  000a7	7d 23		 jge	 SHORT $LN21@FindGroupM

; 362  : 			{
; 363  : 				if ( lpTargetObj->m_Index == iObjIndex )

  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _iObjIndex$[ebp]
  000ac	39 0e		 cmp	 DWORD PTR [esi], ecx
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	0f 44 c1	 cmove	 eax, ecx

; 364  : 					iPercentHP = 1;
; 365  : 
; 366  : 				if ( iPercentHP < iMinHP )

  000b6	3b 45 f8	 cmp	 eax, DWORD PTR _iMinHP$1$[ebp]
  000b9	7d 11		 jge	 SHORT $LN21@FindGroupM

; 367  : 				{
; 368  : 					iMinHP = iPercentHP;
; 369  : 					iMinHPGuid = lpTargetObj->m_iGroupMemberGuid;

  000bb	8b 8e e4 20 00
	00		 mov	 ecx, DWORD PTR [esi+8420]
  000c1	89 45 f8	 mov	 DWORD PTR _iMinHP$1$[ebp], eax
  000c4	8b 45 0c	 mov	 eax, DWORD PTR _iGroupNumber$[ebp]
  000c7	89 4d fc	 mov	 DWORD PTR _iMinHPGuid$1$[ebp], ecx
  000ca	eb 06		 jmp	 SHORT $LN2@FindGroupM
$LN21@FindGroupM:
  000cc	8b 45 0c	 mov	 eax, DWORD PTR _iGroupNumber$[ebp]
$LN22@FindGroupM:
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _iMinHPGuid$1$[ebp]
$LN2@FindGroupM:

; 344  : 	int iCount = TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber];
; 345  : 
; 346  : 	for ( int i=0;i<iCount;i++)

  000d2	83 c7 40	 add	 edi, 64			; 00000040H
  000d5	83 eb 01	 sub	 ebx, 1
  000d8	0f 85 62 ff ff
	ff		 jne	 $LL4@FindGroupM

; 370  : 				}
; 371  : 			}
; 372  : 		}
; 373  : 	}
; 374  : 
; 375  : 	if ( iMinHPGuid != -1 )

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	83 f9 ff	 cmp	 ecx, -1
  000e3	74 12		 je	 SHORT $LN12@FindGroupM

; 376  : 		return &TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iMinHPGuid];

  000e5	6b c0 64	 imul	 eax, eax, 100
  000e8	5b		 pop	 ebx
  000e9	03 c1		 add	 eax, ecx
  000eb	c1 e0 06	 shl	 eax, 6
  000ee	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A ; TMonsterAIGroup::s_MonsterAIGroupMemberArray

; 379  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
$LN12@FindGroupM:

; 377  : 	
; 378  : 	return NULL;

  000f7	33 c0		 xor	 eax, eax
  000f9	5b		 pop	 ebx

; 379  : }

  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z ENDP ; TMonsterAIGroup::FindGroupMemberToHeal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z
_TEXT	SEGMENT
_iObjIndex$ = 8						; size = 4
_iGroupNumber$ = 12					; size = 4
_iGuid$ = 16						; size = 4
?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z PROC ; TMonsterAIGroup::FindGroupMemberToSommon, COMDAT

; 384  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 385  : 	if ( TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber] == 0 )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iGroupNumber$[ebp]
  00007	57		 push	 edi
  00008	8b 3c b5 00 00
	00 00		 mov	 edi, DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[esi*4]
  0000f	85 ff		 test	 edi, edi
  00011	75 06		 jne	 SHORT $LN5@FindGroupM

; 386  : 		return NULL;

  00013	5f		 pop	 edi
  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 413  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN5@FindGroupM:

; 389  : 
; 390  : 	for ( int i=0;i<iCount;i++)

  00019	33 d2		 xor	 edx, edx
  0001b	53		 push	 ebx
  0001c	85 ff		 test	 edi, edi
  0001e	7e 3c		 jle	 SHORT $LN17@FindGroupM

; 387  : 
; 388  : 	int iCount = TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber];

  00020	8b 5d 08	 mov	 ebx, DWORD PTR _iObjIndex$[ebp]
  00023	69 ce 00 19 00
	00		 imul	 ecx, esi, 6400
  00029	81 c1 3c 00 00
	00		 add	 ecx, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+60
  0002f	90		 npad	 1
$LL4@FindGroupM:

; 391  : 	{
; 392  : 		if ( TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iGroupNumber == iGroupNumber )

  00030	39 71 c8	 cmp	 DWORD PTR [ecx-56], esi
  00033	75 1f		 jne	 SHORT $LN2@FindGroupM

; 393  : 		{
; 394  : 			LPOBJ lpTargetObj = &gObj[TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i].m_iObjIndex];

  00035	69 01 40 27 00
	00		 imul	 eax, DWORD PTR [ecx], 10048
  0003b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 395  : 
; 396  : 			if ( lpTargetObj->m_Index == iObjIndex )

  00041	39 18		 cmp	 DWORD PTR [eax], ebx
  00043	74 0f		 je	 SHORT $LN2@FindGroupM

; 397  : 				continue;
; 398  : 
; 399  : 			if ( lpTargetObj == NULL )
; 400  : 				continue;
; 401  : 
; 402  : 			if ( lpTargetObj->m_iRegenType == -1 )

  00045	83 b8 e8 20 00
	00 ff		 cmp	 DWORD PTR [eax+8424], -1
  0004c	74 06		 je	 SHORT $LN2@FindGroupM

; 403  : 				continue;
; 404  : 
; 405  : 			if ( lpTargetObj->Live == FALSE )

  0004e	80 78 51 00	 cmp	 BYTE PTR [eax+81], 0
  00052	74 0f		 je	 SHORT $LN13@FindGroupM
$LN2@FindGroupM:

; 389  : 
; 390  : 	for ( int i=0;i<iCount;i++)

  00054	42		 inc	 edx
  00055	83 c1 40	 add	 ecx, 64			; 00000040H
  00058	3b d7		 cmp	 edx, edi
  0005a	7c d4		 jl	 SHORT $LL4@FindGroupM
$LN17@FindGroupM:
  0005c	5b		 pop	 ebx
  0005d	5f		 pop	 edi

; 408  : 			}
; 409  : 		}
; 410  : 	}
; 411  : 
; 412  : 	return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	5e		 pop	 esi

; 413  : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN13@FindGroupM:

; 406  : 			{
; 407  : 				return &TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][i];

  00063	6b c6 64	 imul	 eax, esi, 100
  00066	5b		 pop	 ebx
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	03 c2		 add	 eax, edx
  0006b	c1 e0 06	 shl	 eax, 6
  0006e	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A ; TMonsterAIGroup::s_MonsterAIGroupMemberArray

; 413  : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z ENDP ; TMonsterAIGroup::FindGroupMemberToSommon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?FindGroupMember@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HH@Z
_TEXT	SEGMENT
_iGroupNumber$ = 8					; size = 4
_iGuid$ = 12						; size = 4
?FindGroupMember@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HH@Z PROC ; TMonsterAIGroup::FindGroupMember, COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 318  : 	if ( iGroupNumber < 0 || iGroupNumber >= MAX_MONSTER_AI_GROUP )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iGroupNumber$[ebp]
  00006	83 f9 31	 cmp	 ecx, 49			; 00000031H
  00009	77 37		 ja	 SHORT $LN3@FindGroupM

; 322  : 	}
; 323  : 
; 324  : 	if ( TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iGroupNumber == iGroupNumber &&

  0000b	8b 55 0c	 mov	 edx, DWORD PTR _iGuid$[ebp]
  0000e	6b c1 64	 imul	 eax, ecx, 100
  00011	03 c2		 add	 eax, edx
  00013	c1 e0 06	 shl	 eax, 6
  00016	39 88 04 00 00
	00		 cmp	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+4], ecx
  0001c	75 10		 jne	 SHORT $LN4@FindGroupM
  0001e	39 90 08 00 00
	00		 cmp	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+8], edx
  00024	75 08		 jne	 SHORT $LN4@FindGroupM

; 325  : 		 TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iGuid == iGuid )
; 326  : 	{
; 327  : 		return &TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid];

  00026	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax]

; 331  : 
; 332  : 	return NULL;
; 333  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN4@FindGroupM:

; 328  : 	}
; 329  : 
; 330  : 	LogAddTD("[Monster AI Group] FindGroupMember() Error - (GroupNumber=%d)(Guid=%d) ", iGroupNumber, iGuid);

  0002e	52		 push	 edx
  0002f	51		 push	 ecx
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PEHGDPOI@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	33 c0		 xor	 eax, eax

; 331  : 
; 332  : 	return NULL;
; 333  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN3@FindGroupM:

; 319  : 	{
; 320  : 		LogAddTD("[Monster AI Group] FindGroupMember() Error - (GroupNumber=%d)(Guid=%d) ", iGroupNumber, iGuid);

  00042	ff 75 0c	 push	 DWORD PTR _iGuid$[ebp]
  00045	51		 push	 ecx
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PEHGDPOI@?$FLMonster?5AI?5Group?$FN?5FindGroupMemb@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 321  : 		return NULL;

  00054	33 c0		 xor	 eax, eax

; 331  : 
; 332  : 	return NULL;
; 333  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?FindGroupMember@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HH@Z ENDP ; TMonsterAIGroup::FindGroupMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?ChangeAIOrder@TMonsterAIGroup@@SAXHH@Z
_TEXT	SEGMENT
_j$1$ = 8						; size = 4
_iGroupNumber$ = 8					; size = 4
_iAIOrder$ = 12						; size = 4
?ChangeAIOrder@TMonsterAIGroup@@SAXHH@Z PROC		; TMonsterAIGroup::ChangeAIOrder, COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 184  : 	if ( iGroupNumber < 0 || iGroupNumber >= MAX_MONSTER_AI_GROUP )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iGroupNumber$[ebp]
  00007	83 fb 31	 cmp	 ebx, 49			; 00000031H
  0000a	0f 87 df 00 00
	00		 ja	 $LN6@ChangeAIOr

; 187  : 		return;
; 188  : 	}
; 189  : 
; 190  : 	TMonsterAIGroupMember * lpMemb = NULL;
; 191  : 
; 192  : 	for ( int j=0;j<TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber];j++)

  00010	83 3c 9d 00 00
	00 00 00	 cmp	 DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[ebx*4], 0
  00018	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _j$1$[ebp], 0
  0001f	0f 8e d9 00 00
	00		 jle	 $LN3@ChangeAIOr
  00025	69 c3 00 19 00
	00		 imul	 eax, ebx, 6400
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	8b 7d 0c	 mov	 edi, DWORD PTR _iAIOrder$[ebp]
  00030	05 14 00 00 00	 add	 eax, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+20
  00035	33 c9		 xor	 ecx, ecx
$LL4@ChangeAIOr:

; 193  : 	{
; 194  : 		lpMemb = &TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][j];
; 195  : 
; 196  : 		if ( lpMemb->m_iGroupNumber == iGroupNumber )

  00037	39 58 f0	 cmp	 DWORD PTR [eax-16], ebx
  0003a	0f 85 96 00 00
	00		 jne	 $LN2@ChangeAIOr

; 197  : 		{
; 198  : 			if ( iAIOrder == 0 )

  00040	85 ff		 test	 edi, edi
  00042	75 1a		 jne	 SHORT $LN8@ChangeAIOr

; 199  : 			{
; 200  : 				gObj[lpMemb->m_iObjIndex].m_iBasicAI = lpMemb->m_iStartAI;

  00044	69 70 28 40 27
	00 00		 imul	 esi, DWORD PTR [eax+40], 10048
  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	8b 10		 mov	 edx, DWORD PTR [eax]
  00053	89 94 0e cc 20
	00 00		 mov	 DWORD PTR [esi+ecx+8396], edx

; 201  : 				gObj[lpMemb->m_iObjIndex].m_iCurrentAI = lpMemb->m_iStartAI;

  0005a	8b 10		 mov	 edx, DWORD PTR [eax]
  0005c	eb 61		 jmp	 SHORT $LN20@ChangeAIOr
$LN8@ChangeAIOr:

; 202  : 			}
; 203  : 			else if (iAIOrder == 1 )

  0005e	83 ff 01	 cmp	 edi, 1
  00061	75 1c		 jne	 SHORT $LN10@ChangeAIOr

; 204  : 			{
; 205  : 				gObj[lpMemb->m_iObjIndex].m_iBasicAI = lpMemb->m_iAI01;

  00063	69 70 28 40 27
	00 00		 imul	 esi, DWORD PTR [eax+40], 10048
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00073	89 94 0e cc 20
	00 00		 mov	 DWORD PTR [esi+ecx+8396], edx

; 206  : 				gObj[lpMemb->m_iObjIndex].m_iCurrentAI = lpMemb->m_iAI01;

  0007a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007d	eb 40		 jmp	 SHORT $LN20@ChangeAIOr
$LN10@ChangeAIOr:

; 207  : 			}
; 208  : 			else if (iAIOrder == 2 )

  0007f	83 ff 02	 cmp	 edi, 2
  00082	75 1c		 jne	 SHORT $LN12@ChangeAIOr

; 209  : 			{
; 210  : 				gObj[lpMemb->m_iObjIndex].m_iBasicAI = lpMemb->m_iAI02;

  00084	69 70 28 40 27
	00 00		 imul	 esi, DWORD PTR [eax+40], 10048
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00091	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00094	89 94 0e cc 20
	00 00		 mov	 DWORD PTR [esi+ecx+8396], edx

; 211  : 				gObj[lpMemb->m_iObjIndex].m_iCurrentAI = lpMemb->m_iAI02;

  0009b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0009e	eb 1f		 jmp	 SHORT $LN20@ChangeAIOr
$LN12@ChangeAIOr:

; 212  : 			}
; 213  : 			else if (iAIOrder == 3 )

  000a0	83 ff 03	 cmp	 edi, 3
  000a3	75 31		 jne	 SHORT $LN2@ChangeAIOr

; 214  : 			{
; 215  : 				gObj[lpMemb->m_iObjIndex].m_iBasicAI = lpMemb->m_iAI03;

  000a5	69 70 28 40 27
	00 00		 imul	 esi, DWORD PTR [eax+40], 10048
  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b2	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000b5	89 94 0e cc 20
	00 00		 mov	 DWORD PTR [esi+ecx+8396], edx

; 216  : 				gObj[lpMemb->m_iObjIndex].m_iCurrentAI = lpMemb->m_iAI03;

  000bc	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
$LN20@ChangeAIOr:
  000bf	69 70 28 40 27
	00 00		 imul	 esi, DWORD PTR [eax+40], 10048
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cc	89 94 0e d0 20
	00 00		 mov	 DWORD PTR [esi+ecx+8400], edx
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _j$1$[ebp]
$LN2@ChangeAIOr:

; 187  : 		return;
; 188  : 	}
; 189  : 
; 190  : 	TMonsterAIGroupMember * lpMemb = NULL;
; 191  : 
; 192  : 	for ( int j=0;j<TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber];j++)

  000d6	41		 inc	 ecx
  000d7	83 c0 40	 add	 eax, 64			; 00000040H
  000da	89 4d 08	 mov	 DWORD PTR _j$1$[ebp], ecx
  000dd	3b 0c 9d 00 00
	00 00		 cmp	 ecx, DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[ebx*4]
  000e4	0f 8c 4d ff ff
	ff		 jl	 $LL4@ChangeAIOr
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx

; 217  : 			}
; 218  : 		}		
; 219  : 	}
; 220  : }

  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN6@ChangeAIOr:

; 185  : 	{
; 186  : 		LogAddTD("[Monster AI Group] ChangeAIOrder() Error - (GroupNumber=%d)", iGroupNumber);

  000ef	53		 push	 ebx
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BFBHLGFI@?$FLMonster?5AI?5Group?$FN?5ChangeAIOrder@
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fb	83 c4 08	 add	 esp, 8
$LN3@ChangeAIOr:
  000fe	5b		 pop	 ebx

; 217  : 			}
; 218  : 		}		
; 219  : 	}
; 220  : }

  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
?ChangeAIOrder@TMonsterAIGroup@@SAXHH@Z ENDP		; TMonsterAIGroup::ChangeAIOrder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?DelGroupInstance@TMonsterAIGroup@@SAHH@Z
_TEXT	SEGMENT
_iGroupNumber$ = 8					; size = 4
?DelGroupInstance@TMonsterAIGroup@@SAHH@Z PROC		; TMonsterAIGroup::DelGroupInstance, COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 227  : 	if ( iGroupNumber < 0 || iGroupNumber >= MAX_MONSTER_AI_GROUP )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iGroupNumber$[ebp]
  00007	83 ff 31	 cmp	 edi, 49			; 00000031H
  0000a	77 42		 ja	 SHORT $LN6@DelGroupIn

; 231  : 	}
; 232  : 
; 233  : 	TMonsterAIGroupMember * lpMemb = NULL;
; 234  : 
; 235  : 	for ( int j=0;j<TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber];j++)

  0000c	53		 push	 ebx
  0000d	33 db		 xor	 ebx, ebx
  0000f	39 1c bd 00 00
	00 00		 cmp	 DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[edi*4], ebx
  00016	7e 30		 jle	 SHORT $LN3@DelGroupIn
  00018	56		 push	 esi
  00019	69 f7 00 19 00
	00		 imul	 esi, edi, 6400
  0001f	81 c6 3c 00 00
	00		 add	 esi, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+60
$LL4@DelGroupIn:

; 236  : 	{
; 237  : 		lpMemb = &TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][j];
; 238  : 
; 239  : 		if ( lpMemb->m_iGroupNumber == iGroupNumber )

  00025	39 7e c8	 cmp	 DWORD PTR [esi-56], edi
  00028	75 10		 jne	 SHORT $LN2@DelGroupIn

; 240  : 		{
; 241  : 			if ( lpMemb->m_iObjIndex != -1 )

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	83 f8 ff	 cmp	 eax, -1
  0002f	74 09		 je	 SHORT $LN2@DelGroupIn

; 242  : 			{
; 243  : 				gObjDel(lpMemb->m_iObjIndex);

  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00037	83 c4 04	 add	 esp, 4
$LN2@DelGroupIn:

; 231  : 	}
; 232  : 
; 233  : 	TMonsterAIGroupMember * lpMemb = NULL;
; 234  : 
; 235  : 	for ( int j=0;j<TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber];j++)

  0003a	43		 inc	 ebx
  0003b	83 c6 40	 add	 esi, 64			; 00000040H
  0003e	3b 1c bd 00 00
	00 00		 cmp	 ebx, DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[edi*4]
  00045	7c de		 jl	 SHORT $LL4@DelGroupIn
  00047	5e		 pop	 esi
$LN3@DelGroupIn:
  00048	5b		 pop	 ebx

; 230  : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	5f		 pop	 edi

; 244  : 			}
; 245  : 		}
; 246  : 	}
; 247  : 
; 248  : 	return FALSE;
; 249  : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN6@DelGroupIn:

; 228  : 	{
; 229  : 		LogAddTD("[Monster AI Group] DelGroup() Error - (GroupNumber=%d)", iGroupNumber);

  0004e	57		 push	 edi
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@OJFKHKGJ@?$FLMonster?5AI?5Group?$FN?5DelGroup?$CI?$CJ?5Er@
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0005a	83 c4 08	 add	 esp, 8

; 230  : 		return FALSE;

  0005d	33 c0		 xor	 eax, eax
  0005f	5f		 pop	 edi

; 244  : 			}
; 245  : 		}
; 246  : 	}
; 247  : 
; 248  : 	return FALSE;
; 249  : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?DelGroupInstance@TMonsterAIGroup@@SAHH@Z ENDP		; TMonsterAIGroup::DelGroupInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?DelAllGroupInfo@TMonsterAIGroup@@SAHXZ
_TEXT	SEGMENT
?DelAllGroupInfo@TMonsterAIGroup@@SAHXZ PROC		; TMonsterAIGroup::DelAllGroupInfo, COMDAT

; 256  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 257  : 	for ( int i=0;i<MAX_MONSTER_AI_GROUP;i++)

  00003	bb 00 00 00 00	 mov	 ebx, OFFSET ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA ; TMonsterAIGroup::s_iMonsterAIGroupMemberCount
  00008	be 00 00 00 00	 mov	 esi, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A ; TMonsterAIGroup::s_MonsterAIGroupMemberArray
  0000d	0f 1f 00	 npad	 3
$LL4@DelAllGrou:

; 258  : 	{
; 259  : 		for ( int j=0;j<MAX_MONSTER_AI_GROUP_MEMBER;j++)

  00010	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
$LL7@DelAllGrou:

; 260  : 		{
; 261  : 			TMonsterAIGroup::s_MonsterAIGroupMemberArray[i][j].Reset();

  00015	8b ce		 mov	 ecx, esi
  00017	e8 00 00 00 00	 call	 ?Reset@TMonsterAIGroupMember@@QAEXXZ ; TMonsterAIGroupMember::Reset
  0001c	83 c6 40	 add	 esi, 64			; 00000040H
  0001f	83 ef 01	 sub	 edi, 1
  00022	75 f1		 jne	 SHORT $LL7@DelAllGrou

; 262  : 		}
; 263  : 
; 264  : 		TMonsterAIGroup::s_iMonsterAIGroupMemberCount[i] = 0;

  00024	89 3b		 mov	 DWORD PTR [ebx], edi
  00026	83 c3 04	 add	 ebx, 4
  00029	81 fe 00 e2 04
	00		 cmp	 esi, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+320000
  0002f	7c df		 jl	 SHORT $LL4@DelAllGrou

; 265  : 	}
; 266  : 
; 267  : 	TMonsterAIGroup::s_bDataLoad = FALSE;

  00031	89 3d 00 00 00
	00		 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIGroup@@2HA, edi ; TMonsterAIGroup::s_bDataLoad

; 268  : 	return FALSE;

  00037	33 c0		 xor	 eax, eax
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 269  : }

  0003c	c3		 ret	 0
?DelAllGroupInfo@TMonsterAIGroup@@SAHXZ ENDP		; TMonsterAIGroup::DelAllGroupInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?LoadData@TMonsterAIGroup@@SAHPAD@Z
_TEXT	SEGMENT
_iStartDir$1$ = -60					; size = 4
_iStartY$1$ = -56					; size = 4
_iStartX$1$ = -52					; size = 4
_iMapNumber$1$ = -48					; size = 4
_iCreateType$1$ = -44					; size = 4
_iAI03$1$ = -40						; size = 4
_iAI02$1$ = -36						; size = 4
_iAI01$1$ = -32						; size = 4
_iStartAI$1$ = -28					; size = 4
_iRank$1$ = -24						; size = 4
_iType$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterAIGroup@@SAHPAD@Z PROC		; TMonsterAIGroup::LoadData, COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterAIGroup@@SAHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 36   : 	TMonsterAIGroup::s_bDataLoad = FALSE;
; 37   : 
; 38   : 	if ( !lpszFileName || !strcmp(lpszFileName, ""))

  0002b	8b 5d 08	 mov	 ebx, DWORD PTR _lpszFileName$[ebp]
  0002e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIGroup@@2HA, 0 ; TMonsterAIGroup::s_bDataLoad
  00038	85 db		 test	 ebx, ebx
  0003a	0f 84 b0 02 00
	00		 je	 $LN7@LoadData
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00045	8b c3		 mov	 eax, ebx
$LL34@LoadData:
  00047	8a 10		 mov	 dl, BYTE PTR [eax]
  00049	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0004b	75 1a		 jne	 SHORT $LN35@LoadData
  0004d	84 d2		 test	 dl, dl
  0004f	74 12		 je	 SHORT $LN36@LoadData
  00051	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00054	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00057	75 0e		 jne	 SHORT $LN35@LoadData
  00059	83 c0 02	 add	 eax, 2
  0005c	83 c1 02	 add	 ecx, 2
  0005f	84 d2		 test	 dl, dl
  00061	75 e4		 jne	 SHORT $LL34@LoadData
$LN36@LoadData:
  00063	33 c0		 xor	 eax, eax
  00065	eb 05		 jmp	 SHORT $LN37@LoadData
$LN35@LoadData:
  00067	1b c0		 sbb	 eax, eax
  00069	83 c8 01	 or	 eax, 1
$LN37@LoadData:
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 7c 02 00
	00		 je	 $LN7@LoadData

; 42   : 	}
; 43   : 
; 44   : 	try
; 45   : 	{
; 46   : 		SMDToken Token;
; 47   : 		SMDFile = fopen(lpszFileName, "r");

  00074	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00079	53		 push	 ebx
  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00081	e8 00 00 00 00	 call	 _fopen
  00086	83 c4 08	 add	 esp, 8
  00089	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 48   : 
; 49   : 		if ( SMDFile == NULL )

  0008e	85 c0		 test	 eax, eax
  00090	75 22		 jne	 SHORT $LL2@LoadData

; 50   : 		{
; 51   : 			MsgBox("[Monster AI Group] - Can't Open %s ", lpszFileName);

  00092	53		 push	 ebx
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LNCDKEDF@?$FLMonster?5AI?5Group?$FN?5?9?5Can?8t?5Open?5@
  00098	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0009d	83 c4 08	 add	 esp, 8
  000a0	33 c0		 xor	 eax, eax

; 175  : 
; 176  : 	return FALSE;
; 177  : }

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LL2@LoadData:

; 52   : 			return FALSE;
; 53   : 		}
; 54   : 
; 55   : 		int iType = -1;
; 56   : 
; 57   : 		while ( true )
; 58   : 		{
; 59   : 			Token = GetToken();

  000b4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 60   : 
; 61   : 			if ( Token == END )

  000b9	83 f8 02	 cmp	 eax, 2
  000bc	75 3a		 jne	 SHORT $LN10@LoadData

; 163  : 		}	// while ( true )
; 164  : 
; 165  : 		fclose(SMDFile);

  000be	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000c4	e8 00 00 00 00	 call	 _fclose

; 166  : 
; 167  : 		LogAddC(2, "[Monster AI Group ] - %s file is Loaded", lpszFileName);

  000c9	53		 push	 ebx
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CJPFLHBA@?$FLMonster?5AI?5Group?5?$FN?5?9?5?$CFs?5file?5is@
  000cf	6a 02		 push	 2
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000d7	83 c4 10	 add	 esp, 16			; 00000010H

; 168  : 
; 169  : 		TMonsterAIGroup::s_bDataLoad = TRUE;

  000da	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIGroup@@2HA, 1 ; TMonsterAIGroup::s_bDataLoad
  000e4	33 c0		 xor	 eax, eax

; 175  : 
; 176  : 	return FALSE;
; 177  : }

  000e6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f0	59		 pop	 ecx
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN10@LoadData:

; 62   : 				break;
; 63   : 
; 64   : 			iType = (int)TokenNumber;

  000f8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00100	89 45 ec	 mov	 DWORD PTR _iType$1$[ebp], eax
$LL4@LoadData:

; 65   : 
; 66   : 			while ( true )
; 67   : 			{
; 68   : 				if ( iType == 0 )

  00103	85 c0		 test	 eax, eax
  00105	75 fc		 jne	 SHORT $LL4@LoadData

; 69   : 				{
; 70   : 					int iGroupNumber = -1;
; 71   : 					int iGuid = -1;
; 72   : 					int iClass = -1;
; 73   : 					int iRank = -1;
; 74   : 					int iStartAI = 0;
; 75   : 					int iAI01 = 0;
; 76   : 					int iAI02 = 0;
; 77   : 					int iAI03 = 0;
; 78   : 					int iCreateType = -1;
; 79   : 					int iMapNumber = -1;
; 80   : 					int iStartX = -1;
; 81   : 					int iStartY = -1;
; 82   : 					int iStartDir = -1;
; 83   : 					int iRegenType = -1;
; 84   : 
; 85   : 					Token = GetToken();

  00107	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 86   : 
; 87   : 					if ( !strcmp("end", TokenString))

  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  00111	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL38@LoadData:
  00116	8a 10		 mov	 dl, BYTE PTR [eax]
  00118	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0011a	75 1a		 jne	 SHORT $LN39@LoadData
  0011c	84 d2		 test	 dl, dl
  0011e	74 12		 je	 SHORT $LN40@LoadData
  00120	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00123	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00126	75 0e		 jne	 SHORT $LN39@LoadData
  00128	83 c0 02	 add	 eax, 2
  0012b	83 c1 02	 add	 ecx, 2
  0012e	84 d2		 test	 dl, dl
  00130	75 e4		 jne	 SHORT $LL38@LoadData
$LN40@LoadData:
  00132	33 c0		 xor	 eax, eax
  00134	eb 05		 jmp	 SHORT $LN41@LoadData
$LN39@LoadData:
  00136	1b c0		 sbb	 eax, eax
  00138	83 c8 01	 or	 eax, 1
$LN41@LoadData:
  0013b	85 c0		 test	 eax, eax
  0013d	0f 84 a5 01 00
	00		 je	 $LN33@LoadData

; 88   : 						break;
; 89   : 
; 90   : 					iGroupNumber = (int)TokenNumber;

  00143	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 91   : 
; 92   : 					Token = GetToken();

  0014b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 93   : 					iGuid = (int)TokenNumber;

  00150	f3 0f 2c 3d 00
	00 00 00	 cvttss2si edi, DWORD PTR ?TokenNumber@@3MA

; 94   : 
; 95   : 					Token = GetToken();

  00158	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 96   : 					iClass = (int)TokenNumber;

  0015d	f3 0f 2c 1d 00
	00 00 00	 cvttss2si ebx, DWORD PTR ?TokenNumber@@3MA

; 97   : 
; 98   : 					Token = GetToken();

  00165	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 99   : 					iRank = (int)TokenNumber;

  0016a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00172	89 45 e8	 mov	 DWORD PTR _iRank$1$[ebp], eax

; 100  : 
; 101  : 					Token = GetToken();

  00175	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 102  : 					iStartAI = (int)TokenNumber;

  0017a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00182	89 45 e4	 mov	 DWORD PTR _iStartAI$1$[ebp], eax

; 103  : 
; 104  : 					Token = GetToken();

  00185	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 105  : 					iAI01 = (int)TokenNumber;

  0018a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00192	89 45 e0	 mov	 DWORD PTR _iAI01$1$[ebp], eax

; 106  : 
; 107  : 					Token = GetToken();

  00195	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 108  : 					iAI02 = (int)TokenNumber;

  0019a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001a2	89 45 dc	 mov	 DWORD PTR _iAI02$1$[ebp], eax

; 109  : 
; 110  : 					Token = GetToken();

  001a5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 111  : 					iAI03 = (int)TokenNumber;

  001aa	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001b2	89 45 d8	 mov	 DWORD PTR _iAI03$1$[ebp], eax

; 112  : 
; 113  : 					Token = GetToken();

  001b5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 114  : 					iCreateType = (int)TokenNumber;

  001ba	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001c2	89 45 d4	 mov	 DWORD PTR _iCreateType$1$[ebp], eax

; 115  : 
; 116  : 					Token = GetToken();

  001c5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 117  : 					iMapNumber = (int)TokenNumber;

  001ca	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001d2	89 45 d0	 mov	 DWORD PTR _iMapNumber$1$[ebp], eax

; 118  : 
; 119  : 					Token = GetToken();

  001d5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 120  : 					iStartX = (int)TokenNumber;

  001da	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001e2	89 45 cc	 mov	 DWORD PTR _iStartX$1$[ebp], eax

; 121  : 
; 122  : 					Token = GetToken();

  001e5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 123  : 					iStartY = (int)TokenNumber;

  001ea	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001f2	89 45 c8	 mov	 DWORD PTR _iStartY$1$[ebp], eax

; 124  : 
; 125  : 					Token = GetToken();

  001f5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 126  : 					iStartDir = (int)TokenNumber;

  001fa	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00202	89 45 c4	 mov	 DWORD PTR _iStartDir$1$[ebp], eax

; 127  : 
; 128  : 					Token = GetToken();

  00205	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 129  : 					iRegenType = (int)TokenNumber;

  0020a	f3 0f 2c 15 00
	00 00 00	 cvttss2si edx, DWORD PTR ?TokenNumber@@3MA

; 130  : 
; 131  : 					if ( iGroupNumber > MAX_MONSTER_AI_GROUP )

  00212	83 fe 32	 cmp	 esi, 50			; 00000032H
  00215	7e 16		 jle	 SHORT $LN13@LoadData

; 132  : 					{
; 133  : 						MsgBox("[Monster AI Group] Exceed Max GroupNumber %d",

  00217	56		 push	 esi
  00218	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CNMPNCB@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@
  0021d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 134  : 							iGroupNumber);
; 135  : 						continue;

  00222	8b 45 ec	 mov	 eax, DWORD PTR _iType$1$[ebp]
  00225	83 c4 08	 add	 esp, 8
  00228	e9 d6 fe ff ff	 jmp	 $LL4@LoadData
$LN13@LoadData:

; 136  : 					}
; 137  : 
; 138  : 					if ( iGuid > MAX_MONSTER_AI_GROUP_MEMBER)

  0022d	83 ff 64	 cmp	 edi, 100		; 00000064H
  00230	7e 2d		 jle	 SHORT $LN14@LoadData

; 139  : 					{
; 140  : 						MsgBox("[Monster AI Group] Exceed Max GroupMember %d, %d ",

  00232	57		 push	 edi
  00233	56		 push	 esi
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LFNOMCBG@?$FLMonster?5AI?5Group?$FN?5Exceed?5Max?5Gr@
  00239	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 141  : 							iGroupNumber, iGuid);
; 142  : 						continue;

  0023e	8b 45 ec	 mov	 eax, DWORD PTR _iType$1$[ebp]
  00241	83 c4 0c	 add	 esp, 12			; 0000000cH
  00244	e9 ba fe ff ff	 jmp	 $LL4@LoadData
__catch$?LoadData@TMonsterAIGroup@@SAHPAD@Z$0:

; 170  : 	}
; 171  : 	catch ( DWORD )
; 172  : 	{
; 173  : 		MsgBox("[Monster AI Group] - Loading Exception Error (%s) File. ", lpszFileName);

  00249	ff 75 08	 push	 DWORD PTR _lpszFileName$[ebp]
  0024c	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@HODFGLNJ@?$FLMonster?5AI?5Group?$FN?5?9?5Loading?5Exc@
  00251	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00256	83 c4 08	 add	 esp, 8

; 174  : 	}

  00259	b8 00 00 00 00	 mov	 eax, $LN49@LoadData
  0025e	c3		 ret	 0
$LN14@LoadData:

; 143  : 					}
; 144  : 
; 145  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iGroupNumber = iGroupNumber;

  0025f	8b 4d e8	 mov	 ecx, DWORD PTR _iRank$1$[ebp]
  00262	6b c6 64	 imul	 eax, esi, 100
  00265	03 c7		 add	 eax, edi
  00267	c1 e0 06	 shl	 eax, 6

; 146  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iGuid = iGuid;
; 147  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iClass = iClass;
; 148  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iRank = iRank;
; 149  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iStartAI = iStartAI;
; 150  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iAI01 = iAI01;
; 151  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iAI02 = iAI02;
; 152  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iAI03 = iAI03;
; 153  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iCreateType = iCreateType;
; 154  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iMapNumber = iMapNumber;
; 155  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iStartX = iStartX;
; 156  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iStartY = iStartY;
; 157  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iStartDir = iStartDir;
; 158  : 					TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][iGuid].m_iRegenType = iRegenType;
; 159  : 					
; 160  : 					TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber]++;

  0026a	ff 04 b5 00 00
	00 00		 inc	 DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[esi*4]
  00271	89 88 10 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+16], ecx
  00277	8b 4d e4	 mov	 ecx, DWORD PTR _iStartAI$1$[ebp]
  0027a	89 88 14 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+20], ecx
  00280	8b 4d e0	 mov	 ecx, DWORD PTR _iAI01$1$[ebp]
  00283	89 88 18 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+24], ecx
  00289	8b 4d dc	 mov	 ecx, DWORD PTR _iAI02$1$[ebp]
  0028c	89 88 1c 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+28], ecx
  00292	8b 4d d8	 mov	 ecx, DWORD PTR _iAI03$1$[ebp]
  00295	89 88 20 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+32], ecx
  0029b	8b 4d d4	 mov	 ecx, DWORD PTR _iCreateType$1$[ebp]
  0029e	89 88 24 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+36], ecx
  002a4	8b 4d d0	 mov	 ecx, DWORD PTR _iMapNumber$1$[ebp]
  002a7	89 88 28 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+40], ecx
  002ad	8b 4d cc	 mov	 ecx, DWORD PTR _iStartX$1$[ebp]
  002b0	89 88 2c 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+44], ecx
  002b6	8b 4d c8	 mov	 ecx, DWORD PTR _iStartY$1$[ebp]
  002b9	89 88 30 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+48], ecx
  002bf	8b 4d c4	 mov	 ecx, DWORD PTR _iStartDir$1$[ebp]
  002c2	89 b0 04 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+4], esi
  002c8	89 b8 08 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+8], edi
  002ce	89 98 0c 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+12], ebx
  002d4	89 88 34 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+52], ecx
  002da	89 90 38 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A[eax+56], edx

; 161  : 				}
; 162  : 			}

  002e0	8b 45 ec	 mov	 eax, DWORD PTR _iType$1$[ebp]
  002e3	e9 1b fe ff ff	 jmp	 $LL4@LoadData
$LN33@LoadData:
  002e8	8b 5d 08	 mov	 ebx, DWORD PTR _lpszFileName$[ebp]
  002eb	e9 c4 fd ff ff	 jmp	 $LL2@LoadData
$LN7@LoadData:

; 39   : 	{
; 40   : 		MsgBox("[Monster AI Group] - File load error : File Name Error");

  002f0	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@EJJEEGKC@?$FLMonster?5AI?5Group?$FN?5?9?5File?5load?5e@
  002f5	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002fa	83 c4 04	 add	 esp, 4
$LN49@LoadData:

; 41   : 		return FALSE;

  002fd	33 c0		 xor	 eax, eax

; 175  : 
; 176  : 	return FALSE;
; 177  : }

  002ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00302	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00309	59		 pop	 ecx
  0030a	5f		 pop	 edi
  0030b	5e		 pop	 esi
  0030c	5b		 pop	 ebx
  0030d	8b e5		 mov	 esp, ebp
  0030f	5d		 pop	 ebp
  00310	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterAIGroup@@SAHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterAIGroup@@SAHPAD@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterAIGroup@@SAHPAD@Z ENDP		; TMonsterAIGroup::LoadData
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?InitAll@TMonsterAIGroup@@SAXXZ
_TEXT	SEGMENT
?InitAll@TMonsterAIGroup@@SAXXZ PROC			; TMonsterAIGroup::InitAll, COMDAT

; 418  : {

  00000	56		 push	 esi

; 419  : 	for ( int i=0;i<MAX_MONSTER_AI_GROUP;i++)

  00001	33 f6		 xor	 esi, esi
$LL4@InitAll:

; 420  : 	{
; 421  : 		if ( TMonsterAIGroup::s_iMonsterAIGroupMemberCount[i] == 0 )

  00003	83 3c b5 00 00
	00 00 00	 cmp	 DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[esi*4], 0
  0000b	74 09		 je	 SHORT $LN2@InitAll

; 422  : 			continue;
; 423  : 
; 424  : 		TMonsterAIGroup::Init(i);

  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 ?Init@TMonsterAIGroup@@SAXH@Z ; TMonsterAIGroup::Init
  00013	83 c4 04	 add	 esp, 4
$LN2@InitAll:

; 419  : 	for ( int i=0;i<MAX_MONSTER_AI_GROUP;i++)

  00016	46		 inc	 esi
  00017	83 fe 32	 cmp	 esi, 50			; 00000032H
  0001a	7c e7		 jl	 SHORT $LL4@InitAll
  0001c	5e		 pop	 esi

; 425  : 	}
; 426  : }

  0001d	c3		 ret	 0
?InitAll@TMonsterAIGroup@@SAXXZ ENDP			; TMonsterAIGroup::InitAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?Init@TMonsterAIGroup@@SAXH@Z
_TEXT	SEGMENT
_iCount$1$ = -16					; size = 4
tv735 = -12						; size = 4
_iResult$1$ = -8					; size = 4
tv743 = -4						; size = 4
_j$1$ = 8						; size = 4
_iGroupNumber$ = 8					; size = 4
_cY$1 = 11						; size = 1
_cX$2 = 11						; size = 1
?Init@TMonsterAIGroup@@SAXH@Z PROC			; TMonsterAIGroup::Init, COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 432  : 	if ( TMonsterAIGroup::s_iMonsterAIGroupMemberCount[iGroupNumber] == 0 )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iGroupNumber$[ebp]
  0000a	83 3c b5 00 00
	00 00 00	 cmp	 DWORD PTR ?s_iMonsterAIGroupMemberCount@TMonsterAIGroup@@2PAHA[esi*4], 0
  00012	0f 84 89 01 00
	00		 je	 $LN3@Init

; 433  : 		return;
; 434  : 
; 435  : 	TMonsterAIGroup::DelGroupInstance(iGroupNumber);

  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?DelGroupInstance@TMonsterAIGroup@@SAHH@Z ; TMonsterAIGroup::DelGroupInstance
  0001f	69 f6 00 19 00
	00		 imul	 esi, esi, 6400
  00025	83 c4 04	 add	 esp, 4

; 436  : 
; 437  : 	for ( int j=0;j<MAX_MONSTER_AI_GROUP_MEMBER;j++)

  00028	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _j$1$[ebp], 0
  0002f	8a 45 0b	 mov	 al, BYTE PTR _cY$1[ebp]
  00032	8a 5d 0b	 mov	 bl, BYTE PTR _cX$2[ebp]
  00035	89 45 fc	 mov	 DWORD PTR tv743[ebp], eax
  00038	81 c6 14 00 00
	00		 add	 esi, OFFSET ?s_MonsterAIGroupMemberArray@TMonsterAIGroup@@2PAY0GE@VTMonsterAIGroupMember@@A+20
  0003e	33 c0		 xor	 eax, eax
  00040	57		 push	 edi
$LL4@Init:

; 438  : 	{
; 439  : 		TMonsterAIGroupMember & Memb = TMonsterAIGroup::s_MonsterAIGroupMemberArray[iGroupNumber][j];
; 440  : 
; 441  : 		if ( Memb.m_iGuid == -1 )

  00041	83 7e f4 ff	 cmp	 DWORD PTR [esi-12], -1
  00045	0f 84 c7 02 00
	00		 je	 $LN2@Init

; 442  : 			continue;
; 443  : 
; 444  : 		int iResult = gObjAddMonster(Memb.m_iMapNumber);

  0004b	ff 76 14	 push	 DWORD PTR [esi+20]
  0004e	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00053	98		 cwde
  00054	83 c4 04	 add	 esp, 4
  00057	89 45 f8	 mov	 DWORD PTR _iResult$1$[ebp], eax

; 445  : 
; 446  : 		if ( iResult >= 0 )

  0005a	85 c0		 test	 eax, eax
  0005c	0f 88 ad 02 00
	00		 js	 $LN31@Init

; 447  : 		{
; 448  : 			gObj[iResult].m_PosNum = -1;

  00062	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  00068	83 c9 ff	 or	 ecx, -1
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	66 89 8c 07 98
	05 00 00	 mov	 WORD PTR [edi+eax+1432], cx

; 449  : 			gObj[iResult].MapNumber = Memb.m_iMapNumber;

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007d	8a 4e 14	 mov	 cl, BYTE PTR [esi+20]
  00080	88 8c 07 23 01
	00 00		 mov	 BYTE PTR [edi+eax+291], cl

; 450  : 			gObj[iResult].Live = TRUE;

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008c	c6 44 07 51 01	 mov	 BYTE PTR [edi+eax+81], 1

; 451  : 
; 452  : 			gObjViewportListProtocolDestroy(&gObj[iResult]);

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00096	03 c7		 add	 eax, edi
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy

; 453  : 			gObjViewportClose(&gObj[iResult]);

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a3	03 c7		 add	 eax, edi
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose

; 454  : 
; 455  : 			BYTE cX;
; 456  : 			BYTE cY;
; 457  : 
; 458  : 			if ( Memb.m_iCreateType == 1 )

  000ab	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ae	83 c4 08	 add	 esp, 8
  000b1	83 f8 01	 cmp	 eax, 1
  000b4	0f 85 ec 00 00
	00		 jne	 $LN10@Init

; 459  : 			{
; 460  : 				int iRadius = 10;
; 461  : 				BOOL bGetPosition = FALSE;
; 462  : 				int iCount = 100;

  000ba	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000bf	90		 npad	 1
$LL5@Init:

; 463  : 
; 464  : 				while ( iCount-- != 0 )

  000c0	48		 dec	 eax
  000c1	89 45 f0	 mov	 DWORD PTR _iCount$1$[ebp], eax

; 465  : 				{
; 466  : 					cX = ( rand() % (iRadius+1) ) * (((rand()%2==0)?-1:1)) + Memb.m_iStartX;

  000c4	e8 00 00 00 00	 call	 _rand
  000c9	99		 cdq
  000ca	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000cf	f7 f9		 idiv	 ecx
  000d1	8b da		 mov	 ebx, edx
  000d3	e8 00 00 00 00	 call	 _rand
  000d8	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000dd	79 05		 jns	 SHORT $LN34@Init
  000df	48		 dec	 eax
  000e0	83 c8 fe	 or	 eax, -2			; fffffffeH
  000e3	40		 inc	 eax
$LN34@Init:
  000e4	f7 d8		 neg	 eax
  000e6	0f b6 cb	 movzx	 ecx, bl
  000e9	1a c0		 sbb	 al, al
  000eb	24 02		 and	 al, 2
  000ed	fe c8		 dec	 al
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	0f af c1	 imul	 eax, ecx
  000f5	02 46 18	 add	 al, BYTE PTR [esi+24]
  000f8	89 45 f4	 mov	 DWORD PTR tv735[ebp], eax

; 467  : 					cY = ( rand() % (iRadius+1) ) * (((rand()%2==0)?-1:1)) + Memb.m_iStartY;

  000fb	e8 00 00 00 00	 call	 _rand
  00100	99		 cdq
  00101	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00106	f7 f9		 idiv	 ecx
  00108	8b da		 mov	 ebx, edx
  0010a	e8 00 00 00 00	 call	 _rand
  0010f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00114	79 05		 jns	 SHORT $LN35@Init
  00116	48		 dec	 eax
  00117	83 c8 fe	 or	 eax, -2			; fffffffeH
  0011a	40		 inc	 eax
$LN35@Init:
  0011b	f7 d8		 neg	 eax
  0011d	0f b6 cb	 movzx	 ecx, bl

; 468  : 
; 469  : 					BYTE btMapAttr = MapC[Memb.m_iMapNumber].GetAttr(cX, cY);

  00120	8b 5d f4	 mov	 ebx, DWORD PTR tv735[ebp]
  00123	1a c0		 sbb	 al, al
  00125	24 02		 and	 al, 2
  00127	fe c8		 dec	 al
  00129	0f b6 c0	 movzx	 eax, al
  0012c	0f af c1	 imul	 eax, ecx
  0012f	69 4e 14 28 38
	05 00		 imul	 ecx, DWORD PTR [esi+20], 342056
  00136	02 46 1c	 add	 al, BYTE PTR [esi+28]
  00139	89 45 fc	 mov	 DWORD PTR tv743[ebp], eax
  0013c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00142	0f b6 c0	 movzx	 eax, al
  00145	50		 push	 eax
  00146	0f b6 c3	 movzx	 eax, bl
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 470  : 
; 471  : 					if ( btMapAttr == 0 )

  0014f	84 c0		 test	 al, al
  00151	74 60		 je	 SHORT $LN14@Init

; 463  : 
; 464  : 				while ( iCount-- != 0 )

  00153	8b 45 f0	 mov	 eax, DWORD PTR _iCount$1$[ebp]
  00156	85 c0		 test	 eax, eax
  00158	0f 85 62 ff ff
	ff		 jne	 $LL5@Init

; 472  : 					{
; 473  : 						bGetPosition = TRUE;
; 474  : 						break;
; 475  : 					}
; 476  : 				}
; 477  : 
; 478  : 				if ( bGetPosition == FALSE )
; 479  : 				{
; 480  : 					gObj[iResult].Live = FALSE;

  0015e	69 75 f8 40 27
	00 00		 imul	 esi, DWORD PTR _iResult$1$[ebp], 10048
  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016a	c6 44 06 51 00	 mov	 BYTE PTR [esi+eax+81], 0

; 481  : 					gObj[iResult].m_State = 4;

  0016f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00174	c7 84 06 d0 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [esi+eax+464], 4

; 482  : 					gObj[iResult].RegenTime = GetTickCount();

  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00185	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018b	5f		 pop	 edi
  0018c	5b		 pop	 ebx
  0018d	89 84 0e 90 05
	00 00		 mov	 DWORD PTR [esi+ecx+1424], eax

; 483  : 					gObj[iResult].DieRegen = 1;

  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00199	c6 84 06 8a 05
	00 00 01	 mov	 BYTE PTR [esi+eax+1418], 1
$LN3@Init:
  001a1	5e		 pop	 esi

; 522  : 
; 523  : 				continue;
; 524  : 			}
; 525  : 			
; 526  : #if (GS_CASTLE != 1)
; 527  : 			LogAddTD("[ KANTURU ][ SetAIMonster ] %s(Index:%d ObjIndex:%d) Map:%d-[%d][%d]",
; 528  : 				gObj[iResult].Name, gObj[iResult].Class, iResult, gObj[iResult].MapNumber,
; 529  : 				gObj[iResult].X, gObj[iResult].Y);
; 530  : #endif
; 531  : 		}
; 532  : 	}
; 533  : }

  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
$LN10@Init:

; 484  : 
; 485  : 					return;
; 486  : 				}
; 487  : 			}
; 488  : 			else if ( Memb.m_iCreateType == 0 )

  001a6	85 c0		 test	 eax, eax
  001a8	75 09		 jne	 SHORT $LN14@Init

; 489  : 			{
; 490  : 				cX = Memb.m_iStartX;
; 491  : 				cY = Memb.m_iStartY;

  001aa	8a 46 1c	 mov	 al, BYTE PTR [esi+28]
  001ad	8a 5e 18	 mov	 bl, BYTE PTR [esi+24]
  001b0	89 45 fc	 mov	 DWORD PTR tv743[ebp], eax
$LN14@Init:

; 492  : 			}
; 493  : 
; 494  : 			gObj[iResult].X = cX;

  001b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 495  : 			gObj[iResult].Y = cY;

  001b8	8b 4d fc	 mov	 ecx, DWORD PTR tv743[ebp]
  001bb	88 9c 07 20 01
	00 00		 mov	 BYTE PTR [edi+eax+288], bl
  001c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c7	88 8c 07 21 01
	00 00		 mov	 BYTE PTR [edi+eax+289], cl

; 496  : 			gObj[iResult].MTX = gObj[iResult].X;

  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d4	8a 84 39 20 01
	00 00		 mov	 al, BYTE PTR [ecx+edi+288]
  001db	88 84 39 54 01
	00 00		 mov	 BYTE PTR [ecx+edi+340], al

; 497  : 			gObj[iResult].MTY = gObj[iResult].Y;

  001e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e8	8a 84 39 21 01
	00 00		 mov	 al, BYTE PTR [ecx+edi+289]
  001ef	88 84 39 55 01
	00 00		 mov	 BYTE PTR [ecx+edi+341], al

; 498  : 			gObj[iResult].TX = gObj[iResult].X;

  001f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fc	8a 84 39 20 01
	00 00		 mov	 al, BYTE PTR [ecx+edi+288]
  00203	88 84 39 52 01
	00 00		 mov	 BYTE PTR [ecx+edi+338], al

; 499  : 			gObj[iResult].TY = gObj[iResult].Y;

  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00210	8a 84 39 21 01
	00 00		 mov	 al, BYTE PTR [ecx+edi+289]
  00217	88 84 39 53 01
	00 00		 mov	 BYTE PTR [ecx+edi+339], al

; 500  : 			gObj[iResult].StartX = gObj[iResult].X;

  0021e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00224	8a 84 39 20 01
	00 00		 mov	 al, BYTE PTR [ecx+edi+288]
  0022b	88 84 39 4e 01
	00 00		 mov	 BYTE PTR [ecx+edi+334], al

; 501  : 			gObj[iResult].StartY = gObj[iResult].Y;

  00232	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00238	8a 84 39 21 01
	00 00		 mov	 al, BYTE PTR [ecx+edi+289]
  0023f	88 84 39 4f 01
	00 00		 mov	 BYTE PTR [ecx+edi+335], al

; 502  : 
; 503  : 
; 504  : 			gObjSetMonster(iResult, Memb.m_iClass);

  00246	ff 76 f8	 push	 DWORD PTR [esi-8]
  00249	ff 75 f8	 push	 DWORD PTR _iResult$1$[ebp]
  0024c	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 505  : 
; 506  : 			gObj[iResult].m_iGroupNumber = Memb.m_iGroupNumber;

  00251	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00256	83 c4 08	 add	 esp, 8
  00259	8b 4e f0	 mov	 ecx, DWORD PTR [esi-16]
  0025c	89 8c 07 dc 20
	00 00		 mov	 DWORD PTR [edi+eax+8412], ecx

; 507  : 			gObj[iResult].m_iGroupMemberGuid = Memb.m_iGuid;

  00263	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00268	8b 4e f4	 mov	 ecx, DWORD PTR [esi-12]
  0026b	89 8c 07 e4 20
	00 00		 mov	 DWORD PTR [edi+eax+8420], ecx

; 508  : 			gObj[iResult].m_iCurrentAI = Memb.m_iStartAI;

  00272	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00277	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00279	89 8c 07 d0 20
	00 00		 mov	 DWORD PTR [edi+eax+8400], ecx

; 509  : 			gObj[iResult].m_iBasicAI = Memb.m_iStartAI;

  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00285	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00287	89 8c 07 cc 20
	00 00		 mov	 DWORD PTR [edi+eax+8396], ecx

; 510  : 			gObj[iResult].m_iRegenType = Memb.m_iRegenType;

  0028e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00293	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00296	89 8c 07 e8 20
	00 00		 mov	 DWORD PTR [edi+eax+8424], ecx

; 511  : 			gObj[iResult].Dir = Memb.m_iStartDir;

  0029d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a2	8a 4e 20	 mov	 cl, BYTE PTR [esi+32]
  002a5	88 8c 07 22 01
	00 00		 mov	 BYTE PTR [edi+eax+290], cl

; 512  : 			gObj[iResult].m_State = 1;

  002ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b1	c7 84 07 d0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax+464], 1

; 513  : 			gObj[iResult].DieRegen = 0;

  002bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c1	c6 84 07 8a 05
	00 00 00	 mov	 BYTE PTR [edi+eax+1418], 0

; 514  : 			Memb.m_iObjIndex = iResult;
; 515  : 
; 516  : 			if ( Memb.m_iCreateType == -1 )

  002c9	83 7e 10 ff	 cmp	 DWORD PTR [esi+16], -1
  002cd	8b 45 f8	 mov	 eax, DWORD PTR _iResult$1$[ebp]
  002d0	89 46 28	 mov	 DWORD PTR [esi+40], eax
  002d3	75 3a		 jne	 SHORT $LN31@Init

; 517  : 			{
; 518  : 				gObj[iResult].Live = FALSE;

  002d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002da	c6 44 07 51 00	 mov	 BYTE PTR [edi+eax+81], 0

; 519  : 				gObj[iResult].m_State = 4;

  002df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e4	c7 84 07 d0 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [edi+eax+464], 4

; 520  : 				gObj[iResult].RegenTime = GetTickCount();

  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fb	89 84 0f 90 05
	00 00		 mov	 DWORD PTR [edi+ecx+1424], eax

; 521  : 				gObj[iResult].DieRegen = 1;

  00302	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00307	c6 84 07 8a 05
	00 00 01	 mov	 BYTE PTR [edi+eax+1418], 1
$LN31@Init:
  0030f	8b 45 08	 mov	 eax, DWORD PTR _j$1$[ebp]
$LN2@Init:

; 436  : 
; 437  : 	for ( int j=0;j<MAX_MONSTER_AI_GROUP_MEMBER;j++)

  00312	40		 inc	 eax
  00313	83 c6 40	 add	 esi, 64			; 00000040H
  00316	89 45 08	 mov	 DWORD PTR _j$1$[ebp], eax
  00319	83 f8 64	 cmp	 eax, 100		; 00000064H
  0031c	0f 8c 1f fd ff
	ff		 jl	 $LL4@Init
  00322	5f		 pop	 edi
  00323	5b		 pop	 ebx
  00324	5e		 pop	 esi

; 522  : 
; 523  : 				continue;
; 524  : 			}
; 525  : 			
; 526  : #if (GS_CASTLE != 1)
; 527  : 			LogAddTD("[ KANTURU ][ SetAIMonster ] %s(Index:%d ObjIndex:%d) Map:%d-[%d][%d]",
; 528  : 				gObj[iResult].Name, gObj[iResult].Class, iResult, gObj[iResult].MapNumber,
; 529  : 				gObj[iResult].X, gObj[iResult].Y);
; 530  : #endif
; 531  : 		}
; 532  : 	}
; 533  : }

  00325	8b e5		 mov	 esp, ebp
  00327	5d		 pop	 ebp
  00328	c3		 ret	 0
?Init@TMonsterAIGroup@@SAXH@Z ENDP			; TMonsterAIGroup::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ??1TMonsterAIGroup@@UAE@XZ
_TEXT	SEGMENT
??1TMonsterAIGroup@@UAE@XZ PROC				; TMonsterAIGroup::~TMonsterAIGroup, COMDAT
; _this$ = ecx

; 28   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TMonsterAIGroup@@6B@

; 29   : 	return;
; 30   : }

  00006	c3		 ret	 0
??1TMonsterAIGroup@@UAE@XZ ENDP				; TMonsterAIGroup::~TMonsterAIGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ??0TMonsterAIGroup@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterAIGroup@@QAE@XZ PROC				; TMonsterAIGroup::TMonsterAIGroup, COMDAT
; _this$ = ecx

; 23   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7TMonsterAIGroup@@6B@

; 24   : 	this->DelAllGroupInfo();

  00009	e8 00 00 00 00	 call	 ?DelAllGroupInfo@TMonsterAIGroup@@SAHXZ ; TMonsterAIGroup::DelAllGroupInfo

; 25   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0TMonsterAIGroup@@QAE@XZ ENDP				; TMonsterAIGroup::TMonsterAIGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsteraigroup.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
