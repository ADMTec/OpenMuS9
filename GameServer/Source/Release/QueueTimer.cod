; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\QueueTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CQueueTimer@@QAE@XZ				; CQueueTimer::CQueueTimer
PUBLIC	?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z	; CQueueTimer::RegCallBack
PUBLIC	??1CQueueTimer@@UAE@XZ				; CQueueTimer::~CQueueTimer
PUBLIC	?QueueTimerInit@CQueueTimer@@QAEXXZ		; CQueueTimer::QueueTimerInit
PUBLIC	?PushEventID@CQueueTimer@@QAEXH@Z		; CQueueTimer::PushEventID
PUBLIC	?PopEventID@CQueueTimer@@QAEXXZ			; CQueueTimer::PopEventID
PUBLIC	?GetEvenetID@CQueueTimer@@QAEPAHXZ		; CQueueTimer::GetEvenetID
PUBLIC	?CreateTimer@CQueueTimer@@QAEHHKK@Z		; CQueueTimer::CreateTimer
PUBLIC	?DeleteQueueTimer@CQueueTimer@@QAEXXZ		; CQueueTimer::DeleteQueueTimer
PUBLIC	?SyncLock@CQueueTimer@@QAEXXZ			; CQueueTimer::SyncLock
PUBLIC	?SyncUnlock@CQueueTimer@@QAEXXZ			; CQueueTimer::SyncUnlock
PUBLIC	?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z	; std::allocator<int *>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEXPAPAHI@Z ; std::_Wrap_alloc<std::allocator<int *> >::deallocate
PUBLIC	?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
PUBLIC	?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::deque<int,std::allocator<int> >::push_back
PUBLIC	?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::deque<int,std::allocator<int> >::_Growmap
PUBLIC	?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy
PUBLIC	??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::stack<int,std::deque<int,std::allocator<int> > >::~stack<int,std::deque<int,std::allocator<int> > >
PUBLIC	??_GCQueueTimer@@UAEPAXI@Z			; CQueueTimer::`scalar deleting destructor'
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-
PUBLIC	??_7CQueueTimer@@6B@				; CQueueTimer::`vftable'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CQueueTimer@@6B@				; CQueueTimer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCQueueTimer@@@8				; CQueueTimer `RTTI Type Descriptor'
PUBLIC	??_R3CQueueTimer@@8				; CQueueTimer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CQueueTimer@@8				; CQueueTimer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CQueueTimer@@8			; CQueueTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__CreateTimerQueue@0:PROC
EXTRN	__imp__CreateTimerQueueTimer@28:PROC
EXTRN	__imp__DeleteTimerQueue@4:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0TSync@@QAE@XZ:PROC				; TSync::TSync
EXTRN	??1TSync@@QAE@XZ:PROC				; TSync::~TSync
EXTRN	?Lock@TSync@@QAEXXZ:PROC			; TSync::Lock
EXTRN	?Unlock@TSync@@QAEXXZ:PROC			; TSync::Unlock
EXTRN	??_ECQueueTimer@@UAEPAXI@Z:PROC			; CQueueTimer::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@CQueueTimer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CQueueTimer@@8 DD FLAT:??_R0?AVCQueueTimer@@@8 ; CQueueTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CQueueTimer@@8
rdata$r	ENDS
;	COMDAT ??_R2CQueueTimer@@8
rdata$r	SEGMENT
??_R2CQueueTimer@@8 DD FLAT:??_R1A@?0A@EA@CQueueTimer@@8 ; CQueueTimer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CQueueTimer@@8
rdata$r	SEGMENT
??_R3CQueueTimer@@8 DD 00H				; CQueueTimer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CQueueTimer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCQueueTimer@@@8
data$r	SEGMENT
??_R0?AVCQueueTimer@@@8 DD FLAT:??_7type_info@@6B@	; CQueueTimer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCQueueTimer@@', 00H
data$r	ENDS
;	COMDAT ??_R4CQueueTimer@@6B@
rdata$r	SEGMENT
??_R4CQueueTimer@@6B@ DD 00H				; CQueueTimer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCQueueTimer@@@8
	DD	FLAT:??_R3CQueueTimer@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CQueueTimer@@6B@
CONST	SEGMENT
??_7CQueueTimer@@6B@ DD FLAT:??_R4CQueueTimer@@6B@	; CQueueTimer::`vftable'
	DD	FLAT:??_ECQueueTimer@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CQueueTimer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CQueueTimer@@QAE@XZ$0
__ehfuncinfo$??0CQueueTimer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CQueueTimer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 656  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAHIPAH@std@@YAPAPAHPAPAHIABQAH@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAHIPAH@std@@YAPAPAHPAPAHIABQAH@Z PROC	; std::_Fill_n<int * *,unsigned int,int *>, COMDAT

; 2727 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2728 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	85 d2		 test	 edx, edx
  0000b	74 11		 je	 SHORT $LN3@Fill_n
  0000d	56		 push	 esi
  0000e	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
$LL4@Fill_n:

; 2729 : 		*_Dest = _Val;

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	89 08		 mov	 DWORD PTR [eax], ecx
  00015	83 c0 04	 add	 eax, 4
  00018	83 ea 01	 sub	 edx, 1
  0001b	75 f4		 jne	 SHORT $LL4@Fill_n
  0001d	5e		 pop	 esi
$LN3@Fill_n:

; 2730 : 	return (_Dest);
; 2731 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Fill_n@PAPAHIPAH@std@@YAPAPAHPAPAHIABQAH@Z ENDP	; std::_Fill_n<int * *,unsigned int,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAHPAH@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAHPAH@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *>, COMDAT

; 402  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 403  : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
; 407  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PAHPAH@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@HABH@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@HABH@?$allocator@H@std@@QAEXPAHABH@Z PROC	; std::allocator<int>::construct<int,int const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 656  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@HABH@?$allocator@H@std@@QAEXPAHABH@Z ENDP	; std::allocator<int>::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@H@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@H@?$allocator@H@std@@QAEXPAH@Z PROC		; std::allocator<int>::destroy<int>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@H@?$allocator@H@std@@QAEXPAH@Z ENDP		; std::allocator<int>::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAH@?$allocator@H@std@@QAEXPAPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAH@?$allocator@H@std@@QAEXPAPAH@Z PROC	; std::allocator<int>::destroy<int *>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAH@?$allocator@H@std@@QAEXPAPAH@Z ENDP	; std::allocator<int>::destroy<int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN8@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAH0AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAH0AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int *> > >, COMDAT

; 180  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAH0AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAHIPAH@std@@YAXPAPAHIAAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAHIPAH@std@@YAXPAPAHIAAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<int *,unsigned int,int *>, COMDAT

; 679  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2728 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN6@Uninit_def
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 680  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN6@Uninit_def:

; 681  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninit_def_fill_n@PAHIPAH@std@@YAXPAPAHIAAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<int *,unsigned int,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAH@std@@YAPAPAHPAPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAH@std@@YAPAPAHPAPAH@Z PROC		; std::_Val_type<int * *>, COMDAT

; 875  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 876  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAH@std@@YAPAPAHPAPAH@Z ENDP		; std::_Val_type<int * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAHPAPAH@std@@YAAAPAPAHAAPAPAHPAPAH@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAHPAPAH@std@@YAAAPAPAHAAPAPAHPAPAH@Z PROC ; std::_Rechecked<int * *,int * *>, COMDAT

; 446  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 448  : 	return (_Dest);
; 449  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAHPAPAH@std@@YAAAPAPAHAAPAPAHPAPAH@Z ENDP ; std::_Rechecked<int * *,int * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAHPAPAHU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAPAHPAPAHU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z PROC ; std::_Uninit_copy<int * *,int * *,std::_Wrap_alloc<std::allocator<int *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PAPAHPAPAHU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z ENDP ; std::_Uninit_copy<int * *,int * *,std::_Wrap_alloc<std::allocator<int *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAH@std@@YAPAPAHPAPAH@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAH@std@@YAPAPAHPAPAH@Z PROC		; std::_Unchecked<int * *>, COMDAT

; 438  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 440  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAH@std@@YAPAPAHPAPAH@Z ENDP		; std::_Unchecked<int * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z PROC ; std::allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z ENDP ; std::allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@H@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAH@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@H@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAH@Z PROC ; std::allocator_traits<std::allocator<int> >::destroy<int>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@H@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAH@Z ENDP ; std::allocator_traits<std::allocator<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAPAH@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAPAH@Z PROC ; std::allocator_traits<std::allocator<int> >::destroy<int *>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@PAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAPAH@Z ENDP ; std::allocator_traits<std::allocator<int> >::destroy<int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN13@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAH0AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAH0AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int *> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAH0AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAHIU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAHIAAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAHIU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAHIAAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<int * *,unsigned int,std::_Wrap_alloc<std::allocator<int *> > >, COMDAT

; 688  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2728 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN12@Uninitiali
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 680  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN12@Uninitiali:

; 689  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 690  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 691  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAHIU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAXPAPAHIAAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<int * *,unsigned int,std::_Wrap_alloc<std::allocator<int *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAHPAPAHU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAHPAPAHU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z PROC ; std::_Uninitialized_copy<int * *,int * *,std::_Wrap_alloc<std::allocator<int *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_copy@PAPAHPAPAHU?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@@std@@YAPAPAHPAPAH00AAU?$_Wrap_alloc@V?$allocator@PAH@std@@@0@@Z ENDP ; std::_Uninitialized_copy<int * *,int * *,std::_Wrap_alloc<std::allocator<int *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 777  : 		_Map = _Mapptr();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 778  : 		_Mapsize = 0;

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 779  : 		_Myoff = 0;

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 780  : 		_Mysize = 0;

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00024	c2 08 00	 ret	 8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>, COMDAT
; _this$ = ecx

; 628  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<int> > >, COMDAT
; _this$ = ecx

; 875  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	77 31		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00013	77 3c		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	c1 e0 03	 shl	 eax, 3

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	77 31		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00013	8b 02		 mov	 eax, DWORD PTR [edx]
  00015	85 c0		 test	 eax, eax
  00017	74 0a		 je	 SHORT $LN15@Deque_iter

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  00019	8b 00		 mov	 eax, DWORD PTR [eax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

  0001b	85 c0		 test	 eax, eax
  0001d	74 04		 je	 SHORT $LN15@Deque_iter

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 01		 mov	 DWORD PTR [ecx], eax
$LN15@Deque_iter:
  00023	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00026	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00029	8b c1		 mov	 eax, ecx
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-, COMDAT
; _this$ = ecx

; 659  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  00006	33 f6		 xor	 esi, esi

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00008	85 c0		 test	 eax, eax
  0000a	74 08		 je	 SHORT $LN17@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

  0000e	85 c0		 test	 eax, eax
  00010	74 02		 je	 SHORT $LN17@operator

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  00012	8b 30		 mov	 esi, DWORD PTR [eax]
$LN17@operator:

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  00014	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 643  : 		this->_Myoff += _Off;

  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	2b 55 0c	 sub	 edx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0002a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 125  : 		if (_Myproxy == _Right._Myproxy)

  0002d	85 f6		 test	 esi, esi
  0002f	74 0a		 je	 SHORT $LN37@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

  00033	85 c9		 test	 ecx, ecx
  00035	74 04		 je	 SHORT $LN37@operator

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  00037	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
$LN37@operator:
  0003b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 662  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-=, COMDAT
; _this$ = ecx

; 654  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 643  : 		this->_Myoff += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	29 41 08	 sub	 DWORD PTR [ecx+8], eax

; 655  : 		return (*this += -_Off);

  00009	8b c1		 mov	 eax, ecx

; 656  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator+=, COMDAT
; _this$ = ecx

; 642  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 643  : 		this->_Myoff += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	01 41 08	 add	 DWORD PTR [ecx+8], eax

; 644  : 		return (*this);

  00009	8b c1		 mov	 eax, ecx

; 645  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBEAAHXZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	85 c0		 test	 eax, eax
  00005	75 04		 jne	 SHORT $LN7@operator
  00007	33 f6		 xor	 esi, esi
  00009	eb 02		 jmp	 SHORT $LN8@operator
$LN7@operator:
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00010	8b ca		 mov	 ecx, edx
  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

  00015	83 e2 03	 and	 edx, 3

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00018	48		 dec	 eax
  00019	c1 e9 02	 shr	 ecx, 2
  0001c	23 c8		 and	 ecx, eax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	5e		 pop	 esi
  00022	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00025	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 607  : 		return ((reference)**(_Mybase *)this);
; 608  : 		}

  00028	c3		 ret	 0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBEAAHXZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >, COMDAT
; _this$ = ecx

; 589  : 		{	// construct with offset _Off in *_Pdeque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 149  : 		if (_Parent == 0)

  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $LN13@Deque_iter

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 305  : 		_Myoff = _Off;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0001e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 590  : 		}

  00021	8b c1		 mov	 eax, ecx
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00013	8b 02		 mov	 eax, DWORD PTR [edx]
  00015	85 c0		 test	 eax, eax
  00017	74 0a		 je	 SHORT $LN13@Deque_cons

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  00019	8b 00		 mov	 eax, DWORD PTR [eax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

  0001b	85 c0		 test	 eax, eax
  0001d	74 04		 je	 SHORT $LN13@Deque_cons

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@Deque_cons:
  00023	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00026	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00029	8b c1		 mov	 eax, ecx
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Setcont, COMDAT
; _this$ = ecx

; 534  : 		{	// set container pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN5@Setcont

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@Setcont:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 536  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBEABHXZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	85 c0		 test	 eax, eax
  00005	75 04		 jne	 SHORT $LN5@operator
  00007	33 f6		 xor	 esi, esi
  00009	eb 02		 jmp	 SHORT $LN6@operator
$LN5@operator:
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
$LN6@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00010	8b ca		 mov	 ecx, edx
  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 323  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 324  : 
; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (_Mycont == 0
; 327  : 			|| this->_Myoff < _Mycont->_Myoff
; 328  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 329  : 		{	// report error
; 330  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 331  : 		_SCL_SECURE_OUT_OF_RANGE;
; 332  : 		}
; 333  : 
; 334  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 335  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 336  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 337  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 338  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 339  : 
; 340  : 		_Analysis_assume_(_Mycont != 0);
; 341  : 
; 342  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 343  : 		size_type _Off = _Myoff % _DEQUESIZ;

  00015	83 e2 03	 and	 edx, 3

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00018	48		 dec	 eax
  00019	c1 e9 02	 shr	 ecx, 2
  0001c	23 c8		 and	 ecx, eax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	5e		 pop	 esi
  00022	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00025	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 345  : 		}

  00028	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBEABHXZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >, COMDAT
; _this$ = ecx

; 302  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 149  : 		if (_Parent == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 149  : 		if (_Parent == 0)

  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $LN11@Deque_cons

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 305  : 		_Myoff = _Off;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0001e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 306  : 		}

  00021	8b c1		 mov	 eax, ecx
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::construct<int,int const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@H@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@H@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAH@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::destroy<int>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@H@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAH@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAPAH@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::destroy<int *>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAPAH@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::destroy<int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0H@?$allocator@PAH@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@PAH@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<int *>::allocator<int *><int>, COMDAT
; _this$ = ecx

; 628  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0H@?$allocator@PAH@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<int *>::allocator<int *><int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<int *> >::_Wrap_alloc<std::allocator<int *> ><std::_Wrap_alloc<std::allocator<int> > >, COMDAT
; _this$ = ecx

; 875  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<int *> >::_Wrap_alloc<std::allocator<int *> ><std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCQueueTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCQueueTimer@@UAEPAXI@Z PROC				; CQueueTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 3c		 push	 60			; 0000003cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCQueueTimer@@UAEPAXI@Z ENDP				; CQueueTimer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::~stack<int,std::deque<int,std::allocator<int> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1265 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 877  : 		_Myproxy() = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi
  00019	c3		 ret	 0
??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::~stack<int,std::deque<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?pop@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::pop, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1543 : 		if (--this->_Mysize() == 0)

  00000	83 41 10 ff	 add	 DWORD PTR [ecx+16], -1
  00004	75 07		 jne	 SHORT $LN4@pop

; 1544 : 			this->_Myoff() = 0;

  00006	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$LN4@pop:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 146  : 		}

  0000d	c3		 ret	 0
?pop@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?push@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXABH@Z PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::push, COMDAT
; _this$ = ecx

; 139  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 141  : 		}

  00003	5d		 pop	 ebp

; 140  : 		c.push_back(_Val);

  00004	e9 00 00 00 00	 jmp	 ?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::deque<int,std::allocator<int> >::push_back
?push@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXABH@Z ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?top@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEAAHXZ
_TEXT	SEGMENT
$T1 = -24						; size = 12
$T2 = -12						; size = 12
?top@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEAAHXZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::top, COMDAT
; _this$ = ecx

; 129  : 		{	// return last element of mutable stack

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1468 : 		return (*(end() - 1));

  00006	8d 45 f4	 lea	 eax, DWORD PTR $T2[ebp]
  00009	56		 push	 esi
  0000a	6a 01		 push	 1
  0000c	50		 push	 eax
  0000d	8d 45 e8	 lea	 eax, DWORD PTR $T1[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0001d	8b 30		 mov	 esi, DWORD PTR [eax]
  0001f	85 f6		 test	 esi, esi
  00021	74 02		 je	 SHORT $LN12@top
$LN11@top:
  00023	8b 36		 mov	 esi, DWORD PTR [esi]
$LN12@top:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00025	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00028	8b ca		 mov	 ecx, edx
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	48		 dec	 eax
  0002e	c1 e9 02	 shr	 ecx, 2
  00031	23 c8		 and	 ecx, eax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  00033	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00036	83 e2 03	 and	 edx, 3
  00039	5e		 pop	 esi
  0003a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0003d	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 131  : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?top@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEAAHXZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::top
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?empty@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::empty, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1414 : 		return (this->_Mysize() == 0);

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 121  : 		}

  00007	c3		 ret	 0
?empty@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??0?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::stack<int,std::deque<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 28   : 		{	// construct with empty container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00007	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 28   : 		{	// construct with empty container

  00009	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 777  : 		_Map = _Mapptr();

  00012	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 778  : 		_Mapsize = 0;

  00019	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 779  : 		_Myoff = 0;

  00020	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 780  : 		_Mysize = 0;

  00027	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00036	85 c0		 test	 eax, eax
  00038	74 1a		 je	 SHORT $LN103@stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 865  : 		_Myproxy() = _Alproxy.allocate(1);

  0003a	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0003c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00042	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 867  : 		_Myproxy()->_Mycont = &_Get_data();

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	89 30		 mov	 DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 29   : 		}

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN103@stack:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN105@stack:
$LN102@stack:
  00059	cc		 int	 3
??0?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::stack<int,std::deque<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::deque<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1881 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1414 : 		return (this->_Mysize() == 0);

  00003	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 1882 : 		_Alpty _Almap(this->_Getal());
; 1883 : 		while (!empty())

  00007	74 1a		 je	 SHORT $LN3@Tidy
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Tidy:

; 1415 : 		}
; 1416 : 
; 1417 : 	allocator_type get_allocator() const _NOEXCEPT
; 1418 : 		{	// return allocator object for values
; 1419 : 		return (this->_Getal());
; 1420 : 		}
; 1421 : 
; 1422 : 	const_reference at(size_type _Pos) const
; 1423 : 		{	// subscript nonmutable sequence with checking
; 1424 : 		if (this->_Mysize() <= _Pos)
; 1425 : 			_Xran();
; 1426 : 		return (*(begin() + _Pos));
; 1427 : 		}
; 1428 : 
; 1429 : 	reference at(size_type _Pos)
; 1430 : 		{	// subscript mutable sequence with checking
; 1431 : 		if (this->_Mysize() <= _Pos)
; 1432 : 			_Xran();
; 1433 : 		return (*(begin() + _Pos));
; 1434 : 		}
; 1435 : 
; 1436 : 	const_reference operator[](size_type _Pos) const
; 1437 : 		{	// subscript nonmutable sequence
; 1438 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1439 : 		if (this->_Mysize() <= _Pos)
; 1440 : 			_DEBUG_ERROR("deque subscript out of range");
; 1441 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1442 : 
; 1443 : 		return (*(begin() + _Pos));
; 1444 : 		}
; 1445 : 
; 1446 : 	reference operator[](size_type _Pos)
; 1447 : 		{	// subscript mutable sequence
; 1448 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1449 : 		if (this->_Mysize() <= _Pos)
; 1450 : 			_DEBUG_ERROR("deque subscript out of range");
; 1451 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1452 : 
; 1453 : 		return (*(begin() + _Pos));
; 1454 : 		}
; 1455 : 
; 1456 : 	reference front()
; 1457 : 		{	// return first element of mutable sequence
; 1458 : 		return (*begin());
; 1459 : 		}
; 1460 : 
; 1461 : 	const_reference front() const
; 1462 : 		{	// return first element of nonmutable sequence
; 1463 : 		return (*begin());
; 1464 : 		}
; 1465 : 
; 1466 : 	reference back()
; 1467 : 		{	// return last element of mutable sequence
; 1468 : 		return (*(end() - 1));
; 1469 : 		}
; 1470 : 
; 1471 : 	const_reference back() const
; 1472 : 		{	// return last element of nonmutable sequence
; 1473 : 		return (*(end() - 1));
; 1474 : 		}
; 1475 : 
; 1476 : 	void push_front(const value_type& _Val)
; 1477 : 		{	// insert element at beginning
; 1478 : 		this->_Orphan_all();
; 1479 : 		_PUSH_FRONT_BEGIN;
; 1480 : 		this->_Getal().construct(
; 1481 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1482 : 		_PUSH_FRONT_END;
; 1483 : 		}
; 1484 : 
; 1485 : 	void pop_front()
; 1486 : 		{	// erase element at beginning
; 1487 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1488 : 		if (empty())
; 1489 : 			_DEBUG_ERROR("deque empty before pop");
; 1490 : 		else
; 1491 : 			{	// something to erase, do it
; 1492 : 			_Orphan_off(this->_Myoff());
; 1493 : 			size_type _Block = this->_Getblock(this->_Myoff());
; 1494 : 			this->_Getal().destroy(
; 1495 : 				this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ);
; 1496 : 			if (--this->_Mysize() == 0)
; 1497 : 				this->_Myoff() = 0;
; 1498 : 			else
; 1499 : 				++this->_Myoff();
; 1500 : 			}
; 1501 : 
; 1502 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1503 : 		size_type _Block = this->_Getblock(this->_Myoff());
; 1504 : 		this->_Getal().destroy(
; 1505 : 			this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ);
; 1506 : 		if (--this->_Mysize() == 0)
; 1507 : 			this->_Myoff() = 0;
; 1508 : 		else
; 1509 : 			++this->_Myoff();
; 1510 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1511 : 		}
; 1512 : 
; 1513 : 	void push_back(const value_type& _Val)
; 1514 : 		{	// insert element at end
; 1515 : 		this->_Orphan_all();
; 1516 : 		_PUSH_BACK_BEGIN;
; 1517 : 		this->_Getal().construct(
; 1518 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1519 : 		_PUSH_BACK_END;
; 1520 : 		}
; 1521 : 
; 1522 : 	void pop_back()
; 1523 : 		{	// erase element at end
; 1524 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1525 : 		if (empty())
; 1526 : 			_DEBUG_ERROR("deque empty before pop");
; 1527 : 		else
; 1528 : 			{	// something to erase, do it
; 1529 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1530 : 			_Orphan_off(_Newoff);
; 1531 : 			size_type _Block = this->_Getblock(_Newoff);
; 1532 : 			this->_Getal().destroy(
; 1533 : 				this->_Map()[_Block] + _Newoff % _DEQUESIZ);
; 1534 : 			if (--this->_Mysize() == 0)
; 1535 : 				this->_Myoff() = 0;
; 1536 : 			}
; 1537 : 
; 1538 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1540 : 		size_type _Block = this->_Getblock(_Newoff);
; 1541 : 		this->_Getal().destroy(
; 1542 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ);
; 1543 : 		if (--this->_Mysize() == 0)

  00010	83 46 10 ff	 add	 DWORD PTR [esi+16], -1
  00014	75 07		 jne	 SHORT $LN29@Tidy

; 1544 : 			this->_Myoff() = 0;

  00016	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN29@Tidy:

; 1414 : 		return (this->_Mysize() == 0);

  0001d	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 1882 : 		_Alpty _Almap(this->_Getal());
; 1883 : 		while (!empty())

  00021	75 ed		 jne	 SHORT $LL2@Tidy
$LN3@Tidy:
  00023	57		 push	 edi

; 1885 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

  00024	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00027	85 ff		 test	 edi, edi
  00029	74 1d		 je	 SHORT $LN5@Tidy
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@Tidy:

; 1886 : 			{	// free storage for a block and destroy pointer
; 1887 : 			if (this->_Map()[--_Block] != pointer())

  00030	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00033	4f		 dec	 edi
  00034	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00037	85 c0		 test	 eax, eax
  00039	74 09		 je	 SHORT $LN7@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	83 c4 04	 add	 esp, 4
$LN7@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1885 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

  00044	85 ff		 test	 edi, edi
  00046	75 e8		 jne	 SHORT $LL4@Tidy
$LN5@Tidy:

; 1888 : 				{	// free block and destroy its pointer
; 1889 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);
; 1890 : 				this->_Getal().destroy(&this->_Map()[_Block]);
; 1891 : 				}
; 1892 : 			}
; 1893 : 
; 1894 : 		if (this->_Map() != _Mapptr())

  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	5f		 pop	 edi
  0004c	85 c9		 test	 ecx, ecx
  0004e	74 37		 je	 SHORT $LN193@Tidy

; 1895 : 			_Almap.deallocate(this->_Map(),

  00050	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00053	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00058	77 3d		 ja	 SHORT $LN226@Tidy

; 101  : 	const size_t _User_size = _Count * _Sz;

  0005a	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0005d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00062	72 1a		 jb	 SHORT $LN188@Tidy

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00064	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00067	75 33		 jne	 SHORT $LN228@Tidy

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00069	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0006c	3b c1		 cmp	 eax, ecx
  0006e	73 31		 jae	 SHORT $LN229@Tidy

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00070	2b c8		 sub	 ecx, eax
  00072	83 f9 04	 cmp	 ecx, 4
  00075	72 2f		 jb	 SHORT $LN230@Tidy

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00077	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0007a	77 2f		 ja	 SHORT $LN231@Tidy

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0007c	8b c8		 mov	 ecx, eax
$LN188@Tidy:

; 138  : 	::operator delete(_Ptr);

  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00084	83 c4 04	 add	 esp, 4
$LN193@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1897 : 		this->_Mapsize() = 0;

  00087	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1898 : 		this->_Map() = _Mapptr();

  0008e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00095	5e		 pop	 esi

; 1899 : 		}

  00096	c3		 ret	 0
$LN226@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00097	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN232@Tidy:
$LN228@Tidy:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0009c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN233@Tidy:
$LN229@Tidy:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  000a1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN234@Tidy:
$LN230@Tidy:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  000a6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN235@Tidy:
$LN231@Tidy:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  000ab	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN236@Tidy:
$LN225@Tidy:
  000b0	cc		 int	 3
?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::deque<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
__Count$1$ = -12					; size = 4
__Myptr$1$ = -8						; size = 4
__Myboff$1$ = -4					; size = 4
__Newmap$1$ = 8						; size = 4
__Count$ = 8						; size = 4
__Almap$ = 11						; size = 1
?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::deque<int,std::allocator<int> >::_Growmap, COMDAT
; _this$ = ecx

; 1825 : 		{	// grow map by at least _Count pointers, _Mapsize() a power of 2

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1826 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1827 : 			"The _Xlen() test should always be performed.");
; 1828 : 
; 1829 : 		typedef typename _Alpty::pointer _Blockptr;
; 1830 : 		_Alpty _Almap(this->_Getal());
; 1831 : 		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	be 01 00 00 00	 mov	 esi, 1
  00012	89 5d f0	 mov	 DWORD PTR _this$1$[ebp], ebx
  00015	57		 push	 edi
  00016	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00019	85 c9		 test	 ecx, ecx
  0001b	0f 45 f1	 cmovne	 esi, ecx
  0001e	66 90		 npad	 2
$LL2@Growmap:

; 1832 : 		while (_Newsize - this->_Mapsize() < _Count
; 1833 : 			|| _Newsize < _DEQUEMAPSIZ)

  00020	8b c6		 mov	 eax, esi
  00022	2b c1		 sub	 eax, ecx
  00024	3b c2		 cmp	 eax, edx
  00026	72 05		 jb	 SHORT $LN4@Growmap
  00028	83 fe 08	 cmp	 esi, 8
  0002b	73 13		 jae	 SHORT $LN3@Growmap
$LN4@Growmap:

; 1834 : 			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
; 1835 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

  0002d	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH
  00032	2b c6		 sub	 eax, esi
  00034	3b c6		 cmp	 eax, esi
  00036	0f 82 15 01 00
	00		 jb	 $LN373@Growmap

; 1836 : 				_Xlen();	// result too long
; 1837 : 			_Newsize *= 2;

  0003c	03 f6		 add	 esi, esi

; 1838 : 			}

  0003e	eb e0		 jmp	 SHORT $LL2@Growmap
$LN3@Growmap:

; 1839 : 		_Count = _Newsize - this->_Mapsize();
; 1840 : 
; 1841 : 		size_type _Myboff = this->_Myoff() / _DEQUESIZ;

  00040	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00043	2b f1		 sub	 esi, ecx
  00045	c1 ef 02	 shr	 edi, 2
  00048	89 7d fc	 mov	 DWORD PTR __Myboff$1$[ebp], edi

; 1842 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);

  0004b	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  0004e	50		 push	 eax
  0004f	8d 4d 0b	 lea	 ecx, DWORD PTR __Almap$[ebp]
  00052	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z ; std::allocator<int *>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1845 : 		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,

  00057	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0005a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0005d	89 45 08	 mov	 DWORD PTR __Newmap$1$[ebp], eax
  00060	c1 e1 02	 shl	 ecx, 2
  00063	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00066	2b c8		 sub	 ecx, eax
  00068	03 ca		 add	 ecx, edx
  0006a	c1 f9 02	 sar	 ecx, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  0006d	8d 3c 8d 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1843 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00074	8b 4d 08	 mov	 ecx, DWORD PTR __Newmap$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00077	57		 push	 edi
  00078	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1843 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Myboff$1$[ebp]
  0007c	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1850 : 			_Myptr = _Uninitialized_copy(this->_Map(),

  00085	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1848 : 		if (_Myboff <= _Count)

  0008e	8b 7d fc	 mov	 edi, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00091	89 55 f8	 mov	 DWORD PTR __Myptr$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1848 : 		if (_Myboff <= _Count)

  00094	3b fe		 cmp	 edi, esi
  00096	77 45		 ja	 SHORT $LN6@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00098	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1853 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,

  0009f	8b d6		 mov	 edx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000a1	c1 f8 02	 sar	 eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1853 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,

  000a4	2b d7		 sub	 edx, edi
  000a6	89 55 f4	 mov	 DWORD PTR __Count$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  000a9	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]
  000b0	53		 push	 ebx
  000b1	51		 push	 ecx
  000b2	ff 75 f8	 push	 DWORD PTR __Myptr$1$[ebp]
  000b5	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2728 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __Count$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2728 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

  000c3	85 c9		 test	 ecx, ecx
  000c5	74 09		 je	 SHORT $LN183@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 927  : 		return (_Get_data()._Map);

  000c7	33 c0		 xor	 eax, eax
  000c9	8b fa		 mov	 edi, edx
  000cb	f3 ab		 rep stosd
  000cd	8b 7d fc	 mov	 edi, DWORD PTR __Myboff$1$[ebp]
$LN183@Growmap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 680  : 	_Fill_n(_First, _Count, (_Valty)0);

  000d0	8b 5d 08	 mov	 ebx, DWORD PTR __Newmap$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2728 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

  000d3	85 ff		 test	 edi, edi
  000d5	74 55		 je	 SHORT $LN277@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 680  : 	_Fill_n(_First, _Count, (_Valty)0);

  000d7	8b cf		 mov	 ecx, edi
  000d9	8b fb		 mov	 edi, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1858 : 		else

  000db	eb 4b		 jmp	 SHORT $LN372@Growmap
$LN6@Growmap:

; 1859 : 			{	// increment not greater than offset of initial block
; 1860 : 			_Uninitialized_copy(this->_Map(),

  000dd	8d 3c b5 00 00
	00 00		 lea	 edi, DWORD PTR [esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  000e4	8b c7		 mov	 eax, edi
  000e6	83 e0 fc	 and	 eax, -4			; fffffffcH
  000e9	50		 push	 eax
  000ea	51		 push	 ecx
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1863 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

  000f1	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000f4	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000f7	8b 7d fc	 mov	 edi, DWORD PTR __Myboff$1$[ebp]
  000fa	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  00101	2b d1		 sub	 edx, ecx
  00103	03 d0		 add	 edx, eax
  00105	c1 fa 02	 sar	 edx, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,

  00108	8d 1c 95 00 00
	00 00		 lea	 ebx, DWORD PTR [edx*4]
  0010f	53		 push	 ebx
  00110	51		 push	 ecx
  00111	ff 75 08	 push	 DWORD PTR __Newmap$1$[ebp]
  00114	e8 00 00 00 00	 call	 _memmove
  00119	83 c4 18	 add	 esp, 24			; 00000018H
  0011c	8d 3c 03	 lea	 edi, DWORD PTR [ebx+eax]
  0011f	8b 5d 08	 mov	 ebx, DWORD PTR __Newmap$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2728 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

  00122	85 f6		 test	 esi, esi
  00124	74 06		 je	 SHORT $LN277@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 927  : 		return (_Get_data()._Map);

  00126	8b ce		 mov	 ecx, esi
$LN372@Growmap:
  00128	33 c0		 xor	 eax, eax
  0012a	f3 ab		 rep stosd
$LN277@Growmap:

; 1864 : 				this->_Map() + _Myboff,
; 1865 : 				_Newmap, _Almap);	// copy rest of old
; 1866 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1867 : 				_Almap);	// clear rest to initial block
; 1868 : 			}
; 1869 : 
; 1870 : 		_Destroy_range(this->_Map() + _Myboff,
; 1871 : 			this->_Map() + this->_Mapsize(), _Almap);
; 1872 : 		if (this->_Map() != _Mapptr())

  0012c	8b 7d f0	 mov	 edi, DWORD PTR _this$1$[ebp]
  0012f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00132	85 c0		 test	 eax, eax
  00134	74 0c		 je	 SHORT $LN8@Growmap

; 1873 : 			_Almap.deallocate(this->_Map(),

  00136	ff 77 08	 push	 DWORD PTR [edi+8]
  00139	8d 4d 0b	 lea	 ecx, DWORD PTR __Almap$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEXPAPAHI@Z ; std::_Wrap_alloc<std::allocator<int *> >::deallocate
$LN8@Growmap:

; 1874 : 				this->_Mapsize());	// free storage for old
; 1875 : 
; 1876 : 		this->_Map() = _Newmap;	// point at new

  00142	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 1877 : 		this->_Mapsize() += _Count;

  00145	01 77 08	 add	 DWORD PTR [edi+8], esi
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx

; 1878 : 		}

  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c2 04 00	 ret	 4
$LN373@Growmap:

; 928  : 		}
; 929  : 
; 930  : 	const _Mapptr& _Map() const _NOEXCEPT
; 931  : 		{	// return const reference to _Map
; 932  : 		return (_Get_data()._Map);
; 933  : 		}
; 934  : 
; 935  : 	size_type& _Mapsize() _NOEXCEPT
; 936  : 		{	// return reference to _Mapsize
; 937  : 		return (_Get_data()._Mapsize);
; 938  : 		}
; 939  : 
; 940  : 	const size_type& _Mapsize() const _NOEXCEPT
; 941  : 		{	// return const reference to _Mapsize
; 942  : 		return (_Get_data()._Mapsize);
; 943  : 		}
; 944  : 
; 945  : 	size_type& _Myoff() _NOEXCEPT
; 946  : 		{	// return reference to _Myoff
; 947  : 		return (_Get_data()._Myoff);
; 948  : 		}
; 949  : 
; 950  : 	const size_type& _Myoff() const _NOEXCEPT
; 951  : 		{	// return const reference to _Myoff
; 952  : 		return (_Get_data()._Myoff);
; 953  : 		}
; 954  : 
; 955  : 	size_type& _Mysize() _NOEXCEPT
; 956  : 		{	// return reference to _Mysize
; 957  : 		return (_Get_data()._Mysize);
; 958  : 		}
; 959  : 
; 960  : 	const size_type& _Mysize() const _NOEXCEPT
; 961  : 		{	// return const reference to _Mysize
; 962  : 		return (_Get_data()._Mysize);
; 963  : 		}
; 964  : 
; 965  : private:
; 966  : 	_Compressed_pair<_Alty, _Deque_val<_Val_types> > _Mypair;
; 967  : 	};
; 968  : 
; 969  : 		// TEMPLATE CLASS deque
; 970  : template<class _Ty,
; 971  : 	class _Alloc = allocator<_Ty> >
; 972  : 	class deque
; 973  : 		: public _Deque_alloc<_Deque_base_types<_Ty, _Alloc> >
; 974  : 	{	// circular queue of pointers to blocks
; 975  : public:
; 976  : 	typedef deque<_Ty, _Alloc> _Myt;
; 977  : 	typedef _Deque_alloc<_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 978  : 	typedef _Alloc allocator_type;
; 979  : 
; 980  : 	typedef typename _Mybase::_Alty _Alty;
; 981  : 	typedef typename _Mybase::_Alpty _Alpty;
; 982  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 983  : 
; 984  : 	typedef typename _Mybase::value_type value_type;
; 985  : 	typedef typename _Mybase::size_type size_type;
; 986  : 	typedef typename _Mybase::difference_type difference_type;
; 987  : 	typedef typename _Mybase::pointer pointer;
; 988  : 	typedef typename _Mybase::const_pointer const_pointer;
; 989  : 	typedef typename _Mybase::reference reference;
; 990  : 	typedef typename _Mybase::const_reference const_reference;
; 991  : 
; 992  : 	typedef typename _Mybase::iterator iterator;
; 993  : 	typedef typename _Mybase::const_iterator const_iterator;
; 994  : 
; 995  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 996  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 997  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 998  : 	deque()
; 999  : 		: _Mybase()
; 1000 : 		{	// construct empty deque
; 1001 : 		}
; 1002 : 
; 1003 : 	explicit deque(const _Alloc& _Al)
; 1004 : 		: _Mybase(_Al)
; 1005 : 		{	// construct empty deque with allocator
; 1006 : 		}
; 1007 : 
; 1008 : 	explicit deque(size_type _Count)
; 1009 : 		: _Mybase()
; 1010 : 		{	// construct from _Count * value_type()
; 1011 : 		resize(_Count);
; 1012 : 		}
; 1013 : 
; 1014 : 	deque(size_type _Count, const value_type& _Val)
; 1015 : 		: _Mybase()
; 1016 : 		{	// construct from _Count * _Val
; 1017 : 		_Construct_n(_Count, _Val);
; 1018 : 		}
; 1019 : 
; 1020 : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 1021 : 		: _Mybase(_Al)
; 1022 : 		{	// construct from _Count * _Val with allocator
; 1023 : 		_Construct_n(_Count, _Val);
; 1024 : 		}
; 1025 : 
; 1026 : 	deque(const _Myt& _Right)
; 1027 : 
; 1028 : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 1029 : 
; 1030 : 
; 1031 : 		{	// construct by copying _Right
; 1032 : 		_Construct(_Right.begin(), _Right.end());
; 1033 : 		}
; 1034 : 
; 1035 : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 1036 : 		: _Mybase(_Al)
; 1037 : 		{	// construct by copying _Right
; 1038 : 		_Construct(_Right.begin(), _Right.end());
; 1039 : 		}
; 1040 : 
; 1041 : 	template<class _Iter,
; 1042 : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 1043 : 			void>::type>
; 1044 : 		deque(_Iter _First, _Iter _Last)
; 1045 : 		: _Mybase()
; 1046 : 		{	// construct from [_First, _Last)
; 1047 : 		_Construct(_First, _Last);
; 1048 : 		}
; 1049 : 
; 1050 : 	template<class _Iter,
; 1051 : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 1052 : 			void>::type>
; 1053 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 1054 : 		: _Mybase(_Al)
; 1055 : 		{	// construct from [_First, _Last) with allocator
; 1056 : 		_Construct(_First, _Last);
; 1057 : 		}
; 1058 : 
; 1059 : 	template<class _Iter>
; 1060 : 		void _Construct(_Iter _First, _Iter _Last)
; 1061 : 		{	// initialize from [_First, _Last), input iterators
; 1062 : 		_TRY_BEGIN
; 1063 : 
; 1064 : 		for (; _First != _Last; ++_First)
; 1065 : 			emplace_back(*_First);
; 1066 : 
; 1067 : 		_CATCH_ALL
; 1068 : 		_Tidy();
; 1069 : 		_RERAISE;
; 1070 : 		_CATCH_END
; 1071 : 		}
; 1072 : 
; 1073 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1074 : 		{	// construct from _Count * _Val
; 1075 : 		_TRY_BEGIN
; 1076 : 		for (; 0 < _Count; --_Count)
; 1077 : 			push_back(_Val);
; 1078 : 		_CATCH_ALL
; 1079 : 		_Tidy();
; 1080 : 		_RERAISE;
; 1081 : 		_CATCH_END
; 1082 : 		}
; 1083 : 
; 1084 : #define _PUSH_FRONT_BEGIN \
; 1085 : 	if (this->_Myoff() % _DEQUESIZ == 0 \
; 1086 : 		&& this->_Mapsize() <= (this->_Mysize() + _DEQUESIZ) / _DEQUESIZ) \
; 1087 : 		_Growmap(1); \
; 1088 : 	this->_Myoff() &= this->_Mapsize() * _DEQUESIZ - 1; \
; 1089 : 	size_type _Newoff = this->_Myoff() != 0 ? this->_Myoff() \
; 1090 : 		: this->_Mapsize() * _DEQUESIZ; \
; 1091 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1092 : 	if (this->_Map()[_Block] == pointer()) \
; 1093 : 		this->_Map()[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1094 : 
; 1095 : #define _PUSH_FRONT_END \
; 1096 : 	this->_Myoff() = _Newoff; \
; 1097 : 	++this->_Mysize()
; 1098 : 
; 1099 : #define _PUSH_BACK_BEGIN \
; 1100 : 	if ((this->_Myoff() + this->_Mysize()) % _DEQUESIZ == 0 \
; 1101 : 		&& this->_Mapsize() <= (this->_Mysize() + _DEQUESIZ) / _DEQUESIZ) \
; 1102 : 		_Growmap(1); \
; 1103 : 	this->_Myoff() &= this->_Mapsize() * _DEQUESIZ - 1; \
; 1104 : 	size_type _Newoff = this->_Myoff() + this->_Mysize(); \
; 1105 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1106 : 	if (this->_Map()[_Block] == pointer()) \
; 1107 : 		this->_Map()[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1108 : 
; 1109 : #define _PUSH_BACK_END \
; 1110 : 	++this->_Mysize()
; 1111 : 
; 1112 : 	deque(_Myt&& _Right)
; 1113 : 		: _Mybase(_STD move(_Right._Getal()))
; 1114 : 		{	// construct by moving _Right
; 1115 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1116 : 		}
; 1117 : 
; 1118 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1119 : 		: _Mybase(_Al)
; 1120 : 		{	// construct by moving _Right
; 1121 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1122 : 		}
; 1123 : 
; 1124 : 	_Myt& operator=(_Myt&& _Right)
; 1125 : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 1126 : 		{	// assign by moving _Right
; 1127 : 		if (this != &_Right)
; 1128 : 			{	// different, assign it
; 1129 : 			_Tidy();
; 1130 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1131 : 				&& this->_Getal() != _Right._Getal())
; 1132 : 				this->_Move_alloc(_Right._Getal());
; 1133 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1134 : 			}
; 1135 : 		return (*this);
; 1136 : 		}
; 1137 : 
; 1138 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1139 : 		{	// move from _Right, stealing its contents
; 1140 : 		this->_Swap_all((_Myt&)_Right);
; 1141 : 		this->_Map() = _Right._Map();
; 1142 : 		this->_Mapsize() = _Right._Mapsize();
; 1143 : 		this->_Myoff() = _Right._Myoff();
; 1144 : 		this->_Mysize() = _Right._Mysize();
; 1145 : 
; 1146 : 		_Right._Map() = _Mapptr();
; 1147 : 		_Right._Mapsize() = 0;
; 1148 : 		_Right._Myoff() = 0;
; 1149 : 		_Right._Mysize() = 0;
; 1150 : 		}
; 1151 : 
; 1152 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1153 : 		{	// move from _Right, possibly moving its contents
; 1154 : 		if (get_allocator() == _Right.get_allocator())
; 1155 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1156 : 		else
; 1157 : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 1158 : 				_STD make_move_iterator(_Right.end()));
; 1159 : 		}
; 1160 : 
; 1161 : 	void _Assign_rv(_Myt&& _Right)
; 1162 : 		{	// assign by moving _Right
; 1163 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1164 : 			typename _Alty::propagate_on_container_move_assignment());
; 1165 : 		}
; 1166 : 
; 1167 : 
; 1168 : 	void push_front(value_type&& _Val)
; 1169 : 		{	// insert element at beginning
; 1170 : 		this->_Orphan_all();
; 1171 : 		_PUSH_FRONT_BEGIN;
; 1172 : 		this->_Getal().construct(
; 1173 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ,
; 1174 : 			_STD forward<value_type>(_Val));
; 1175 : 		_PUSH_FRONT_END;
; 1176 : 		}
; 1177 : 
; 1178 : 	void push_back(value_type&& _Val)
; 1179 : 		{	// insert element at end
; 1180 : 		this->_Orphan_all();
; 1181 : 		_PUSH_BACK_BEGIN;
; 1182 : 		this->_Getal().construct(
; 1183 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ,
; 1184 : 			_STD forward<value_type>(_Val));
; 1185 : 		_PUSH_BACK_END;
; 1186 : 		}
; 1187 : 
; 1188 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1189 : 		{	// insert _Val at _Where
; 1190 : 		return (emplace(_Where, _STD move(_Val)));
; 1191 : 		}
; 1192 : 
; 1193 : 	template<class... _Valty>
; 1194 : 		void emplace_front(_Valty&&... _Val)
; 1195 : 		{	// insert element at beginning
; 1196 : 		this->_Orphan_all();
; 1197 : 		_PUSH_FRONT_BEGIN;
; 1198 : 		this->_Getal().construct(
; 1199 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ,
; 1200 : 			_STD forward<_Valty>(_Val)...);
; 1201 : 		_PUSH_FRONT_END;
; 1202 : 		}
; 1203 : 
; 1204 : 	template<class... _Valty>
; 1205 : 		void emplace_back(_Valty&&... _Val)
; 1206 : 		{	// insert element at end
; 1207 : 		this->_Orphan_all();
; 1208 : 		_PUSH_BACK_BEGIN;
; 1209 : 		this->_Getal().construct(
; 1210 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ,
; 1211 : 			_STD forward<_Valty>(_Val)...);
; 1212 : 		_PUSH_BACK_END;
; 1213 : 		}
; 1214 : 
; 1215 : 	template<class... _Valty>
; 1216 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1217 : 		{	// insert element at _Where
; 1218 : 		size_type _Off = _Where - begin();
; 1219 : 
; 1220 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1221 : 		if (this->_Mysize() < _Off)
; 1222 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1223 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1224 : 
; 1225 : 		if (_Off <= this->_Mysize() / 2)
; 1226 : 			{	// closer to front, push to front then rotate
; 1227 : 			emplace_front(_STD forward<_Valty>(_Val)...);
; 1228 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off);
; 1229 : 			}
; 1230 : 		else
; 1231 : 			{	// closer to back, push to back then rotate
; 1232 : 			emplace_back(_STD forward<_Valty>(_Val)...);
; 1233 : 			_STD rotate(begin() + _Off, end() - 1, end());
; 1234 : 			}
; 1235 : 		return (begin() + _Off);
; 1236 : 		}
; 1237 : 
; 1238 : 
; 1239 : 	deque(_XSTD initializer_list<value_type> _Ilist,
; 1240 : 		const _Alloc& _Al = allocator_type())
; 1241 : 		: _Mybase(_Al)
; 1242 : 		{	// construct from initializer_list
; 1243 : 		_Construct(_Ilist.begin(), _Ilist.end());
; 1244 : 		}
; 1245 : 
; 1246 : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 1247 : 		{	// assign initializer_list
; 1248 : 		assign(_Ilist.begin(), _Ilist.end());
; 1249 : 		return (*this);
; 1250 : 		}
; 1251 : 
; 1252 : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 1253 : 		{	// assign initializer_list
; 1254 : 		assign(_Ilist.begin(), _Ilist.end());
; 1255 : 		}
; 1256 : 
; 1257 : 	iterator insert(const_iterator _Where,
; 1258 : 		_XSTD initializer_list<value_type> _Ilist)
; 1259 : 		{	// insert initializer_list
; 1260 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1261 : 		}
; 1262 : 
; 1263 : 	~deque() _NOEXCEPT
; 1264 : 		{	// destroy the deque
; 1265 : 		_Tidy();
; 1266 : 		}
; 1267 : 
; 1268 : 	_Myt& operator=(const _Myt& _Right)
; 1269 : 		{	// assign _Right
; 1270 : 		if (this != &_Right)
; 1271 : 			{	// different, assign it
; 1272 : 			if (this->_Getal() != _Right._Getal()
; 1273 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1274 : 				{	// change allocator before copying
; 1275 : 				_Tidy();
; 1276 : 				this->_Copy_alloc(_Right._Getal());
; 1277 : 				}
; 1278 : 
; 1279 : 			this->_Orphan_all();
; 1280 : 
; 1281 : 			if (_Right._Mysize() == 0)
; 1282 : 				clear();
; 1283 : 			else if (_Right._Mysize() <= this->_Mysize())
; 1284 : 				{	// enough elements, copy new and destroy old
; 1285 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1286 : 					begin());
; 1287 : 				erase(_Mid, end());
; 1288 : 				}
; 1289 : 			else
; 1290 : 				{	// new sequence longer, copy and construct new
; 1291 : 				const_iterator _Mid = _Right.begin() + this->_Mysize();
; 1292 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1293 : 				insert(end(), _Mid, _Right.end());
; 1294 : 				}
; 1295 : 			}
; 1296 : 		return (*this);
; 1297 : 		}
; 1298 : 
; 1299 : 	iterator begin() _NOEXCEPT
; 1300 : 		{	// return iterator for beginning of mutable sequence
; 1301 : 		return (iterator(this->_Myoff(), &this->_Get_data()));
; 1302 : 		}
; 1303 : 
; 1304 : 	const_iterator begin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of nonmutable sequence
; 1306 : 		return (const_iterator(this->_Myoff(), &this->_Get_data()));
; 1307 : 		}
; 1308 : 
; 1309 : 	iterator end() _NOEXCEPT
; 1310 : 		{	// return iterator for end of mutable sequence
; 1311 : 		return (iterator(this->_Myoff() + this->_Mysize(),
; 1312 : 			&this->_Get_data()));
; 1313 : 		}
; 1314 : 
; 1315 : 	const_iterator end() const _NOEXCEPT
; 1316 : 		{	// return iterator for end of nonmutable sequence
; 1317 : 		return (const_iterator(this->_Myoff() + this->_Mysize(),
; 1318 : 			&this->_Get_data()));
; 1319 : 		}
; 1320 : 
; 1321 : 	iterator _Make_iter(const_iterator _Where) const
; 1322 : 		{	// make iterator from const_iterator
; 1323 : 		return (iterator(_Where._Myoff, &this->_Get_data()));
; 1324 : 		}
; 1325 : 
; 1326 : 	reverse_iterator rbegin() _NOEXCEPT
; 1327 : 		{	// return iterator for beginning of reversed mutable sequence
; 1328 : 		return (reverse_iterator(end()));
; 1329 : 		}
; 1330 : 
; 1331 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1332 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1333 : 		return (const_reverse_iterator(end()));
; 1334 : 		}
; 1335 : 
; 1336 : 	reverse_iterator rend() _NOEXCEPT
; 1337 : 		{	// return iterator for end of reversed mutable sequence
; 1338 : 		return (reverse_iterator(begin()));
; 1339 : 		}
; 1340 : 
; 1341 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1342 : 		{	// return iterator for end of reversed nonmutable sequence
; 1343 : 		return (const_reverse_iterator(begin()));
; 1344 : 		}
; 1345 : 
; 1346 : 	const_iterator cbegin() const _NOEXCEPT
; 1347 : 		{	// return iterator for beginning of nonmutable sequence
; 1348 : 		return (begin());
; 1349 : 		}
; 1350 : 
; 1351 : 	const_iterator cend() const _NOEXCEPT
; 1352 : 		{	// return iterator for end of nonmutable sequence
; 1353 : 		return (end());
; 1354 : 		}
; 1355 : 
; 1356 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1357 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1358 : 		return (rbegin());
; 1359 : 		}
; 1360 : 
; 1361 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1362 : 		{	// return iterator for end of reversed nonmutable sequence
; 1363 : 		return (rend());
; 1364 : 		}
; 1365 : 
; 1366 : 	void shrink_to_fit()
; 1367 : 		{	// reduce capacity
; 1368 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize();
; 1369 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1370 : 
; 1371 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1372 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1373 : 
; 1374 : 		if ((empty() && 0 < this->_Mapsize())
; 1375 : 			|| (!empty()
; 1376 : 				&& size() <= _Newcapacity
; 1377 : 				&& _Newcapacity < _Oldcapacity))
; 1378 : 			{	// worth shrinking, do it
; 1379 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1380 : 				_STD make_move_iterator(end()));
; 1381 : 			swap(_Tmp);
; 1382 : 			}
; 1383 : 		}
; 1384 : 
; 1385 : 	void resize(size_type _Newsize)
; 1386 : 		{	// determine new length, padding as needed
; 1387 : 		while (this->_Mysize() < _Newsize)
; 1388 : 			emplace_back();
; 1389 : 
; 1390 : 		while (_Newsize < this->_Mysize())
; 1391 : 			pop_back();
; 1392 : 		}
; 1393 : 
; 1394 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1395 : 		{	// determine new length, padding with _Val elements as needed
; 1396 : 		while (this->_Mysize() < _Newsize)
; 1397 : 			push_back(_Val);
; 1398 : 		while (_Newsize < this->_Mysize())
; 1399 : 			pop_back();
; 1400 : 		}
; 1401 : 
; 1402 : 	size_type size() const _NOEXCEPT
; 1403 : 		{	// return length of sequence
; 1404 : 		return (this->_Mysize());
; 1405 : 		}
; 1406 : 
; 1407 : 	size_type max_size() const _NOEXCEPT
; 1408 : 		{	// return maximum possible length of sequence
; 1409 : 		return (this->_Getal().max_size());
; 1410 : 		}
; 1411 : 
; 1412 : 	bool empty() const _NOEXCEPT
; 1413 : 		{	// test if sequence is empty
; 1414 : 		return (this->_Mysize() == 0);
; 1415 : 		}
; 1416 : 
; 1417 : 	allocator_type get_allocator() const _NOEXCEPT
; 1418 : 		{	// return allocator object for values
; 1419 : 		return (this->_Getal());
; 1420 : 		}
; 1421 : 
; 1422 : 	const_reference at(size_type _Pos) const
; 1423 : 		{	// subscript nonmutable sequence with checking
; 1424 : 		if (this->_Mysize() <= _Pos)
; 1425 : 			_Xran();
; 1426 : 		return (*(begin() + _Pos));
; 1427 : 		}
; 1428 : 
; 1429 : 	reference at(size_type _Pos)
; 1430 : 		{	// subscript mutable sequence with checking
; 1431 : 		if (this->_Mysize() <= _Pos)
; 1432 : 			_Xran();
; 1433 : 		return (*(begin() + _Pos));
; 1434 : 		}
; 1435 : 
; 1436 : 	const_reference operator[](size_type _Pos) const
; 1437 : 		{	// subscript nonmutable sequence
; 1438 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1439 : 		if (this->_Mysize() <= _Pos)
; 1440 : 			_DEBUG_ERROR("deque subscript out of range");
; 1441 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1442 : 
; 1443 : 		return (*(begin() + _Pos));
; 1444 : 		}
; 1445 : 
; 1446 : 	reference operator[](size_type _Pos)
; 1447 : 		{	// subscript mutable sequence
; 1448 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1449 : 		if (this->_Mysize() <= _Pos)
; 1450 : 			_DEBUG_ERROR("deque subscript out of range");
; 1451 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1452 : 
; 1453 : 		return (*(begin() + _Pos));
; 1454 : 		}
; 1455 : 
; 1456 : 	reference front()
; 1457 : 		{	// return first element of mutable sequence
; 1458 : 		return (*begin());
; 1459 : 		}
; 1460 : 
; 1461 : 	const_reference front() const
; 1462 : 		{	// return first element of nonmutable sequence
; 1463 : 		return (*begin());
; 1464 : 		}
; 1465 : 
; 1466 : 	reference back()
; 1467 : 		{	// return last element of mutable sequence
; 1468 : 		return (*(end() - 1));
; 1469 : 		}
; 1470 : 
; 1471 : 	const_reference back() const
; 1472 : 		{	// return last element of nonmutable sequence
; 1473 : 		return (*(end() - 1));
; 1474 : 		}
; 1475 : 
; 1476 : 	void push_front(const value_type& _Val)
; 1477 : 		{	// insert element at beginning
; 1478 : 		this->_Orphan_all();
; 1479 : 		_PUSH_FRONT_BEGIN;
; 1480 : 		this->_Getal().construct(
; 1481 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1482 : 		_PUSH_FRONT_END;
; 1483 : 		}
; 1484 : 
; 1485 : 	void pop_front()
; 1486 : 		{	// erase element at beginning
; 1487 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1488 : 		if (empty())
; 1489 : 			_DEBUG_ERROR("deque empty before pop");
; 1490 : 		else
; 1491 : 			{	// something to erase, do it
; 1492 : 			_Orphan_off(this->_Myoff());
; 1493 : 			size_type _Block = this->_Getblock(this->_Myoff());
; 1494 : 			this->_Getal().destroy(
; 1495 : 				this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ);
; 1496 : 			if (--this->_Mysize() == 0)
; 1497 : 				this->_Myoff() = 0;
; 1498 : 			else
; 1499 : 				++this->_Myoff();
; 1500 : 			}
; 1501 : 
; 1502 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1503 : 		size_type _Block = this->_Getblock(this->_Myoff());
; 1504 : 		this->_Getal().destroy(
; 1505 : 			this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ);
; 1506 : 		if (--this->_Mysize() == 0)
; 1507 : 			this->_Myoff() = 0;
; 1508 : 		else
; 1509 : 			++this->_Myoff();
; 1510 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1511 : 		}
; 1512 : 
; 1513 : 	void push_back(const value_type& _Val)
; 1514 : 		{	// insert element at end
; 1515 : 		this->_Orphan_all();
; 1516 : 		_PUSH_BACK_BEGIN;
; 1517 : 		this->_Getal().construct(
; 1518 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1519 : 		_PUSH_BACK_END;
; 1520 : 		}
; 1521 : 
; 1522 : 	void pop_back()
; 1523 : 		{	// erase element at end
; 1524 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1525 : 		if (empty())
; 1526 : 			_DEBUG_ERROR("deque empty before pop");
; 1527 : 		else
; 1528 : 			{	// something to erase, do it
; 1529 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1530 : 			_Orphan_off(_Newoff);
; 1531 : 			size_type _Block = this->_Getblock(_Newoff);
; 1532 : 			this->_Getal().destroy(
; 1533 : 				this->_Map()[_Block] + _Newoff % _DEQUESIZ);
; 1534 : 			if (--this->_Mysize() == 0)
; 1535 : 				this->_Myoff() = 0;
; 1536 : 			}
; 1537 : 
; 1538 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1540 : 		size_type _Block = this->_Getblock(_Newoff);
; 1541 : 		this->_Getal().destroy(
; 1542 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ);
; 1543 : 		if (--this->_Mysize() == 0)
; 1544 : 			this->_Myoff() = 0;
; 1545 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1546 : 		}
; 1547 : 
; 1548 : 	template<class _Iter>
; 1549 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1550 : 			void>::type
; 1551 : 		assign(_Iter _First, _Iter _Last)
; 1552 : 		{	// assign [_First, _Last), input iterators
; 1553 : 		clear();
; 1554 : 
; 1555 : 		for (; _First != _Last; ++_First)
; 1556 : 			emplace_back(*_First);
; 1557 : 		}
; 1558 : 
; 1559 : 	void assign(size_type _Count, const value_type& _Val)
; 1560 : 		{	// assign _Count * _Val
; 1561 : 		erase(begin(), end());
; 1562 : 		_Insert_n(begin(), _Count, _Val);
; 1563 : 		}
; 1564 : 
; 1565 : 	iterator insert(const_iterator _Where,
; 1566 : 		const value_type& _Val)
; 1567 : 		{	// insert _Val at _Where
; 1568 : 		size_type _Off = _Where - begin();
; 1569 : 
; 1570 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1571 : 		if (this->_Mysize() < _Off)
; 1572 : 			_DEBUG_ERROR("deque insert iterator outside range");
; 1573 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1574 : 
; 1575 : 		if (_Off <= this->_Mysize() / 2)
; 1576 : 			{	// closer to front, push to front then copy
; 1577 : 			push_front(_Val);
; 1578 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off);
; 1579 : 			}
; 1580 : 		else
; 1581 : 			{	// closer to back, push to back then copy
; 1582 : 			push_back(_Val);
; 1583 : 			_STD rotate(begin() + _Off, end() - 1, end());
; 1584 : 			}
; 1585 : 		return (begin() + _Off);
; 1586 : 		}
; 1587 : 
; 1588 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1589 : 		const value_type& _Val)
; 1590 : 		{	// insert _Count * _Val at _Where
; 1591 : 		size_type _Off = _Where - begin();
; 1592 : 		_Insert_n(_Where, _Count, _Val);
; 1593 : 		return (begin() + _Off);
; 1594 : 		}
; 1595 : 
; 1596 : 	template<class _Iter>
; 1597 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1598 : 			iterator>::type
; 1599 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1600 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1601 : 		size_type _Off = _Where - begin();
; 1602 : 
; 1603 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1604 : 		if (this->_Mysize() < _Off)
; 1605 : 			_DEBUG_ERROR("deque insert iterator outside range");
; 1606 : 		_DEBUG_RANGE(_First, _Last);
; 1607 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1608 : 
; 1609 : 		size_type _Oldsize = this->_Mysize();
; 1610 : 
; 1611 : 		if (_First == _Last)
; 1612 : 			;
; 1613 : 		else if (_Off <= this->_Mysize() / 2)
; 1614 : 			{	// closer to front, push to front then rotate
; 1615 : 			_TRY_BEGIN
; 1616 : 			for (; _First != _Last; ++_First)
; 1617 : 				push_front(*_First);	// prepend flipped
; 1618 : 
; 1619 : 			_CATCH_ALL
; 1620 : 			for (; _Oldsize < this->_Mysize(); )
; 1621 : 				pop_front();	// restore old size, at least
; 1622 : 			_RERAISE;
; 1623 : 			_CATCH_END
; 1624 : 
; 1625 : 			size_type _Num = this->_Mysize() - _Oldsize;
; 1626 : 			_STD reverse(begin(), begin() + _Num);	// flip new stuff in place
; 1627 : 			_STD rotate(begin(), begin() + _Num, begin() + _Num + _Off);
; 1628 : 			}
; 1629 : 		else
; 1630 : 			{	// closer to back
; 1631 : 			_TRY_BEGIN
; 1632 : 			for (; _First != _Last; ++_First)
; 1633 : 				push_back(*_First);	// append
; 1634 : 
; 1635 : 			_CATCH_ALL
; 1636 : 			for (; _Oldsize < this->_Mysize(); )
; 1637 : 				pop_back();	// restore old size, at least
; 1638 : 			_RERAISE;
; 1639 : 			_CATCH_END
; 1640 : 
; 1641 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1642 : 			}
; 1643 : 		return (begin() + _Off);
; 1644 : 		}
; 1645 : 
; 1646 : 	iterator erase(const_iterator _Where)
; 1647 : 		{	// erase element at _Where
; 1648 : 		return (erase(_Where, _Where + 1));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator erase(const_iterator _First_arg,
; 1652 : 		const_iterator _Last_arg)
; 1653 : 		{	// erase [_First, _Last)
; 1654 : 		iterator _First = _Make_iter(_First_arg);
; 1655 : 		iterator _Last = _Make_iter(_Last_arg);
; 1656 : 
; 1657 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1658 : 		if (_Last < _First
; 1659 : 			|| _First < begin() || end() < _Last)
; 1660 : 			_DEBUG_ERROR("deque erase iterator outside range");
; 1661 : 		_DEBUG_RANGE(_First, _Last);
; 1662 : 
; 1663 : 		size_type _Off = _First - begin();
; 1664 : 		size_type _Count = _Last - _First;
; 1665 : 		bool _Moved = 0 < _Off && _Off + _Count < this->_Mysize();
; 1666 : 
; 1667 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1668 : 		size_type _Off = _First - begin();
; 1669 : 		size_type _Count = _Last - _First;
; 1670 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1671 : 
; 1672 : 		if (_Off < (size_type)(end() - _Last))
; 1673 : 			{	// closer to front
; 1674 : 			_Move_backward(begin(), _First, _Last);	// copy over hole
; 1675 : 			for (; 0 < _Count; --_Count)
; 1676 : 				pop_front();	// pop copied elements
; 1677 : 			}
; 1678 : 		else
; 1679 : 			{	// closer to back
; 1680 : 			_Move(_Last, end(), _First);	// copy over hole
; 1681 : 			for (; 0 < _Count; --_Count)
; 1682 : 				pop_back();	// pop copied elements
; 1683 : 			}
; 1684 : 
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_Moved)
; 1687 : 			this->_Orphan_all();
; 1688 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1689 : 
; 1690 : 		return (begin() + _Off);
; 1691 : 		}
; 1692 : 
; 1693 : 	void clear() _NOEXCEPT
; 1694 : 		{	// erase all
; 1695 : 		_Tidy();
; 1696 : 		}
; 1697 : 
; 1698 : 	void swap(_Myt& _Right)
; 1699 : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 1700 : 		{	// exchange contents with _Right
; 1701 : 		if (this == &_Right)
; 1702 : 			;	// same object, do nothing
; 1703 : 		else if (this->_Getal() == _Right._Getal())
; 1704 : 			{	// same allocator, swap control information
; 1705 : 			this->_Swap_all(_Right);
; 1706 : 			_Swap_adl(this->_Map(), _Right._Map());
; 1707 : 			_STD swap(this->_Mapsize(), _Right._Mapsize());
; 1708 : 			_STD swap(this->_Myoff(), _Right._Myoff());
; 1709 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1710 : 			}
; 1711 : 
; 1712 : 		else if (_Alty::propagate_on_container_swap::value)
; 1713 : 			{	// swap allocators and control information
; 1714 : 			this->_Swap_alloc(_Right);
; 1715 : 			_Swap_adl(this->_Map(), _Right._Map());
; 1716 : 			_STD swap(this->_Mapsize(), _Right._Mapsize());
; 1717 : 			_STD swap(this->_Myoff(), _Right._Myoff());
; 1718 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1719 : 			}
; 1720 : 		else
; 1721 : 			{	// containers are incompatible
; 1722 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1723 : 			_DEBUG_ERROR("deque containers incompatible for swap");
; 1724 : 
; 1725 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1726 : 			_XSTD terminate();
; 1727 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1728 : 			}
; 1729 : 
; 1730 : 		}
; 1731 : 
; 1732 : protected:
; 1733 : 	void _Insert_n(const_iterator _Where,
; 1734 : 		size_type _Count, const value_type& _Val)
; 1735 : 		{	// insert _Count * _Val at _Where
; 1736 : 		iterator _Mid;
; 1737 : 		size_type _Num;
; 1738 : 		size_type _Off = _Where - begin();
; 1739 : 		size_type _Rem = this->_Mysize() - _Off;
; 1740 : 		size_type _Oldsize = this->_Mysize();
; 1741 : 
; 1742 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1743 : 		if (this->_Mysize() < _Off)
; 1744 : 			_DEBUG_ERROR("deque insert iterator outside range");
; 1745 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1746 : 
; 1747 : 		if (_Off < _Rem)
; 1748 : 			{	// closer to front
; 1749 : 			_TRY_BEGIN
; 1750 : 			if (_Off < _Count)
; 1751 : 				{	// insert longer than prefix
; 1752 : 				for (_Num = _Count - _Off; 0 < _Num; --_Num)
; 1753 : 					push_front(_Val);	// push excess values
; 1754 : 				for (_Num = _Off; 0 < _Num; --_Num)
; 1755 : 					push_front(begin()[_Count - 1]);	// push prefix
; 1756 : 
; 1757 : 				_Mid = begin() + _Count;
; 1758 : 				_STD fill(_Mid, _Mid + _Off,
; 1759 : 					_Val);	// fill in rest of values
; 1760 : 				}
; 1761 : 			else
; 1762 : 				{	// insert not longer than prefix
; 1763 : 				for (_Num = _Count; 0 < _Num; --_Num)
; 1764 : 					push_front(begin()[_Count - 1]);	// push part of prefix
; 1765 : 
; 1766 : 				_Mid = begin() + _Count;
; 1767 : 				value_type _Tmp = _Val;	// in case _Val is in sequence
; 1768 : 				_Move(_Mid + _Count, _Mid + _Off,
; 1769 : 					_Mid);	// copy rest of prefix
; 1770 : 				_STD fill(begin() + _Off, _Mid + _Off,
; 1771 : 					_Tmp);	// fill in values
; 1772 : 				}
; 1773 : 			_CATCH_ALL
; 1774 : 			for (; _Oldsize < this->_Mysize(); )
; 1775 : 				pop_front();	// restore old size, at least
; 1776 : 			_RERAISE;
; 1777 : 			_CATCH_END
; 1778 : 			}
; 1779 : 		else
; 1780 : 			{		// closer to back
; 1781 : 			_TRY_BEGIN
; 1782 : 			if (_Rem < _Count)
; 1783 : 				{	// insert longer than suffix
; 1784 : 				for (_Num = _Count - _Rem; 0 < _Num; --_Num)
; 1785 : 					push_back(_Val);	// push excess values
; 1786 : 				for (_Num = 0; _Num < _Rem; ++_Num)
; 1787 : 					push_back(begin()[_Off + _Num]);	// push suffix
; 1788 : 
; 1789 : 				_Mid = begin() + _Off;
; 1790 : 				_STD fill(_Mid, _Mid + _Rem,
; 1791 : 					_Val);	// fill in rest of values
; 1792 : 				}
; 1793 : 			else
; 1794 : 				{	// insert not longer than prefix
; 1795 : 				for (_Num = 0; _Num < _Count; ++_Num)
; 1796 : 					push_back(begin()[_Off + _Rem
; 1797 : 						- _Count + _Num]);	// push part of prefix
; 1798 : 
; 1799 : 				_Mid = begin() + _Off;
; 1800 : 				value_type _Tmp = _Val;	// in case _Val is in sequence
; 1801 : 				_Move_backward(_Mid, _Mid + _Rem - _Count,
; 1802 : 					_Mid + _Rem);	// copy rest of prefix
; 1803 : 				_STD fill(_Mid, _Mid + _Count,
; 1804 : 					_Tmp);	// fill in values
; 1805 : 				}
; 1806 : 			_CATCH_ALL
; 1807 : 			for (; _Oldsize < this->_Mysize(); )
; 1808 : 				pop_back();	// restore old size, at least
; 1809 : 			_RERAISE;
; 1810 : 			_CATCH_END
; 1811 : 			}
; 1812 : 		}
; 1813 : 
; 1814 : 	[[noreturn]] void _Xlen() const
; 1815 : 		{	// report a length_error
; 1816 : 		_Xlength_error("deque<T> too long");

  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00156	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN374@Growmap:
$LN371@Growmap:
  0015b	cc		 int	 3
?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::deque<int,std::allocator<int> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::deque<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 1816 : 		_Xlength_error("deque<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$deque@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::deque<int,std::allocator<int> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@HV?$allocator@H@std@@@std@@QAEXXZ PROC ; std::deque<int,std::allocator<int> >::pop_back, COMDAT
; _this$ = ecx

; 1524 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1525 : 		if (empty())
; 1526 : 			_DEBUG_ERROR("deque empty before pop");
; 1527 : 		else
; 1528 : 			{	// something to erase, do it
; 1529 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1530 : 			_Orphan_off(_Newoff);
; 1531 : 			size_type _Block = this->_Getblock(_Newoff);
; 1532 : 			this->_Getal().destroy(
; 1533 : 				this->_Map()[_Block] + _Newoff % _DEQUESIZ);
; 1534 : 			if (--this->_Mysize() == 0)
; 1535 : 				this->_Myoff() = 0;
; 1536 : 			}
; 1537 : 
; 1538 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1540 : 		size_type _Block = this->_Getblock(_Newoff);
; 1541 : 		this->_Getal().destroy(
; 1542 : 			this->_Map()[_Block] + _Newoff % _DEQUESIZ);
; 1543 : 		if (--this->_Mysize() == 0)

  00000	83 41 10 ff	 add	 DWORD PTR [ecx+16], -1
  00004	75 07		 jne	 SHORT $LN2@pop_back

; 1544 : 			this->_Myoff() = 0;

  00006	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$LN2@pop_back:

; 1545 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1546 : 		}

  0000d	c3		 ret	 0
?pop_back@?$deque@HV?$allocator@H@std@@@std@@QAEXXZ ENDP ; std::deque<int,std::allocator<int> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::deque<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 1514 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1516 : 		_PUSH_BACK_BEGIN;

  00006	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00009	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000c	03 c1		 add	 eax, ecx
  0000e	a8 03		 test	 al, 3
  00010	75 14		 jne	 SHORT $LN2@push_back
  00012	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00015	c1 e8 02	 shr	 eax, 2
  00018	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  0001b	77 09		 ja	 SHORT $LN2@push_back
  0001d	6a 01		 push	 1
  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::deque<int,std::allocator<int> >::_Growmap
$LN2@push_back:
  00026	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00029	53		 push	 ebx
  0002a	57		 push	 edi
  0002b	8d 04 85 ff ff
	ff ff		 lea	 eax, DWORD PTR [eax*4-1]
  00032	21 46 0c	 and	 DWORD PTR [esi+12], eax
  00035	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00038	03 7e 0c	 add	 edi, DWORD PTR [esi+12]

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0003b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003e	8b c7		 mov	 eax, edi
  00040	c1 e8 02	 shr	 eax, 2
  00043	49		 dec	 ecx
  00044	23 c8		 and	 ecx, eax

; 1516 : 		_PUSH_BACK_BEGIN;

  00046	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00049	8d 1c 8d 00 00
	00 00		 lea	 ebx, DWORD PTR [ecx*4]
  00050	83 3c 03 00	 cmp	 DWORD PTR [ebx+eax], 0
  00054	75 16		 jne	 SHORT $LN3@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00056	6a 10		 push	 16			; 00000010H
  00058	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005d	8b c8		 mov	 ecx, eax
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c9		 test	 ecx, ecx
  00064	74 27		 je	 SHORT $LN171@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1516 : 		_PUSH_BACK_BEGIN;

  00066	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00069	89 0c 03	 mov	 DWORD PTR [ebx+eax], ecx
$LN3@push_back:

; 1517 : 		this->_Getal().construct(

  0006c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006f	83 e7 03	 and	 edi, 3
  00072	8b 04 03	 mov	 eax, DWORD PTR [ebx+eax]
  00075	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00078	5f		 pop	 edi
  00079	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0007a	85 c9		 test	 ecx, ecx
  0007c	74 07		 je	 SHORT $LN154@push_back
  0007e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	89 01		 mov	 DWORD PTR [ecx], eax
$LN154@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1519 : 		_PUSH_BACK_END;

  00085	ff 46 10	 inc	 DWORD PTR [esi+16]
  00088	5e		 pop	 esi

; 1520 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
$LN171@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0008d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN173@push_back:
$LN170@push_back:
  00092	cc		 int	 3
?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::deque<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?back@?$deque@HV?$allocator@H@std@@@std@@QAEAAHXZ
_TEXT	SEGMENT
$T1 = -24						; size = 12
$T2 = -12						; size = 12
?back@?$deque@HV?$allocator@H@std@@@std@@QAEAAHXZ PROC	; std::deque<int,std::allocator<int> >::back, COMDAT
; _this$ = ecx

; 1467 : 		{	// return last element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1468 : 		return (*(end() - 1));

  00006	8d 45 f4	 lea	 eax, DWORD PTR $T2[ebp]
  00009	56		 push	 esi
  0000a	6a 01		 push	 1
  0000c	50		 push	 eax
  0000d	8d 45 e8	 lea	 eax, DWORD PTR $T1[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0001d	8b 30		 mov	 esi, DWORD PTR [eax]
  0001f	85 f6		 test	 esi, esi
  00021	74 02		 je	 SHORT $LN10@back
$LN9@back:
  00023	8b 36		 mov	 esi, DWORD PTR [esi]
$LN10@back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00025	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00028	8b ca		 mov	 ecx, edx
  0002a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002d	48		 dec	 eax
  0002e	c1 e9 02	 shr	 ecx, 2
  00031	23 c8		 and	 ecx, eax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  00033	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00036	83 e2 03	 and	 edx, 3
  00039	5e		 pop	 esi
  0003a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0003d	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1469 : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?back@?$deque@HV?$allocator@H@std@@@std@@QAEAAHXZ ENDP	; std::deque<int,std::allocator<int> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?empty@?$deque@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@HV?$allocator@H@std@@@std@@QBE_NXZ PROC	; std::deque<int,std::allocator<int> >::empty, COMDAT
; _this$ = ecx

; 1414 : 		return (this->_Mysize() == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 1415 : 		}

  00008	c3		 ret	 0
?empty@?$deque@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::deque<int,std::allocator<int> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?max_size@?$deque@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::deque<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1409 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1410 : 		}

  00005	c3		 ret	 0
?max_size@?$deque@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::deque<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@2@XZ PROC ; std::deque<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 1310 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1311 : 		return (iterator(this->_Myoff() + this->_Mysize(),

  00006	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00009	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 171  : 			_Myproxy = _Parent_proxy;

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 171  : 			_Myproxy = _Parent_proxy;

  00015	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 305  : 		_Myoff = _Off;

  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1312 : 			&this->_Get_data()));
; 1313 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@2@XZ ENDP ; std::deque<int,std::allocator<int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$deque@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 1264 : 		{	// destroy the deque

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1265 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 877  : 		_Myproxy() = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 1266 : 		}

  00019	c3		 ret	 0
??1?$deque@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::deque<int,std::allocator<int> >::deque<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 1000 : 		{	// construct empty deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00007	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1000 : 		{	// construct empty deque

  00009	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 777  : 		_Map = _Mapptr();

  00012	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 778  : 		_Mapsize = 0;

  00019	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 779  : 		_Myoff = 0;

  00020	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 780  : 		_Mysize = 0;

  00027	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00036	85 c0		 test	 eax, eax
  00038	74 1a		 je	 SHORT $LN99@deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 865  : 		_Myproxy() = _Alproxy.allocate(1);

  0003a	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0003c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00042	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 867  : 		_Myproxy()->_Mycont = &_Get_data();

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 1001 : 		}

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN99@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN101@deque:
$LN98@deque:
  00059	cc		 int	 3
??0?$deque@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::deque<int,std::allocator<int> >::deque<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Deque_val<std::_Deque_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<int> >::~_Deque_val<std::_Deque_simple_types<int> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<int> >::~_Deque_val<std::_Deque_simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<int> >::_Getblock, COMDAT
; _this$ = ecx

; 784  : 		{	// determine block from offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 785  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	48		 dec	 eax
  0000a	c1 e9 02	 shr	 ecx, 2
  0000d	23 c1		 and	 eax, ecx

; 787  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<int> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<int> >::_Deque_val<std::_Deque_simple_types<int> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 781  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00024	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<int> >::_Deque_val<std::_Deque_simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Mysize, COMDAT
; _this$ = ecx

; 962  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 963  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Mysize, COMDAT
; _this$ = ecx

; 957  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 958  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Myoff, COMDAT
; _this$ = ecx

; 947  : 		return (_Get_data()._Myoff);

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 948  : 		}

  00003	c3		 ret	 0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Mapsize, COMDAT
; _this$ = ecx

; 937  : 		return (_Get_data()._Mapsize);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 938  : 		}

  00003	c3		 ret	 0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAPAHXZ
_TEXT	SEGMENT
?_Map@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAPAHXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Map, COMDAT
; _this$ = ecx

; 927  : 		return (_Get_data()._Map);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 928  : 		}

  00003	c3		 ret	 0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAPAHXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Map
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 922  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 923  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 917  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 918  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@H@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Getal, COMDAT
; _this$ = ecx

; 912  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 913  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Getal, COMDAT
; _this$ = ecx

; 907  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 908  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 897  : 		_Get_data()._Orphan_all();
; 898  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Myproxy, COMDAT
; _this$ = ecx

; 887  : 		return (_Get_data()._Myproxy);

  00000	8b c1		 mov	 eax, ecx

; 888  : 		}

  00002	c3		 ret	 0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 871  : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 877  : 		_Myproxy() = 0;

  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 878  : 		}

  00014	c3		 ret	 0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 862  : 		{	// construct proxy

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00001	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 862  : 		{	// construct proxy

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0000d	85 c0		 test	 eax, eax
  0000f	74 15		 je	 SHORT $LN80@Alloc_prox
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 865  : 		_Myproxy() = _Alproxy.allocate(1);

  00011	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 867  : 		_Myproxy()->_Mycont = &_Get_data();

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	89 30		 mov	 DWORD PTR [eax], esi
  00024	5e		 pop	 esi

; 868  : 		}

  00025	c3		 ret	 0
$LN80@Alloc_prox:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00026	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN82@Alloc_prox:
$LN79@Alloc_prox:
  0002b	cc		 int	 3
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::~_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 837  : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 877  : 		_Myproxy() = 0;

  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 838  : 		_Free_proxy();
; 839  : 		}

  00014	c3		 ret	 0
??1?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::~_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 825  : 		{	// construct allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00003	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 777  : 		_Map = _Mapptr();

  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 778  : 		_Mapsize = 0;

  00012	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 779  : 		_Myoff = 0;

  00019	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 780  : 		_Mysize = 0;

  00020	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0002f	85 c0		 test	 eax, eax
  00031	74 19		 je	 SHORT $LN92@Deque_allo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 865  : 		_Myproxy() = _Alproxy.allocate(1);

  00033	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 867  : 		_Myproxy()->_Mycont = &_Get_data();

  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	89 30		 mov	 DWORD PTR [eax], esi

; 827  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	c2 04 00	 ret	 4
$LN92@Deque_allo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN94@Deque_allo:
$LN91@Deque_allo:
  00051	cc		 int	 3
??0?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Getblock, COMDAT
; _this$ = ecx

; 819  : 		{	// determine block from offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	48		 dec	 eax
  0000a	c1 e9 02	 shr	 ecx, 2
  0000d	23 c1		 and	 eax, ecx

; 820  : 		return (_Get_data()._Getblock(_Off));
; 821  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@HV?$allocator@H@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<int,std::allocator<int> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEXPAPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEXPAPAHI@Z PROC ; std::_Wrap_alloc<std::allocator<int *> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEXPAPAHI@Z ENDP ; std::_Wrap_alloc<std::allocator<int *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEPAPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEPAPAHI@Z PROC ; std::_Wrap_alloc<std::allocator<int *> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z ; std::allocator<int *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAH@std@@@std@@QAEPAPAHI@Z ENDP ; std::_Wrap_alloc<std::allocator<int *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z PROC		; std::allocator<int *>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00013	77 3c		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	c1 e0 02	 shl	 eax, 2

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z ENDP		; std::allocator<int *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAH@std@@QAEXPAPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAH@std@@QAEXPAPAHI@Z PROC	; std::allocator<int *>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@PAH@std@@QAEXPAPAHI@Z ENDP	; std::allocator<int *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::allocator_traits<std::allocator<int> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00013	77 3c		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	c1 e0 02	 shl	 eax, 2

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?SyncUnlock@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?SyncUnlock@CQueueTimer@@QAEXXZ PROC			; CQueueTimer::SyncUnlock, COMDAT
; _this$ = ecx

; 82   : 	this->m_sync.Unlock();

  00000	83 c1 20	 add	 ecx, 32			; 00000020H
  00003	e9 00 00 00 00	 jmp	 ?Unlock@TSync@@QAEXXZ	; TSync::Unlock
?SyncUnlock@CQueueTimer@@QAEXXZ ENDP			; CQueueTimer::SyncUnlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?SyncLock@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?SyncLock@CQueueTimer@@QAEXXZ PROC			; CQueueTimer::SyncLock, COMDAT
; _this$ = ecx

; 77   : 	this->m_sync.Lock();

  00000	83 c1 20	 add	 ecx, 32			; 00000020H
  00003	e9 00 00 00 00	 jmp	 ?Lock@TSync@@QAEXXZ	; TSync::Lock
?SyncLock@CQueueTimer@@QAEXXZ ENDP			; CQueueTimer::SyncLock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?DeleteQueueTimer@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?DeleteQueueTimer@CQueueTimer@@QAEXXZ PROC		; CQueueTimer::DeleteQueueTimer, COMDAT
; _this$ = ecx

; 70   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 71   : 	DeleteTimerQueue(this->m_timerqueue);

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteTimerQueue@4

; 72   : 	this->m_timerqueue = INVALID_HANDLE_VALUE;

  0000c	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  00013	5e		 pop	 esi

; 73   : }

  00014	c3		 ret	 0
?DeleteQueueTimer@CQueueTimer@@QAEXXZ ENDP		; CQueueTimer::DeleteQueueTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?CreateTimer@CQueueTimer@@QAEHHKK@Z
_TEXT	SEGMENT
_hTimer$ = -4						; size = 4
_eventID$ = 8						; size = 4
_period$ = 12						; size = 4
_flags$ = 16						; size = 4
?CreateTimer@CQueueTimer@@QAEHHKK@Z PROC		; CQueueTimer::CreateTimer, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 54   : 	HANDLE hTimer = INVALID_HANDLE_VALUE;
; 55   : 	int* tmpEventID;
; 56   : 	int result;
; 57   : 
; 58   : 	this->PushEventID(eventID);

  00006	ff 75 08	 push	 DWORD PTR _eventID$[ebp]
  00009	8b f9		 mov	 edi, ecx
  0000b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _hTimer$[ebp], -1
  00012	e8 00 00 00 00	 call	 ?PushEventID@CQueueTimer@@QAEXH@Z ; CQueueTimer::PushEventID

; 59   : 	tmpEventID = this->GetEvenetID();

  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?GetEvenetID@CQueueTimer@@QAEPAHXZ ; CQueueTimer::GetEvenetID

; 60   : 
; 61   : 	result = CreateTimerQueueTimer(&hTimer,this->m_timerqueue,(WAITORTIMERCALLBACK)this->m_callback,tmpEventID,1000,period,flags);

  0001e	ff 75 10	 push	 DWORD PTR _flags$[ebp]
  00021	ff 75 0c	 push	 DWORD PTR _period$[ebp]
  00024	68 e8 03 00 00	 push	 1000			; 000003e8H
  00029	50		 push	 eax
  0002a	ff 77 04	 push	 DWORD PTR [edi+4]
  0002d	8d 45 fc	 lea	 eax, DWORD PTR _hTimer$[ebp]
  00030	ff 77 08	 push	 DWORD PTR [edi+8]
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateTimerQueueTimer@28
  0003a	8b f0		 mov	 esi, eax

; 62   : 
; 63   : 	if( !result )

  0003c	85 f6		 test	 esi, esi
  0003e	75 09		 jne	 SHORT $LN2@CreateTime

; 64   : 		this->PopEventID();

  00040	8b cf		 mov	 ecx, edi
  00042	e8 00 00 00 00	 call	 ?PopEventID@CQueueTimer@@QAEXXZ ; CQueueTimer::PopEventID

; 65   : 
; 66   : return result;

  00047	8b c6		 mov	 eax, esi
$LN2@CreateTime:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 67   : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
?CreateTimer@CQueueTimer@@QAEHHKK@Z ENDP		; CQueueTimer::CreateTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?GetEvenetID@CQueueTimer@@QAEPAHXZ
_TEXT	SEGMENT
$T1 = -24						; size = 12
$T2 = -12						; size = 12
?GetEvenetID@CQueueTimer@@QAEPAHXZ PROC			; CQueueTimer::GetEvenetID, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1468 : 		return (*(end() - 1));

  00006	8d 45 f4	 lea	 eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 130  : 		return (c.back());

  00009	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000c	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1468 : 		return (*(end() - 1));

  0000d	6a 01		 push	 1
  0000f	50		 push	 eax
  00010	8d 45 e8	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
  00019	8b c8		 mov	 ecx, eax
  0001b	e8 00 00 00 00	 call	 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<int> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00020	8b 30		 mov	 esi, DWORD PTR [eax]
  00022	85 f6		 test	 esi, esi
  00024	74 02		 je	 SHORT $LN14@GetEvenetI
$LN13@GetEvenetI:
  00026	8b 36		 mov	 esi, DWORD PTR [esi]
$LN14@GetEvenetI:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 786  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00028	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002b	8b ca		 mov	 ecx, edx
  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	48		 dec	 eax
  00031	c1 e9 02	 shr	 ecx, 2
  00034	23 c8		 and	 ecx, eax

; 344  : 		return (_Mycont->_Map[_Block][_Off]);

  00036	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00039	83 e2 03	 and	 edx, 3
  0003c	5e		 pop	 esi
  0003d	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00040	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 50   : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GetEvenetID@CQueueTimer@@QAEPAHXZ ENDP			; CQueueTimer::GetEvenetID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?PopEventID@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?PopEventID@CQueueTimer@@QAEXXZ PROC			; CQueueTimer::PopEventID, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1543 : 		if (--this->_Mysize() == 0)

  00000	83 41 1c ff	 add	 DWORD PTR [ecx+28], -1
  00004	75 07		 jne	 SHORT $LN6@PopEventID

; 1544 : 			this->_Myoff() = 0;

  00006	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN6@PopEventID:
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 45   : }

  0000d	c3		 ret	 0
?PopEventID@CQueueTimer@@QAEXXZ ENDP			; CQueueTimer::PopEventID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?PushEventID@CQueueTimer@@QAEXH@Z
_TEXT	SEGMENT
_eventID$ = 8						; size = 4
?PushEventID@CQueueTimer@@QAEXH@Z PROC			; CQueueTimer::PushEventID, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 140  : 		c.push_back(_Val);

  00003	8d 45 08	 lea	 eax, DWORD PTR _eventID$[ebp]
  00006	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::deque<int,std::allocator<int> >::push_back
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 40   : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?PushEventID@CQueueTimer@@QAEXH@Z ENDP			; CQueueTimer::PushEventID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?QueueTimerInit@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?QueueTimerInit@CQueueTimer@@QAEXXZ PROC		; CQueueTimer::QueueTimerInit, COMDAT
; _this$ = ecx

; 33   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 34   : 	this->m_timerqueue = CreateTimerQueue();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateTimerQueue@0
  00009	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0000c	5e		 pop	 esi

; 35   : }

  0000d	c3		 ret	 0
?QueueTimerInit@CQueueTimer@@QAEXXZ ENDP		; CQueueTimer::QueueTimerInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ??1CQueueTimer@@UAE@XZ
_TEXT	SEGMENT
??1CQueueTimer@@UAE@XZ PROC				; CQueueTimer::~CQueueTimer, COMDAT
; _this$ = ecx

; 22   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 23   : 	if( this->m_timerqueue != INVALID_HANDLE_VALUE )

  00003	83 7e 08 ff	 cmp	 DWORD PTR [esi+8], -1
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CQueueTimer@@6B@
  0000d	74 05		 je	 SHORT $LN149@CQueueTime

; 24   : 	{
; 25   : 		this->DeleteQueueTimer();

  0000f	e8 00 00 00 00	 call	 ?DeleteQueueTimer@CQueueTimer@@QAEXXZ ; CQueueTimer::DeleteQueueTimer
$LN149@CQueueTime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1414 : 		return (this->_Mysize() == 0);

  00014	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 28   : 	while( this->m_stack.empty() == 0 )

  00018	74 19		 je	 SHORT $LN3@CQueueTime
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@CQueueTime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1543 : 		if (--this->_Mysize() == 0)

  00020	83 46 1c ff	 add	 DWORD PTR [esi+28], -1
  00024	75 07		 jne	 SHORT $LN23@CQueueTime

; 1544 : 			this->_Myoff() = 0;

  00026	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN23@CQueueTime:

; 1414 : 		return (this->_Mysize() == 0);

  0002d	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 28   : 	while( this->m_stack.empty() == 0 )

  00031	75 ed		 jne	 SHORT $LL2@CQueueTime
$LN3@CQueueTime:

; 30   : }

  00033	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00036	e8 00 00 00 00	 call	 ??1TSync@@QAE@XZ	; TSync::~TSync
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1265 : 		_Tidy();

  0003b	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0003e	e8 00 00 00 00	 call	 ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00043	ff 76 0c	 push	 DWORD PTR [esi+12]
  00046	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 877  : 		_Myproxy() = 0;

  0004e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00055	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 30   : }

  00056	c3		 ret	 0
??1CQueueTimer@@UAE@XZ ENDP				; CQueueTimer::~CQueueTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z
_TEXT	SEGMENT
_callback$ = 8						; size = 4
?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z PROC		; CQueueTimer::RegCallBack, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   : 	this->m_callback = callback;

  00003	8b 45 08	 mov	 eax, DWORD PTR _callback$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 19   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z ENDP		; CQueueTimer::RegCallBack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ??0CQueueTimer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CQueueTimer@@QAE@XZ PROC				; CQueueTimer::CQueueTimer, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CQueueTimer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
  0002f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CQueueTimer@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00035	6a 08		 push	 8
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 11   : {

  00037	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 777  : 		_Map = _Mapptr();

  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 778  : 		_Mapsize = 0;

  00047	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 779  : 		_Myoff = 0;

  0004e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 780  : 		_Mysize = 0;

  00055	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  0005c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00061	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00064	85 c0		 test	 eax, eax
  00066	75 05		 jne	 SHORT $LN44@CQueueTime
  00068	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN109@CQueueTime:
$LN44@CQueueTime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 865  : 		_Myproxy() = _Alproxy.allocate(1);

  0006d	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0006f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00075	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 867  : 		_Myproxy()->_Mycont = &_Get_data();

  0007c	8b 06		 mov	 eax, DWORD PTR [esi]
  0007e	89 30		 mov	 DWORD PTR [eax], esi
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp

; 11   : {

  00080	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008a	e8 00 00 00 00	 call	 ??0TSync@@QAE@XZ	; TSync::TSync

; 12   : 	this->m_callback = 0;
; 13   : 	this->QueueTimerInit();

  0008f	8b cf		 mov	 ecx, edi
  00091	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00098	e8 00 00 00 00	 call	 ?QueueTimerInit@CQueueTimer@@QAEXXZ ; CQueueTimer::QueueTimerInit

; 14   : }

  0009d	8b c7		 mov	 eax, edi
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a9	59		 pop	 ecx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN108@CQueueTime:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CQueueTimer@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
__ehhandler$??0CQueueTimer@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CQueueTimer@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CQueueTimer@@QAE@XZ ENDP				; CQueueTimer::CQueueTimer
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 01		 jne	 SHORT $LN3@Getcont

; 184  : 		}

  00006	c3		 ret	 0
$LN3@Getcont:

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00007	8b 00		 mov	 eax, DWORD PTR [eax]

; 184  : 		}

  00009	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 148  : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  : 		if (_Parent == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN3@Adopt

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Adopt:

; 172  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 173  : 			}
; 174  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

  00000	c3		 ret	 0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	39 01		 cmp	 DWORD PTR [ecx], eax
  0000a	74 0e		 je	 SHORT $LN12@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN12@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  00010	8b 00		 mov	 eax, DWORD PTR [eax]

; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

  00012	85 c0		 test	 eax, eax
  00014	74 04		 je	 SHORT $LN12@operator

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 01		 mov	 DWORD PTR [ecx], eax
$LN12@operator:

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 137  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 122  : 
; 123  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 124  : 		{	// assign an iterator
; 125  : 		if (_Myproxy == _Right._Myproxy)

  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	85 c0		 test	 eax, eax
  00017	74 0a		 je	 SHORT $LN15@Iterator_b

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

  00019	8b 00		 mov	 eax, DWORD PTR [eax]

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	~_Iterator_base12() _NOEXCEPT
; 140  : 		{	// destroy the iterator
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);
; 143  : 		_Orphan_me();
; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}
; 146  : 
; 147  : 	void _Adopt(const _Container_base12 *_Parent)
; 148  : 		{	// adopt this iterator by parent
; 149  : 		if (_Parent == 0)

  0001b	85 c0		 test	 eax, eax
  0001d	74 04		 je	 SHORT $LN15@Iterator_b

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);
; 153  : 			_Orphan_me();
; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else
; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)
; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);
; 164  : 				_Orphan_me();
; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 166  : 				_Parent_proxy->_Myfirstiter = this;
; 167  : 				_Myproxy = _Parent_proxy;
; 168  : 				}
; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 01		 mov	 DWORD PTR [ecx], eax
$LN15@Iterator_b:

; 120  : 		*this = _Right;
; 121  : 		}

  00023	8b c1		 mov	 eax, ecx
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 115  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != 0)
; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);
; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 222  : 			(*_Pnext)->_Myproxy = 0;
; 223  : 		_Myproxy->_Myfirstiter = 0;
; 224  : 		}
; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 95   : 		_Orphan_all();
; 96   : 		}

  00000	c3		 ret	 0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 81   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 67   : 		: _Mycont(0), _Myfirstiter(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 69   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 84   : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\queuetimer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 84   : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
