; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\ZTLogger.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??0ZTLogger@@QAE@PBD@Z				; ZTLogger::ZTLogger
PUBLIC	??1ZTLogger@@QAE@XZ				; ZTLogger::~ZTLogger
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?LuaLog@@3VZTLogger@@A				; LuaLog
PUBLIC	??_C@_0BA@GNAJCAIF@?4?2Log?2Scripting?$AA@	; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?LuaLog@@3VZTLogger@@A DB 04cH DUP (?)			; LuaLog
_BSS	ENDS
CRT$XCU	SEGMENT
?LuaLog$initializer$@@3P6AXXZA DD FLAT:??__ELuaLog@@YAXXZ ; LuaLog$initializer$
CRT$XCU	ENDS
;	COMDAT ??_C@_0BA@GNAJCAIF@?4?2Log?2Scripting?$AA@
CONST	SEGMENT
??_C@_0BA@GNAJCAIF@?4?2Log?2Scripting?$AA@ DB '.\Log\Scripting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ZTLogger@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ZTLogger@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ZTLogger@@QAE@PBD@Z$1
__ehfuncinfo$??0ZTLogger@@QAE@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ZTLogger@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$129 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$128 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$128
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$129
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FLuaLog@@YAXXZ
text$yd	SEGMENT
??__FLuaLog@@YAXXZ PROC					; `dynamic atexit destructor for 'LuaLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?LuaLog@@3VZTLogger@@A ; LuaLog
  00005	e9 00 00 00 00	 jmp	 ??1ZTLogger@@QAE@XZ	; ZTLogger::~ZTLogger
??__FLuaLog@@YAXXZ ENDP					; `dynamic atexit destructor for 'LuaLog''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.cpp
;	COMDAT ??__ELuaLog@@YAXXZ
text$di	SEGMENT
??__ELuaLog@@YAXXZ PROC					; `dynamic initializer for 'LuaLog'', COMDAT

; 4    : ZTLogger LuaLog(LOG_PATH_LUA);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GNAJCAIF@?4?2Log?2Scripting?$AA@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?LuaLog@@3VZTLogger@@A ; LuaLog
  0000a	e8 00 00 00 00	 call	 ??0ZTLogger@@QAE@PBD@Z	; ZTLogger::ZTLogger
  0000f	68 00 00 00 00	 push	 OFFSET ??__FLuaLog@@YAXXZ ; `dynamic atexit destructor for 'LuaLog''
  00014	e8 00 00 00 00	 call	 _atexit
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
??__ELuaLog@@YAXXZ ENDP					; `dynamic initializer for 'LuaLog''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
;	COMDAT ?Initialize@ZTLogger@@QAEXXZ
_TEXT	SEGMENT
?Initialize@ZTLogger@@QAEXXZ PROC			; ZTLogger::Initialize, COMDAT
; _this$ = ecx

; 18   : 	void Initialize() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00003	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 319  : 		return (_Myval2);

  00007	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  0000a	72 02		 jb	 SHORT $LN16@Initialize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN16@Initialize:
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h

; 19   : 		CreateDirectory(m_FilePath.c_str(), 0);

  0000e	6a 00		 push	 0
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8

; 20   : 		THREAD_LOCK_CREATE(&m_CriticalSection);

  00017	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  00021	5e		 pop	 esi

; 21   : 	}

  00022	c3		 ret	 0
?Initialize@ZTLogger@@QAEXXZ ENDP			; ZTLogger::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
;	COMDAT ??1ZTLogger@@QAE@XZ
_TEXT	SEGMENT
??1ZTLogger@@QAE@XZ PROC				; ZTLogger::~ZTLogger, COMDAT
; _this$ = ecx

; 14   : 	~ZTLogger() {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 15   : 		THREAD_LOCK_DELETE(&m_CriticalSection);

  00004	8d 47 34	 lea	 eax, DWORD PTR [edi+52]
  00007	50		 push	 eax
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  0000e	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h

; 16   : 	};

  00011	8d 77 1c	 lea	 esi, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00014	83 f8 10	 cmp	 eax, 16			; 00000010H
  00017	72 0b		 jb	 SHORT $LN9@ZTLogger

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00019	40		 inc	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	50		 push	 eax
  0001d	ff 36		 push	 DWORD PTR [esi]
  0001f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN9@ZTLogger:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00024	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);
; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0002b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00032	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00036	72 02		 jb	 SHORT $LN109@ZTLogger
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00038	8b 36		 mov	 esi, DWORD PTR [esi]
$LN109@ZTLogger:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0003a	c6 06 00	 mov	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  0003d	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00040	83 f8 10	 cmp	 eax, 16			; 00000010H
  00043	72 0d		 jb	 SHORT $LN126@ZTLogger

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00045	40		 inc	 eax
  00046	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00049	50		 push	 eax
  0004a	ff 77 04	 push	 DWORD PTR [edi+4]
  0004d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN126@ZTLogger:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00052	c7 47 18 0f 00
	00 00		 mov	 DWORD PTR [edi+24], 15	; 0000000fH

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);
; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00059	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00060	83 7f 18 10	 cmp	 DWORD PTR [edi+24], 16	; 00000010H
  00064	72 09		 jb	 SHORT $LN226@ZTLogger
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00066	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0006b	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h

; 16   : 	};

  0006e	c3		 ret	 0
$LN226@ZTLogger:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0006f	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h

; 16   : 	};

  00075	c3		 ret	 0
??1ZTLogger@@QAE@XZ ENDP				; ZTLogger::~ZTLogger
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h
;	COMDAT ??0ZTLogger@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_Path$ = 8						; size = 4
??0ZTLogger@@QAE@PBD@Z PROC				; ZTLogger::ZTLogger, COMDAT
; _this$ = ecx

; 9    : 	ZTLogger(const char* Path) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ZTLogger@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f9		 mov	 edi, ecx
  00028	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002b	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0002e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0003c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00040	72 04		 jb	 SHORT $LN123@ZTLogger
  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	eb 02		 jmp	 SHORT $LN124@ZTLogger
$LN123@ZTLogger:
  00046	8b c6		 mov	 eax, esi
$LN124@ZTLogger:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00048	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h

; 9    : 	ZTLogger(const char* Path) {

  0004b	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00055	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0005c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00063	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00067	72 02		 jb	 SHORT $LN253@ZTLogger
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
$LN253@ZTLogger:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0006b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 523  : 		return (*_First == 0 ? 0

  0006e	8b 55 08	 mov	 edx, DWORD PTR _Path$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h

; 9    : 	ZTLogger(const char* Path) {

  00071	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  00075	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00078	75 04		 jne	 SHORT $LN267@ZTLogger
  0007a	33 c9		 xor	 ecx, ecx
  0007c	eb 0e		 jmp	 SHORT $LN268@ZTLogger
$LN267@ZTLogger:
  0007e	8b ca		 mov	 ecx, edx
  00080	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
$LL292@ZTLogger:
  00083	8a 01		 mov	 al, BYTE PTR [ecx]
  00085	41		 inc	 ecx
  00086	84 c0		 test	 al, al
  00088	75 f9		 jne	 SHORT $LL292@ZTLogger
  0008a	2b cb		 sub	 ecx, ebx
$LN268@ZTLogger:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0008c	51		 push	 ecx
  0008d	52		 push	 edx
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00095	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00099	72 02		 jb	 SHORT $LN285@ZTLogger
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0009b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN285@ZTLogger:
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.h

; 19   : 		CreateDirectory(m_FilePath.c_str(), 0);

  0009d	6a 00		 push	 0
  0009f	56		 push	 esi
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8

; 20   : 		THREAD_LOCK_CREATE(&m_CriticalSection);

  000a6	8d 47 34	 lea	 eax, DWORD PTR [edi+52]
  000a9	50		 push	 eax
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 10   : 		m_FilePath.assign(Path);
; 11   : 		Initialize();
; 12   : 	};

  000b0	8b c7		 mov	 eax, edi
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ZTLogger@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ZTLogger@@QAE@PBD@Z$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0ZTLogger@@QAE@PBD@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ZTLogger@@QAE@PBD@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ZTLogger@@QAE@PBD@Z ENDP				; ZTLogger::ZTLogger
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 656  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<char>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00007	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 489  : 		_Myres = 0;

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2252 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2247 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2230 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN58@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN58@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);
; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0003d	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00040	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00044	72 0c		 jb	 SHORT $LN104@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2243 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LN104@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2243 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2219 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:

; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN34@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00024	eb 02		 jmp	 SHORT $LN35@Inside
$LN34@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN35@Inside:

; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2223 : 		else
; 2224 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2225 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2222 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2225 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2206 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 62		 ja	 SHORT $LN103@Grow

; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 16		 jae	 SHORT $LN3@Grow

; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  0001a	33 c0		 xor	 eax, eax
  0001c	3b c6		 cmp	 eax, esi
  0001e	5e		 pop	 esi
  0001f	1b c0		 sbb	 eax, eax
  00021	f7 d8		 neg	 eax

; 2216 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 22		 je	 SHORT $LN5@Grow
  0002d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00030	73 1d		 jae	 SHORT $LN5@Grow

; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  00042	33 c0		 xor	 eax, eax
  00044	3b c6		 cmp	 eax, esi
  00046	5e		 pop	 esi
  00047	1b c0		 sbb	 eax, eax
  00049	f7 d8		 neg	 eax

; 2216 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN5@Grow:

; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)

  0004f	85 f6		 test	 esi, esi
  00051	75 0e		 jne	 SHORT $LN100@Grow

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);
; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00053	89 71 10	 mov	 DWORD PTR [ecx+16], esi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00056	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0005a	72 02		 jb	 SHORT $LN91@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0005c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN91@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0005e	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN100@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  00061	33 c0		 xor	 eax, eax
  00063	3b c6		 cmp	 eax, esi
  00065	5e		 pop	 esi
  00066	1b c0		 sbb	 eax, eax
  00068	f7 d8		 neg	 eax

; 2216 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
$LN103@Grow:

; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");

  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00073	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN105@Grow:
$LN102@Grow:
  00078	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2199 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00003	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00006	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000d	72 0a		 jb	 SHORT $LN22@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2201 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN22@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2201 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2166 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2167 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax

; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:
  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2171 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00072	50		 push	 eax
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  0007a	8b c8		 mov	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
  0007c	eb 29		 jmp	 SHORT $LN469@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0007e	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00084	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax

; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00087	40		 inc	 eax
  00088	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  0008b	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2181 : 			_TRY_BEGIN

  0008c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00090	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00095	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END

  00098	b8 00 00 00 00	 mov	 eax, $LN466@Copy
  0009d	c3		 ret	 0
$LN466@Copy:
  0009e	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a4	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN469@Copy:

; 2188 : 
; 2189 : 		if (0 < _Oldlen)

  000a7	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000aa	89 4d e8	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
  000ad	85 db		 test	 ebx, ebx
  000af	74 1b		 je	 SHORT $LN276@Copy

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000b1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b5	72 04		 jb	 SHORT $LN265@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000b9	eb 02		 jmp	 SHORT $LN266@Copy
$LN265@Copy:
  000bb	8b c6		 mov	 eax, esi
$LN266@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000bd	85 db		 test	 ebx, ebx
  000bf	74 0b		 je	 SHORT $LN276@Copy
  000c1	53		 push	 ebx
  000c2	50		 push	 eax
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN276@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  000cc	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000cf	83 f8 10	 cmp	 eax, 16			; 00000010H
  000d2	72 0b		 jb	 SHORT $LN280@Copy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  000d4	40		 inc	 eax
  000d5	8b ce		 mov	 ecx, esi
  000d7	50		 push	 eax
  000d8	ff 36		 push	 DWORD PTR [esi]
  000da	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN280@Copy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  000df	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000e6	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000ed	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f1	72 04		 jb	 SHORT $LN380@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000f3	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000f5	eb 02		 jmp	 SHORT $LN381@Copy
$LN380@Copy:
  000f7	8b c6		 mov	 eax, esi
$LN381@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000f9	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  000ff	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2194 : 		this->_Myres() = _Newres;

  00101	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00104	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00107	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0010b	72 02		 jb	 SHORT $LN456@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0010d	8b f0		 mov	 esi, eax
$LN456@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0010f	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2196 : 		}

  00113	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00116	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011d	59		 pop	 ecx
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);

  00127	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  0012a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0012d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00130	72 0b		 jb	 SHORT $LN144@Copy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00132	40		 inc	 eax
  00133	8b ce		 mov	 ecx, esi
  00135	50		 push	 eax
  00136	ff 36		 push	 DWORD PTR [esi]
  00138	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN144@Copy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0013d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00144	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0014b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0014f	72 02		 jb	 SHORT $LN245@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00151	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2185 : 			_RERAISE;

  00153	6a 00		 push	 0
  00155	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00157	c6 06 00	 mov	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2185 : 			_RERAISE;

  0015a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN470@Copy:
$LN468@Copy:
  0015f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1757 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1750 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1751 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN13@c_str

; 1735 : 		return (this->_Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1736 : 		}

  00008	c3		 ret	 0
$LN13@c_str:

; 1735 : 		return (this->_Myptr());

  00009	8b c1		 mov	 eax, ecx

; 1736 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1345 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1346 : 		if (this->_Mysize() < _Off)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN124@erase

; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN3@erase

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN49@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1357 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1358 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
$LN49@erase:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN3@erase:

; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN121@erase

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN70@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0004b	eb 02		 jmp	 SHORT $LN71@erase
$LN70@erase:
  0004d	8b c6		 mov	 eax, esi
$LN71@erase:

; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

  00059	74 0e		 je	 SHORT $LN90@erase
  0005b	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN90@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00069	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0006c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN112@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00073	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1357 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1358 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
$LN112@erase:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00081	8b c6		 mov	 eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN121@erase:
  00087	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1357 : 		return (*this);

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1358 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN124@erase:

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");
; 2248 : 		}
; 2249 : 
; 2250 : 	[[noreturn]] void _Xran() const
; 2251 : 		{	// report an out_of_range error
; 2252 : 		_Xout_of_range("invalid string position");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN126@erase:
$LN123@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1337 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1338 : 		if (this->_Mysize() < _Off)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN49@erase

; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN37@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1341 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1342 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN37@erase:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00020	8b d1		 mov	 edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1341 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1342 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN49@erase:

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");
; 2248 : 		}
; 2249 : 
; 2250 : 	[[noreturn]] void _Xran() const
; 2251 : 		{	// report an out_of_range error
; 2252 : 		_Xout_of_range("invalid string position");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN51@erase:
$LN48@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1174 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1177 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1177 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi

; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)

  00008	8b f1		 mov	 esi, ecx

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN38@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00025	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00027	eb 02		 jmp	 SHORT $LN39@assign
$LN38@assign:
  00029	8b d6		 mov	 edx, esi
$LN39@assign:

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN65@assign

; 1162 : 			return (assign(*this,

  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1162 : 			return (assign(*this,

  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1171 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN65@assign:

; 1162 : 			return (assign(*this,

  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00052	8b c6		 mov	 eax, esi

; 1162 : 			return (assign(*this,

  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1171 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN233@assign

; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)

  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN75@assign

; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  0007e	85 ff		 test	 edi, edi

; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))

  00080	74 60		 je	 SHORT $LN227@assign
$LN232@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN185@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00088	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0008a	eb 29		 jmp	 SHORT $LN186@assign
$LN75@assign:

; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)

  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN232@assign

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00090	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00093	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00097	72 0e		 jb	 SHORT $LN163@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1170 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1171 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8
$LN163@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1171 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
$LN185@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000b3	8b c6		 mov	 eax, esi
$LN186@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN196@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN196@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000c4	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000c7	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000cb	72 0f		 jb	 SHORT $LN218@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1170 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1171 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8
$LN218@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000dc	8b c6		 mov	 eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN227@assign:
  000e2	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1170 : 		return (*this);

  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1171 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN233@assign:

; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN235@assign:
$LN230@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1141 : 		if (_Right.size() < _Roff)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000e	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00011	3b f9		 cmp	 edi, ecx
  00013	0f 82 e8 00 00
	00		 jb	 $LN258@assign

; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;

  00019	2b f9		 sub	 edi, ecx

; 1144 : 		if (_Count < _Num)

  0001b	39 7d 10	 cmp	 DWORD PTR __Count$[ebp], edi
  0001e	0f 42 7d 10	 cmovb	 edi, DWORD PTR __Count$[ebp]

; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 47		 jne	 SHORT $LN4@assign

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00026	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]

; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)

  00029	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002c	0f 82 d9 00 00
	00		 jb	 $LN260@assign

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00032	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00035	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00039	72 19		 jb	 SHORT $LN71@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0003b	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0003d	51		 push	 ecx
  0003e	6a 00		 push	 0
  00040	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00042	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00046	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004b	5f		 pop	 edi

; 1155 : 		return (*this);

  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx

; 1156 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN71@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00054	8b d6		 mov	 edx, esi

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00056	51		 push	 ecx
  00057	6a 00		 push	 0
  00059	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0005b	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0005f	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00064	5f		 pop	 edi

; 1155 : 		return (*this);

  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx

; 1156 : 		}

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
$LN4@assign:

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)

  0006d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00070	0f 87 9f 00 00
	00		 ja	 $LN261@assign

; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)

  00076	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00079	73 24		 jae	 SHORT $LN84@assign

; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  0007b	ff 76 10	 push	 DWORD PTR [esi+16]
  0007e	8b ce		 mov	 ecx, esi
  00080	57		 push	 edi
  00081	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]

; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  00089	85 ff		 test	 edi, edi

; 1149 : 		else if (_Grow(_Num))

  0008b	74 6b		 je	 SHORT $LN253@assign
$LN257@assign:

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  0008d	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00091	72 02		 jb	 SHORT $LN193@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00093	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN193@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00095	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00099	72 2b		 jb	 SHORT $LN211@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0009b	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0009d	eb 29		 jmp	 SHORT $LN212@assign
$LN84@assign:

; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)

  0009f	85 ff		 test	 edi, edi
  000a1	75 ea		 jne	 SHORT $LN257@assign

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000a3	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000aa	72 0e		 jb	 SHORT $LN172@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000af	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1155 : 		return (*this);

  000b2	8b c6		 mov	 eax, esi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx

; 1156 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN172@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000ba	8b c6		 mov	 eax, esi
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000bf	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1156 : 		}

  000c2	5d		 pop	 ebp
  000c3	c2 0c 00	 ret	 12			; 0000000cH
$LN211@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000c6	8b d6		 mov	 edx, esi
$LN212@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000c8	85 ff		 test	 edi, edi
  000ca	74 0e		 je	 SHORT $LN222@assign
  000cc	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1151 : 			_Traits::copy(this->_Myptr(),

  000cd	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000d0	50		 push	 eax
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _memcpy
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN222@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000da	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000dd	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000e1	72 0f		 jb	 SHORT $LN244@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000e3	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000e5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1155 : 		return (*this);

  000e9	8b c6		 mov	 eax, esi
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx

; 1156 : 		}

  000ee	5d		 pop	 ebp
  000ef	c2 0c 00	 ret	 12			; 0000000cH
$LN244@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000f2	8b c6		 mov	 eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000f4	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN253@assign:
  000f8	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1155 : 		return (*this);

  000f9	8b c6		 mov	 eax, esi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx

; 1156 : 		}

  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
$LN258@assign:

; 2248 : 		}
; 2249 : 
; 2250 : 	[[noreturn]] void _Xran() const
; 2251 : 		{	// report an out_of_range error
; 2252 : 		_Xout_of_range("invalid string position");

  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00106	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN262@assign:
$LN260@assign:
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00110	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN263@assign:
$LN261@assign:

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");

  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN264@assign:
$LN255@assign:
  0011f	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1005 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00022	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00026	72 07		 jb	 SHORT $LN106@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1007 : 		}

  0002e	c3		 ret	 0
$LN106@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1007 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 784  : 		}

  00007	8b c1		 mov	 eax, ecx

; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 784  : 		}

  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 722  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 723  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 717  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 718  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 712  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 713  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 702  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 695  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 696  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 690  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 691  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 685  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 686  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 680  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 681  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 488  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 573  : 		}

  00007	8b c1		 mov	 eax, ecx

; 489  : 		_Myres = 0;

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 573  : 		}

  00010	c2 04 00	 ret	 4
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr

; 566  : 		return (_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 567  : 		}

  00008	c3		 ret	 0
$LN11@Myptr:

; 566  : 		return (_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 567  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr

; 561  : 		return (_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 562  : 		}

  00008	c3		 ret	 0
$LN11@Myptr:

; 561  : 		return (_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 562  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	8b c1		 mov	 eax, ecx

; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	8b c1		 mov	 eax, ecx

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 487  : 		{	// initialize values
; 488  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 489  : 		_Myres = 0;
; 490  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 931  : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	83 f9 ff	 cmp	 ecx, -1
  0000c	77 2e		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 19		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00016	a8 1f		 test	 al, 31			; 0000001fH
  00018	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0001d	3b c8		 cmp	 ecx, eax
  0001f	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00021	2b c1		 sub	 eax, ecx
  00023	83 f8 04	 cmp	 eax, 4
  00026	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00028	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002b	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b c1		 mov	 eax, ecx
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0003c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00055	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 786  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 668  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 f8 ff	 cmp	 eax, -1
  00011	77 39		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001a	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  0001d	3b c8		 cmp	 ecx, eax
  0001f	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	8b c8		 mov	 ecx, eax
  00029	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0002c	85 c9		 test	 ecx, ecx
  0002e	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00033	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00036	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00043	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00046	85 c0		 test	 eax, eax
  00048	75 c0		 jne	 SHORT $LN12@allocate
  0004a	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  0004c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00056	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00060	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	83 f9 ff	 cmp	 ecx, -1
  0000c	77 2e		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 19		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00016	a8 1f		 test	 al, 31			; 0000001fH
  00018	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0001d	3b c8		 cmp	 ecx, eax
  0001f	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00021	2b c1		 sub	 eax, ecx
  00023	83 f8 04	 cmp	 eax, 4
  00026	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00028	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002b	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b c1		 mov	 eax, ecx
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4

; 639  : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0003c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00055	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 5    : ZTLogger LuaLog(LOG_PATH_LUA);

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\ztlogger.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 5    : ZTLogger LuaLog(LOG_PATH_LUA);

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
