; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\WzUdp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0WzUdp@@QAE@XZ				; WzUdp::WzUdp
PUBLIC	??1WzUdp@@UAE@XZ				; WzUdp::~WzUdp
PUBLIC	?Init@WzUdp@@QAEHXZ				; WzUdp::Init
PUBLIC	?CreateSocket@WzUdp@@QAEHXZ			; WzUdp::CreateSocket
PUBLIC	?Run@WzUdp@@QAEHXZ				; WzUdp::Run
PUBLIC	?SendData@WzUdp@@QAEHPAEK@Z			; WzUdp::SendData
PUBLIC	?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z		; WzUdp::MuProtocolParse
PUBLIC	?Close@WzUdp@@QAEHXZ				; WzUdp::Close
PUBLIC	?SendSet@WzUdp@@QAEHPADH@Z			; WzUdp::SendSet
PUBLIC	?RecvSet@WzUdp@@QAEHH@Z				; WzUdp::RecvSet
PUBLIC	?RecvThread@WzUdp@@QAEHXZ			; WzUdp::RecvThread
PUBLIC	?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z	; WzUdp::SetProtocolCore
PUBLIC	??_GWzUdp@@UAEPAXI@Z				; WzUdp::`scalar deleting destructor'
PUBLIC	?WzUdpRecvThread@@YGKPAVWzUdp@@@Z		; WzUdpRecvThread
PUBLIC	??_7WzUdp@@6B@					; WzUdp::`vftable'
PUBLIC	??_R4WzUdp@@6B@					; WzUdp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVWzUdp@@@8				; WzUdp `RTTI Type Descriptor'
PUBLIC	??_R3WzUdp@@8					; WzUdp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2WzUdp@@8					; WzUdp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@WzUdp@@8				; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__recvfrom@24:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSASendTo@36:PROC
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	??_EWzUdp@@UAEPAXI@Z:PROC			; WzUdp::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@WzUdp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@WzUdp@@8 DD FLAT:??_R0?AVWzUdp@@@8	; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R2WzUdp@@8
rdata$r	SEGMENT
??_R2WzUdp@@8 DD FLAT:??_R1A@?0A@EA@WzUdp@@8		; WzUdp::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3WzUdp@@8
rdata$r	SEGMENT
??_R3WzUdp@@8 DD 00H					; WzUdp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWzUdp@@@8
data$r	SEGMENT
??_R0?AVWzUdp@@@8 DD FLAT:??_7type_info@@6B@		; WzUdp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWzUdp@@', 00H
data$r	ENDS
;	COMDAT ??_R4WzUdp@@6B@
rdata$r	SEGMENT
??_R4WzUdp@@6B@ DD 00H					; WzUdp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWzUdp@@@8
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_7WzUdp@@6B@
CONST	SEGMENT
??_7WzUdp@@6B@ DD FLAT:??_R4WzUdp@@6B@			; WzUdp::`vftable'
	DD	FLAT:??_EWzUdp@@UAEPAXI@Z
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z
_TEXT	SEGMENT
_lpWzUdp$ = 8						; size = 4
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z PROC			; WzUdpRecvThread, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  : 	lpWzUdp->RecvThread();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpWzUdp$[ebp]
  00006	e8 00 00 00 00	 call	 ?RecvThread@WzUdp@@QAEHXZ ; WzUdp::RecvThread
$LN4@WzUdpRecvT:
$LN3@WzUdpRecvT:
  0000b	cc		 int	 3
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ENDP			; WzUdpRecvThread
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GWzUdp@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GWzUdp@@UAEPAXI@Z PROC				; WzUdp::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1WzUdp@@UAE@XZ	; WzUdp::~WzUdp
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 60 08 00 00	 push	 2144			; 00000860H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GWzUdp@@UAEPAXI@Z ENDP				; WzUdp::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z
_TEXT	SEGMENT
_pc$ = 8						; size = 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z PROC		; WzUdp::SetProtocolCore, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  : 	this->ProtocolCore=pc;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pc$[ebp]
  00006	89 81 5c 08 00
	00		 mov	 DWORD PTR [ecx+2140], eax

; 107  : 	return 1;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 108  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z ENDP		; WzUdp::SetProtocolCore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?RecvThread@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_dwSenderSize$ = -24					; size = 4
_sender$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?RecvThread@WzUdp@@QAEHXZ PROC				; WzUdp::RecvThread, COMDAT
; _this$ = ecx

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 254  : 	int ret;
; 255  : 	DWORD dwSenderSize;
; 256  : 	sockaddr_in sender;
; 257  : 	dwSenderSize=16;

  00012	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__recvfrom@24
  00018	8b f1		 mov	 esi, ecx
  0001a	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _dwSenderSize$[ebp], 16 ; 00000010H
$LL2@RecvThread:

; 258  : 	while ( true )
; 259  : 	{
; 260  : 		ret=recvfrom(this->m_Socket , (char*)&this->m_Recvbuf[this->m_dwRecvOfs], ( 4096 - this->m_dwRecvOfs ), 0, (sockaddr*)&sender, (int*)&dwSenderSize);

  00021	8d 45 e8	 lea	 eax, DWORD PTR _dwSenderSize$[ebp]
  00024	50		 push	 eax
  00025	8d 45 ec	 lea	 eax, DWORD PTR _sender$[ebp]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00030	2b 46 20	 sub	 eax, DWORD PTR [esi+32]
  00033	50		 push	 eax
  00034	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00037	03 46 20	 add	 eax, DWORD PTR [esi+32]
  0003a	50		 push	 eax
  0003b	ff 76 10	 push	 DWORD PTR [esi+16]
  0003e	ff d7		 call	 edi

; 261  : 
; 262  : 		if ( ret == -1 )

  00040	83 f8 ff	 cmp	 eax, -1
  00043	74 dc		 je	 SHORT $LL2@RecvThread

; 263  : 		{
; 264  : 			//continue;
; 265  : 		}
; 266  : 		else if ( ret == 0 )

  00045	85 c0		 test	 eax, eax
  00047	74 d8		 je	 SHORT $LL2@RecvThread

; 267  : 		{
; 268  : 			//continue;
; 269  : 		}
; 270  : 		else
; 271  : 		{
; 272  : 			this->m_dwLength=ret;
; 273  : 			this->m_dwRecvOfs += ret;

  00049	01 46 20	 add	 DWORD PTR [esi+32], eax
  0004c	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]

; 274  : 			this->MuProtocolParse(this->m_Recvbuf, this->m_dwLength);

  0004f	51		 push	 ecx
  00050	ff 76 14	 push	 DWORD PTR [esi+20]
  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	8b ce		 mov	 ecx, esi
  00057	e8 00 00 00 00	 call	 ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ; WzUdp::MuProtocolParse

; 275  : 		}
; 276  : 	}

  0005c	eb c3		 jmp	 SHORT $LL2@RecvThread
?RecvThread@WzUdp@@QAEHXZ ENDP				; WzUdp::RecvThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?RecvSet@WzUdp@@QAEHH@Z
_TEXT	SEGMENT
_port$ = 8						; size = 4
?RecvSet@WzUdp@@QAEHH@Z PROC				; WzUdp::RecvSet, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 112  : 
; 113  : 	this->m_Port=port;

  00003	8b 45 08	 mov	 eax, DWORD PTR _port$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 114  : 
; 115  : 	this->m_SockAddr.sin_port=htons(port);

  0000a	50		 push	 eax
  0000b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00014	66 89 87 4e 08
	00 00		 mov	 WORD PTR [edi+2126], ax

; 116  : 	this->m_SockAddr.sin_family=AF_INET;

  0001b	8d b7 4c 08 00
	00		 lea	 esi, DWORD PTR [edi+2124]
  00021	b8 02 00 00 00	 mov	 eax, 2

; 117  : 
; 118  : 	this->m_SockAddr.sin_addr.S_un.S_addr=htonl(0);

  00026	6a 00		 push	 0
  00028	66 89 06	 mov	 WORD PTR [esi], ax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4

; 119  : 	
; 120  : 	if( bind(this->m_Socket, (sockaddr*)&this->m_SockAddr, 16) == -1 )

  00031	6a 10		 push	 16			; 00000010H
  00033	56		 push	 esi
  00034	ff 77 10	 push	 DWORD PTR [edi+16]
  00037	89 87 50 08 00
	00		 mov	 DWORD PTR [edi+2128], eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  00043	83 f8 ff	 cmp	 eax, -1
  00046	75 08		 jne	 SHORT $LN2@RecvSet

; 121  : 	{
; 122  : 		return 0;

  00048	5f		 pop	 edi
  00049	33 c0		 xor	 eax, eax
  0004b	5e		 pop	 esi

; 127  : 	{
; 128  : 		return 0;
; 129  : 	}
; 130  : 	return 1;
; 131  : }

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
$LN2@RecvSet:

; 123  : 	}
; 124  : 	this->m_Recvbuf=(unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, this->m_dwLength);

  00050	ff 77 1c	 push	 DWORD PTR [edi+28]
  00053	6a 08		 push	 8
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0005b	50		 push	 eax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12

; 125  : 
; 126  : 	if ( this->m_Recvbuf == 0)

  00062	33 c9		 xor	 ecx, ecx
  00064	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00067	85 c0		 test	 eax, eax
  00069	5f		 pop	 edi
  0006a	0f 95 c1	 setne	 cl
  0006d	8b c1		 mov	 eax, ecx
  0006f	5e		 pop	 esi

; 127  : 	{
; 128  : 		return 0;
; 129  : 	}
; 130  : 	return 1;
; 131  : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
?RecvSet@WzUdp@@QAEHH@Z ENDP				; WzUdp::RecvSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?SendSet@WzUdp@@QAEHPADH@Z
_TEXT	SEGMENT
_ip$ = 8						; size = 4
_port$ = 12						; size = 4
?SendSet@WzUdp@@QAEHPADH@Z PROC				; WzUdp::SendSet, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	this->m_Port = port;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _port$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 82   : 	this->m_SockAddr.sin_family=AF_INET;

  00009	b9 02 00 00 00	 mov	 ecx, 2

; 83   : 
; 84   : 	this->m_SockAddr.sin_port=htons(port);

  0000e	50		 push	 eax
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00012	66 89 8e 4c 08
	00 00		 mov	 WORD PTR [esi+2124], cx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 85   : 	this->m_SockAddr.sin_addr.S_un.S_addr=inet_addr(ip);

  0001f	ff 75 08	 push	 DWORD PTR _ip$[ebp]
  00022	66 89 86 4e 08
	00 00		 mov	 WORD PTR [esi+2126], ax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  0002f	81 c6 50 08 00
	00		 add	 esi, 2128		; 00000850H
  00035	89 06		 mov	 DWORD PTR [esi], eax

; 86   : 
; 87   : 	if ( this->m_SockAddr.sin_addr.S_un.S_addr == -1)

  00037	83 f8 ff	 cmp	 eax, -1
  0003a	75 20		 jne	 SHORT $LN4@SendSet

; 88   : 	{
; 89   : 		hostent* host=0;	// NULL pointer
; 90   : 		host=gethostbyname(ip);

  0003c	ff 75 08	 push	 DWORD PTR _ip$[ebp]
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4

; 91   : 
; 92   : 		if (host != 0)

  00045	85 c0		 test	 eax, eax
  00047	74 1d		 je	 SHORT $LN3@SendSet

; 93   : 		{
; 94   : 			memcpy(&this->m_SockAddr.sin_addr.S_un.S_addr,*host->h_addr_list ,host->h_length);	// Add Type Structure {$D }

  00049	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  0004d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00050	51		 push	 ecx
  00051	ff 30		 push	 DWORD PTR [eax]
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendSet:

; 99   : 		}
; 100  : 	}
; 101  : 	return 1;

  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	5e		 pop	 esi

; 102  : }

  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
$LN3@SendSet:

; 95   : 		}
; 96   : 		else
; 97   : 		{
; 98   : 			return 0;

  00066	33 c0		 xor	 eax, eax
  00068	5e		 pop	 esi

; 102  : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
?SendSet@WzUdp@@QAEHPADH@Z ENDP				; WzUdp::SendSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?Close@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?Close@WzUdp@@QAEHXZ PROC				; WzUdp::Close, COMDAT
; _this$ = ecx

; 48   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 49   : 	::TerminateThread(this->m_ThreadHandle, 0);

  00003	6a 00		 push	 0
  00005	ff 76 08	 push	 DWORD PTR [esi+8]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 50   : 
; 51   : 	if (this->m_ThreadHandle != 0)

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $LN2@Close

; 52   : 	{
; 53   : 		WaitForSingleObject(this->m_ThreadHandle , INFINITE);	// Interesting, this could block GS

  00015	6a ff		 push	 -1
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 54   : 		CloseHandle(this->m_ThreadHandle );

  0001e	ff 76 08	 push	 DWORD PTR [esi+8]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 55   : 		this->m_ThreadHandle =0;	// NULL handle

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Close:

; 56   : 	}
; 57   : 
; 58   : 	HeapFree(GetProcessHeap(), 0, this->m_Recvbuf);

  0002e	ff 76 14	 push	 DWORD PTR [esi+20]
  00031	6a 00		 push	 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 59   : 	return 1;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	5e		 pop	 esi

; 60   : }

  00046	c3		 ret	 0
?Close@WzUdp@@QAEHXZ ENDP				; WzUdp::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_headcode$ = 8						; size = 1
_RecvData$ = 8						; size = 4
_nRecvDataLen$ = 12					; size = 4
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z PROC		; WzUdp::MuProtocolParse, COMDAT
; _this$ = ecx

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 176  : 	int lOfs=0;

  00005	33 ff		 xor	 edi, edi
  00007	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 177  : 	int size=0;
; 178  : 	BYTE headcode;
; 179  : 
; 180  : 	if (this->ProtocolCore == 0)

  0000a	39 b9 5c 08 00
	00		 cmp	 DWORD PTR [ecx+2140], edi
  00010	75 09		 jne	 SHORT $LN26@MuProtocol

; 181  : 	{
; 182  : 		return 0;

  00012	33 c0		 xor	 eax, eax
  00014	5f		 pop	 edi

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN26@MuProtocol:
  0001b	53		 push	 ebx

; 181  : 	{
; 182  : 		return 0;

  0001c	8b 5d 08	 mov	 ebx, DWORD PTR _RecvData$[ebp]
  0001f	56		 push	 esi
$LL2@MuProtocol:

; 183  : 	}
; 184  : 
; 185  : 	while ( true )	
; 186  : 	{
; 187  : 		if ( RecvData[lOfs]==0xC1 ) // Packet Type Manager

  00020	8a 04 1f	 mov	 al, BYTE PTR [edi+ebx]
  00023	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  00026	3c c1		 cmp	 al, 193			; 000000c1H
  00028	75 0b		 jne	 SHORT $LN5@MuProtocol

; 188  : 		{
; 189  : 			size=RecvData[lOfs+1];	// Set Size

  0002a	0f b6 74 1f 01	 movzx	 esi, BYTE PTR [edi+ebx+1]

; 190  : 			headcode=RecvData[lOfs+2];

  0002f	8a 44 1f 02	 mov	 al, BYTE PTR [edi+ebx+2]
  00033	eb 17		 jmp	 SHORT $LN29@MuProtocol
$LN5@MuProtocol:

; 191  : 		}
; 192  : 		else if ( RecvData[lOfs]== 0xC2 )

  00035	3c c2		 cmp	 al, 194			; 000000c2H
  00037	75 75		 jne	 SHORT $LN7@MuProtocol

; 193  : 		{
; 194  : 			size=RecvData[lOfs+1];

  00039	0f b6 74 1f 01	 movzx	 esi, BYTE PTR [edi+ebx+1]

; 195  : 			size =size<<8;
; 196  : 			size |= RecvData[lOfs+2];

  0003e	0f b6 44 1f 02	 movzx	 eax, BYTE PTR [edi+ebx+2]
  00043	c1 e6 08	 shl	 esi, 8
  00046	0b f0		 or	 esi, eax

; 197  : 			headcode = RecvData[lOfs+3];

  00048	8a 44 1f 03	 mov	 al, BYTE PTR [edi+ebx+3]
$LN29@MuProtocol:
  0004c	88 45 08	 mov	 BYTE PTR _headcode$[ebp], al

; 203  : 		}
; 204  : 
; 205  : 		if ( size <= 0 )

  0004f	85 f6		 test	 esi, esi
  00051	7e 62		 jle	 SHORT $LN30@MuProtocol

; 206  : 		{
; 207  : 			return 0;
; 208  : 		}
; 209  : 
; 210  : 		if ( size <= nRecvDataLen )

  00053	8b 45 0c	 mov	 eax, DWORD PTR _nRecvDataLen$[ebp]
  00056	3b 30		 cmp	 esi, DWORD PTR [eax]
  00058	7f 2c		 jg	 SHORT $LN10@MuProtocol

; 211  : 		{
; 212  : 			this->ProtocolCore(headcode, &RecvData[lOfs], size );

  0005a	8b 81 5c 08 00
	00		 mov	 eax, DWORD PTR [ecx+2140]
  00060	56		 push	 esi
  00061	52		 push	 edx
  00062	ff 75 08	 push	 DWORD PTR _headcode$[ebp]
  00065	ff d0		 call	 eax

; 213  : 			lOfs += size;
; 214  : 			this->m_dwRecvOfs -= size;

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	03 fe		 add	 edi, esi
  0006f	29 71 20	 sub	 DWORD PTR [ecx+32], esi

; 215  : 
; 216  : 			if (this->m_dwRecvOfs <= 0 )

  00072	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00076	7f a8		 jg	 SHORT $LL2@MuProtocol

; 229  : 			return 1;

  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	5f		 pop	 edi

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN10@MuProtocol:

; 217  : 			{
; 218  : 				break;
; 219  : 			}
; 220  : 		}
; 221  : 		else if ( lOfs > 0 )

  00086	85 ff		 test	 edi, edi
  00088	7e 16		 jle	 SHORT $LN13@MuProtocol

; 222  : 		{
; 223  : 			if (this->m_dwRecvOfs < 1 )

  0008a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0008d	83 f8 01	 cmp	 eax, 1
  00090	7c 23		 jl	 SHORT $LN30@MuProtocol

; 224  : 			{
; 225  : 				return 0;
; 226  : 			}
; 227  : 
; 228  : 			memcpy(RecvData, &RecvData[lOfs], this->m_dwRecvOfs);

  00092	50		 push	 eax
  00093	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  00096	50		 push	 eax
  00097	53		 push	 ebx
  00098	e8 00 00 00 00	 call	 _memcpy
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@MuProtocol:

; 229  : 			return 1;

  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	5f		 pop	 edi

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 08 00	 ret	 8
$LN7@MuProtocol:

; 198  : 		}
; 199  : 		else
; 200  : 		{
; 201  : 			this->m_dwRecvOfs = 0;

  000ae	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
$LN30@MuProtocol:
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 202  : 			return 0;

  000b7	33 c0		 xor	 eax, eax
  000b9	5f		 pop	 edi

; 230  : 		}
; 231  : 		else
; 232  : 		{
; 233  : 			break;
; 234  : 		}
; 235  : 	}
; 236  : 	return 1;
; 237  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ENDP		; WzUdp::MuProtocolParse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?SendData@WzUdp@@QAEHPAEK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_SendData$ = 8						; size = 4
_nSendDataLen$ = 12					; size = 4
?SendData@WzUdp@@QAEHPAEK@Z PROC			; WzUdp::SendData, COMDAT
; _this$ = ecx

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 135  : 	/*int Ret;
; 136  : 	memset(&this->m_PerIoSendData.Overlapped, 0, 20);	// Add Type Structure {$D}
; 137  : 	memcpy(this->m_PerIoSendData.Buffer , SendData, nSendDataLen);
; 138  : 	
; 139  : 	this->m_PerIoSendData.lOfs=nSendDataLen;
; 140  : 	this->m_PerIoSendData.DataBuf.buf =this->m_PerIoSendData.Buffer;	// 40 Pointer 44 ...
; 141  : 	this->m_PerIoSendData.DataBuf.len =this->m_PerIoSendData.lOfs;	// No complex
; 142  : 
; 143  : 	Ret=WSASendTo(this->m_Socket, &this->m_PerIoSendData.DataBuf, 1, (unsigned long*)&nSendDataLen, 0, (sockaddr*)&this->m_SockAddr, 16, &this->m_PerIoSendData.Overlapped, NULL); 		// 28 Add Type Structure {$D}
; 144  : 	if (Ret == -1 )
; 145  : 	{
; 146  : 		if (WSAGetLastError() != WSA_IO_PENDING ) //WSA_IO_PENDING
; 147  : 		{
; 148  : 			return -1;
; 149  : 		}
; 150  : 	}
; 151  : 	return 1;*/
; 152  : 	DWORD Ret;
; 153  : 
; 154  : 	ZeroMemory(&(m_PerIoSendData.Overlapped), sizeof(OVERLAPPED));
; 155  : 	
; 156  : 	memcpy(m_PerIoSendData.Buffer, SendData, nSendDataLen);

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _nSendDataLen$[ebp]
  0000a	8d 59 28	 lea	 ebx, DWORD PTR [ecx+40]
  0000d	57		 push	 edi
  0000e	ff 75 08	 push	 DWORD PTR _SendData$[ebp]
  00011	0f 57 c0	 xorps	 xmm0, xmm0
  00014	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00017	8d 71 44	 lea	 esi, DWORD PTR [ecx+68]
  0001a	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  0001d	56		 push	 esi
  0001e	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00025	e8 00 00 00 00	 call	 _memcpy

; 157  : 	
; 158  : 	m_PerIoSendData.lOfs		= nSendDataLen;

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 	m_PerIoSendData.DataBuf.buf = m_PerIoSendData.Buffer;
; 160  : 	m_PerIoSendData.DataBuf.len = m_PerIoSendData.lOfs;

  00030	8d 4a 3c	 lea	 ecx, DWORD PTR [edx+60]
  00033	89 39		 mov	 DWORD PTR [ecx], edi

; 161  : 		
; 162  : 	Ret = WSASendTo(m_Socket, &(m_PerIoSendData.DataBuf), 1, &nSendDataLen, 0, (SOCKADDR*)&m_SockAddr, sizeof(m_SockAddr), &(m_PerIoSendData.Overlapped), NULL);

  00035	6a 00		 push	 0
  00037	53		 push	 ebx
  00038	6a 10		 push	 16			; 00000010H
  0003a	8d 82 4c 08 00
	00		 lea	 eax, DWORD PTR [edx+2124]
  00040	89 ba 48 08 00
	00		 mov	 DWORD PTR [edx+2120], edi
  00046	50		 push	 eax
  00047	6a 00		 push	 0
  00049	8d 45 0c	 lea	 eax, DWORD PTR _nSendDataLen$[ebp]
  0004c	89 72 40	 mov	 DWORD PTR [edx+64], esi
  0004f	50		 push	 eax
  00050	6a 01		 push	 1
  00052	51		 push	 ecx
  00053	ff 72 10	 push	 DWORD PTR [edx+16]
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASendTo@36
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx

; 163  : 	if( Ret == SOCKET_ERROR )

  0005f	83 f8 ff	 cmp	 eax, -1
  00062	75 16		 jne	 SHORT $LN3@SendData

; 164  : 	{
; 165  : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0006a	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  0006f	74 09		 je	 SHORT $LN3@SendData

; 166  : 		{
; 167  : 			//printf("WSASend() failed with error %d\n", WSAGetLastError());
; 168  : 			return -1;

  00071	83 c8 ff	 or	 eax, -1

; 172  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN3@SendData:

; 169  : 		}
; 170  : 	}
; 171  : 	return TRUE;

  0007a	b8 01 00 00 00	 mov	 eax, 1

; 172  : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?SendData@WzUdp@@QAEHPAEK@Z ENDP			; WzUdp::SendData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?Run@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?Run@WzUdp@@QAEHXZ PROC					; WzUdp::Run, COMDAT
; _this$ = ecx

; 242  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 243  : 	this->m_ThreadHandle=CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WzUdpRecvThread, this, 0, &this->m_ThreadID);

  00003	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	68 00 00 00 00	 push	 OFFSET ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ; WzUdpRecvThread
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24

; 244  : 
; 245  : 	if (this->m_ThreadHandle == 0 )

  00019	33 c9		 xor	 ecx, ecx
  0001b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001e	85 c0		 test	 eax, eax
  00020	5e		 pop	 esi
  00021	0f 95 c1	 setne	 cl
  00024	8b c1		 mov	 eax, ecx

; 246  : 	{
; 247  : 		return 0;
; 248  : 	}
; 249  : 	 return 1;
; 250  : }

  00026	c3		 ret	 0
?Run@WzUdp@@QAEHXZ ENDP					; WzUdp::Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?CreateSocket@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?CreateSocket@WzUdp@@QAEHXZ PROC			; WzUdp::CreateSocket, COMDAT
; _this$ = ecx

; 64   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 65   : 	if ( this->m_Socket != INVALID_SOCKET )

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 0e		 je	 SHORT $LN2@CreateSock

; 66   : 	{
; 67   : 		closesocket(this->m_Socket );

  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 68   : 		this->m_Socket=INVALID_SOCKET;

  00012	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1
$LN2@CreateSock:

; 69   : 	}
; 70   : 	this->m_Socket=WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_IP, NULL, 0,0);

  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	6a 02		 push	 2
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24

; 71   : 
; 72   : 	if ( this->m_Socket== INVALID_SOCKET)

  0002b	33 c9		 xor	 ecx, ecx
  0002d	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00030	83 f8 ff	 cmp	 eax, -1
  00033	5e		 pop	 esi
  00034	0f 95 c1	 setne	 cl
  00037	8b c1		 mov	 eax, ecx

; 73   : 	{
; 74   : 		return 0;
; 75   : 	}
; 76   : 	return 1;
; 77   : }

  00039	c3		 ret	 0
?CreateSocket@WzUdp@@QAEHXZ ENDP			; WzUdp::CreateSocket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?Init@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_wsd$ = -404						; size = 400
__$ArrayPad$ = -4					; size = 4
?Init@WzUdp@@QAEHXZ PROC				; WzUdp::Init, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 33   : 	WSADATA wsd;
; 34   : 
; 35   : 	if ( WSAStartup(WZ_UPD_WINSOCK_VERSION, &wsd) )

  00014	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _wsd$[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	50		 push	 eax
  0001d	68 02 02 00 00	 push	 514			; 00000202H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8
  00028	85 c0		 test	 eax, eax
  0002a	74 11		 je	 SHORT $LN2@Init

; 36   : 	{
; 37   : 		return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 38   : 	}
; 39   : 	this->m_Socket = INVALID_SOCKET;	// Set socket NULL
; 40   : 	this->m_dwLength = 4096;
; 41   : 	this->m_dwRecvOfs = 0;
; 42   : 	this->m_ThreadHandle = NULL;
; 43   : 	this->ProtocolCore=0;	// Protocol Core Null
; 44   : 	return 1;
; 45   : }

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN2@Init:
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1
  0004c	33 cd		 xor	 ecx, ebp
  0004e	c7 46 1c 00 10
	00 00		 mov	 DWORD PTR [esi+28], 4096 ; 00001000H
  00055	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  0005c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00063	c7 86 5c 08 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2140], 0
  0006d	5e		 pop	 esi
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?Init@WzUdp@@QAEHXZ ENDP				; WzUdp::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ??1WzUdp@@UAE@XZ
_TEXT	SEGMENT
??1WzUdp@@UAE@XZ PROC					; WzUdp::~WzUdp, COMDAT
; _this$ = ecx

; 27   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7WzUdp@@6B@

; 28   : 	this->Close();

  00006	e9 00 00 00 00	 jmp	 ?Close@WzUdp@@QAEHXZ	; WzUdp::Close
??1WzUdp@@UAE@XZ ENDP					; WzUdp::~WzUdp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ??0WzUdp@@QAE@XZ
_TEXT	SEGMENT
??0WzUdp@@QAE@XZ PROC					; WzUdp::WzUdp, COMDAT
; _this$ = ecx

; 21   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7WzUdp@@6B@

; 22   : 	this->Init();

  00009	e8 00 00 00 00	 call	 ?Init@WzUdp@@QAEHXZ	; WzUdp::Init

; 23   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0WzUdp@@QAE@XZ ENDP					; WzUdp::WzUdp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\wzudp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
