; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\LuaFun.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z	; Debug_AddDebugPrintTemp
PUBLIC	?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ	; g_Generic_Call
PUBLIC	??_C@_0L@NNLLPGPO@DebugPrint?$AA@		; `string'
PUBLIC	??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@ ; `string'
PUBLIC	??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@	; `string'
PUBLIC	??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@ ; `string'
PUBLIC	??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@ ; `string'
EXTRN	_lua_settop:PROC
EXTRN	_lua_isnumber:PROC
EXTRN	_lua_isstring:PROC
EXTRN	_lua_tonumber:PROC
EXTRN	_lua_tolstring:PROC
EXTRN	_lua_pushnumber:PROC
EXTRN	_lua_pushlstring:PROC
EXTRN	_lua_pushcclosure:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pcall:PROC
EXTRN	_luaL_checkstack:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@
CONST	SEGMENT
??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@ DB 'luacall_Generi'
	DB	'c_Call wrong result type [%c][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@
CONST	SEGMENT
??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@ DB 'luacall_Generi'
	DB	'c_Call error running function `%s'': %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@
CONST	SEGMENT
??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@ DB 'too many arguments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@
CONST	SEGMENT
??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@ DB 'luacall_Generi'
	DB	'c_Call invalid option (%c)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNLLPGPO@DebugPrint?$AA@
CONST	SEGMENT
??_C@_0L@NNLLPGPO@DebugPrint?$AA@ DB 'DebugPrint', 00H	; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\luafun.cpp
;	COMDAT ?Debug_Print@@YAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?Debug_Print@@YAHPAUlua_State@@@Z PROC			; Debug_Print, COMDAT

; 13   : #ifdef _DEBUG
; 14   : 	// here must be some code
; 15   : 	// no code in executable, since it was build without _DEBUG
; 16   : #endif
; 17   : 
; 18   : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 19   : }

  00002	c3		 ret	 0
?Debug_Print@@YAHPAUlua_State@@@Z ENDP			; Debug_Print
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\luafun.cpp
;	COMDAT ?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ
_TEXT	SEGMENT
_nRetValCnt$1$ = -8					; size = 4
_narg$1$ = -8						; size = 4
tv333 = -4						; size = 4
_vl$1$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
tv335 = 16						; size = 4
_sig$ = 16						; size = 4
?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ PROC		; g_Generic_Call, COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 40   : 	va_list vl;
; 41   : 	int narg, nres;  /* number of arguments and results */
; 42   :     
; 43   : 	va_start(vl, sig);
; 44   : 	// lua_setfield(L, LUA_GLOBALSINDEX, func); -- webzen error ? ... 
; 45   : 	lua_getglobal(L,func);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _L$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR _func$[ebp]
  0000f	8d 75 14	 lea	 esi, DWORD PTR _sig$[ebp+4]
  00012	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00017	53		 push	 ebx
  00018	89 75 fc	 mov	 DWORD PTR _vl$1$[ebp], esi
  0001b	e8 00 00 00 00	 call	 _lua_getfield

; 46   :     
; 47   : 	/* push arguments */
; 48   : 	narg = 0;
; 49   : 	while (*sig) 

  00020	8b 7d 10	 mov	 edi, DWORD PTR _sig$[ebp]
  00023	33 d2		 xor	 edx, edx
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	89 55 f8	 mov	 DWORD PTR _narg$1$[ebp], edx
  0002b	8a 07		 mov	 al, BYTE PTR [edi]
  0002d	84 c0		 test	 al, al
  0002f	0f 84 b0 00 00
	00		 je	 $endwhile$49
$LL2@g_Generic_:

; 50   : 	{  
; 51   : 		/* push arguments */
; 52   : 		switch (*sig++) 

  00035	0f be c0	 movsx	 eax, al
  00038	47		 inc	 edi
  00039	83 e8 3e	 sub	 eax, 62			; 0000003eH
  0003c	89 7d 10	 mov	 DWORD PTR _sig$[ebp], edi
  0003f	83 f8 39	 cmp	 eax, 57			; 00000039H
  00042	0f 87 ea 00 00
	00		 ja	 $LN16@g_Generic_
  00048	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN40@g_Generic_[eax]
  0004f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN48@g_Generic_[eax*4]
$LN10@g_Generic_:

; 53   : 		{
; 54   : 			case 'w':  /* word argument */
; 55   : 				lua_pushnumber(L, va_arg(vl, short));

  00056	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00059	83 c6 04	 add	 esi, 4
  0005c	66 0f 6e c0	 movd	 xmm0, eax
$LN46@g_Generic_:
  00060	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00064	83 ec 08	 sub	 esp, 8
  00067	89 75 fc	 mov	 DWORD PTR _vl$1$[ebp], esi
  0006a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0006f	53		 push	 ebx
  00070	e8 00 00 00 00	 call	 _lua_pushnumber

; 56   : 			break;

  00075	eb 4b		 jmp	 SHORT $LN44@g_Generic_
$LN11@g_Generic_:

; 57   : 
; 58   : 			case 'd':  /* double argument */
; 59   : 				lua_pushnumber(L, va_arg(vl, double));

  00077	f2 0f 10 06	 movsd	 xmm0, QWORD PTR [esi]
  0007b	83 c6 08	 add	 esi, 8
  0007e	83 ec 08	 sub	 esp, 8
  00081	89 75 fc	 mov	 DWORD PTR _vl$1$[ebp], esi
  00084	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00089	53		 push	 ebx
  0008a	e8 00 00 00 00	 call	 _lua_pushnumber

; 60   :             break;

  0008f	eb 31		 jmp	 SHORT $LN44@g_Generic_
$LN12@g_Generic_:
  00091	66 0f 6e 06	 movd	 xmm0, DWORD PTR [esi]

; 61   :     
; 62   : 			case 'i':  /* int argument */
; 63   : 				lua_pushnumber(L, va_arg(vl, int));

  00095	83 c6 04	 add	 esi, 4

; 64   :             break;

  00098	eb c6		 jmp	 SHORT $LN46@g_Generic_
$LN13@g_Generic_:

; 65   :     
; 66   : 			case 's':  /* string argument */
; 67   : 			{
; 68   : 				char* pszString = va_arg(vl, char *);

  0009a	8b 16		 mov	 edx, DWORD PTR [esi]
  0009c	83 c6 04	 add	 esi, 4

; 69   : 				lua_pushlstring(L, pszString, strlen(pszString));

  0009f	8b ca		 mov	 ecx, edx
  000a1	89 75 fc	 mov	 DWORD PTR _vl$1$[ebp], esi
  000a4	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000a7	89 45 10	 mov	 DWORD PTR tv335[ebp], eax
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL41@g_Generic_:
  000b0	8a 01		 mov	 al, BYTE PTR [ecx]
  000b2	41		 inc	 ecx
  000b3	84 c0		 test	 al, al
  000b5	75 f9		 jne	 SHORT $LL41@g_Generic_
  000b7	2b 4d 10	 sub	 ecx, DWORD PTR tv335[ebp]
  000ba	51		 push	 ecx
  000bb	52		 push	 edx
  000bc	53		 push	 ebx
  000bd	e8 00 00 00 00	 call	 _lua_pushlstring
$LN44@g_Generic_:

; 79   :         }
; 80   :         narg++;

  000c2	ff 45 f8	 inc	 DWORD PTR _narg$1$[ebp]
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   :         luaL_checkstack(L, 1, "too many arguments");

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@
  000cd	6a 01		 push	 1
  000cf	53		 push	 ebx
  000d0	e8 00 00 00 00	 call	 _luaL_checkstack
  000d5	8a 07		 mov	 al, BYTE PTR [edi]
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	84 c0		 test	 al, al
  000dc	0f 85 53 ff ff
	ff		 jne	 $LL2@g_Generic_
$LN43@g_Generic_:
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _narg$1$[ebp]
$endwhile$49:

; 82   : 	} 
; 83   : endwhile:
; 84   :     
; 85   : 	/* do the call */
; 86   : 	nres = strlen(sig);  /* number of expected results */

  000e5	8b f7		 mov	 esi, edi
  000e7	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL42@g_Generic_:
  000f0	8a 06		 mov	 al, BYTE PTR [esi]
  000f2	46		 inc	 esi
  000f3	84 c0		 test	 al, al
  000f5	75 f9		 jne	 SHORT $LL42@g_Generic_
  000f7	2b f1		 sub	 esi, ecx

; 87   : 
; 88   : 	if (lua_pcall(L, narg, nres, 0) != 0)  /* do the call */

  000f9	6a 00		 push	 0
  000fb	56		 push	 esi
  000fc	52		 push	 edx
  000fd	53		 push	 ebx
  000fe	89 75 f8	 mov	 DWORD PTR _nRetValCnt$1$[ebp], esi
  00101	e8 00 00 00 00	 call	 _lua_pcall
  00106	83 c4 10	 add	 esp, 16			; 00000010H
  00109	85 c0		 test	 eax, eax
  0010b	74 41		 je	 SHORT $LN17@g_Generic_

; 89   : 	{
; 90   : 		LogAdd("luacall_Generic_Call error running function `%s': %s", func, lua_tolstring(L, -1, NULL));

  0010d	6a 00		 push	 0
  0010f	6a ff		 push	 -1
  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 _lua_tolstring
  00117	50		 push	 eax
  00118	ff 75 0c	 push	 DWORD PTR _func$[ebp]
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00126	83 c4 18	 add	 esp, 24			; 00000018H

; 91   : 		return false;

  00129	32 c0		 xor	 al, al
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx

; 143  : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
$LN16@g_Generic_:

; 70   : 			}
; 71   :             break;
; 72   :     
; 73   : 			case '>':
; 74   : 				goto endwhile;
; 75   :     
; 76   : 			default:
; 77   : 				LogAdd("luacall_Generic_Call invalid option (%c)", *(sig - 1));

  00132	0f be 47 ff	 movsx	 eax, BYTE PTR [edi-1]
  00136	50		 push	 eax
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00142	83 c4 08	 add	 esp, 8

; 78   : 			return false;

  00145	32 c0		 xor	 al, al
  00147	5f		 pop	 edi
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx

; 143  : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
$LN17@g_Generic_:

; 96   : 	nres = -nres;  /* stack index of first result */
; 97   : 	while (*sig) 

  0014e	8a 07		 mov	 al, BYTE PTR [edi]
  00150	f7 de		 neg	 esi
  00152	84 c0		 test	 al, al
  00154	0f 84 a2 00 00
	00		 je	 $LN7@g_Generic_

; 92   : 	}
; 93   :     
; 94   : 	/* retrieve results */
; 95   : 	int nRetValCnt = nres;

  0015a	8b 55 fc	 mov	 edx, DWORD PTR _vl$1$[ebp]
  0015d	83 c2 fc	 add	 edx, -4			; fffffffcH
  00160	89 55 fc	 mov	 DWORD PTR tv333[ebp], edx
$LL6@g_Generic_:

; 98   : 	{  
; 99   : 		/* get results */
; 100  : 		switch (*sig++) 

  00163	0f be c0	 movsx	 eax, al
  00166	47		 inc	 edi
  00167	89 7d 10	 mov	 DWORD PTR _sig$[ebp], edi
  0016a	83 f8 64	 cmp	 eax, 100		; 00000064H
  0016d	74 5f		 je	 SHORT $LN18@g_Generic_
  0016f	83 f8 69	 cmp	 eax, 105		; 00000069H
  00172	74 30		 je	 SHORT $LN20@g_Generic_
  00174	83 f8 73	 cmp	 eax, 115		; 00000073H
  00177	75 b9		 jne	 SHORT $LN16@g_Generic_

; 120  :     
; 121  : 			case 's':  /* string result */
; 122  : 				if (!lua_isstring(L, nres))

  00179	56		 push	 esi
  0017a	53		 push	 ebx
  0017b	e8 00 00 00 00	 call	 _lua_isstring
  00180	83 c4 08	 add	 esp, 8
  00183	85 c0		 test	 eax, eax
  00185	0f 84 90 00 00
	00		 je	 $LN30@g_Generic_

; 126  : 				}
; 127  : 				*va_arg(vl, const char **) = lua_tolstring(L, nres, NULL);

  0018b	83 45 fc 04	 add	 DWORD PTR tv333[ebp], 4
  0018f	6a 00		 push	 0
  00191	56		 push	 esi
  00192	53		 push	 ebx
  00193	e8 00 00 00 00	 call	 _lua_tolstring
  00198	8b 55 fc	 mov	 edx, DWORD PTR tv333[ebp]
  0019b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001a0	89 01		 mov	 DWORD PTR [ecx], eax

; 128  :             break;

  001a2	eb 4d		 jmp	 SHORT $LN8@g_Generic_
$LN20@g_Generic_:

; 110  :             break;
; 111  :     
; 112  : 			case 'i':  /* int result */
; 113  : 				if (!lua_isnumber(L, nres))

  001a4	56		 push	 esi
  001a5	53		 push	 ebx
  001a6	e8 00 00 00 00	 call	 _lua_isnumber
  001ab	83 c4 08	 add	 esp, 8

; 114  : 				{
; 115  : 					LogAdd("luacall_Generic_Call wrong result type [%c][%d]", *(sig-1), nres);
; 116  : 					return false;
; 117  : 				}
; 118  : 				*va_arg(vl, int *) = (int)lua_tonumber(L, nres);

  001ae	56		 push	 esi
  001af	85 c0		 test	 eax, eax
  001b1	74 69		 je	 SHORT $LN32@g_Generic_
  001b3	83 45 fc 04	 add	 DWORD PTR tv333[ebp], 4
  001b7	53		 push	 ebx
  001b8	e8 00 00 00 00	 call	 _lua_tonumber
  001bd	83 c4 08	 add	 esp, 8
  001c0	e8 00 00 00 00	 call	 __ftol2_sse
  001c5	8b 55 fc	 mov	 edx, DWORD PTR tv333[ebp]
  001c8	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001ca	89 01		 mov	 DWORD PTR [ecx], eax

; 119  :             break;

  001cc	eb 23		 jmp	 SHORT $LN8@g_Generic_
$LN18@g_Generic_:

; 101  : 		{
; 102  :     
; 103  : 			case 'd':  /* double result */
; 104  : 				if (!lua_isnumber(L, nres))

  001ce	56		 push	 esi
  001cf	53		 push	 ebx
  001d0	e8 00 00 00 00	 call	 _lua_isnumber
  001d5	83 c4 08	 add	 esp, 8

; 105  : 				{
; 106  : 					LogAdd("luacall_Generic_Call wrong result type [%c][%d]", *(sig-1), nres);
; 107  : 					return false;
; 108  : 				}
; 109  : 				*va_arg(vl, double *) = lua_tonumber(L, nres);

  001d8	56		 push	 esi
  001d9	85 c0		 test	 eax, eax
  001db	74 3f		 je	 SHORT $LN32@g_Generic_
  001dd	83 45 fc 04	 add	 DWORD PTR tv333[ebp], 4
  001e1	53		 push	 ebx
  001e2	e8 00 00 00 00	 call	 _lua_tonumber
  001e7	8b 55 fc	 mov	 edx, DWORD PTR tv333[ebp]
  001ea	83 c4 08	 add	 esp, 8
  001ed	8b 02		 mov	 eax, DWORD PTR [edx]
  001ef	dd 18		 fstp	 QWORD PTR [eax]
$LN8@g_Generic_:

; 129  :     
; 130  : 			default:
; 131  : 				LogAdd("luacall_Generic_Call invalid option (%c)", *(sig - 1));
; 132  : 			return false;
; 133  : 		}
; 134  :         nres++;

  001f1	8a 07		 mov	 al, BYTE PTR [edi]
  001f3	46		 inc	 esi
  001f4	84 c0		 test	 al, al
  001f6	0f 85 67 ff ff
	ff		 jne	 $LL6@g_Generic_
$LN7@g_Generic_:

; 135  : 	}
; 136  : 
; 137  : 	if(nRetValCnt)

  001fc	8b 4d f8	 mov	 ecx, DWORD PTR _nRetValCnt$1$[ebp]
  001ff	85 c9		 test	 ecx, ecx
  00201	74 0f		 je	 SHORT $LN25@g_Generic_

; 138  : 		lua_settop(L, -nRetValCnt-1);

  00203	83 c8 ff	 or	 eax, -1
  00206	2b c1		 sub	 eax, ecx
  00208	50		 push	 eax
  00209	53		 push	 ebx
  0020a	e8 00 00 00 00	 call	 _lua_settop
  0020f	83 c4 08	 add	 esp, 8
$LN25@g_Generic_:

; 139  : 
; 140  : //	va_end(vl);
; 141  : 
; 142  : 	return true;

  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	b0 01		 mov	 al, 1
  00216	5b		 pop	 ebx

; 143  : }

  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c3		 ret	 0
$LN30@g_Generic_:

; 123  : 				{
; 124  : 					LogAdd("luacall_Generic_Call wrong result type [%c][%d]", *(sig-1), nres);

  0021b	56		 push	 esi
$LN32@g_Generic_:
  0021c	0f be 47 ff	 movsx	 eax, BYTE PTR [edi-1]
  00220	50		 push	 eax
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 125  : 					return false;

  0022f	32 c0		 xor	 al, al
  00231	5f		 pop	 edi
  00232	5e		 pop	 esi
  00233	5b		 pop	 ebx

; 143  : }

  00234	8b e5		 mov	 esp, ebp
  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
$LN48@g_Generic_:
  00238	00 00 00 00	 DD	 $LN43@g_Generic_
  0023c	00 00 00 00	 DD	 $LN11@g_Generic_
  00240	00 00 00 00	 DD	 $LN12@g_Generic_
  00244	00 00 00 00	 DD	 $LN13@g_Generic_
  00248	00 00 00 00	 DD	 $LN10@g_Generic_
  0024c	00 00 00 00	 DD	 $LN16@g_Generic_
$LN40@g_Generic_:
  00250	00		 DB	 0
  00251	05		 DB	 5
  00252	05		 DB	 5
  00253	05		 DB	 5
  00254	05		 DB	 5
  00255	05		 DB	 5
  00256	05		 DB	 5
  00257	05		 DB	 5
  00258	05		 DB	 5
  00259	05		 DB	 5
  0025a	05		 DB	 5
  0025b	05		 DB	 5
  0025c	05		 DB	 5
  0025d	05		 DB	 5
  0025e	05		 DB	 5
  0025f	05		 DB	 5
  00260	05		 DB	 5
  00261	05		 DB	 5
  00262	05		 DB	 5
  00263	05		 DB	 5
  00264	05		 DB	 5
  00265	05		 DB	 5
  00266	05		 DB	 5
  00267	05		 DB	 5
  00268	05		 DB	 5
  00269	05		 DB	 5
  0026a	05		 DB	 5
  0026b	05		 DB	 5
  0026c	05		 DB	 5
  0026d	05		 DB	 5
  0026e	05		 DB	 5
  0026f	05		 DB	 5
  00270	05		 DB	 5
  00271	05		 DB	 5
  00272	05		 DB	 5
  00273	05		 DB	 5
  00274	05		 DB	 5
  00275	05		 DB	 5
  00276	01		 DB	 1
  00277	05		 DB	 5
  00278	05		 DB	 5
  00279	05		 DB	 5
  0027a	05		 DB	 5
  0027b	02		 DB	 2
  0027c	05		 DB	 5
  0027d	05		 DB	 5
  0027e	05		 DB	 5
  0027f	05		 DB	 5
  00280	05		 DB	 5
  00281	05		 DB	 5
  00282	05		 DB	 5
  00283	05		 DB	 5
  00284	05		 DB	 5
  00285	03		 DB	 3
  00286	05		 DB	 5
  00287	05		 DB	 5
  00288	05		 DB	 5
  00289	04		 DB	 4
?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ ENDP		; g_Generic_Call
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\luafun.cpp
;	COMDAT ?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z
_TEXT	SEGMENT
_DebugGlue$ = -16					; size = 16
_L$ = 8							; size = 4
?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z PROC	; Debug_AddDebugPrintTemp, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 23   : 	luaL_reg DebugGlue[] =
; 24   : 	{
; 25   : 		{"DebugPrint", Debug_Print},
; 26   : 		{NULL, NULL}
; 27   : 	};
; 28   : 
; 29   : 
; 30   : 	for (int i = 0; DebugGlue[i].name; ++i )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _L$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	33 f6		 xor	 esi, esi
  0000e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _DebugGlue$[ebp], OFFSET ??_C@_0L@NNLLPGPO@DebugPrint?$AA@
  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _DebugGlue$[ebp+4], OFFSET ?Debug_Print@@YAHPAUlua_State@@@Z ; Debug_Print
  0001c	33 c0		 xor	 eax, eax
  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _DebugGlue$[ebp+8], 0
  00025	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0L@NNLLPGPO@DebugPrint?$AA@
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _DebugGlue$[ebp+12], 0
$LL4@Debug_AddD:

; 31   : 	{
; 32   : 		lua_pushcclosure(L, DebugGlue[i].func, 0);

  00031	6a 00		 push	 0
  00033	ff 74 05 f4	 push	 DWORD PTR _DebugGlue$[ebp+eax+4]
  00037	53		 push	 ebx
  00038	e8 00 00 00 00	 call	 _lua_pushcclosure

; 33   : 		lua_setfield(L, LUA_GLOBALSINDEX, DebugGlue[i].name);

  0003d	57		 push	 edi
  0003e	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00043	53		 push	 ebx
  00044	e8 00 00 00 00	 call	 _lua_setfield
  00049	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
  0004f	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00056	8b 7c 05 f0	 mov	 edi, DWORD PTR _DebugGlue$[ebp+eax]
  0005a	85 ff		 test	 edi, edi
  0005c	75 d3		 jne	 SHORT $LL4@Debug_AddD
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 34   : 	}
; 35   : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z ENDP	; Debug_AddDebugPrintTemp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\luafun.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 144  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\luafun.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 144  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
