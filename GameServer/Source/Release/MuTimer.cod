; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\MuTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CMuTimer@@QAE@XZ				; CMuTimer::CMuTimer
PUBLIC	??1CMuTimer@@UAE@XZ				; CMuTimer::~CMuTimer
PUBLIC	?SetMuTimer@CMuTimer@@QAEXXZ			; CMuTimer::SetMuTimer
PUBLIC	?GetTimerEnd@CMuTimer@@QAEHXZ			; CMuTimer::GetTimerEnd
PUBLIC	?SetTimerEnd@CMuTimer@@QAEXXZ			; CMuTimer::SetTimerEnd
PUBLIC	??_GCMuTimer@@UAEPAXI@Z				; CMuTimer::`scalar deleting destructor'
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?getInstance@MonsterSpawnerMng@@SAPAV1@XZ	; MonsterSpawnerMng::getInstance
PUBLIC	?TimerProcQueue@@YGXPAXH@Z			; TimerProcQueue
PUBLIC	?TimerProcQueue2@@YGXPAXH@Z			; TimerProcQueue2
PUBLIC	??_7CMuTimer@@6B@				; CMuTimer::`vftable'
PUBLIC	?g_MuTimer@@3VCMuTimer@@A			; g_MuTimer
PUBLIC	??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@	; `string'
PUBLIC	??_R4CMuTimer@@6B@				; CMuTimer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMuTimer@@@8				; CMuTimer `RTTI Type Descriptor'
PUBLIC	??_R3CMuTimer@@8				; CMuTimer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMuTimer@@8				; CMuTimer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMuTimer@@8			; CMuTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	__imp__timeBeginPeriod@4:PROC
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	??0CQueueTimer@@QAE@XZ:PROC			; CQueueTimer::CQueueTimer
EXTRN	?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z:PROC	; CQueueTimer::RegCallBack
EXTRN	??1CQueueTimer@@UAE@XZ:PROC			; CQueueTimer::~CQueueTimer
EXTRN	?CreateTimer@CQueueTimer@@QAEHHKK@Z:PROC	; CQueueTimer::CreateTimer
EXTRN	?SyncLock@CQueueTimer@@QAEXXZ:PROC		; CQueueTimer::SyncLock
EXTRN	?SyncUnlock@CQueueTimer@@QAEXXZ:PROC		; CQueueTimer::SyncUnlock
EXTRN	??_ECMuTimer@@UAEPAXI@Z:PROC			; CMuTimer::`vector deleting destructor'
EXTRN	?UpdateRun@CGensSystem@@QAEXXZ:PROC		; CGensSystem::UpdateRun
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?LogDateChange@@YAHXZ:PROC			; LogDateChange
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?MonsterAndMsgProc@@YAXXZ:PROC			; MonsterAndMsgProc
EXTRN	?MoveMonsterProc@@YAXXZ:PROC			; MoveMonsterProc
EXTRN	?gObjAllLogOut@@YAXXZ:PROC			; gObjAllLogOut
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjViewportListCreate@@YAXF@Z:PROC		; gObjViewportListCreate
EXTRN	?gObjViewportListDestroy@@YAXF@Z:PROC		; gObjViewportListDestroy
EXTRN	?PShop_ViewportListRegenarate@@YAXF@Z:PROC	; PShop_ViewportListRegenarate
EXTRN	?gObjStateSetCreate@@YAXH@Z:PROC		; gObjStateSetCreate
EXTRN	?gObjSetState@@YAXXZ:PROC			; gObjSetState
EXTRN	?gObjSecondProc@@YAXXZ:PROC			; gObjSecondProc
EXTRN	?gObjViewportListProtocol@@YAXF@Z:PROC		; gObjViewportListProtocol
EXTRN	?gObjUnionUpdateProc@@YAXH@Z:PROC		; gObjUnionUpdateProc
EXTRN	?WeatherVariationProcess@MapClass@@QAEXXZ:PROC	; MapClass::WeatherVariationProcess
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?DGGuildListRequest@@YAXXZ:PROC			; DGGuildListRequest
EXTRN	?Run@CKanturu@@QAEXXZ:PROC			; CKanturu::Run
EXTRN	?UserMonsterCountCheck@CKanturu@@QAEXXZ:PROC	; CKanturu::UserMonsterCountCheck
EXTRN	?Run@CBloodCastle@@QAEXXZ:PROC			; CBloodCastle::Run
EXTRN	?Run@CRingAttackEvent@@QAEXXZ:PROC		; CRingAttackEvent::Run
EXTRN	?Run@CXMasAttackEvent@@QAEXXZ:PROC		; CXMasAttackEvent::Run
EXTRN	?Run@CChaosCastle@@QAEXXZ:PROC			; CChaosCastle::Run
EXTRN	?WeaponAttackProc@CWeapon@@QAEXXZ:PROC		; CWeapon::WeaponAttackProc
EXTRN	?Run@CIllusionTempleEvent@@QAEXXZ:PROC		; CIllusionTempleEvent::Run
EXTRN	?Run@CRaklion@@QAEXXZ:PROC			; CRaklion::Run
EXTRN	?MonsterMoveProc@TMonsterAI@@SAXXZ:PROC		; TMonsterAI::MonsterMoveProc
EXTRN	?MonsterAIProc@TMonsterAI@@SAXXZ:PROC		; TMonsterAI::MonsterAIProc
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?Run@CDragonEvent@@QAEXXZ:PROC			; CDragonEvent::Run
EXTRN	?TimeCheckCashDelete@CWhisperCash@@QAEXXZ:PROC	; CWhisperCash::TimeCheckCashDelete
EXTRN	?Run@CAttackEvent@@QAEXXZ:PROC			; CAttackEvent::Run
EXTRN	?gSetDate@@YAXXZ:PROC				; gSetDate
EXTRN	?GameServerInfoSend@@YAXXZ:PROC			; GameServerInfoSend
EXTRN	?Run@CEledoradoEvent@@QAEXXZ:PROC		; CEledoradoEvent::Run
EXTRN	?Run@CEventManagement@@QAEXXZ:PROC		; CEventManagement::Run
EXTRN	?AdjustTributeMoney@CCastleSiegeSync@@QAEXXZ:PROC ; CCastleSiegeSync::AdjustTributeMoney
EXTRN	?Run@CImperialGuardian@@QAEXXZ:PROC		; CImperialGuardian::Run
EXTRN	?DataRequest@CCastleSiege@@QAEHXZ:PROC		; CCastleSiege::DataRequest
EXTRN	?Run@CCastleSiege@@QAEXXZ:PROC			; CCastleSiege::Run
EXTRN	?GetDataLoadState@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetDataLoadState
EXTRN	?SendCastleStateSync@CCastleSiege@@QAEXXZ:PROC	; CCastleSiege::SendCastleStateSync
EXTRN	?Run@CCrywolf@@QAEXXZ:PROC			; CCrywolf::Run
EXTRN	?CrywolfSecondAct@CCrywolf@@QAEXXZ:PROC		; CCrywolf::CrywolfSecondAct
EXTRN	?Run@CCastleDeepEvent@@QAEXXZ:PROC		; CCastleDeepEvent::Run
EXTRN	?Run@CDoubleGoerEvent@@QAEXXZ:PROC		; CDoubleGoerEvent::Run
EXTRN	?GetActiveDS@DBSockMng@@QAEHXZ:PROC		; DBSockMng::GetActiveDS
EXTRN	?ClearOverTimeUserData@CTemporaryUserManager@@QAEHK@Z:PROC ; CTemporaryUserManager::ClearOverTimeUserData
EXTRN	?Load@CConMember@@QAEXPAD@Z:PROC		; CConMember::Load
EXTRN	?Run@CNewPVP@@QAEXXZ:PROC			; CNewPVP::Run
EXTRN	??0MonsterSpawnerMng@@QAE@XZ:PROC		; MonsterSpawnerMng::MonsterSpawnerMng
EXTRN	?procRun@MonsterSpawnerMng@@QAEXXZ:PROC		; MonsterSpawnerMng::procRun
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?gGensSystem@@3VCGensSystem@@A:BYTE		; gGensSystem
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_Kanturu@@3VCKanturu@@A:BYTE			; g_Kanturu
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?gCloseMsg@@3HA:DWORD				; gCloseMsg
EXTRN	?gCloseMsgTime@@3HA:DWORD			; gCloseMsgTime
EXTRN	?g_RingAttackEvent@@3VCRingAttackEvent@@A:BYTE	; g_RingAttackEvent
EXTRN	?g_XMasAttackEvent@@3VCXMasAttackEvent@@A:BYTE	; g_XMasAttackEvent
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?g_CsNPC_Weapon@@3VCWeapon@@A:BYTE		; g_CsNPC_Weapon
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	?g_Raklion@@3VCRaklion@@A:BYTE			; g_Raklion
EXTRN	?DragonEvent@@3PAVCDragonEvent@@A:DWORD		; DragonEvent
EXTRN	?AttackEvent@@3PAVCAttackEvent@@A:DWORD		; AttackEvent
EXTRN	?g_ConnectMemberReload@@3_NA:BYTE		; g_ConnectMemberReload
EXTRN	?g_ConnectMemberReloadTime@@3HA:DWORD		; g_ConnectMemberReloadTime
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
EXTRN	?wsGServer@@3VCwsGameServer@@A:BYTE		; wsGServer
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?gEledoradoEvent@@3VCEledoradoEvent@@A:BYTE	; gEledoradoEvent
EXTRN	?g_EventManager@@3VCEventManagement@@A:BYTE	; g_EventManager
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?g_ImperialGuardian@@3VCImperialGuardian@@A:BYTE ; g_ImperialGuardian
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_iCastleItemMixLimit@@3HA:DWORD		; g_iCastleItemMixLimit
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
EXTRN	?g_CastleDeepEvent@@3VCCastleDeepEvent@@A:BYTE	; g_CastleDeepEvent
EXTRN	?gDoubleGoer@@3VCDoubleGoerEvent@@A:BYTE	; gDoubleGoer
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?cpTimerTempUserManager@@3PAVCTemporaryUserManager@@A:DWORD ; cpTimerTempUserManager
EXTRN	?g_MaintainUserConnectionSecond@@3HA:DWORD	; g_MaintainUserConnectionSecond
EXTRN	?ConMember@@3VCConMember@@A:BYTE		; ConMember
EXTRN	?g_NewPVP@@3VCNewPVP@@A:BYTE			; g_NewPVP
EXTRN	?m_Instance@MonsterSpawnerMng@@0PAV1@A:DWORD	; MonsterSpawnerMng::m_Instance
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?g_MuTimer@@3VCMuTimer@@A DB 080H DUP (?)		; g_MuTimer
_BSS	ENDS
CRT$XCU	SEGMENT
?g_MuTimer$initializer$@@3P6AXXZA DD FLAT:??__Eg_MuTimer@@YAXXZ ; g_MuTimer$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CMuTimer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMuTimer@@8 DD FLAT:??_R0?AVCMuTimer@@@8	; CMuTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMuTimer@@8
rdata$r	ENDS
;	COMDAT ??_R2CMuTimer@@8
rdata$r	SEGMENT
??_R2CMuTimer@@8 DD FLAT:??_R1A@?0A@EA@CMuTimer@@8	; CMuTimer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMuTimer@@8
rdata$r	SEGMENT
??_R3CMuTimer@@8 DD 00H					; CMuTimer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMuTimer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMuTimer@@@8
data$r	SEGMENT
??_R0?AVCMuTimer@@@8 DD FLAT:??_7type_info@@6B@		; CMuTimer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMuTimer@@', 00H
data$r	ENDS
;	COMDAT ??_R4CMuTimer@@6B@
rdata$r	SEGMENT
??_R4CMuTimer@@6B@ DD 00H				; CMuTimer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMuTimer@@@8
	DD	FLAT:??_R3CMuTimer@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@
CONST	SEGMENT
??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@ DB 'ConnectMember.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CMuTimer@@6B@
CONST	SEGMENT
??_7CMuTimer@@6B@ DD FLAT:??_R4CMuTimer@@6B@		; CMuTimer::`vftable'
	DD	FLAT:??_ECMuTimer@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0
__ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CMuTimer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CMuTimer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CMuTimer@@QAE@XZ$1
__ehfuncinfo$??0CMuTimer@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CMuTimer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_MuTimer@@YAXXZ
text$yd	SEGMENT
??__Fg_MuTimer@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MuTimer'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00005	e9 00 00 00 00	 jmp	 ??1CMuTimer@@UAE@XZ	; CMuTimer::~CMuTimer
??__Fg_MuTimer@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MuTimer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ??__Eg_MuTimer@@YAXXZ
text$di	SEGMENT
??__Eg_MuTimer@@YAXXZ PROC				; `dynamic initializer for 'g_MuTimer'', COMDAT

; 45   : CMuTimer g_MuTimer;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00005	e8 00 00 00 00	 call	 ??0CMuTimer@@QAE@XZ	; CMuTimer::CMuTimer
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_MuTimer@@YAXXZ ; `dynamic atexit destructor for 'g_MuTimer''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_MuTimer@@YAXXZ ENDP				; `dynamic initializer for 'g_MuTimer''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ?TimerProcQueue2@@YGXPAXH@Z
_TEXT	SEGMENT
_lpParametar$ = 8					; size = 4
_TimerOrWaitFired$ = 12					; size = 4
?TimerProcQueue2@@YGXPAXH@Z PROC			; TimerProcQueue2, COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 	if (g_MuTimer.GetTimerEnd() == TRUE)

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00008	e8 00 00 00 00	 call	 ?GetTimerEnd@CMuTimer@@QAEHXZ ; CMuTimer::GetTimerEnd
  0000d	83 f8 01	 cmp	 eax, 1
  00010	0f 84 e2 00 00
	00		 je	 $LN1@TimerProcQ

; 311  : 	{
; 312  : 		return;
; 313  : 	}
; 314  : 	
; 315  : 	g_MuTimer.m_QueueTimer2.SyncLock();

  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	b9 40 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+64
  0001d	e8 00 00 00 00	 call	 ?SyncLock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncLock

; 316  : 		
; 317  : 	int nEventID = *(DWORD*)lpParametar;

  00022	8b 45 08	 mov	 eax, DWORD PTR _lpParametar$[ebp]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]

; 318  : 	
; 319  : 	switch (nEventID)

  00027	83 f8 65	 cmp	 eax, 101		; 00000065H
  0002a	74 4b		 je	 SHORT $LN17@TimerProcQ
  0002c	3d f4 03 00 00	 cmp	 eax, 1012		; 000003f4H
  00031	0f 85 b5 00 00
	00		 jne	 $LN14@TimerProcQ

; 349  : 
; 350  : 		} break;
; 351  : 		
; 352  : 		case WM_VIEWPORT_UPDATE:
; 353  : 		{
; 354  : 			for (int n = 0; n < OBJMAX; n++)

  00037	33 ff		 xor	 edi, edi
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL15@TimerProcQ:

; 355  : 			{
; 356  : 				gObjStateSetCreate(n);

  00040	57		 push	 edi
  00041	e8 00 00 00 00	 call	 ?gObjStateSetCreate@@YAXH@Z ; gObjStateSetCreate

; 357  : 				gObjViewportListDestroy(n);

  00046	0f b7 f7	 movzx	 esi, di
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?gObjViewportListDestroy@@YAXF@Z ; gObjViewportListDestroy

; 358  : 				gObjViewportListCreate(n);

  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ?gObjViewportListCreate@@YAXF@Z ; gObjViewportListCreate

; 359  : 				gObjViewportListProtocol(n);

  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ?gObjViewportListProtocol@@YAXF@Z ; gObjViewportListProtocol
  0005b	47		 inc	 edi
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	81 ff ec 2c 00
	00		 cmp	 edi, 11500		; 00002cecH
  00065	7c d9		 jl	 SHORT $LL15@TimerProcQ

; 360  : 			}
; 361  : 		} 
; 362  : 		break;
; 363  : 	}
; 364  : 		
; 365  : 	g_MuTimer.m_QueueTimer2.SyncUnlock();

  00067	b9 40 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+64
  0006c	e8 00 00 00 00	 call	 ?SyncUnlock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncUnlock
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi

; 366  : }

  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN17@TimerProcQ:

; 320  : 	{
; 321  : 		case WM_FIRST_MSG_PROCESS:
; 322  : 		{
; 323  : 			int n;
; 324  : 
; 325  : 			if (gDoPShopOpen != FALSE)

  00077	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0007e	74 4a		 je	 SHORT $LN8@TimerProcQ

; 326  : 			{
; 327  : 				for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  00080	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
$LL6@TimerProcQ:

; 328  : 				{
; 329  : 					PShop_ViewportListRegenarate(n);

  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?PShop_ViewportListRegenarate@@YAXF@Z ; PShop_ViewportListRegenarate
  0008b	46		 inc	 esi
  0008c	83 c4 04	 add	 esp, 4
  0008f	81 fe ec 2c 00
	00		 cmp	 esi, 11500		; 00002cecH
  00095	7c ee		 jl	 SHORT $LL6@TimerProcQ

; 330  : 				}
; 331  : 				
; 332  : 				for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  00097	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0009c	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL9@TimerProcQ:

; 333  : 				{
; 334  : 					if (gObjIsConnected(n) != PLAYER_EMPTY)

  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000a7	83 c4 04	 add	 esp, 4
  000aa	85 c0		 test	 eax, eax
  000ac	74 0d		 je	 SHORT $LN7@TimerProcQ

; 335  : 					{
; 336  : 						gObj[n].m_bPShopItemChange = false;

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b3	c6 84 06 5e 12
	00 00 00	 mov	 BYTE PTR [esi+eax+4702], 0
$LN7@TimerProcQ:

; 330  : 				}
; 331  : 				
; 332  : 				for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  000bb	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  000c1	47		 inc	 edi
  000c2	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  000c8	7c d7		 jl	 SHORT $LL9@TimerProcQ
$LN8@TimerProcQ:

; 337  : 					}
; 338  : 				}
; 339  : 			}
; 340  : 			
; 341  : 			for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  000ca	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
  000cf	90		 npad	 1
$LL12@TimerProcQ:

; 342  : 			{
; 343  : 				gObjUnionUpdateProc(n);

  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ?gObjUnionUpdateProc@@YAXH@Z ; gObjUnionUpdateProc
  000d6	46		 inc	 esi
  000d7	83 c4 04	 add	 esp, 4
  000da	81 fe ec 2c 00
	00		 cmp	 esi, 11500		; 00002cecH
  000e0	7c ee		 jl	 SHORT $LL12@TimerProcQ

; 344  : 			}
; 345  : 			
; 346  : 			gObjSetState();

  000e2	e8 00 00 00 00	 call	 ?gObjSetState@@YAXXZ	; gObjSetState

; 347  : 
; 348  : 			GameServerInfoSend();

  000e7	e8 00 00 00 00	 call	 ?GameServerInfoSend@@YAXXZ ; GameServerInfoSend
$LN14@TimerProcQ:

; 360  : 			}
; 361  : 		} 
; 362  : 		break;
; 363  : 	}
; 364  : 		
; 365  : 	g_MuTimer.m_QueueTimer2.SyncUnlock();

  000ec	b9 40 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+64
  000f1	e8 00 00 00 00	 call	 ?SyncUnlock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncUnlock
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
$LN1@TimerProcQ:

; 366  : }

  000f8	5d		 pop	 ebp
  000f9	c2 08 00	 ret	 8
?TimerProcQueue2@@YGXPAXH@Z ENDP			; TimerProcQueue2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ?TimerProcQueue@@YGXPAXH@Z
_TEXT	SEGMENT
_szTemp$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpParametar$ = 8					; size = 4
_TimerOrWaitFired$ = 12					; size = 4
?TimerProcQueue@@YGXPAXH@Z PROC				; TimerProcQueue, COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 106  : 	if( g_MuTimer.GetTimerEnd() == TRUE )

  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00018	e8 00 00 00 00	 call	 ?GetTimerEnd@CMuTimer@@QAEHXZ ; CMuTimer::GetTimerEnd
  0001d	83 f8 01	 cmp	 eax, 1
  00020	0f 84 1d 03 00
	00		 je	 $LN1@TimerProcQ

; 107  : 		return;
; 108  : 
; 109  : 	g_MuTimer.m_QueueTimer1.SyncLock();

  00026	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+4
  0002b	e8 00 00 00 00	 call	 ?SyncLock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncLock

; 110  : 
; 111  : 	int nEventID = *(int*)(lpParametar);
; 112  : 	
; 113  : 	switch(nEventID)

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpParametar$[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	05 18 fc ff ff	 add	 eax, -1000		; fffffc18H
  0003a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003d	0f 87 f6 02 00
	00		 ja	 $LN28@TimerProcQ
  00043	56		 push	 esi
  00044	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN38@TimerProcQ[eax*4]
$LN8@TimerProcQ:

; 114  : 	{
; 115  : 	case WM_GUILD_LIST_REQUEST:	DGGuildListRequest();	break;

  0004b	e8 00 00 00 00	 call	 ?DGGuildListRequest@@YAXXZ ; DGGuildListRequest
  00050	e9 e3 02 00 00	 jmp	 $LN35@TimerProcQ
$LN9@TimerProcQ:

; 116  : 	case WM_MONSTER_AND_MSG_PROC:
; 117  : 		MonsterAndMsgProc();

  00055	e8 00 00 00 00	 call	 ?MonsterAndMsgProc@@YAXXZ ; MonsterAndMsgProc

; 118  : 		//gDuelSystem.Run();
; 119  : #if (ENABLETEST_NEWPVP == 1)
; 120  : 		g_NewPVP.Run();

  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0005f	e8 00 00 00 00	 call	 ?Run@CNewPVP@@QAEXXZ	; CNewPVP::Run

; 121  : #endif
; 122  : 		break;

  00064	e9 cf 02 00 00	 jmp	 $LN35@TimerProcQ
$LN11@TimerProcQ:

; 123  : 	case WM_DUEL_RUN_PROC:
; 124  : 		//g_DuelManager.Run();
; 125  : 		break;
; 126  : 	case WM_MOVE_MONSTER_PROC:
; 127  : 		MoveMonsterProc();

  00069	e8 00 00 00 00	 call	 ?MoveMonsterProc@@YAXXZ	; MoveMonsterProc

; 128  : 		g_Kanturu.UserMonsterCountCheck();

  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Kanturu@@3VCKanturu@@A ; g_Kanturu
  00073	e8 00 00 00 00	 call	 ?UserMonsterCountCheck@CKanturu@@QAEXXZ ; CKanturu::UserMonsterCountCheck

; 129  : 		break;

  00078	e9 bb 02 00 00	 jmp	 $LN35@TimerProcQ
$LN12@TimerProcQ:

; 130  : 	case WM_EVENT_RUN_PROC:
; 131  : #if (ENABLE_CUSTOM_MONSTERSPAWNER == 1)
; 132  : 		MonsterSpawnerMng::getInstance()->procRun();

  0007d	e8 00 00 00 00	 call	 ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ; MonsterSpawnerMng::getInstance
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 ?procRun@MonsterSpawnerMng@@QAEXXZ ; MonsterSpawnerMng::procRun

; 133  : #endif
; 134  : 		g_BloodCastle.Run();

  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0008e	e8 00 00 00 00	 call	 ?Run@CBloodCastle@@QAEXXZ ; CBloodCastle::Run

; 135  : 		g_RingAttackEvent.Run();

  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RingAttackEvent@@3VCRingAttackEvent@@A ; g_RingAttackEvent
  00098	e8 00 00 00 00	 call	 ?Run@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::Run

; 136  : 		g_ChaosCastle.Run();

  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  000a2	e8 00 00 00 00	 call	 ?Run@CChaosCastle@@QAEXXZ ; CChaosCastle::Run

; 137  : 		g_IllusionTemple.Run();

  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000ac	e8 00 00 00 00	 call	 ?Run@CIllusionTempleEvent@@QAEXXZ ; CIllusionTempleEvent::Run

; 138  : #if (GS_CASTLE==1)
; 139  : 		g_CastleSiege.Run();

  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b6	e8 00 00 00 00	 call	 ?Run@CCastleSiege@@QAEXXZ ; CCastleSiege::Run

; 140  : 		g_CastleDeepEvent.Run();

  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleDeepEvent@@3VCCastleDeepEvent@@A ; g_CastleDeepEvent
  000c0	e8 00 00 00 00	 call	 ?Run@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::Run

; 141  : 		g_CsNPC_Weapon.WeaponAttackProc();

  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  000ca	e8 00 00 00 00	 call	 ?WeaponAttackProc@CWeapon@@QAEXXZ ; CWeapon::WeaponAttackProc

; 142  : 		g_Crywolf.Run();

  000cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A ; g_Crywolf
  000d4	e8 00 00 00 00	 call	 ?Run@CCrywolf@@QAEXXZ	; CCrywolf::Run

; 143  : #endif
; 144  : #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 145  : 		g_Kanturu.Run();

  000d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Kanturu@@3VCKanturu@@A ; g_Kanturu
  000de	e8 00 00 00 00	 call	 ?Run@CKanturu@@QAEXXZ	; CKanturu::Run

; 146  : 		g_CsNPC_Weapon.WeaponAttackProc();

  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  000e8	e8 00 00 00 00	 call	 ?WeaponAttackProc@CWeapon@@QAEXXZ ; CWeapon::WeaponAttackProc

; 147  : #endif
; 148  : 		g_Raklion.Run();

  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Raklion@@3VCRaklion@@A ; g_Raklion
  000f2	e8 00 00 00 00	 call	 ?Run@CRaklion@@QAEXXZ	; CRaklion::Run

; 149  : 		g_XMasAttackEvent.Run();

  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_XMasAttackEvent@@3VCXMasAttackEvent@@A ; g_XMasAttackEvent
  000fc	e8 00 00 00 00	 call	 ?Run@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::Run

; 150  : 		g_ImperialGuardian.Run();

  00101	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  00106	e8 00 00 00 00	 call	 ?Run@CImperialGuardian@@QAEXXZ ; CImperialGuardian::Run

; 151  : 		gDoubleGoer.Run();

  0010b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  00110	e8 00 00 00 00	 call	 ?Run@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::Run

; 152  : 
; 153  : #if (ENABLETEST_ACHERON == 1)
; 154  : 		g_AcheronGuardianEvent.Run();
; 155  : #endif
; 156  : 
; 157  : #ifdef VMPROTECT
; 158  : 		if( VMProtectIsDebuggerPresent(true) )
; 159  : 		{
; 160  : 			ExitProcess(0);
; 161  : 		}
; 162  : #endif
; 163  : 		break;

  00115	e9 1e 02 00 00	 jmp	 $LN35@TimerProcQ
$LN13@TimerProcQ:

; 164  : 	case WM_AI_MONSTER_MOVE_PROC: TMonsterAI::MonsterMoveProc();	break;

  0011a	e8 00 00 00 00	 call	 ?MonsterMoveProc@TMonsterAI@@SAXXZ ; TMonsterAI::MonsterMoveProc
  0011f	e9 14 02 00 00	 jmp	 $LN35@TimerProcQ
$LN14@TimerProcQ:

; 165  : 	case WM_AI_MONSTER_PROC: TMonsterAI::MonsterAIProc();	break;

  00124	e8 00 00 00 00	 call	 ?MonsterAIProc@TMonsterAI@@SAXXZ ; TMonsterAI::MonsterAIProc
  00129	e9 0a 02 00 00	 jmp	 $LN35@TimerProcQ
$LN15@TimerProcQ:

; 166  : 	case WM_SECOND_MSG_PROCESS:
; 167  : 		{
; 168  : 			for(int n = 0; n < MAX_NUMBER_MAP; n++ )

  0012e	be 00 00 00 00	 mov	 esi, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
$LL6@TimerProcQ:

; 169  : 			{
; 170  : 				MapC[n].WeatherVariationProcess();

  00133	8b ce		 mov	 ecx, esi
  00135	e8 00 00 00 00	 call	 ?WeatherVariationProcess@MapClass@@QAEXXZ ; MapClass::WeatherVariationProcess
  0013a	81 c6 28 38 05
	00		 add	 esi, 342056		; 00053828H
  00140	81 fe a0 ef 09
	02		 cmp	 esi, OFFSET ?MapC@@3PAVMapClass@@A+34205600
  00146	7c eb		 jl	 SHORT $LL6@TimerProcQ

; 171  : 			}
; 172  : 
; 173  : 			wsGServer.m_SendSec = wsGServer.m_SendSecTmp;

  00148	a1 20 00 00 00	 mov	 eax, DWORD PTR ?wsGServer@@3VCwsGameServer@@A+32

; 174  : 			wsGServer.m_RecvSec = wsGServer.m_RecvSecTmp;
; 175  : 			wsGServer.m_SendSecTmp = 0;
; 176  : 			wsGServer.m_RecvSecTmp = 0;
; 177  : 			DragonEvent->Run();

  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00153	a3 1c 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+28, eax
  00158	a1 28 00 00 00	 mov	 eax, DWORD PTR ?wsGServer@@3VCwsGameServer@@A+40
  0015d	a3 24 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+36, eax
  00162	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+32, 0
  0016c	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+40, 0
  00176	e8 00 00 00 00	 call	 ?Run@CDragonEvent@@QAEXXZ ; CDragonEvent::Run

; 178  : 			AttackEvent->Run();

  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AttackEvent@@3PAVCAttackEvent@@A ; AttackEvent
  00181	e8 00 00 00 00	 call	 ?Run@CAttackEvent@@QAEXXZ ; CAttackEvent::Run

; 179  : 			gEledoradoEvent.Run();

  00186	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  0018b	e8 00 00 00 00	 call	 ?Run@CEledoradoEvent@@QAEXXZ ; CEledoradoEvent::Run

; 180  : 			g_EventManager.Run();

  00190	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventManager@@3VCEventManagement@@A ; g_EventManager
  00195	e8 00 00 00 00	 call	 ?Run@CEventManagement@@QAEXXZ ; CEventManagement::Run

; 181  : #if (CUSTOM_OLYMP==1)
; 182  : 			g_CustomOlymp.Run();
; 183  : #endif
; 184  : 		}
; 185  : 		break;

  0019a	e9 99 01 00 00	 jmp	 $LN35@TimerProcQ
$LN16@TimerProcQ:

; 186  : 	case WM_CONNECTMEMBER_RELOAD:
; 187  : 		{
; 188  : 			ConMember.Load(gDirPath.GetNewPath(FILE_WHITELIST));

  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@
  001a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001a9	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001ae	50		 push	 eax
  001af	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  001b4	e8 00 00 00 00	 call	 ?Load@CConMember@@QAEXPAD@Z ; CConMember::Load

; 189  : 		}
; 190  : 		break;

  001b9	e9 7a 01 00 00	 jmp	 $LN35@TimerProcQ
$LN17@TimerProcQ:

; 191  : 	case WM_GS_CLOSE:
; 192  : 		if ( gCloseMsg != 0 )

  001be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCloseMsg@@3HA, 0 ; gCloseMsg
  001c5	0f 84 d9 00 00
	00		 je	 $LN23@TimerProcQ

; 193  : 		{
; 194  : 			gCloseMsgTime--;

  001cb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gCloseMsgTime@@3HA ; gCloseMsgTime
  001d1	4e		 dec	 esi
  001d2	89 35 00 00 00
	00		 mov	 DWORD PTR ?gCloseMsgTime@@3HA, esi ; gCloseMsgTime

; 195  : 
; 196  : 			if ( gCloseMsgTime <= 1 )

  001d8	83 fe 01	 cmp	 esi, 1
  001db	7f 3b		 jg	 SHORT $LN19@TimerProcQ

; 197  : 			{
; 198  : 				if ( gCloseMsgTime == 1 )

  001dd	0f 85 93 00 00
	00		 jne	 $LN22@TimerProcQ

; 199  : 				{
; 200  : 					AllSendServerMsg(lMsg.Get(MSGGET(1, 193)));

  001e3	68 c1 01 00 00	 push	 449			; 000001c1H
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ed	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  001f8	83 c4 04	 add	 esp, 4

; 201  : 					LogAddC(2, lMsg.Get(MSGGET(1, 193)));

  001fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00200	68 c1 01 00 00	 push	 449			; 000001c1H
  00205	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0020a	50		 push	 eax
  0020b	6a 02		 push	 2
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00213	83 c4 08	 add	 esp, 8

; 202  : 				}
; 203  : 			}
; 204  : 			else

  00216	eb 58		 jmp	 SHORT $LN36@TimerProcQ
$LN19@TimerProcQ:

; 205  : 			{
; 206  : 				if ( (gCloseMsgTime % 10) == 0 )

  00218	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0021d	f7 ee		 imul	 esi
  0021f	c1 fa 02	 sar	 edx, 2
  00222	8b c2		 mov	 eax, edx
  00224	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00227	03 c2		 add	 eax, edx
  00229	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0022c	8b c6		 mov	 eax, esi
  0022e	03 c9		 add	 ecx, ecx
  00230	2b c1		 sub	 eax, ecx
  00232	75 42		 jne	 SHORT $LN22@TimerProcQ

; 207  : 				{
; 208  : 					char szTemp[256];
; 209  : 
; 210  : 					wsprintf( szTemp, lMsg.Get(MSGGET(1, 194)), gCloseMsgTime);

  00234	56		 push	 esi
  00235	68 c2 01 00 00	 push	 450			; 000001c2H
  0023a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0023f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00244	50		 push	 eax
  00245	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  0024b	50		 push	 eax
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 211  : 					AllSendServerMsg(szTemp);

  00252	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 212  : 					LogAddC(2, szTemp);

  0025e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  00264	50		 push	 eax
  00265	6a 02		 push	 2
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0026d	83 c4 18	 add	 esp, 24			; 00000018H
$LN36@TimerProcQ:
  00270	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gCloseMsgTime@@3HA ; gCloseMsgTime
$LN22@TimerProcQ:

; 213  : 				}
; 214  : 			}
; 215  : 
; 216  : 			if ( gCloseMsgTime < 0 )

  00276	85 f6		 test	 esi, esi
  00278	79 2a		 jns	 SHORT $LN23@TimerProcQ

; 217  : 			{
; 218  : 				KillTimer(ghWnd, WM_GS_CLOSE);

  0027a	68 ea 03 00 00	 push	 1002			; 000003eaH
  0027f	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00285	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 219  : 				gObjAllLogOut();

  0028b	e8 00 00 00 00	 call	 ?gObjAllLogOut@@YAXXZ	; gObjAllLogOut

; 220  : 				gCloseMsgTime = 0;

  00290	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCloseMsgTime@@3HA, 0 ; gCloseMsgTime

; 221  : 				gCloseMsg = 0;

  0029a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCloseMsg@@3HA, 0 ; gCloseMsg
$LN23@TimerProcQ:

; 222  : 			}
; 223  : 		}
; 224  : 		gObjSecondProc();

  002a4	e8 00 00 00 00	 call	 ?gObjSecondProc@@YAXXZ	; gObjSecondProc

; 225  : #if (GS_CASTLE == 1)
; 226  : 		if(cDBSMng.GetActiveDS() > -1)

  002a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002ae	e8 00 00 00 00	 call	 ?GetActiveDS@DBSockMng@@QAEHXZ ; DBSockMng::GetActiveDS
  002b3	83 f8 ff	 cmp	 eax, -1
  002b6	7e 19		 jle	 SHORT $LN25@TimerProcQ

; 227  : 		{
; 228  : 			if(g_CastleSiege.GetDataLoadState() == 2)

  002b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002bd	e8 00 00 00 00	 call	 ?GetDataLoadState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDataLoadState
  002c2	83 f8 02	 cmp	 eax, 2
  002c5	75 0a		 jne	 SHORT $LN25@TimerProcQ

; 229  : 			{
; 230  : 				g_CastleSiege.DataRequest();

  002c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002cc	e8 00 00 00 00	 call	 ?DataRequest@CCastleSiege@@QAEHXZ ; CCastleSiege::DataRequest
$LN25@TimerProcQ:

; 231  : 			}
; 232  : 
; 233  : #if (CUSTOM_OLYMP==1)
; 234  : 			if(g_CustomOlymp.GetDataLoadState() == 2 )
; 235  : 			{
; 236  : 				g_CustomOlymp.DataRequest();
; 237  : 			}
; 238  : 			
; 239  : #endif
; 240  : 		}
; 241  : 					
; 242  : 		g_CastleSiege.SendCastleStateSync();

  002d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002d6	e8 00 00 00 00	 call	 ?SendCastleStateSync@CCastleSiege@@QAEXXZ ; CCastleSiege::SendCastleStateSync

; 243  : 		g_CastleSiegeSync.AdjustTributeMoney();

  002db	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  002e0	e8 00 00 00 00	 call	 ?AdjustTributeMoney@CCastleSiegeSync@@QAEXXZ ; CCastleSiegeSync::AdjustTributeMoney

; 244  : 		g_Crywolf.CrywolfSecondAct();

  002e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A ; g_Crywolf
  002ea	e8 00 00 00 00	 call	 ?CrywolfSecondAct@CCrywolf@@QAEXXZ ; CCrywolf::CrywolfSecondAct

; 245  : #endif
; 246  : #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 247  : 		//g_CastleSiegeSync.AdjustTributeMoney();
; 248  : #if(__GENS_SYSTEM__ == 1)
; 249  : 		gGensSystem.UpdateRun();

  002ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  002f4	e8 00 00 00 00	 call	 ?UpdateRun@CGensSystem@@QAEXXZ ; CGensSystem::UpdateRun

; 250  : #endif
; 251  : #endif
; 252  : 		//g_PeriodItemEx.CheckPeriodData(); --  need to decompile
; 253  : 		//g_CashShopInGame.CheckMileageUpdate(); -- need to decompile
; 254  : 		//g_CashShopInGame.CheckShopServerReconnect(); -- need to decompile
; 255  : 		//g_HacktoolBlockEx.CheckHacktoolUse(); -- need to decompile
; 256  : 
; 257  : 		/*if ( DBSockMng::GetActiveDS(&cDBSMng) > -1 && !CArcaBattle::IsDataLoadWinGuild(&g_ArcaBattle) )
; 258  :           CArcaBattle::GDReqWinGuildInfo(&g_ArcaBattle);
; 259  :         if ( DBSockMng::GetActiveDS(&cDBSMng) > -1 && !CArcaBattle::IsDataLoadProcState(&g_ArcaBattle) )
; 260  :           CArcaBattle::GDReqProcState(&g_ArcaBattle);
; 261  :         if ( DBSockMng::GetActiveDS(&cDBSMng) > -1
; 262  :           && !CArcaBattle::IsInitABProcMultiCast(&g_ArcaBattle)
; 263  :           && CArcaBattle::IsArcaBattleServer(&g_ArcaBattle) == 1 )
; 264  :           CArcaBattle::SetArcaBattleProcMultiCast(&g_ArcaBattle, 1);
; 265  :         if ( DBSockMng::GetActiveDS(&cDBSMng) > -1
; 266  :           && !CAcheronGuardianEvent::IsInitAEProcMultiCast(&g_AcheronGuardianEvent)
; 267  :           && CArcaBattle::IsArcaBattleServer(&g_ArcaBattle) == 1 )
; 268  :           CAcheronGuardianEvent::SetAcheronEventProcMultiCast(&g_AcheronGuardianEvent, 1);*/
; 269  : 		break;

  002f9	eb 3d		 jmp	 SHORT $LN35@TimerProcQ
$LN26@TimerProcQ:

; 270  : 	case WM_SET_DATE:
; 271  : 		gSetDate();

  002fb	e8 00 00 00 00	 call	 ?gSetDate@@YAXXZ	; gSetDate

; 272  : 		WhisperCash.TimeCheckCashDelete();

  00300	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  00305	e8 00 00 00 00	 call	 ?TimeCheckCashDelete@CWhisperCash@@QAEXXZ ; CWhisperCash::TimeCheckCashDelete

; 273  : 		break;

  0030a	eb 2c		 jmp	 SHORT $LN35@TimerProcQ
$LN27@TimerProcQ:

; 274  : 	case WM_LOG_DATE_CHANGE:
; 275  : 
; 276  : 		cpTimerTempUserManager->ClearOverTimeUserData(g_MaintainUserConnectionSecond);

  0030c	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_MaintainUserConnectionSecond@@3HA ; g_MaintainUserConnectionSecond
  00312	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cpTimerTempUserManager@@3PAVCTemporaryUserManager@@A ; cpTimerTempUserManager
  00318	e8 00 00 00 00	 call	 ?ClearOverTimeUserData@CTemporaryUserManager@@QAEHK@Z ; CTemporaryUserManager::ClearOverTimeUserData

; 277  : 		/*
; 278  : 		if( g_GensAbusingResetTime > 0 )
; 279  : 		{
; 280  : 			for(int n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)
; 281  : 			{
; 282  : 				if( gObjIsConnected(n) )
; 283  : 					g_GensSystem.AbusingInfoReset(&gObj[n]);
; 284  : 			}
; 285  : 		}
; 286  : 		*/
; 287  : 
; 288  : #if (GS_CASTLE == 1)
; 289  : 		if(LogDateChange() == TRUE)

  0031d	e8 00 00 00 00	 call	 ?LogDateChange@@YAHXZ	; LogDateChange
  00322	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_iCastleItemMixLimit@@3HA ; g_iCastleItemMixLimit
  00328	be 01 00 00 00	 mov	 esi, 1
  0032d	3b c6		 cmp	 eax, esi
  0032f	0f 44 d6	 cmove	 edx, esi
  00332	89 15 00 00 00
	00		 mov	 DWORD PTR ?g_iCastleItemMixLimit@@3HA, edx ; g_iCastleItemMixLimit
$LN35@TimerProcQ:
  00338	5e		 pop	 esi
$LN28@TimerProcQ:

; 290  : 			g_iCastleItemMixLimit = 1;
; 291  : #else
; 292  : 		LogDateChange()
; 293  : #endif
; 294  : 		break;
; 295  : 
; 296  : 	default:
; 297  : 		break;
; 298  : 	}
; 299  : 
; 300  : 	g_MuTimer.m_QueueTimer1.SyncUnlock();

  00339	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+4
  0033e	e8 00 00 00 00	 call	 ?SyncUnlock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncUnlock
$LN1@TimerProcQ:

; 301  : }

  00343	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00346	33 cd		 xor	 ecx, ebp
  00348	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034d	8b e5		 mov	 esp, ebp
  0034f	5d		 pop	 ebp
  00350	c2 08 00	 ret	 8
  00353	90		 npad	 1
$LN38@TimerProcQ:
  00354	00 00 00 00	 DD	 $LN15@TimerProcQ
  00358	00 00 00 00	 DD	 $LN26@TimerProcQ
  0035c	00 00 00 00	 DD	 $LN17@TimerProcQ
  00360	00 00 00 00	 DD	 $LN27@TimerProcQ
  00364	00 00 00 00	 DD	 $LN12@TimerProcQ
  00368	00 00 00 00	 DD	 $LN11@TimerProcQ
  0036c	00 00 00 00	 DD	 $LN9@TimerProcQ
  00370	00 00 00 00	 DD	 $LN35@TimerProcQ
  00374	00 00 00 00	 DD	 $LN8@TimerProcQ
  00378	00 00 00 00	 DD	 $LN35@TimerProcQ
  0037c	00 00 00 00	 DD	 $LN13@TimerProcQ
  00380	00 00 00 00	 DD	 $LN14@TimerProcQ
  00384	00 00 00 00	 DD	 $LN35@TimerProcQ
  00388	00 00 00 00	 DD	 $LN35@TimerProcQ
  0038c	00 00 00 00	 DD	 $LN35@TimerProcQ
  00390	00 00 00 00	 DD	 $LN35@TimerProcQ
  00394	00 00 00 00	 DD	 $LN16@TimerProcQ
?TimerProcQueue@@YGXPAXH@Z ENDP				; TimerProcQueue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monsterspawner.h
;	COMDAT ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ PROC		; MonsterSpawnerMng::getInstance, COMDAT

; 137  : 	static MonsterSpawnerMng* getInstance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 138  : 		if (m_Instance == NULL) {

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A ; MonsterSpawnerMng::m_Instance
  00028	85 c0		 test	 eax, eax
  0002a	75 3a		 jne	 SHORT $LN2@getInstanc

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0002c	6a 1c		 push	 28			; 0000001cH
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	85 c0		 test	 eax, eax
  00042	74 1b		 je	 SHORT $LN4@getInstanc
  00044	8b c8		 mov	 ecx, eax
  00046	e8 00 00 00 00	 call	 ??0MonsterSpawnerMng@@QAE@XZ ; MonsterSpawnerMng::MonsterSpawnerMng
  0004b	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN4@getInstanc:

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0005f	33 c0		 xor	 eax, eax
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance
$LN2@getInstanc:

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0:
  00000	6a 1c		 push	 28			; 0000001cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ENDP		; MonsterSpawnerMng::getInstance
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCMuTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMuTimer@@UAEPAXI@Z PROC				; CMuTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMuTimer@@UAE@XZ	; CMuTimer::~CMuTimer
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 80 00 00 00	 push	 128			; 00000080H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCMuTimer@@UAEPAXI@Z ENDP				; CMuTimer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ?SetTimerEnd@CMuTimer@@QAEXXZ
_TEXT	SEGMENT
?SetTimerEnd@CMuTimer@@QAEXXZ PROC			; CMuTimer::SetTimerEnd, COMDAT
; _this$ = ecx

; 370  : 	this->m_bTimerEnd = TRUE;

  00000	c7 41 7c 01 00
	00 00		 mov	 DWORD PTR [ecx+124], 1

; 371  : }

  00007	c3		 ret	 0
?SetTimerEnd@CMuTimer@@QAEXXZ ENDP			; CMuTimer::SetTimerEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ?GetTimerEnd@CMuTimer@@QAEHXZ
_TEXT	SEGMENT
?GetTimerEnd@CMuTimer@@QAEHXZ PROC			; CMuTimer::GetTimerEnd, COMDAT
; _this$ = ecx

; 305  : 	return this->m_bTimerEnd;

  00000	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]

; 306  : }

  00003	c3		 ret	 0
?GetTimerEnd@CMuTimer@@QAEHXZ ENDP			; CMuTimer::GetTimerEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ?SetMuTimer@CMuTimer@@QAEXXZ
_TEXT	SEGMENT
?SetMuTimer@CMuTimer@@QAEXXZ PROC			; CMuTimer::SetMuTimer, COMDAT
; _this$ = ecx

; 66   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 67   : VM_START
; 68   : 	INT		result;
; 69   : 
; 70   : 	DWORD	MuTimer1Flag = 0x20;
; 71   : 	DWORD	MuTimer2Flag = 0x01;
; 72   : 
; 73   : 	MuTimer1Flag = 0x00010000|MuTimer1Flag;
; 74   : 	MuTimer2Flag = 0x00010000|MuTimer2Flag;
; 75   : 
; 76   : 	result = this->m_QueueTimer1.CreateTimer(WM_SET_DATE,60000,MuTimer1Flag);

  00004	68 20 00 01 00	 push	 65568			; 00010020H
  00009	68 60 ea 00 00	 push	 60000			; 0000ea60H
  0000e	68 e9 03 00 00	 push	 1001			; 000003e9H
  00013	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00016	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 77   : 	result = this->m_QueueTimer1.CreateTimer(WM_LOG_DATE_CHANGE,60000,MuTimer1Flag);

  0001b	68 20 00 01 00	 push	 65568			; 00010020H
  00020	68 60 ea 00 00	 push	 60000			; 0000ea60H
  00025	68 eb 03 00 00	 push	 1003			; 000003ebH
  0002a	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0002d	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 78   : 	
; 79   : 	//result = this->m_QueueTimer1.CreateTimer(0x3EF,10000,MuTimer1Flag);
; 80   : 	result = this->m_QueueTimer1.CreateTimer(WM_CONNECT_DATASERVER,10000,MuTimer1Flag);

  00032	68 20 00 01 00	 push	 65568			; 00010020H
  00037	68 10 27 00 00	 push	 10000			; 00002710H
  0003c	68 ef 03 00 00	 push	 1007			; 000003efH
  00041	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00044	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 81   : 	
; 82   : 	result = this->m_QueueTimer1.CreateTimer(WM_GS_CLOSE,1000,MuTimer1Flag);

  00049	68 20 00 01 00	 push	 65568			; 00010020H
  0004e	68 e8 03 00 00	 push	 1000			; 000003e8H
  00053	68 ea 03 00 00	 push	 1002			; 000003eaH
  00058	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0005b	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 83   : 	result = this->m_QueueTimer1.CreateTimer(WM_MONSTER_AND_MSG_PROC,500,MuTimer1Flag);

  00060	68 20 00 01 00	 push	 65568			; 00010020H
  00065	68 f4 01 00 00	 push	 500			; 000001f4H
  0006a	68 ee 03 00 00	 push	 1006			; 000003eeH
  0006f	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00072	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 84   : 	result = this->m_QueueTimer1.CreateTimer(WM_MOVE_MONSTER_PROC,300,MuTimer1Flag);

  00077	68 20 00 01 00	 push	 65568			; 00010020H
  0007c	68 2c 01 00 00	 push	 300			; 0000012cH
  00081	68 ed 03 00 00	 push	 1005			; 000003edH
  00086	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00089	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 85   : 	result = this->m_QueueTimer1.CreateTimer(WM_EVENT_RUN_PROC,100,MuTimer1Flag);

  0008e	68 20 00 01 00	 push	 65568			; 00010020H
  00093	6a 64		 push	 100			; 00000064H
  00095	68 ec 03 00 00	 push	 1004			; 000003ecH
  0009a	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0009d	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 86   : 	result = this->m_QueueTimer1.CreateTimer(WM_AI_MONSTER_MOVE_PROC,100,MuTimer1Flag);

  000a2	68 20 00 01 00	 push	 65568			; 00010020H
  000a7	6a 64		 push	 100			; 00000064H
  000a9	68 f2 03 00 00	 push	 1010			; 000003f2H
  000ae	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000b1	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 87   : 	result = this->m_QueueTimer1.CreateTimer(WM_AI_MONSTER_PROC,500,MuTimer1Flag);

  000b6	68 20 00 01 00	 push	 65568			; 00010020H
  000bb	68 f4 01 00 00	 push	 500			; 000001f4H
  000c0	68 f3 03 00 00	 push	 1011			; 000003f3H
  000c5	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000c8	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 88   : 	result = this->m_QueueTimer1.CreateTimer(WM_GUILD_LIST_REQUEST,0,MuTimer1Flag | 8);

  000cd	68 28 00 01 00	 push	 65576			; 00010028H
  000d2	6a 00		 push	 0
  000d4	68 f0 03 00 00	 push	 1008			; 000003f0H
  000d9	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000dc	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 89   : 	result = this->m_QueueTimer1.CreateTimer(WM_SECOND_MSG_PROCESS,1000,MuTimer1Flag);

  000e1	68 20 00 01 00	 push	 65568			; 00010020H
  000e6	68 e8 03 00 00	 push	 1000			; 000003e8H
  000eb	68 e8 03 00 00	 push	 1000			; 000003e8H
  000f0	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000f3	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 90   : 
; 91   : 	result = this->m_QueueTimer1.CreateTimer(WM_DUEL_RUN_PROC,1000,MuTimer1Flag);

  000f8	68 20 00 01 00	 push	 65568			; 00010020H
  000fd	68 e8 03 00 00	 push	 1000			; 000003e8H
  00102	68 f6 03 00 00	 push	 1014			; 000003f6H
  00107	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0010a	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 92   : 
; 93   : 	if( g_ConnectMemberReload == true && g_ConnectMemberReloadTime > 0 )

  0010f	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_ConnectMemberReload@@3_NA, 1 ; g_ConnectMemberReload
  00116	75 22		 jne	 SHORT $LN2@SetMuTimer
  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_ConnectMemberReloadTime@@3HA ; g_ConnectMemberReloadTime
  0011d	85 c0		 test	 eax, eax
  0011f	7e 19		 jle	 SHORT $LN2@SetMuTimer

; 94   : 	{
; 95   : 		result = this->m_QueueTimer1.CreateTimer(WM_CONNECTMEMBER_RELOAD, 1000 * 60 * g_ConnectMemberReloadTime, MuTimer1Flag);

  00121	69 c0 60 ea 00
	00		 imul	 eax, eax, 60000
  00127	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0012a	68 20 00 01 00	 push	 65568			; 00010020H
  0012f	50		 push	 eax
  00130	68 f8 03 00 00	 push	 1016			; 000003f8H
  00135	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer
$LN2@SetMuTimer:

; 96   : 	}
; 97   : 
; 98   : 	//THE PROBLEM IS IN THESE TIMERS
; 99   : 	result = this->m_QueueTimer2.CreateTimer(WM_FIRST_MSG_PROCESS, 1000, MuTimer2Flag);

  0013a	68 01 00 01 00	 push	 65537			; 00010001H
  0013f	68 e8 03 00 00	 push	 1000			; 000003e8H
  00144	6a 65		 push	 101			; 00000065H
  00146	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00149	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 100  : 	result = this->m_QueueTimer2.CreateTimer(WM_VIEWPORT_UPDATE, 1000, MuTimer2Flag);

  0014e	68 01 00 01 00	 push	 65537			; 00010001H
  00153	68 e8 03 00 00	 push	 1000			; 000003e8H
  00158	68 f4 03 00 00	 push	 1012			; 000003f4H
  0015d	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00160	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi

; 101  : VM_END
; 102  : }

  00167	c3		 ret	 0
?SetMuTimer@CMuTimer@@QAEXXZ ENDP			; CMuTimer::SetMuTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ??1CMuTimer@@UAE@XZ
_TEXT	SEGMENT
??1CMuTimer@@UAE@XZ PROC				; CMuTimer::~CMuTimer, COMDAT
; _this$ = ecx

; 61   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 62   : 	timeEndPeriod(1);

  00003	6a 01		 push	 1
  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMuTimer@@6B@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeEndPeriod@4

; 63   : }

  00011	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00014	e8 00 00 00 00	 call	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
  00019	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0001c	5e		 pop	 esi
  0001d	e9 00 00 00 00	 jmp	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
??1CMuTimer@@UAE@XZ ENDP				; CMuTimer::~CMuTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ??0CMuTimer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CMuTimer@@QAE@XZ PROC				; CMuTimer::CMuTimer, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMuTimer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b d9		 mov	 ebx, ecx
  00028	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
  0002b	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0002e	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CMuTimer@@6B@
  00034	e8 00 00 00 00	 call	 ??0CQueueTimer@@QAE@XZ	; CQueueTimer::CQueueTimer
  00039	8d 4b 40	 lea	 ecx, DWORD PTR [ebx+64]
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ??0CQueueTimer@@QAE@XZ	; CQueueTimer::CQueueTimer

; 54   : 	timeBeginPeriod(1);

  00048	6a 01		 push	 1
  0004a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeBeginPeriod@4

; 55   : 	this->m_bTimerEnd = 0;
; 56   : 	this->m_QueueTimer1.RegCallBack((WAITORTIMERCALLBACK)TimerProcQueue);

  00054	68 00 00 00 00	 push	 OFFSET ?TimerProcQueue@@YGXPAXH@Z ; TimerProcQueue
  00059	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0005c	c7 43 7c 00 00
	00 00		 mov	 DWORD PTR [ebx+124], 0
  00063	e8 00 00 00 00	 call	 ?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z ; CQueueTimer::RegCallBack

; 57   : 	this->m_QueueTimer2.RegCallBack((WAITORTIMERCALLBACK)TimerProcQueue2);

  00068	68 00 00 00 00	 push	 OFFSET ?TimerProcQueue2@@YGXPAXH@Z ; TimerProcQueue2
  0006d	8d 4b 40	 lea	 ecx, DWORD PTR [ebx+64]
  00070	e8 00 00 00 00	 call	 ?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z ; CQueueTimer::RegCallBack

; 58   : }

  00075	8b c3		 mov	 eax, ebx
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CMuTimer@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
__unwindfunclet$??0CMuTimer@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 40	 add	 ecx, 64			; 00000040H
  00011	e9 00 00 00 00	 jmp	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
__ehhandler$??0CMuTimer@@QAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CMuTimer@@QAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CMuTimer@@QAE@XZ ENDP				; CMuTimer::CMuTimer
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 372  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mutimer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 372  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
